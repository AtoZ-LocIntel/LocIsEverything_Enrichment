import React, { useEffect, useRef, useState } from 'react';
import { EnrichmentResult } from '../App';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'maplibre-gl/dist/maplibre-gl.css';
import '@maplibre/maplibre-gl-leaflet';
import { exportEnrichmentResultsToCSV } from '../utils/csvExport';
import { poiConfigManager } from '../lib/poiConfig';

interface MapViewProps {
  results: EnrichmentResult[];
  onBackToConfig: () => void;
  isMobile?: boolean;
  previousViewMode?: string | null;
  initialCenter?: [number, number];
  initialZoom?: number;
  poiRadii?: Record<string, number>;
}

interface LegendItem {
  icon: string;
  color: string;
  title: string;
  count: number;
  radius?: number; // Proximity radius used for this layer
  radiusDisplay?: string; // Formatted radius display (e.g., "100ft", "2 miles")
  ranges?: Array<{ label: string; color: string; count: number }>; // For color-coded layers like broadband
}

// Basemap configuration supporting MapLibre (vector), WMS (raster), and direct tile layers
type BasemapType = 'maplibre' | 'wms' | 'tile';

interface BasemapConfig {
  type: BasemapType;
  name: string;
  attribution: string;
  // For MapLibre basemaps
  styleUrl?: string;
  // For WMS basemaps
  wmsUrl?: string;
  wmsLayers?: string;
  wmsFormat?: string;
  wmsCrs?: string; // 'EPSG4326' or 'EPSG3857'
  wmsVersion?: string; // '1.1.1' or '1.3.0' (default: '1.3.0')
  wmsUppercase?: boolean; // Required for some WMS 1.3.0 services
  wmsRasterFunction?: string; // Raster function name for ImageServer services (e.g., 'RoadDensity')
  // For direct tile layers (ArcGIS MapServer tiles)
  tileUrl?: string; // URL template with {z}/{y}/{x} placeholders, or ExportImage endpoint URL, or MapServer base URL for ExportMap
  // For ExportImage-based tile layers
  exportImageRasterFunction?: string; // Raster function name for ExportImage endpoint
  // For ExportMap-based tile layers (MapServer raster services)
  exportMapLayerId?: number; // Layer ID for MapServer ExportMap endpoint (e.g., 0, 1, 2...)
}

export const BASEMAP_CONFIGS: Record<string, BasemapConfig> = {
  // OpenFreeMap (MapLibre vector tiles)
  liberty: {
    type: 'maplibre',
    styleUrl: 'https://tiles.openfreemap.org/styles/liberty',
    name: 'Liberty (OpenFreeMap)',
    attribution: 'OpenFreeMap © OpenMapTiles Data © OpenStreetMap contributors',
  },
  bright: {
    type: 'maplibre',
    styleUrl: 'https://tiles.openfreemap.org/styles/bright',
    name: 'Bright (OpenFreeMap)',
    attribution: 'OpenFreeMap © OpenMapTiles Data © OpenStreetMap contributors',
  },
  positron: {
    type: 'maplibre',
    styleUrl: 'https://tiles.openfreemap.org/styles/positron',
    name: 'Positron (OpenFreeMap)',
    attribution: 'OpenFreeMap © OpenMapTiles Data © OpenStreetMap contributors',
  },
  natgeo_world_map: {
    type: 'tile',
    name: 'National Geographic World Map',
    attribution: 'National Geographic, Esri, Garmin, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp.',
    tileUrl: 'https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',
  },
  usa_topo_maps: {
    type: 'tile',
    name: 'USA Topo Maps',
    attribution: 'Copyright:© 2013 National Geographic Society, i-cubed',
    tileUrl: 'https://services.arcgisonline.com/arcgis/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}',
  },
  // USGS National Map WMS basemaps
  usgs_hydrography: {
    type: 'wms',
    name: 'Hydrography - Tile Cache',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://basemap.nationalmap.gov/arcgis/services/USGSHydroCached/MapServer/WMSServer',
    wmsLayers: '0',
    wmsFormat: 'image/png',
  },
  usgs_imagery_topo: {
    type: 'wms',
    name: 'USGS Imagery Topo Base Map - Primary Tile Cache',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://basemap.nationalmap.gov/arcgis/services/USGSImageryTopo/MapServer/WMSServer',
    wmsLayers: '0',
    wmsFormat: 'image/png',
  },
  usgs_imagery_only: {
    type: 'wms',
    name: 'USGS ImageryOnly Base Map - Primary Tile Cache',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://basemap.nationalmap.gov/arcgis/services/USGSImageryOnly/MapServer/WMSServer',
    wmsLayers: '0',
    wmsFormat: 'image/png',
  },
  usgs_shaded_relief: {
    type: 'wms',
    name: 'USGS Shaded Relief - Primary Tile Cache',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://basemap.nationalmap.gov/arcgis/services/USGSShadedReliefOnly/MapServer/WMSServer',
    wmsLayers: '0',
    wmsFormat: 'image/png',
  },
  usgs_topo: {
    type: 'wms',
    name: 'USGS Topo Base Map - Primary Tile Cache',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://basemap.nationalmap.gov/arcgis/services/USGSTopo/MapServer/WMSServer',
    wmsLayers: '0',
    wmsFormat: 'image/png',
  },
  // NLCD Canopy Cover WMS
  nlcd_canopy: {
    type: 'wms',
    name: 'NLCD Canopy Cover',
    attribution: 'USGS MRLC',
    wmsUrl: 'https://www.mrlc.gov/geoserver/NLCD_Canopy/wms',
    wmsLayers: 'NLCD_Canopy',
    wmsFormat: 'image/png',
  },
  // NLCD Impervious Descriptor WMS
  nlcd_impervious_descriptor: {
    type: 'wms',
    name: 'NLCD Impervious Descriptor',
    attribution: 'USGS MRLC',
    wmsUrl: 'https://www.mrlc.gov/geoserver/NLCD_Impervious_Descriptor/wms',
    wmsLayers: 'NLCD_Impervious_Descriptor',
    wmsFormat: 'image/png',
  },
  // NLCD Imperviousness WMS
  nlcd_impervious: {
    type: 'wms',
    name: 'NLCD Imperviousness',
    attribution: 'USGS MRLC',
    wmsUrl: 'https://www.mrlc.gov/geoserver/NLCD_Impervious/wms',
    wmsLayers: 'NLCD_Impervious',
    wmsFormat: 'image/png',
  },
  // NLCD Land Cover WMS
  nlcd_land_cover: {
    type: 'wms',
    name: 'NLCD Land Cover',
    attribution: 'USGS MRLC',
    wmsUrl: 'https://www.mrlc.gov/geoserver/NLCD_Land_Cover/wms',
    wmsLayers: 'NLCD_Land_Cover',
    wmsFormat: 'image/png',
  },
  // NLCD Shrublands WMS - REMOVED: Service returns 404 (not available)
  // nlcd_shrubland: {
  //   type: 'wms',
  //   name: 'NLCD Shrublands',
  //   attribution: 'USGS MRLC',
  //   wmsUrl: 'https://www.mrlc.gov/geoserver/NLCD_Shrubland/wms',
  //   wmsLayers: 'NLCD_Shrubland',
  //   wmsFormat: 'image/png',
  // },
  // USGS NAIP Plus Imagery WMS
  usgs_naip_plus: {
    type: 'wms',
    name: 'USGS NAIP Plus Imagery',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer',
    wmsLayers: 'USGSNAIPPlus', // Use service name as layer for ImageServer WMS
    wmsFormat: 'image/png',
  },
  // USGS National Map Contours WMS
  usgs_contours: {
    type: 'wms',
    name: 'USGS National Map Contours',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://carto.nationalmap.gov/arcgis/services/contours/MapServer/WMSServer',
    wmsLayers: '0', // Contours - Large-Scale
    wmsFormat: 'image/png',
  },
  // USGS Geographic Names (GNIS) WMS
  usgs_geographic_names: {
    type: 'wms',
    name: 'USGS Geographic Names (GNIS)',
    attribution: 'USGS The National Map',
    wmsUrl: 'https://carto.nationalmap.gov/arcgis/services/geonames/MapServer/WMSServer',
    wmsLayers: '12', // Populated Places
    wmsFormat: 'image/png',
  },
  // USGS/FWS Wetlands WMS
  usgs_wetlands: {
    type: 'wms',
    name: 'USGS/FWS Wetlands',
    attribution: 'USGS/FWS National Wetlands Inventory',
    wmsUrl: 'https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/services/Wetlands/MapServer/WMSServer',
    wmsLayers: '1', // Wetlands layer
    wmsFormat: 'image/png',
  },
  // BLM PLSS (Public Land Survey System) WMS
  blm_plss: {
    type: 'wms',
    name: 'BLM PLSS (Public Land Survey System)',
    attribution: 'BLM Bureau of Land Management',
    wmsUrl: 'https://gis.blm.gov/arcgis/services/Cadastral/BLM_Natl_PLSS_CadNSDI/MapServer/WMSServer',
    wmsLayers: '0,1,2,3', // PLSS layers: Intersected (0), Section (1), Township (2), State Boundaries (3)
    wmsFormat: 'image/png',
  },
  // USFS Forest Inventory and Analysis Above Ground Forest Carbon WMS
  // Note: Use service name as layer, EPSG4326 CRS, and uppercase=true for WMS 1.3.0
  usfs_fia_forest_carbon: {
    type: 'wms',
    name: 'USFS FIA Above Ground Forest Carbon',
    attribution: 'USFS Forest Inventory and Analysis',
    wmsUrl: 'https://imagery.geoplatform.gov/iipp/services/Ecosystems/USFS_EDW_FIA_AboveGroundForestCarbon/ImageServer/WMSServer',
    wmsLayers: 'USFS_EDW_FIA_AboveGroundForestCarbon', // Use service name as layer name
    wmsFormat: 'image/png',
    wmsCrs: 'EPSG4326', // Use EPSG4326 instead of EPSG3857
    wmsUppercase: true, // Required for WMS 1.3.0
  },
  // USFS Forest Inventory and Analysis Below Ground Forest Carbon WMS
  // Note: Use service name as layer, EPSG4326 CRS, and uppercase=true for WMS 1.3.0
  usfs_fia_belowground_forest_carbon: {
    type: 'wms',
    name: 'USFS FIA Below Ground Forest Carbon',
    attribution: 'USFS Forest Inventory and Analysis',
    wmsUrl: 'https://imagery.geoplatform.gov/iipp/services/Ecosystems/USFS_EDW_FIA_BelowGroundForestCarbon/ImageServer/WMSServer',
    wmsLayers: 'USFS_EDW_FIA_BelowGroundForestCarbon', // Use service name as layer name
    wmsFormat: 'image/png',
    wmsCrs: 'EPSG4326', // Use EPSG4326 instead of EPSG3857
    wmsUppercase: true, // Required for WMS 1.3.0
  },
  // USFS Riparian Areas WMS
  // Note: Use service name as layer, EPSG4326 CRS, and uppercase=true for WMS 1.3.0
  usfs_riparian_areas: {
    type: 'wms',
    name: 'USFS Riparian Areas',
    attribution: 'USDA Forest Service',
    wmsUrl: 'https://imagery.geoplatform.gov/iipp/services/Ecosystems/USFS_EDW_Riparian_Areas/ImageServer/WMSServer',
    wmsLayers: 'USFS_EDW_Riparian_Areas', // Use service name as layer name
    wmsFormat: 'image/png',
    wmsCrs: 'EPSG4326', // Use EPSG4326 instead of EPSG3857
    wmsUppercase: true, // Required for WMS 1.3.0
  },
  // USFS TCA Road Density - Using ExportImage endpoint with raster function
  // Note: ImageServer services with raster functions work better via ExportImage than WMS
  // This requires a custom tile URL function to construct the ExportImage URL with bbox
  usfs_tca_road_density: {
    type: 'tile',
    name: 'USFS TCA Road Density',
    attribution: 'USDA Forest Service',
    tileUrl: 'https://imagery.geoplatform.gov/iipp/rest/services/Ecosystems/USFS_EDW_TCA_RoadDensity/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'RoadDensity',
  },
  // USFS TCA Nitrogen Deposition - Using ExportImage endpoint with raster function
  // Note: ImageServer services with raster functions work better via ExportImage than WMS
  // This requires a custom tile URL function to construct the ExportImage URL with bbox
  usfs_tca_nitrogen_deposition: {
    type: 'tile',
    name: 'USFS TCA Nitrogen Deposition',
    attribution: 'USDA Forest Service - Total Deposition (TDep) modeling system',
    tileUrl: 'https://imagery.geoplatform.gov/iipp/rest/services/Ecosystems/USFS_EDW_TCA_NitrogenDeposition/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'Nitrogen Deposition',
  },
  // USFS TCA Insect and Disease Hazard - Using ExportImage endpoint with raster function
  // Note: ImageServer services with raster functions work better via ExportImage than WMS
  // This requires a custom tile URL function to construct the ExportImage URL with bbox
  usfs_tca_insect_disease_hazard: {
    type: 'tile',
    name: 'USFS TCA Insect and Disease Hazard',
    attribution: 'USDA Forest Service - National Insect and Disease Risk Map (NIDRM) 2018',
    tileUrl: 'https://imagery.geoplatform.gov/iipp/rest/services/Ecosystems/USFS_EDW_TCA_InsectAndDiseaseHazard/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'Insect and Disease Risk',
  },
  // USFS TCA Fire Deficit - Using ExportImage endpoint with raster function
  // Note: ImageServer services with raster functions work better via ExportImage than WMS
  // This requires a custom tile URL function to construct the ExportImage URL with bbox
  usfs_tca_fire_deficit: {
    type: 'tile',
    name: 'USFS TCA Fire Deficit',
    attribution: 'USDA Forest Service - MTBS, Landfire MFRI, NIFC Fire Perimeters',
    tileUrl: 'https://imagery.geoplatform.gov/iipp/rest/services/Ecosystems/USFS_EDW_TCA_FireDeficit/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'Fire Deficit',
  },
  // USFS National Snag Hazard - Using ExportImage endpoint with raster function
  // Note: ImageServer service with Single Fused Map Cache: false
  // National Snag Hazard Map provides landscape-level view of current snag hazard for firefighter safety
  usfs_national_snag_hazard: {
    type: 'tile',
    name: 'USFS National Snag Hazard',
    attribution: 'USDA Forest Service, Fire and Aviation Management, Strategic Analytics Branch',
    tileUrl: 'https://imagery.geoplatform.gov/iipp/rest/services/Fire_Aviation/USFS_EDW_SAB_NationalSnagHazard/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'SnagHaz', // Snag hazard raster function
  },
  // USFS FIA Forest Atlas - American Elm Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  // Note: Single fused cache shows all layers, but this is the historical range layer
  fia_american_elm_historical_range_basemap: {
    type: 'tile',
    name: 'FIA American Elm Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_American_elm_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Ashe Juniper Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_ashe_juniper_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Ashe Juniper Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_Ashe_juniper_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Balsam Fir Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_balsam_fir_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Balsam Fir Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_balsam_fir_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Chestnut Oak Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_chestnut_oak_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Chestnut Oak Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_chestnut_oak_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Common Pinyon Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_common_pinyon_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Common Pinyon Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_common_pinyon_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Douglas Fir Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_douglas_fir_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Douglas Fir Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_Douglas_fir_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Gambel Oak Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_gambel_oak_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Gambel Oak Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_Gambel_oak_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Honey Mesquite Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_honey_mesquite_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Honey Mesquite Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_honey_mesquite_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Loblolly Pine Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_loblolly_pine_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Loblolly Pine Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_loblolly_pine_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Lodgepole Pine Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_lodgepole_pine_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Lodgepole Pine Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_lodgepole_pine_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Pond Cypress Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_pond_cypress_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Pond Cypress Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_pondcypress_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Ponderosa Pine Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_ponderosa_pine_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Ponderosa Pine Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_ponderosa_pine_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Post Oak Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_post_oak_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Post Oak Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_post_oak_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Quaking Aspen Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_quaking_aspen_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Quaking Aspen Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_quaking_aspen_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Red Alder Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_red_alder_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Red Alder Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_red_alder_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Red Maple Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_red_maple_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Red Maple Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_red_maple_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Redwood Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_redwood_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Redwood Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_redwood_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Shortleaf Pine Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_shortleaf_pine_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Shortleaf Pine Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_shortleaf_pine_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Sugar Maple Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_sugar_maple_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Sugar Maple Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_sugar_maple_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Sweetgum Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_sweetgum_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Sweetgum Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_sweetgum_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Tanoak Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_tanoak_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Tanoak Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_tanoak_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Utah Juniper Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_utah_juniper_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Utah Juniper Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_Utah_juniper_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Western Hemlock Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_western_hemlock_historical_range_basemap: {
    type: 'tile',
    name: 'FIA Western Hemlock Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_western_hemlock_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - White Oak Historical Range Boundary
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_white_oak_historical_range_basemap: {
    type: 'tile',
    name: 'FIA White Oak Historical Range',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/107_white_oak_spp/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - White/Red/Jack Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_white_red_jack_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA White/Red/Jack Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_100WhiteRedJackPine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Spruce Fir Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_spruce_fir_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Spruce Fir Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_120SpruceFir/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Longleaf/Slash Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_longleaf_slash_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Longleaf/Slash Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_140LongleafSlashPine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Loblolly/Shortleaf Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_loblolly_shortleaf_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Loblolly/Shortleaf Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_160LoblollyShortleafPine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Pinyon/Juniper Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_pinyon_juniper_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Pinyon/Juniper Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_180PinyonJuniper/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Douglas Fir Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_douglas_fir_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Douglas Fir Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_200DouglasFir/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Ponderosa Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_ponderosa_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Ponderosa Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_220PonderosaPine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Western White Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_western_white_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Western White Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_240WesternWhitePine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Fir/Spruce/Mountain Hemlock Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_fir_spruce_mountain_hemlock_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Fir/Spruce/Mountain Hemlock Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_260FirSpruceMountainHemlock/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Lodgepole Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_lodgepole_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Lodgepole Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_280LodgepolePine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Hemlock/Sitka Spruce Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_hemlock_sitka_spruce_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Hemlock/Sitka Spruce Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_300HemlockSitkaSpruce/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Western Larch Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_western_larch_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Western Larch Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_320WesternLarch/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Redwood Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_redwood_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Redwood Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_340Redwood/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Other Western Softwoods Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_other_western_softwoods_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Other Western Softwoods Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_360OtherWesternSoftwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - California Mixed Conifer Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_california_mixed_conifer_forest_type_basemap: {
    type: 'tile',
    name: 'FIA California Mixed Conifer Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_370CaliforniaMixedConifer/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Exotic Softwoods Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_exotic_softwoods_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Exotic Softwoods Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_380ExoticSoftwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Oak/Pine Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_oak_pine_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Oak/Pine Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_400OakPine/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Oak/Hickory Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_oak_hickory_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Oak/Hickory Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_500OakHickory/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Oak/Gum/Cypress Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_oak_gum_cypress_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Oak/Gum/Cypress Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_600OakGumCypress/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Elm/Ash/Cottonwood Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_elm_ash_cottonwood_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Elm/Ash/Cottonwood Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_700ElmAshCottonwood/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Maple/Beech/Birch Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_maple_beech_birch_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Maple/Beech/Birch Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_800MmapleBeechBirch/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Aspen/Birch Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_aspen_birch_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Aspen/Birch Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_900AspenBirch/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Western Oak Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_western_oak_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Western Oak Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_920WesternOak/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Tanoak/Laurel Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_tanoak_laurel_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Tanoak/Laurel Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_940TanoakLaurel/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Other Western Hardwoods Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_other_western_hardwoods_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Other Western Hardwoods Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_950OtherWesternHardwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Tropical Hardwoods Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_tropical_hardwoods_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Tropical Hardwoods Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_980TropicalHardwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Exotic Hardwoods Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_exotic_hardwoods_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Exotic Hardwoods Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_990ExoticHardwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // Alaska AHRI 2020 RGB Cache
  // Tiled map service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  alaska_ahri_2020_rgb_cache: {
    type: 'tile',
    name: 'Alaska AHRI 2020 RGB Cache',
    attribution: 'Maxar Products. Dynamic Mosaic © 2020 Maxar Technologies Inc., Alaska Geospatial Office, USGS',
    tileUrl: 'https://geoportal.alaska.gov/arcgis/rest/services/ahri_2020_rgb_cache/MapServer/tile/{z}/{y}/{x}',
  },
  // Alaska IFSAR DSM (Digital Surface Model)
  // ImageServer service - visualization only, not queryable
  // Note: Using ExportImage endpoint since Single Fused Map Cache: false
  // Service has raster functions available (Hillshade, Shaded Relief, Slope, Aspect, etc.)
  // Using 'Hillshade' raster function for better visualization of elevation data
  alaska_ifsar_dsm: {
    type: 'tile',
    name: 'Alaska IFSAR DSM',
    attribution: 'Alaska Geospatial Office',
    tileUrl: 'https://geoportal.alaska.gov/arcgis/rest/services/Alaska_IFSAR_DSM/ImageServer/exportImage',
    exportImageRasterFunction: 'Hillshade', // Use Hillshade for better elevation visualization
  },
  // Alaska SPOT5 Orthoimagery (CIR - Color Infrared)
  // WMS service - visualization only, not queryable
  alaska_spot5_2013_cir_cache: {
    type: 'wms',
    name: 'Alaska SPOT5 Orthoimagery (CIR)',
    attribution: 'Alaska Geospatial Office',
    wmsUrl: 'https://geoportal.alaska.gov/arcgis/services/spot5_2013_cir_cache/MapServer/WMSServer',
    wmsLayers: '0', // Use layer 0 for the orthoimagery
    wmsFormat: 'image/png',
  },
  // Alaska SPOT5 Orthoimagery (PAN - Panchromatic)
  // WMS service - visualization only, not queryable
  alaska_spot5_2013_pan_cache: {
    type: 'wms',
    name: 'Alaska SPOT5 Orthoimagery (PAN)',
    attribution: 'Alaska Geospatial Office',
    wmsUrl: 'https://geoportal.alaska.gov/arcgis/services/spot5_2013_pan_cache/MapServer/WMSServer',
    wmsLayers: '0', // Use layer 0 for the orthoimagery
    wmsFormat: 'image/png',
  },
  // Alaska NWI (National Wetlands Inventory) Vector Tiles
  // VectorTileServer - visualization only, not queryable
  // Uses MapLibre style URL for vector tile rendering
  alaska_nwi_ak: {
    type: 'maplibre',
    name: 'Alaska NWI (National Wetlands Inventory)',
    attribution: 'Alaska Geospatial Office, USFWS',
    styleUrl: 'https://geoportal.alaska.gov/arcgis/rest/services/Hosted/NWI_AK/VectorTileServer/resources/styles/root.json',
  },
  // Alaska IFSAR DTM (Digital Terrain Model)
  // ImageServer service - visualization only, not queryable
  // Note: Using ExportImage endpoint since Single Fused Map Cache: false
  // Service has raster functions available (Hillshade, Shaded Relief, Slope, Aspect, etc.)
  // Using 'Hillshade' raster function for better visualization of elevation data
  alaska_ifsar_dtm: {
    type: 'tile',
    name: 'Alaska IFSAR DTM',
    attribution: 'Alaska Geospatial Office',
    tileUrl: 'https://geoportal.alaska.gov/arcgis/rest/services/Alaska_IFSAR_DTM/ImageServer/exportImage',
    exportImageRasterFunction: 'Hillshade', // Use Hillshade for better elevation visualization
  },
  // USFS FIA Forest Atlas - Alaska Forest-Type Group
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_alaska_forest_type_basemap: {
    type: 'tile',
    name: 'FIA Alaska Forest-Type',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_ak_forest_type_group/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Hardwood Groups
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_hardwoods_basemap: {
    type: 'tile',
    name: 'FIA Hardwood Groups',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_Hardwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Softwood Groups
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_softwoods_basemap: {
    type: 'tile',
    name: 'FIA Softwood Groups',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/109_Softwoods/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Harvest as a Fraction of Live Volume
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_harvest_fraction_by_county_basemap: {
    type: 'tile',
    name: 'FIA Harvest Fraction by County',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/308_HarvestFractionByCounty/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Harvest as a Fraction of Annual Growth
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_harvest_fraction_growth_state_basemap: {
    type: 'tile',
    name: 'FIA Harvest Fraction by Growth State',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/308_HarvestFractionGrowthState/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Forest Ownership
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_forest_ownership_basemap: {
    type: 'tile',
    name: 'FIA Forest Ownership',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/501_ForestOwnership/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Carbon Growth Per Year
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_carbon_growth_basemap: {
    type: 'tile',
    name: 'FIA Carbon Growth Per Year',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/506_CarbonGrowth/MapServer/tile/{z}/{y}/{x}',
  },
  // USFS FIA Forest Atlas - Carbon Sequestered in Harvested Products
  // Raster/tiled basemap service - visualization only, not queryable
  // Uses direct tile endpoint - works with /tile/{z}/{y}/{x} format
  fia_carbon_harvest_basemap: {
    type: 'tile',
    name: 'FIA Carbon Sequestered in Harvested Products',
    attribution: 'USDA Forest Service – FIA Forest Atlas',
    tileUrl: 'https://apps.fs.usda.gov/arcx/rest/services/RDW_FIA_ForestAtlas/506_CarbonHarvest/MapServer/tile/{z}/{y}/{x}',
  },
  // NOAA DEM Global Mosaic Hillshade - Using ExportImage endpoint with raster function
  // Note: ImageServer service with Single Fused Map Cache: false
  // Uses ExportImage endpoint with ColorHillshade raster function for elevation-tinted shaded relief visualization
  noaa_dem_global_mosaic_hillshade: {
    type: 'tile',
    name: 'NOAA DEM Global Mosaic Hillshade',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/DEM_global_mosaic_hillshade/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'ColorHillshade', // Multidirectional Color Hillshade with global bathy/topo color palette
  },
  // NOAA ETOPO1 Bedrock - Using ExportImage endpoint
  // Note: ImageServer service with Single Fused Map Cache: false
  // ETOPO1 is a 1 arc-minute global relief model of Earth's surface that integrates land topography and ocean bathymetry
  noaa_etopo1_bedrock: {
    type: 'tile',
    name: 'NOAA ETOPO1 Bedrock',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/ETOPO1_bedrock/ImageServer/exportImage',
    // Custom parameters for ExportImage - service only supports "None" raster function
    exportImageRasterFunction: 'None',
  },
  // NOAA ETOPO1 Ice Surface - Using ExportImage endpoint
  // Note: ImageServer service with Single Fused Map Cache: false
  // ETOPO1 ice surface shows the top of the Greenland and Antarctic ice sheets
  noaa_etopo1_ice_surface: {
    type: 'tile',
    name: 'NOAA ETOPO1 Ice Surface',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/ETOPO1_ice_surface/ImageServer/exportImage',
    // Custom parameters for ExportImage - service only supports "None" raster function
    exportImageRasterFunction: 'None',
  },
  // NOAA CRM Mosaic - Using ExportImage endpoint with raster function
  // Note: ImageServer service with Single Fused Map Cache: false
  // Coastal Relief Model (CRM) provides comprehensive coverage of the U.S. coastal zone
  noaa_crm_mosaic: {
    type: 'tile',
    name: 'NOAA CRM Mosaic',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/CRM_mosaic/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'ColorHillshade', // Multidirectional Color Hillshade with global bathy/topo color palette
  },
  // NOAA DEM Global Mosaic - Using ExportImage endpoint
  // Note: ImageServer service with Single Fused Map Cache: false
  // Global digital elevation model mosaic combining multiple DEM sources
  noaa_dem_global_mosaic: {
    type: 'tile',
    name: 'NOAA DEM Global Mosaic',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/DEM_global_mosaic/ImageServer/exportImage',
    // Custom parameters for ExportImage
    exportImageRasterFunction: 'ColorHillshade', // Multidirectional Color Hillshade with global bathy/topo color palette
  },
  // NOAA DEM Tiles Mosaic Hillshade - Using ExportImage endpoint
  // Note: ImageServer service with Single Fused Map Cache: false
  // Hillshade visualization of the global DEM tiles mosaic
  noaa_dem_tiles_mosaic_hillshade: {
    type: 'tile',
    name: 'NOAA DEM Tiles Mosaic Hillshade',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/DEM_mosaics/DEM_tiles_mosaic_hillshade/ImageServer/exportImage',
    // Custom parameters for ExportImage - service already provides hillshade visualization, use "None" for default
    exportImageRasterFunction: 'None',
  },
  // NOAA Tsunami Energy - Cascadia Subduction Zone (1700/01/27)
  // MapServer ExportMap service - visualization only, not queryable
  // Note: Uses Export Map REST endpoint for dynamic raster rendering
  noaa_tsunami_cascadia_1700: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Cascadia Subduction Zone (1700)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 0, // Layer ID for ExportMap endpoint
  },
  // NOAA Tsunami Energy - Lisbon, Portugal (1755/11/01)
  noaa_tsunami_lisbon_1755: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Lisbon, Portugal (1755)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 1,
  },
  // NOAA Tsunami Energy - Unimak Island, Alaska (1946/04/01)
  noaa_tsunami_unimak_1946: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Unimak Island, Alaska (1946)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 2,
  },
  // NOAA Tsunami Energy - Andreanof Islands, Alaska (1957/03/09)
  noaa_tsunami_andreanof_1957: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Andreanof Islands, Alaska (1957)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 3,
  },
  // NOAA Tsunami Energy - Southern Chile (1960/05/22)
  noaa_tsunami_chile_1960: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Southern Chile (1960)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 4,
  },
  // NOAA Tsunami Energy - Prince William Sound, Alaska (1964/03/28)
  noaa_tsunami_prince_william_1964: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Prince William Sound, Alaska (1964)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 5,
  },
  // NOAA Tsunami Energy - Sumatra, Indonesia (2004/12/16)
  noaa_tsunami_sumatra_2004: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Sumatra, Indonesia (2004)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 6,
  },
  // NOAA Tsunami Energy - Samoa (2009/09/29)
  noaa_tsunami_samoa_2009: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Samoa (2009)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 7,
  },
  // NOAA Tsunami Energy - Central Chile (2010/02/27)
  noaa_tsunami_chile_2010: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Central Chile (2010)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 8,
  },
  // NOAA Tsunami Energy - Tohoku, Japan (2011/03/11)
  noaa_tsunami_tohoku_2011: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - Tohoku, Japan (2011)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 9,
  },
  // NOAA Tsunami Energy - South Sandwich Is. (2021/08/12)
  noaa_tsunami_south_sandwich_2021: {
    type: 'tile',
    name: 'NOAA Tsunami Energy - South Sandwich Is. (2021)',
    attribution: 'NOAA National Centers for Environmental Information (NCEI)',
    tileUrl: 'https://gis.ngdc.noaa.gov/arcgis/rest/services/tsunami_energy/MapServer',
    exportMapLayerId: 10,
  },
  // Note: ArcGIS Online services (services.arcgisonline.com) do not support WMS.
  // They use WMTS or direct tile services instead, which would require a different implementation.
  // The ArcGIS World Imagery layers have been removed as they don't support WMS protocol.
};


// Fix for Leaflet marker icons in React
delete (L.Icon.Default.prototype as any)._getIconUrl;
// Disable shadows on mobile to prevent white ovals (iOS Safari issue)
// Explicitly set shadowUrl to null on mobile - if undefined, mobile browsers may render white fallback oval
const isMobileDevice = typeof window !== 'undefined' && window.innerWidth <= 768;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: isMobileDevice ? null : 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
  shadowSize: isMobileDevice ? [0, 0] : [41, 41],
  shadowAnchor: isMobileDevice ? [0, 0] : [12, 41],
});

// Also ensure divIcon shadows are disabled on mobile (prevent any fallback shadow rendering)
if (isMobileDevice && (L.Icon as any).DivIcon) {
  (L.Icon as any).DivIcon.prototype.options = (L.Icon as any).DivIcon.prototype.options || {};
  (L.Icon as any).DivIcon.prototype.options.shadowUrl = null;
}

// Custom tile layer for ArcGIS ImageServer ExportImage endpoint with raster functions
/**
 * Fetch and transform ArcGIS VectorTileServer style JSON to fix relative sprite URLs
 */
async function fetchAndTransformVectorTileStyle(styleUrl: string): Promise<any> {
  try {
    const response = await fetch(styleUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch style: ${response.statusText}`);
    }
    const style = await response.json();
    
    // Extract base URL from style URL - this is the directory containing the style JSON
    // For ArcGIS VectorTileServer, the style URL is typically:
    // https://geoportal.alaska.gov/arcgis/rest/services/Hosted/NWI_AK/VectorTileServer/resources/styles/root.json
    // Style directory: https://geoportal.alaska.gov/arcgis/rest/services/Hosted/NWI_AK/VectorTileServer/resources/styles/
    const urlObj = new URL(styleUrl);
    // Get the directory containing the style JSON (remove the filename)
    const styleDir = urlObj.pathname.substring(0, urlObj.pathname.lastIndexOf('/') + 1);
    const styleDirUrl = `${urlObj.protocol}//${urlObj.host}${styleDir}`;
    
    // Helper function to resolve relative URLs
    // Special handling for glyphs URLs which may contain template tokens like {fontstack} and {range}
    const resolveUrl = (relativeUrl: string, preserveTokens: boolean = false): string => {
      if (relativeUrl.startsWith('http://') || relativeUrl.startsWith('https://')) {
        return relativeUrl; // Already absolute
      }
      
      // For glyphs URLs with template tokens, we need to preserve {fontstack} and {range}
      // The new URL() constructor will URL-encode these tokens, so we handle them manually
      if (preserveTokens && (relativeUrl.includes('{fontstack}') || relativeUrl.includes('{range}'))) {
        const baseUrlObj = new URL(styleDirUrl);
        let resolvedPath = baseUrlObj.pathname;
        
        // Ensure styleDirUrl path ends with /
        if (!resolvedPath.endsWith('/')) {
          resolvedPath += '/';
        }
        
        // Handle relative paths
        if (relativeUrl.startsWith('../')) {
          // Go up one directory: remove last segment from path
          const pathParts = resolvedPath.split('/').filter(p => p !== '');
          if (pathParts.length > 0) {
            pathParts.pop();
          }
          resolvedPath = '/' + pathParts.join('/') + '/';
          // Remove '../' prefix and append the rest
          const remainingPath = relativeUrl.substring(3);
          resolvedPath = resolvedPath + remainingPath;
        } else if (relativeUrl.startsWith('./')) {
          resolvedPath = resolvedPath + relativeUrl.substring(2);
        } else {
          resolvedPath = resolvedPath + relativeUrl;
        }
        
        // Construct final URL manually to avoid encoding template tokens
        const finalUrl = `${baseUrlObj.protocol}//${baseUrlObj.host}${resolvedPath}`;
        console.log('🔍 [DEBUG] Resolving glyphs URL with tokens:', { relativeUrl, styleDirUrl, resolvedPath, finalUrl });
        return finalUrl;
      }
      
      // For other URLs, use standard URL resolution
      return new URL(relativeUrl, styleDirUrl).href;
    };
    
    // Transform sprite URLs from relative to absolute
    if (style.sprite) {
      const originalSprite = style.sprite;
      style.sprite = resolveUrl(style.sprite);
      console.log('🔍 [DEBUG] Original sprite URL:', originalSprite);
      console.log('🔍 [DEBUG] Transformed sprite URL:', style.sprite);
      
      // Verify sprite URL format - MapLibre expects base URL without extension
      // It will automatically append .json and .png
      // If the sprite URL has an extension, remove it
      if (style.sprite.endsWith('.json') || style.sprite.endsWith('.png')) {
        console.warn('⚠️ Sprite URL has extension, removing:', style.sprite);
        style.sprite = style.sprite.replace(/\.(json|png)$/, '');
        console.log('🔍 [DEBUG] Corrected sprite URL:', style.sprite);
      }
      
      // Test sprite URL accessibility (optional - for debugging)
      try {
        const spriteTestUrl = style.sprite + '.json';
        console.log('🔍 [DEBUG] Testing sprite URL accessibility:', spriteTestUrl);
      } catch (e) {
        console.warn('⚠️ Could not test sprite URL:', e);
      }
    }
    
    // Transform glyphs URLs if present - preserve template tokens
    if (style.glyphs) {
      // Glyphs URLs contain template tokens {fontstack} and {range} that must be preserved
      const originalGlyphs = style.glyphs;
      style.glyphs = resolveUrl(originalGlyphs, true);
      console.log('🔍 [DEBUG] Original glyphs URL:', originalGlyphs);
      console.log('🔍 [DEBUG] Style directory URL:', styleDirUrl);
      console.log('🔍 [DEBUG] Transformed glyphs URL:', style.glyphs);
    }
    
    // Transform sources URLs if present (for vector tile sources)
    // These are critical - if source URLs are wrong, tiles won't load
    if (style.sources) {
      console.log('🔍 [DEBUG] Transforming source URLs:', Object.keys(style.sources));
      
      // Determine if this is an ArcGIS VectorTileServer based on the style URL
      const isArcGISVectorTileServer = styleUrl.includes('/VectorTileServer');
      const vectorTileServerBaseUrl = isArcGISVectorTileServer 
        ? styleUrl.replace(/\/resources\/styles\/.*$/, '')
        : null;
      
      for (const sourceKey in style.sources) {
        const source = style.sources[sourceKey];
        
        // Check if source uses 'url' property (single URL template)
        if (source.url && !source.url.startsWith('http://') && !source.url.startsWith('https://')) {
          const originalSourceUrl = source.url;
          source.url = resolveUrl(source.url);
          console.log(`🔍 [DEBUG] Source "${sourceKey}": ${originalSourceUrl} -> ${source.url}`);
          
          // For ArcGIS VectorTileServer, if the URL points to the service root (ends with VectorTileServer/),
          // we need to append the tile endpoint pattern
          if (isArcGISVectorTileServer && vectorTileServerBaseUrl && 
              (source.url.endsWith('/VectorTileServer/') || source.url.endsWith('/VectorTileServer'))) {
            // Convert to tiles array format for MapLibre
            if (!source.tiles) {
              source.tiles = [`${vectorTileServerBaseUrl}/tile/{z}/{y}/{x}.pbf`];
              delete source.url; // Remove url property, use tiles array instead
              console.log(`✅ Fixed ArcGIS VectorTileServer source "${sourceKey}" - converted to tiles array:`, source.tiles);
            }
          } else if (isArcGISVectorTileServer && !source.url.includes('/tile/') && !source.url.includes('{z}')) {
            console.warn(`⚠️ Source "${sourceKey}" URL might be incorrect - doesn't contain tile endpoint pattern:`, source.url);
          }
        } else if (source.url) {
          console.log(`🔍 [DEBUG] Source "${sourceKey}" already absolute: ${source.url}`);
          
          // Even if absolute, check if it's an ArcGIS VectorTileServer root URL that needs fixing
          if (isArcGISVectorTileServer && vectorTileServerBaseUrl && 
              (source.url.endsWith('/VectorTileServer/') || source.url.endsWith('/VectorTileServer'))) {
            if (!source.tiles) {
              source.tiles = [`${vectorTileServerBaseUrl}/tile/{z}/{y}/{x}.pbf`];
              delete source.url;
              console.log(`✅ Fixed ArcGIS VectorTileServer source "${sourceKey}" - converted to tiles array:`, source.tiles);
            }
          }
        }
        
        // Also check for tiles array (some vector sources use tiles array instead of url)
        if (source.tiles && Array.isArray(source.tiles)) {
          source.tiles = source.tiles.map((tileUrl: string) => {
            const original = tileUrl;
            if (!tileUrl.startsWith('http://') && !tileUrl.startsWith('https://')) {
              tileUrl = resolveUrl(tileUrl);
            }
            console.log(`🔍 [DEBUG] Source "${sourceKey}" tile: ${original} -> ${tileUrl}`);
            return tileUrl;
          });
          console.log(`🔍 [DEBUG] Source "${sourceKey}" all tiles:`, source.tiles);
        }
      }
    }
    
    // Log the complete transformed style for debugging
    console.log('🔍 [DEBUG] Complete transformed style:', {
      sprite: style.sprite,
      glyphs: style.glyphs,
      sources: style.sources ? Object.keys(style.sources) : null,
      layers: style.layers ? style.layers.length : 0
    });
    
    return style;
  } catch (error) {
    console.error('Error fetching/transforming vector tile style:', error);
    throw error;
  }
}

const createExportImageTileLayer = (exportImageUrl: string, rasterFunction: string, options: any): L.TileLayer => {
  // Create a standard tile layer with a placeholder URL
  const layer = L.tileLayer('', options);
  
  // Store the export image URL and raster function
  (layer as any)._exportImageUrl = exportImageUrl;
  (layer as any)._rasterFunction = rasterFunction;
  
  // Override getTileUrl method
  (layer as any).getTileUrl = function(coords: any) {
    const z = coords.z;
    const x = coords.x;
    const y = coords.y;
    const layerInstance = this as any;
    
    // Convert tile coordinates to bbox (Web Mercator/EPSG:3857)
    const n = Math.pow(2, z);
    const lonMin = (x / n) * 360 - 180;
    const lonMax = ((x + 1) / n) * 360 - 180;
    const latMin = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;
    const latMax = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
    
    // Convert to Web Mercator bbox (EPSG:3857)
    const bboxMinX = lonMin * 20037508.34 / 180;
    const bboxMaxX = lonMax * 20037508.34 / 180;
    const bboxMinY = Math.log(Math.tan((90 + latMin) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
    const bboxMaxY = Math.log(Math.tan((90 + latMax) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
    
    const bbox = `${bboxMinX},${bboxMinY},${bboxMaxX},${bboxMaxY}`;
    const rasterFunctionJson = JSON.stringify({ rasterFunction: layerInstance._rasterFunction });
    
    return `${layerInstance._exportImageUrl}?bbox=${bbox}&bboxSR=3857&imageSR=3857&size=256,256&f=image&rasterFunction=${encodeURIComponent(rasterFunctionJson)}`;
  };
  
  return layer;
};

// Create a tile layer for ArcGIS MapServer Export Map endpoint
// Used for MapServer raster services (like NOAA tsunami energy)
// Note: Handles global layers that wrap around the dateline
const createExportMapTileLayer = (mapServerUrl: string, layerId: number, options: any): L.TileLayer => {
  // Create a standard tile layer with a placeholder URL
  // Use noWrap: true to prevent Leaflet from requesting duplicate wrapped tiles
  const layerOptions = { ...options, noWrap: true };
  const layer = L.tileLayer('', layerOptions);
  
  // Store the map server URL and layer ID
  (layer as any)._mapServerUrl = mapServerUrl;
  (layer as any)._layerId = layerId;
  
  // Track requested tiles to prevent duplicates
  const tileCache = new Map<string, string>();
  
  // Override getTileUrl method
  (layer as any).getTileUrl = function(coords: any) {
    const z = coords.z;
    let x = coords.x;
    const y = coords.y;
    const layerInstance = this as any;
    
    // Normalize x coordinate to prevent duplicate tile requests
    // This ensures each unique geographic area only gets one tile request
    const n = Math.pow(2, z);
    const normalizedX = ((x % n) + n) % n; // Normalize x to 0 to n-1 range
    
    // Create a unique key for this tile to prevent duplicates
    const tileKey = `${z}_${normalizedX}_${y}`;
    
    // Check if we've already generated a URL for this normalized tile
    if (tileCache.has(tileKey)) {
      return tileCache.get(tileKey)!;
    }
    
    // Convert normalized tile coordinates to Web Mercator bbox (EPSG:3857)
    // Using Web Mercator matches Leaflet's internal coordinate system better
    const lonMin = (normalizedX / n) * 360 - 180;
    const lonMax = ((normalizedX + 1) / n) * 360 - 180;
    const latMin = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI;
    const latMax = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
    
    // Convert to Web Mercator bbox (EPSG:3857) for better compatibility
    const bboxMinX = lonMin * 20037508.34 / 180;
    const bboxMaxX = lonMax * 20037508.34 / 180;
    const bboxMinY = Math.log(Math.tan((90 + latMin) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
    const bboxMaxY = Math.log(Math.tan((90 + latMax) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180;
    
    const bbox = `${bboxMinX},${bboxMinY},${bboxMaxX},${bboxMaxY}`;
    
    // Export Map endpoint format: /export?bbox=...&size=...&format=png&f=image&layers=show:0
    // Use Web Mercator (EPSG:3857) which matches Leaflet's coordinate system
    // This should prevent duplicate rendering issues
    const url = `${layerInstance._mapServerUrl}/export?bbox=${bbox}&bboxSR=3857&imageSR=3857&size=256,256&format=png&f=image&layers=show:${layerInstance._layerId}`;
    
    // Cache the URL for this normalized tile
    tileCache.set(tileKey, url);
    
    return url;
  };
  
  return layer;
};

// POI Category Icons and Colors
const POI_ICONS: Record<string, { icon: string; color: string; title: string }> = {
  'poi_animal_vehicle_collisions': { icon: '🦌', color: '#dc2626', title: 'Animal-Vehicle Impact (AVI)' },
  'poi_wildfires': { icon: '🔥', color: '#ff4500', title: 'Current Wildfires' },
  'poi_restaurants': { icon: '🍽️', color: '#ef4444', title: 'Restaurants' },
  'poi_hotels': { icon: '🏨', color: '#3b82f6', title: 'Hotels' },
  'poi_breweries': { icon: '🍺', color: '#f59e0b', title: 'Breweries' },
  'poi_police_stations': { icon: '🚔', color: '#1f2937', title: 'Police Stations' },
  'poi_fire_stations': { icon: '🚒', color: '#dc2626', title: 'Fire Stations' },
  'poi_osm_city_town_halls': { icon: '🏛️', color: '#4b5563', title: 'City and Town Halls' },
  'poi_osm_courthouses': { icon: '⚖️', color: '#6b7280', title: 'Courthouses' },
  'poi_osm_dmv_licensing': { icon: '🚗', color: '#374151', title: 'DMV & Licensing' },
  'poi_osm_zoning_planning': { icon: '📋', color: '#475569', title: 'Zoning and Planning' },
  'poi_osm_public_works': { icon: '🚧', color: '#1f2937', title: 'Public Works' },
  'poi_osm_social_services': { icon: '🏛️', color: '#4b5563', title: 'Social Services' },
  'poi_osm_elementary_schools': { icon: '🏫', color: '#10b981', title: 'Elementary Schools' },
  'poi_osm_daycares_preschools': { icon: '👶', color: '#f59e0b', title: 'Daycares/Preschools' },
  'poi_osm_vocational_technical': { icon: '🔧', color: '#8b5cf6', title: 'Vocational/Technical Schools' },
  'poi_osm_tutoring_centers': { icon: '📚', color: '#10b981', title: 'Tutoring Centers' },
  'poi_osm_libraries': { icon: '📖', color: '#3b82f6', title: 'Libraries' },
  'poi_osm_prep_schools': { icon: '🎓', color: '#7c3aed', title: 'Prep Schools' },
  'poi_osm_middle_schools': { icon: '🏫', color: '#10b981', title: 'Middle Schools' },
  'poi_osm_high_schools': { icon: '🏫', color: '#059669', title: 'High Schools' },
  'poi_osm_fast_food': { icon: '🍔', color: '#dc2626', title: 'Fast Food' },
  'poi_osm_bars_pubs': { icon: '🍺', color: '#ea580c', title: 'Bars & Pubs' },
  'poi_osm_bakeries': { icon: '🥖', color: '#d97706', title: 'Bakeries' },
  'poi_osm_ice_cream_shops': { icon: '🍦', color: '#eab308', title: 'Ice Cream Shops' },
  'poi_osm_farmers_markets': { icon: '🌾', color: '#84cc16', title: 'Farmers Markets' },
  'poi_osm_food_trucks': { icon: '🚚', color: '#f59e0b', title: 'Food Trucks' },
  'poi_hospitals': { icon: '🏥', color: '#f97316', title: 'Hospitals' },
  'poi_pharmacies': { icon: '💊', color: '#06b6d4', title: 'Pharmacies' },
  'poi_parks': { icon: '🏞️', color: '#22c55e', title: 'Parks' },
  'poi_libraries': { icon: '📚', color: '#8b5cf6', title: 'Libraries' },
  'poi_markets': { icon: '🛒', color: '#06b6d4', title: 'Markets' },
  'poi_cafes': { icon: '☕', color: '#a855f7', title: 'Cafes' },
  'poi_osm_banks': { icon: '🏦', color: '#1e40af', title: 'Banks' },
  'poi_osm_atms': { icon: '💳', color: '#3b82f6', title: 'ATMs' },
  'poi_osm_credit_unions': { icon: '🏛️', color: '#2563eb', title: 'Credit Unions' },
  'poi_osm_financial_institutions': { icon: '💰', color: '#1e3a8a', title: 'Financial Institutions' },
  'poi_airports': { icon: '✈️', color: '#6366f1', title: 'Airports' },
  'noaa_weather_radar_impact_zones': { icon: '🌩️', color: '#ef4444', title: 'NOAA Weather Radar Impact Zones' },
  'noaa_maritime_overview': { icon: '🌊', color: '#3b82f6', title: 'NOAA Maritime Limits - Overview' },
  'noaa_maritime_12nm': { icon: '🌊', color: '#06b6d4', title: 'NOAA Maritime Limits - 12NM Territorial Sea' },
  'noaa_maritime_24nm': { icon: '🌊', color: '#10b981', title: 'NOAA Maritime Limits - 24NM Contiguous Zone' },
  'noaa_maritime_200nm': { icon: '🌊', color: '#8b5cf6', title: 'NOAA Maritime Limits - 200NM EEZ' },
  'noaa_maritime_us_canada_boundary': { icon: '🌊', color: '#f59e0b', title: 'NOAA Maritime Limits - US/Canada Boundary' },
  'poi_tnm_trails': { icon: '🥾', color: '#059669', title: 'Trails' },
  'poi_mountain_biking': { icon: '🚵', color: '#10b981', title: 'Mountain Biking & Biking Trails' },
  'poi_wikipedia': { icon: '📖', color: '#1d4ed8', title: 'Wikipedia Articles' },
  'poi_fema_flood_zones': { icon: '🌊', color: '#0891b2', title: 'FEMA Flood Zones' },
  'poi_wetlands': { icon: '🌿', color: '#059669', title: 'USGS Wetlands' },
  'poi_earthquakes': { icon: '🌋', color: '#dc2626', title: 'USGS Earthquakes' },
  'poi_volcanoes': { icon: '🌋', color: '#ea580c', title: 'USGS Volcanoes' },
  'poi_flood_reference_points': { icon: '🚨', color: '#dc2626', title: 'USGS Flood Reference Points' },
  
  // Appalachian Trail Features
  'at_bridges': { icon: '🌉', color: '#8b5cf6', title: 'AT Bridges' },
  'at_campsites': { icon: '🏕️', color: '#059669', title: 'AT Campsites' },
  'at_parking': { icon: '🅿️', color: '#1f2937', title: 'AT Parking' },
  'at_privies': { icon: '🚻', color: '#7c2d12', title: 'AT Privies' },
  'at_shelters': { icon: '🏠', color: '#dc2626', title: 'AT Shelters' },
  'at_vistas': { icon: '🏔️', color: '#0891b2', title: 'AT Vistas' },
  'at_side_trails': { icon: '🥾', color: '#059669', title: 'AT Side Trails' },
  'at_treadway': { icon: '🛤️', color: '#7c3aed', title: 'AT Treadway' },
  'at_assets_trail': { icon: '🔧', color: '#f59e0b', title: 'AT Trail Assets' },
  'at_assets_structures': { icon: '🏗️', color: '#6b7280', title: 'AT Structure Assets' },
  'at_assets_bridges': { icon: '🌉', color: '#8b5cf6', title: 'AT Bridge Assets' },
  'at_centerline': { icon: '🗺️', color: '#dc2626', title: 'AT Centerline' },
  
  // Pacific Crest Trail (PCT)
  'pct_centerline': { icon: '🥾', color: '#dc2626', title: 'PCT Centerline' },
  'pct_sheriff_offices': { icon: '👮', color: '#1e40af', title: 'PCT Sheriff Offices' },
  'pct_side_trails': { icon: '🛤️', color: '#7c2d12', title: 'PCT Side Trails' },
  'pct_mile_markers_2024': { icon: '📍', color: '#dc2626', title: 'PCT 2024 Mile Markers' },
  'pct_tenth_mile_markers_2024': { icon: '📍', color: '#dc2626', title: 'PCT 2025 Tenth/Mile Markers' },
  'pct_resupply_towns': { icon: '🏘️', color: '#059669', title: 'PCT Resupply Towns' },
  'pct_osm_features': { icon: '🏔️', color: '#dc2626', title: 'PCT OSM Features' },
  
  // EPA FRS Environmental Hazards
  'poi_epa_brownfields': { icon: '🏭', color: '#8b4513', title: 'EPA Brownfields' },
  'poi_epa_superfund': { icon: '⚠️', color: '#dc2626', title: 'EPA Superfund Sites' },
  'poi_epa_rcra': { icon: '☣️', color: '#7c2d12', title: 'EPA RCRA Facilities' },
  'poi_epa_npdes': { icon: '💧', color: '#0891b2', title: 'EPA NPDES Permits' },
  'poi_epa_air': { icon: '💨', color: '#6b7280', title: 'EPA Air Facilities' },
  'poi_epa_radiation': { icon: '☢️', color: '#fbbf24', title: 'EPA Radiation Facilities' },
  'poi_epa_power': { icon: '⚡', color: '#f59e0b', title: 'EPA Power Generation' },
  'poi_epa_oil_spill': { icon: '🛢️', color: '#1f2937', title: 'EPA Oil Spill Response' },
  
  // EPA TRI (Toxics Release Inventory) - Comprehensive facility data
  'tri_facilities': { icon: '🧪', color: '#059669', title: 'TRI Facilities' },
  'tri_facilities_tribal': { icon: '🏛️', color: '#7c2d12', title: 'TRI Facilities (Tribal Land)' },
  'tri_all_facilities': { icon: '🏭', color: '#1f2937', title: 'All TRI Facilities' },
  'tri_manufacturing': { icon: '⚙️', color: '#6b7280', title: 'Manufacturing Facilities' },
  'tri_metal_mining': { icon: '⛏️', color: '#92400e', title: 'Metal Mining Facilities' },
  'tri_electric_utility': { icon: '⚡', color: '#f59e0b', title: 'Electric Utility Facilities' },
  'tri_wood_products': { icon: '🪵', color: '#7c2d12', title: 'Wood Products Facilities' },
  'tri_automotive': { icon: '🚗', color: '#1e40af', title: 'Automotive Manufacturing' },
  'tri_pfas': { icon: '🧬', color: '#dc2626', title: 'PFAS Facilities' },
  'tri_lead': { icon: '🔗', color: '#6b7280', title: 'Lead Facilities' },
  'tri_dioxins': { icon: '☠️', color: '#7c2d12', title: 'Dioxins Facilities' },
  'tri_ethylene_oxide': { icon: '💨', color: '#0891b2', title: 'Ethylene Oxide Facilities' },
  'tri_carcinogens': { icon: '⚠️', color: '#dc2626', title: 'Carcinogens Facilities' },
  'tri_mercury': { icon: '🌡️', color: '#fbbf24', title: 'Mercury Facilities' },
  'tri_federal': { icon: '🏛️', color: '#1f2937', title: 'Federal TRI Facilities' },
  
  // Power and Infrastructure
  'poi_powerlines': { icon: '⚡', color: '#f59e0b', title: 'Powerlines' },
  'poi_cell_towers': { icon: '📡', color: '#8b5cf6', title: 'Cell Towers' },
  
  // Recreation and Leisure
  'poi_golf_courses': { icon: '⛳', color: '#10b981', title: 'Golf Courses' },
  'poi_theatres': { icon: '🎭', color: '#800080', title: 'Theatres' },
  'poi_museums_historic': { icon: '🏛️', color: '#7c3aed', title: 'Museums, Historic Sites & Memorials' },
  'poi_bars_nightlife': { icon: '🍻', color: '#f59e0b', title: 'Bars & Nightlife' },
  
  // USDA Local Food Portal - Farmers Markets & Local Food
  'poi_usda_agritourism': { icon: '🚜', color: '#22c55e', title: 'Agritourism' },
  'poi_usda_csa': { icon: '🧺', color: '#16a34a', title: 'CSA Programs' },
  'poi_usda_farmers_market': { icon: '🍎', color: '#dc2626', title: 'Farmers Markets' },
  'poi_usda_food_hub': { icon: '📦', color: '#f97316', title: 'Food Hubs' },
  'poi_usda_onfarm_market': { icon: '🥕', color: '#eab308', title: 'On-Farm Markets' },
 
  // Transportation
  'poi_bus': { icon: '🚌', color: '#2563eb', title: 'Bus' },
  'poi_train': { icon: '🚂', color: '#7c3aed', title: 'Train' },
  'poi_subway_metro': { icon: '🚇', color: '#dc2626', title: 'Subway/Metro' },
  'poi_tram': { icon: '🚊', color: '#059669', title: 'Tram' },
  'poi_monorail': { icon: '🚝', color: '#ea580c', title: 'Monorail' },
  'poi_aerialway': { icon: '🚡', color: '#0891b2', title: 'Aerialway' },
  'poi_ferry': { icon: '⛴️', color: '#1d4ed8', title: 'Ferry' },
  'poi_airport_air': { icon: '✈️', color: '#7c2d12', title: 'Airport/Air' },
  'poi_taxi': { icon: '🚕', color: '#fbbf24', title: 'Taxi' },
  'poi_bike_scooter_share': { icon: '🚲', color: '#10b981', title: 'Bike/Scooter Share' },
  'poi_dockless_hub': { icon: '🛴️', color: '#8b5cf6', title: 'Dockless Hub' },
  'poi_electric_charging': { icon: '🔌', color: '#10b981', title: 'Electric Charging Stations' },
  'poi_gas_stations': { icon: '⛽', color: '#f59e0b', title: 'Gas Stations' },
  'poi_mail_shipping': { icon: '📮', color: '#3b82f6', title: 'Mail & Shipping' },
  'poi_colleges_universities': { icon: '🎓', color: '#7c3aed', title: 'Colleges & Universities' },
  'ct_urgent_care': { icon: '🏥', color: '#f97316', title: 'CT Urgent Care' },
  'ct_parcels': { icon: '🏠', color: '#059669', title: 'CT Parcels' },
  'ct_tribal_lands': { icon: '🏛️', color: '#8b5cf6', title: 'CT Tribal Lands' },
  'ct_drinking_water_watersheds': { icon: '💧', color: '#0891b2', title: 'CT Drinking Water Watersheds' },
  'ct_broadband_availability': { icon: '📡', color: '#7c3aed', title: 'CT 2025 Broadband Availability by Block' },
  'ct_water_pollution_control': { icon: '💧', color: '#0ea5e9', title: 'CT Water Pollution Control Facilities' },
  'ct_boat_launches': { icon: '🚤', color: '#3b82f6', title: 'CT Boat Launches' },
  'ct_federal_open_space': { icon: '🏞️', color: '#10b981', title: 'CT Federal Open Space' },
  'ct_huc_watersheds': { icon: '🌊', color: '#06b6d4', title: 'CT HUC Watershed Boundaries' },
  'ct_soils_parent_material': { icon: '🌱', color: '#a16207', title: 'CT Soils Parent Material Name' },
  'ca_power_outage_areas': { icon: '⚡', color: '#f59e0b', title: 'CA Power Outage Areas' },
  'ca_fire_perimeters_all': { icon: '🔥', color: '#dc2626', title: 'Historical CA Fire Perimeters (All)' },
  'ca_fire_perimeters_recent_large': { icon: '🔥', color: '#f97316', title: 'CA Recent Large Fire Perimeters' },
  'ca_fire_perimeters_1950': { icon: '🔥', color: '#f59e0b', title: 'CA Fire Perimeters (1950+)' },
  'ca_land_ownership': { icon: '🏛️', color: '#6366f1', title: 'CA Land Ownership' },
  'ca_wildland_fire_direct_protection': { icon: '🔥', color: '#eab308', title: 'CA Wildland Fire Direct Protection Areas' },
  'ca_calvtp_treatment_areas': { icon: '🔥', color: '#fbbf24', title: 'CA CalVTP Treatment Areas' },
  'ca_postfire_damage_inspections': { icon: '🔥', color: '#dc2626', title: 'CA Post-Fire Damage Inspections (DINS)' },
  'ca_medium_heavy_duty_infrastructure': { icon: '🚛', color: '#f97316', title: 'CA Medium & Heavy Duty Infrastructure' },
  'ca_frap_facilities': { icon: '🚒', color: '#dc2626', title: 'CA Facilities for Wildland Fire Protection' },
  'ca_solar_footprints': { icon: '☀️', color: '#fbbf24', title: 'CA Solar Footprints' },
  'ca_natural_gas_service_areas': { icon: '⛽', color: '#8b5cf6', title: 'CA Natural Gas Service Areas' },
  'ca_plss_sections': { icon: '🗺️', color: '#6366f1', title: 'CA Public Land Survey Sections' },
  'ca_geothermal_wells': { icon: '🌋', color: '#ea580c', title: 'CA Geothermal Wells' },
  'ca_oil_gas_wells': { icon: '🛢️', color: '#1f2937', title: 'CA Oil and Gas Wells' },
  'ca_eco_regions': { icon: '🌿', color: '#16a34a', title: 'CA Eco Regions' },
  'ca_la_zoning': { icon: '🏙️', color: '#7c3aed', title: 'City of Los Angeles Zoning' },
  'la_county_arts_recreation': { icon: '🎨', color: '#ec4899', title: 'LA County Arts and Recreation' },
  'la_county_education': { icon: '🎓', color: '#3b82f6', title: 'LA County Education' },
  'la_county_hospitals': { icon: '🏥', color: '#ef4444', title: 'LA County Hospitals' },
  'la_county_municipal_services': { icon: '🏛️', color: '#6366f1', title: 'LA County Municipal Services' },
  'la_county_physical_features': { icon: '🏔️', color: '#10b981', title: 'LA County Physical Features' },
  'la_county_public_safety': { icon: '🚨', color: '#dc2626', title: 'LA County Public Safety' },
  'la_county_transportation': { icon: '🚌', color: '#f59e0b', title: 'LA County Transportation' },
  'la_county_fire_hydrants': { icon: '🚒', color: '#ef4444', title: 'LA County Fire Hydrants' },
  'chicago_311': { icon: '📞', color: '#3b82f6', title: 'Chicago 311 Service Requests' },
  'chicago_traffic_crashes': { icon: '🚗', color: '#dc2626', title: 'Chicago Traffic Crashes' },
  'la_county_historic_cultural_monuments': { icon: '🏛️', color: '#a855f7', title: 'LA County Historic Cultural Monuments' },
  'la_county_housing_lead_risk': { icon: '🏠', color: '#dc2626', title: 'LA County Housing with Potential Lead Risk' },
  'la_county_school_district_boundaries': { icon: '🏫', color: '#3b82f6', title: 'LA County School District Boundaries' },
  'la_county_metro_lines': { icon: '🚇', color: '#7c3aed', title: 'LA County MTA Metro Lines' },
  'la_county_street_inventory': { icon: '🛣️', color: '#fbbf24', title: 'LA County Street Inventory' },
  'houston_roads_centerline': { icon: '🛣️', color: '#3b82f6', title: 'Houston Roads Centerline' },
  'houston_metro_bus_routes': { icon: '🚌', color: '#2563eb', title: 'Houston Metro Bus Routes' },
  'houston_metro_park_and_ride': { icon: '🚗', color: '#3b82f6', title: 'Houston METRO Park and Ride Locations' },
  'houston_metro_transit_centers': { icon: '🚇', color: '#8b5cf6', title: 'Houston METRO Transit Centers' },
  'houston_metro_rail_stations': { icon: '🚆', color: '#7c3aed', title: 'Houston METRO Rail Stations' },
  'houston_airports': { icon: '✈️', color: '#f59e0b', title: 'Houston Airports' },
  'houston_bikeways': { icon: '🚴', color: '#14b8a6', title: 'Houston Bikeways (Existing)' },
  'houston_olc_grid_6digit': { icon: '🗺️', color: '#8b5cf6', title: 'Houston OLC Grid - 6 Digits' },
  'houston_olc_grid_8digit': { icon: '🗺️', color: '#a855f7', title: 'Houston OLC Grid - 8 Digits' },
  'houston_fire_stations': { icon: '🚒', color: '#dc2626', title: 'Houston Fire Stations' },
  'houston_fire_hydrants': { icon: '🚰', color: '#ef4444', title: 'Houston Fire Hydrants' },
  'houston_tirz': { icon: '🏛️', color: '#f59e0b', title: 'Houston Tax Incentive Reinvestment Zones' },
  'houston_affordability': { icon: '🏘️', color: '#10b981', title: 'Houston Affordability (by Census Tract)' },
  'poi_osm_health_mental_behavioral': { icon: '🧠', color: '#7c3aed', title: 'Mental & Behavioral Health' },
  'poi_osm_health_fitness_movement': { icon: '🏃', color: '#f59e0b', title: 'Fitness & Movement' },
  'poi_osm_health_wellness_alternative': { icon: '🧘', color: '#10b981', title: 'Wellness & Alternative Care' },
  'poi_osm_health_public_community': { icon: '🏛️', color: '#8b5cf6', title: 'Public & Community Health' },
  'poi_osm_health_senior_assisted': { icon: '♿', color: '#ec4899', title: 'Senior & Assisted Care' },
  // LA County Hazards
  'la_county_fire_hazards': { icon: '🔥', color: '#dc2626', title: 'LA County Fire Hazards' },
  'la_county_fire_hazard_responsibility_areas': { icon: '🔥', color: '#ef4444', title: 'LA County Fire Hazard Responsibility Areas' },
  'la_county_fire_hazard_severity_zones': { icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones' },
  'la_county_fire_hazard_severity_zones_lra': { icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones LRA' },
  'la_county_fire_hazard_severity_zones_sra': { icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones SRA' },
  'la_county_earthquake_hazards': { icon: '🌍', color: '#7c2d12', title: 'LA County Earthquake Hazards' },
  'la_county_alquist_priolo_fault_traces': { icon: '⚡', color: '#991b1b', title: 'LA County Alquist-Priolo Fault Traces' },
  'la_county_alquist_priolo_fault_zones': { icon: '⚡', color: '#b91c1c', title: 'LA County Alquist-Priolo Fault Zones' },
  'la_county_usgs_faults': { icon: '⚡', color: '#dc2626', title: 'LA County USGS Faults' },
  'la_county_tsunami_inundation_runup_line': { icon: '🌊', color: '#0ea5e9', title: 'LA County Tsunami Inundation Runup Line' },
  'la_county_tsunami_inundation_zones': { icon: '🌊', color: '#0284c7', title: 'LA County Tsunami Inundation Zones' },
  'la_county_landslide_zones': { icon: '⛰️', color: '#a16207', title: 'LA County Landslide Zones' },
  'la_county_liquefaction_zones': { icon: '🌋', color: '#ca8a04', title: 'LA County Liquefaction Zones' },
  'la_county_flood_hazards': { icon: '💧', color: '#0ea5e9', title: 'LA County Flood Hazards' },
  'la_county_100_year_flood_plain': { icon: '💧', color: '#0284c7', title: 'LA County 100-Year Flood Plain' },
  'la_county_500_year_flood_plain': { icon: '💧', color: '#0369a1', title: 'LA County 500-Year Flood Plain' },
  'la_county_dam_inundation_eta': { icon: '🏗️', color: '#1e40af', title: 'LA County Dam Inundation ETA' },
  'la_county_dam_inundation_areas': { icon: '🏗️', color: '#1e3a8a', title: 'LA County Dam Inundation Areas' },
  // LA County Basemaps and Grids
  'la_county_us_national_grid': { icon: '🗺️', color: '#6366f1', title: 'LA County US National Grid' },
  'la_county_usng_100k': { icon: '🗺️', color: '#818cf8', title: 'LA County USNG 100K' },
  'la_county_usng_10000m': { icon: '🗺️', color: '#a78bfa', title: 'LA County USNG 10000M' },
  'la_county_usng_1000m': { icon: '🗺️', color: '#c084fc', title: 'LA County USNG 1000M' },
  'la_county_usng_100m': { icon: '🗺️', color: '#d8b4fe', title: 'LA County USNG 100M' },
  'la_county_township_range_section_rancho_boundaries': { icon: '📐', color: '#4b5563', title: 'LA County Township Range Section Rancho Boundaries' },
  // US National Grid
  'us_national_grid_usng_6x8_zones': { icon: '🗺️', color: '#3b82f6', title: 'USNG 6x8 Zones' },
  'us_national_grid_usng_100000m': { icon: '🗺️', color: '#2563eb', title: 'USNG 100000m' },
  'us_national_grid_usng_10000m': { icon: '🗺️', color: '#1d4ed8', title: 'USNG 10000m' },
  'us_national_grid_usng_1000m': { icon: '🗺️', color: '#1e40af', title: 'USNG 1000m' },
  'us_national_grid_usng_100m': { icon: '🗺️', color: '#1e3a8a', title: 'USNG 100m' },
  'us_historical_cultural_political_points': { icon: '🏛️', color: '#8b5cf6', title: 'US Historical Cultural Political Points' },
  'us_historical_hydrographic_points': { icon: '💧', color: '#06b6d4', title: 'US Historical Hydrographic Points' },
  'us_historical_physical_points': { icon: '🏔️', color: '#10b981', title: 'US Historical Physical Points' },
  'hurricane_evacuation_routes': { icon: '🌀', color: '#f97316', title: 'Hurricane Evacuation Routes' },
  'hurricane_evacuation_routes_hazards': { icon: '🌀', color: '#f97316', title: 'Hurricane Evacuation Routes' },
  // USGS Government Units
  'usgs_gov_incorporated_place': { icon: '🏛️', color: '#3b82f6', title: 'USGS Incorporated Place' },
  'usgs_gov_unincorporated_place': { icon: '🏘️', color: '#2563eb', title: 'USGS Unincorporated Place' },
  'usgs_gov_minor_civil_division': { icon: '🏘️', color: '#1d4ed8', title: 'USGS Minor Civil Division' },
  'usgs_gov_native_american_area': { icon: '🏕️', color: '#1e40af', title: 'USGS Native American Area' },
  'usgs_gov_national_park': { icon: '🏞️', color: '#059669', title: 'USGS National Park' },
  'usgs_gov_national_forest': { icon: '🌲', color: '#047857', title: 'USGS National Forest' },
  'usgs_gov_national_wilderness': { icon: '⛰️', color: '#065f46', title: 'USGS National Wilderness' },
  'usgs_gov_fish_wildlife_service': { icon: '🦅', color: '#0d9488', title: 'USGS US Fish & Wildlife Service' },
  'usgs_gov_national_grassland': { icon: '🌾', color: '#84cc16', title: 'USGS National Grassland' },
  'usgs_gov_national_cemetery': { icon: '🪦', color: '#64748b', title: 'USGS National Cemetery' },
  'usgs_gov_military_reserve': { icon: '🎖️', color: '#dc2626', title: 'USGS Military Reserve' },
  'usgs_gov_nasa_facility': { icon: '🚀', color: '#7c3aed', title: 'USGS NASA Facility' },
  'usgs_gov_met_washington_airport': { icon: '✈️', color: '#6366f1', title: 'USGS Met. Washington Airport' },
  'usgs_gov_tennessee_valley_authority': { icon: '⚡', color: '#f59e0b', title: 'USGS Tennessee Valley Authority' },
  'usgs_gov_bureau_land_management': { icon: '🌵', color: '#d97706', title: 'USGS Bureau of Land Management' },
  'usgs_gov_congressional_district': { icon: '🗳️', color: '#8b5cf6', title: 'USGS Congressional District' },
  'usgs_gov_county_equivalent': { icon: '🗺️', color: '#3b82f6', title: 'USGS County or Equivalent' },
  'usgs_gov_state_territory_small_scale': { icon: '🗺️', color: '#2563eb', title: 'USGS State or Territory (Small-Scale)' },
  'usgs_gov_state_territory_large_scale': { icon: '🗺️', color: '#1d4ed8', title: 'USGS State or Territory (Large-Scale)' },
  'tnm_structures': { icon: '🏢', color: '#3b82f6', title: 'TNM Structures' },
  'ca_state_parks_entry_points': { icon: '🏞️', color: '#059669', title: 'CA State Parks Entry Points' },
  'ca_state_parks_parking_lots': { icon: '🅿️', color: '#0891b2', title: 'CA State Parks Parking Lots' },
  'ca_state_parks_boundaries': { icon: '🏞️', color: '#10b981', title: 'CA State Parks Boundaries' },
  'ca_state_parks_campgrounds': { icon: '⛺', color: '#f59e0b', title: 'CA State Parks Campgrounds' },
  'ca_state_parks_recreational_routes': { icon: '🛤️', color: '#fbbf24', title: 'CA State Parks Recreational Routes' },
  'ca_condor_range': { icon: '🦅', color: '#7c3aed', title: 'CA Condor Range' },
  'ca_black_bear_range': { icon: '🐻', color: '#1f2937', title: 'CA Black Bear Range' },
  'ca_brush_rabbit_range': { icon: '🐰', color: '#92400e', title: 'CA Brush Rabbit Range' },
  'ca_great_gray_owl_range': { icon: '🦉', color: '#374151', title: 'CA Great Gray Owl Range' },
  'ca_sandhill_crane_range': { icon: '🦩', color: '#059669', title: 'CA Sandhill Crane Range' },
  'ca_highway_rest_areas': { icon: '🚗', color: '#dc2626', title: 'CA Highway Rest Areas' },
  'ca_marine_oil_terminals': { icon: '🛢️', color: '#1f2937', title: 'CA Marine Oil Terminals' },
  'de_state_forest': { icon: '🌲', color: '#16a34a', title: 'DE State Forest' },
  'de_pine_plantations': { icon: '🌲', color: '#15803d', title: 'DE Pine Plantations' },
  'de_child_care_centers': { icon: '🏫', color: '#f59e0b', title: 'DE Child Care Centers' },
  'de_fishing_access': { icon: '🎣', color: '#0284c7', title: 'DE Fishing Access' },
  'de_trout_streams': { icon: '🐟', color: '#0ea5e9', title: 'DE Trout Streams' },
  'de_public_schools': { icon: '🏫', color: '#3b82f6', title: 'DE Public Schools' },
  'de_private_schools': { icon: '🏛️', color: '#6366f1', title: 'DE Private Schools' },
  'de_votech_districts': { icon: '🎓', color: '#8b5cf6', title: 'DE VoTech Districts' },
  'de_school_districts': { icon: '📚', color: '#7c3aed', title: 'DE School Districts' },
  'de_stands_blinds_fields': { icon: '🎯', color: '#16a34a', title: 'DE Wildlife Areas Stands Blinds Fields' },
  'de_boat_ramps': { icon: '🚤', color: '#0284c7', title: 'DE Wildlife Areas Boat Ramps' },
  'de_facilities': { icon: '🏢', color: '#dc2626', title: 'DE Wildlife Areas Facilities' },
  'de_parking': { icon: '🅿️', color: '#f59e0b', title: 'DE Wildlife Areas Parking' },
  'de_restrooms': { icon: '🚻', color: '#8b5cf6', title: 'DE Wildlife Areas Restrooms' },
  'de_safety_zones': { icon: '⚠️', color: '#ef4444', title: 'DE Wildlife Areas Safety Zones' },
  'de_wildlife_management_zones': { icon: '🦌', color: '#059669', title: 'DE Wildlife Management Zones' },
  'ireland_provinces': { icon: '🇮🇪', color: '#10b981', title: 'Ireland Provinces' },
  'ireland_built_up_areas': { icon: '🏘️', color: '#3b82f6', title: 'Ireland Built-Up Areas' },
  'ireland_small_areas': { icon: '📍', color: '#8b5cf6', title: 'Ireland Small Areas' },
  'ireland_centres_of_population': { icon: '🏘️', color: '#a855f7', title: 'Ireland Centres of Population' },
  'de_rail_lines': { icon: '🚂', color: '#1f2937', title: 'DE Rail Lines' },
  'nj_parcels': { icon: '🏠', color: '#059669', title: 'NJ Tax Parcels' },
  'nj_address_points': { icon: '📍', color: '#3b82f6', title: 'NJ Address Points' },
  'uk_nspl_postcode_centroids': { icon: '📮', color: '#dc2626', title: 'NSPL Latest Postcode Centroids' },
  'nj_bus_stops': { icon: '🚌', color: '#f59e0b', title: 'NJ Bus Stops' },
  'nj_safety_service_patrol': { icon: '🚨', color: '#dc2626', title: 'NJ Safety Service Patrol' },
  'nj_service_areas': { icon: '🛣️', color: '#8b5cf6', title: 'NJ Service Areas' },
  'nj_roadway_network': { icon: '🛣️', color: '#fbbf24', title: 'NJ Roadway Network' },
  'nj_known_contaminated_sites': { icon: '⚠️', color: '#dc2626', title: 'NJ Known Contaminated Sites' },
  'nj_alternative_fuel_stations': { icon: '⛽', color: '#10b981', title: 'NJ Alternative Fuel Stations' },
  'nj_power_plants': { icon: '⚡', color: '#f59e0b', title: 'NJ Power Plants' },
  'nj_public_solar_facilities': { icon: '☀️', color: '#fbbf24', title: 'NJ Public Solar Facilities' },
  'nj_public_places_to_keep_cool': { icon: '❄️', color: '#3b82f6', title: 'NJ Public Places to Keep Cool' },
  'de_urban_tree_canopy': { icon: '🌳', color: '#22c55e', title: 'DE Urban Tree Canopy' },
  'de_forest_cover_2007': { icon: '🌲', color: '#166534', title: 'DE Forest Cover 2007' },
  'poi_walkability_index': { icon: '🚶', color: '#10b981', title: 'Walkability Index' },
   
  // Natural Resources
  'poi_beaches': { icon: '🏖️', color: '#fbbf24', title: 'Beaches' },
  'poi_lakes_ponds': { icon: '🏞️', color: '#0891b2', title: 'Lakes & Ponds' },
  'poi_rivers_streams': { icon: '🌊', color: '#1d4ed8', title: 'Rivers & Streams' },
  'poi_mountains_peaks': { icon: '🏔️', color: '#7c2d12', title: 'Mountains & Peaks' },
  'poi_aurora_viewing_sites': { icon: '🌌', color: '#a855f7', title: 'Aurora Viewing Sites' },
  'poi_ebird_hotspots': { icon: '🐦', color: '#1d4ed8', title: 'Birding Hotspots' },
  'ebird_recent_observations': { icon: '🪶', color: '#f97316', title: 'Recent Bird Observations' },
  
  // Public Lands & Protected Areas
  'poi_padus_public_access': { icon: '🏞️', color: '#22c55e', title: 'Public Lands' },
  'poi_padus_protection_status': { icon: '🛡️', color: '#059669', title: 'Protected Areas' },
  // District of Columbia Urban Tree Canopy
  'dc_urban_tree_canopy_anc_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Advisory Neighborhood Commission 2020' },
  'dc_urban_tree_canopy_census_block_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Census Block 2020' },
  'dc_urban_tree_canopy_census_block_group_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Census Block Group 2020' },
  'dc_urban_tree_canopy_2010_census_block_group_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by 2010 Census Block Group 2020' },
  'dc_urban_tree_canopy_dc_boundary_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by DC Boundary 2020' },
  'dc_urban_tree_canopy_dc_owned_property_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by DC Owned Property 2020' },
  'dc_urban_tree_canopy_generalized_ownership_parcel_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy at Generalized Ownership Parcel Level 2020' },
  'dc_urban_tree_canopy_ownership_lot_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy at Ownership Lot Level 2020' },
  'dc_urban_tree_canopy_2019_right_of_way_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by 2019 Right of Way 2020' },
  'dc_urban_tree_canopy_single_member_district_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Single Member District 2020' },
  'dc_urban_tree_canopy_ward_2020': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Ward 2020' },
  'dc_trees': { icon: '🌳', color: '#22c55e', title: 'DC Trees' },
  'dc_urban_tree_canopy_ownership_lot_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy at Ownership Lot Level 2015' },
  'dc_urban_tree_canopy_ward_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Ward 2015' },
  'dc_ufa_street_trees': { icon: '🌳', color: '#22c55e', title: 'DC UFA Street Trees' },
  'dc_arborists_zone': { icon: '🌳', color: '#22c55e', title: 'DC Arborists Zone' },
  'dc_urban_tree_canopy_anc_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Advisory Neighborhood Commission 2015' },
  'dc_urban_tree_canopy_census_block_group_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Census Block Group 2015' },
  'dc_urban_tree_canopy_census_block_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Census Block 2015' },
  'dc_urban_tree_canopy_single_member_district_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by Single Member District 2015' },
  'dc_urban_tree_canopy_2006_landuse_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by 2006 Landuse 2015' },
  'dc_urban_tree_canopy_2011_landuse_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by 2011 Landuse 2015' },
  'dc_urban_tree_canopy_2015_landuse_2015': { icon: '🌳', color: '#22c55e', title: 'DC Urban Tree Canopy by 2015 Landuse 2015' },
  'dc_trail_mile_marker': { icon: '📍', color: '#3b82f6', title: 'DC Trail Mile Marker' },
  'dc_planned_multi_use_trails': { icon: '🚴', color: '#3b82f6', title: 'DC Planned Multi Use Trails' },
  'dc_bicycle_lanes': { icon: '🚴', color: '#3b82f6', title: 'DC Bicycle Lanes' },
  'dc_bike_trails': { icon: '🚴', color: '#10b981', title: 'DC Bike Trails' },
  'dc_capital_bike_share_locations': { icon: '🚲', color: '#ef4444', title: 'DC Capital Bike Share Locations' },
  'dc_signed_bike_routes': { icon: '🚴', color: '#3b82f6', title: 'DC Signed Bike Routes' },
  'dc_nps_trails': { icon: '🥾', color: '#10b981', title: 'DC NPS Trails' },
  'dc_public_bike_racks': { icon: '🚲', color: '#6366f1', title: 'DC Public Bike Racks' },
  'dc_property_air_rights_lot_points': { icon: '📍', color: '#3b82f6', title: 'DC Air Rights Lot Points' },
  'dc_property_alley_frontage_lines': { icon: '🛣️', color: '#3b82f6', title: 'DC Alley Frontage Lines' },
  'dc_property_air_rights_lots_historical': { icon: '🏢', color: '#8b5cf6', title: 'DC Air Rights Lots (Historical)' },
  'dc_property_air_rights_lots': { icon: '🏢', color: '#8b5cf6', title: 'DC Air Rights Lots' },
  'dc_property_appropriation_points': { icon: '📍', color: '#3b82f6', title: 'DC Appropriation Points' },
  'dc_property_appropriations': { icon: '🏛️', color: '#8b5cf6', title: 'DC Appropriations' },
  'dc_property_assessment_neighborhoods': { icon: '🏘️', color: '#8b5cf6', title: 'DC Assessment Neighborhoods' },
  'dc_property_assessment_sub_neighborhoods': { icon: '🏘️', color: '#8b5cf6', title: 'DC Assessment Sub-Neighborhoods' },
  'dc_property_district_land_points': { icon: '📍', color: '#3b82f6', title: 'DC District Land Points' },
  'dc_property_building_restriction_lines': { icon: '🛣️', color: '#3b82f6', title: 'DC Building Restriction Lines' },
  'dc_property_certificate_of_occupancy_points': { icon: '📍', color: '#3b82f6', title: 'DC Certificate Of Occupancy Points' },
  'dc_property_military_bases': { icon: '🏛️', color: '#8b5cf6', title: 'DC Military Bases' },
  'dc_property_parcel_lot_points': { icon: '📍', color: '#3b82f6', title: 'DC Parcel Lot Points' },
  'dc_property_record_lot_points': { icon: '📍', color: '#3b82f6', title: 'DC Record Lot Points' },
  'dc_property_reservations_points': { icon: '📍', color: '#3b82f6', title: 'DC Reservations Points' },
  'dc_property_square_points': { icon: '📍', color: '#3b82f6', title: 'DC Square Points' },
  'dc_property_tax_lot_points': { icon: '📍', color: '#3b82f6', title: 'DC Tax Lot Points' },
  'dc_property_highway_plan_lines': { icon: '🛣️', color: '#3b82f6', title: 'DC Highway Plan Lines' },
  'dc_property_parcel_lots_historical': { icon: '🏘️', color: '#8b5cf6', title: 'DC Parcel Lots (Historical)' },
  'dc_property_parcel_lots': { icon: '🏘️', color: '#8b5cf6', title: 'DC Parcel Lots' },
  'dc_property_record_lots_historical': { icon: '🏘️', color: '#8b5cf6', title: 'DC Record Lots (Historical)' },
  'dc_property_record_lots': { icon: '🏘️', color: '#8b5cf6', title: 'DC Record Lots' },
  'dc_property_reservations_historical': { icon: '🏛️', color: '#8b5cf6', title: 'DC Reservations (Historical)' },
  'dc_property_reservations': { icon: '🏛️', color: '#8b5cf6', title: 'DC Reservations' },
  'dc_property_tax_lots_historical': { icon: '🏘️', color: '#8b5cf6', title: 'DC Tax Lots (Historical)' },
  'dc_property_tax_lots': { icon: '🏘️', color: '#8b5cf6', title: 'DC Tax Lots' },
  'dc_property_owner_polygons': { icon: '🏢', color: '#8b5cf6', title: 'DC Owner Polygons (Common Ownership Layer)' },
  'dc_property_square_boundaries': { icon: '🏛️', color: '#8b5cf6', title: 'DC Square Boundaries' },
  'dc_property_boundary_stones_location': { icon: '📍', color: '#3b82f6', title: 'DC Boundary Stones Location' },
  'dc_property_condo_approval_lots': { icon: '🏘️', color: '#8b5cf6', title: 'DC Condo Approval Lots' },
  'dc_property_public_easement_lines': { icon: '🛣️', color: '#3b82f6', title: 'DC Public Easement Lines' },
  'dc_property_district_land_rpta_ownership': { icon: '🏛️', color: '#8b5cf6', title: 'DC District Land (RPTA Ownership)' },
  'dc_property_federal_land_rpta_ownership': { icon: '🏛️', color: '#8b5cf6', title: 'DC Federal Land (RPTA Ownership)' },
  'dc_property_owner_lines_dimensions': { icon: '🛣️', color: '#3b82f6', title: 'DC Owner Lines (Dimensions)' },
  'dc_property_district_land': { icon: '🏛️', color: '#8b5cf6', title: 'DC District Land' },
  'dc_property_affordable_housing': { icon: '🏠', color: '#8b5cf6', title: 'DC Affordable Housing' },
  'dc_property_real_estate_portfolio': { icon: '🏢', color: '#8b5cf6', title: 'DC Real Estate Portfolio' },
  'dc_property_district_land_lines_dimensions': { icon: '🛣️', color: '#3b82f6', title: 'DC District Land Lines (Dimensions)' },
  'dc_property_wdcep_development_point': { icon: '📍', color: '#3b82f6', title: 'DC WDCEP Development Point' },
  'dc_property_alley_and_street_changes': { icon: '🏘️', color: '#8b5cf6', title: 'DC Alley and Street Changes' },
  'dc_property_district_structures': { icon: '🏢', color: '#8b5cf6', title: 'DC District Structures' },
  'dc_property_land_boundary_changes': { icon: '🏘️', color: '#8b5cf6', title: 'DC Land Boundary Changes' },
  'dc_property_alley_street_changes_dimensions': { icon: '🛣️', color: '#3b82f6', title: 'DC Alley Street Changes (Dimensions)' },
  'dc_property_vacant_and_blighted_building_footprints': { icon: '🏚️', color: '#8b5cf6', title: 'DC Vacant and Blighted Building Footprints' },
  'dc_property_vacant_and_blighted_building_addresses': { icon: '📍', color: '#3b82f6', title: 'DC Vacant and Blighted Building Addresses' },
  'blm_national_trails': { icon: '🥾', color: '#059669', title: 'BLM National GTLF Public Managed Trails' },
  'blm_national_motorized_trails': { icon: '🏍️', color: '#dc2626', title: 'BLM National GTLF Public Motorized Trails' },
  'blm_national_nonmotorized_trails': { icon: '🚶', color: '#10b981', title: 'BLM National GTLF Public Nonmotorized Trails' },
  'blm_national_limited_motorized_roads': { icon: '🛣️', color: '#ea580c', title: 'BLM National GTLF Limited Public Motorized Roads' },
  'blm_national_public_motorized_roads': { icon: '🛣️', color: '#f97316', title: 'BLM National GTLF Public Motorized Roads' },
  'blm_national_grazing_pastures': { icon: '🐄', color: '#a16207', title: 'BLM National Grazing Pasture Polygons' },
  'blm_national_acec': { icon: '🌿', color: '#16a34a', title: 'BLM National Areas of Critical Environmental Concern' },
  'blm_national_sheep_goat_grazing': { icon: '🐑', color: '#ca8a04', title: 'BLM National Sheep and Goat Billed Grazing Allotments' },
  'blm_national_sheep_goat_authorized_grazing': { icon: '🐐', color: '#d97706', title: 'BLM National Sheep and Goat Authorized Grazing Allotments' },
  'blm_national_nlcs_monuments_ncas': { icon: '🏛️', color: '#9333ea', title: 'BLM National NLCS National Monuments and National Conservation Areas' },
  'blm_national_wild_horse_burro_herd_areas': { icon: '🐴', color: '#7c2d12', title: 'BLM National Wild Horse and Burro Herd Areas' },
  'blm_national_recreation_sites': { icon: '🏕️', color: '#059669', title: 'BLM National Recreation Site Polygons' },
  'blm_national_fire_perimeters': { icon: '🔥', color: '#dc2626', title: 'BLM National Fire Perimeters' },
  'blm_national_lwcf': { icon: '💧', color: '#0284c7', title: 'BLM National Land and Water Conservation Fund (LWCF) Polygons' },
  'usfs_forest_boundaries': { icon: '🌲', color: '#166534', title: 'USFS Forest Boundaries' },
  'usfs_wilderness_areas': { icon: '🏔️', color: '#1e40af', title: 'USFS National Wilderness Areas' },
  'usfs_national_grasslands': { icon: '🌾', color: '#ca8a04', title: 'USFS National Grassland Units' },
  'usfs_hazardous_sites': { icon: '⚠️', color: '#dc2626', title: 'USFS Hazardous Sites (CERCLA Sites)' },
  'usfs_office_locations': { icon: '🏢', color: '#059669', title: 'USFS Office Locations' },
  'usfs_special_uses_communications_sites': { icon: '📡', color: '#0891b2', title: 'USFS Special Uses Communications Sites' },
  'usfs_administrative_boundaries': { icon: '🏛️', color: '#1e40af', title: 'USFS Administrative Boundaries' },
  'usfs_recreation_opportunities': { icon: '🏕️', color: '#059669', title: 'USFS Recreation Opportunities' },
  'usfs_recreation_area_activities': { icon: '🎯', color: '#7c3aed', title: 'USFS Recreation Area Activities' },
  'usfs_roads_closed_to_motorized': { icon: '🚫', color: '#dc2626', title: 'USFS Roads Closed to Motorized Uses' },
  'usfs_system_roads': { icon: '🛣️', color: '#6b7280', title: 'USFS System Roads' },
  'usfs_mvum': { icon: '🚗', color: '#f59e0b', title: 'USFS Motor Vehicle Use Map (MVUM)' },
  'usfs_co_roadless_areas': { icon: '🏔️', color: '#059669', title: 'USFS Colorado Roadless Areas' },
  
  // TIGER CBSA Layers
  'tiger_cbsa_combined_statistical_areas': { icon: '🏙️', color: '#3b82f6', title: 'TIGER Combined Statistical Areas' },
  'tiger_cbsa_metro_micropolitan_statistical_areas': { icon: '🏙️', color: '#2563eb', title: 'TIGER Metropolitan and Micropolitan Statistical Areas' },
  'tiger_cbsa_metropolitan_divisions': { icon: '🏙️', color: '#1d4ed8', title: 'TIGER Metropolitan Divisions' },
  'tiger_cbsa_metropolitan_statistical_areas': { icon: '🏙️', color: '#1e40af', title: 'TIGER Metropolitan Statistical Areas' },
  'tiger_cbsa_micropolitan_statistical_areas': { icon: '🏙️', color: '#1e3a8a', title: 'TIGER Micropolitan Statistical Areas' },
  'tiger_bas2025_cbsa_combined_statistical_areas': { icon: '🏙️', color: '#3b82f6', title: 'TIGER BAS 2025 Combined Statistical Areas' },
  'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas': { icon: '🏙️', color: '#2563eb', title: 'TIGER BAS 2025 Metropolitan and Micropolitan Statistical Areas' },
  'tiger_bas2025_cbsa_metropolitan_divisions': { icon: '🏙️', color: '#1d4ed8', title: 'TIGER BAS 2025 Metropolitan Divisions' },
  'tiger_bas2025_cbsa_metropolitan_statistical_areas': { icon: '🏙️', color: '#1e40af', title: 'TIGER BAS 2025 Metropolitan Statistical Areas' },
  'tiger_bas2025_cbsa_micropolitan_statistical_areas': { icon: '🏙️', color: '#1e3a8a', title: 'TIGER BAS 2025 Micropolitan Statistical Areas' },
  'tiger_acs2024_cbsa_combined_statistical_areas': { icon: '🏙️', color: '#3b82f6', title: 'TIGER ACS 2024 Combined Statistical Areas' },
  'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas': { icon: '🏙️', color: '#2563eb', title: 'TIGER ACS 2024 Metropolitan and Micropolitan Statistical Areas' },
  'tiger_acs2024_cbsa_metropolitan_divisions': { icon: '🏙️', color: '#1d4ed8', title: 'TIGER ACS 2024 Metropolitan Divisions' },
  'tiger_acs2024_cbsa_metropolitan_statistical_areas': { icon: '🏙️', color: '#1e40af', title: 'TIGER ACS 2024 Metropolitan Statistical Areas' },
  'tiger_acs2024_cbsa_micropolitan_statistical_areas': { icon: '🏙️', color: '#1e3a8a', title: 'TIGER ACS 2024 Micropolitan Statistical Areas' },
  'tiger_census2020_cbsa_combined_new_england_city_town_areas': { icon: '🏙️', color: '#3b82f6', title: 'TIGER Census 2020 Combined New England City and Town Areas' },
  'tiger_census2020_cbsa_new_england_city_town_areas': { icon: '🏙️', color: '#2563eb', title: 'TIGER Census 2020 New England City and Town Areas' },
  'tiger_census2020_cbsa_new_england_city_town_area_divisions': { icon: '🏙️', color: '#1d4ed8', title: 'TIGER Census 2020 New England City and Town Area Divisions' },
  'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas': { icon: '🏙️', color: '#1e40af', title: 'TIGER Census 2020 Metropolitan New England City and Town Areas' },
  'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas': { icon: '🏙️', color: '#1e3a8a', title: 'TIGER Census 2020 Micropolitan New England City and Town Areas' },
  'tiger_census2020_cbsa_combined_statistical_areas': { icon: '🏙️', color: '#3b82f6', title: 'TIGER Census 2020 Combined Statistical Areas' },
  'tiger_census2020_cbsa_metro_micropolitan_statistical_areas': { icon: '🏙️', color: '#2563eb', title: 'TIGER Census 2020 Metropolitan and Micropolitan Statistical Areas' },
  'tiger_census2020_cbsa_metropolitan_divisions': { icon: '🏙️', color: '#1d4ed8', title: 'TIGER Census 2020 Metropolitan Divisions' },
  'tiger_census2020_cbsa_metropolitan_statistical_areas': { icon: '🏙️', color: '#1e40af', title: 'TIGER Census 2020 Metropolitan Statistical Areas' },
  'tiger_census2020_cbsa_micropolitan_statistical_areas': { icon: '🏙️', color: '#1e3a8a', title: 'TIGER Census 2020 Micropolitan Statistical Areas' },
  // TIGER Urban Areas Layers
  'tiger_urban_2020_urban_areas': { icon: '🏙️', color: '#8b5cf6', title: 'TIGER 2020 Urban Areas' },
  'tiger_urban_bas2025_2020_urban_areas': { icon: '🏙️', color: '#7c3aed', title: 'TIGER BAS 2025 2020 Urban Areas' },
  'tiger_urban_acs2024_2020_urban_areas': { icon: '🏙️', color: '#6d28d9', title: 'TIGER ACS 2024 2020 Urban Areas' },
  'tiger_urban_census2020_2020_urban_areas_corrected': { icon: '🏙️', color: '#5b21b6', title: 'TIGER Census 2020 2020 Urban Areas - Corrected' },
  'tiger_urban_census2020_2020_urban_areas': { icon: '🏙️', color: '#4c1d95', title: 'TIGER Census 2020 2020 Urban Areas' },
  'tiger_urban_urban_areas': { icon: '🏙️', color: '#3b1a7a', title: 'TIGER Urban Areas' },
  
  'australia_waste_management_facilities': { icon: '🗑️', color: '#8b5cf6', title: 'Australia Waste Management Facilities' },
  'australia_maritime_ports': { icon: '⚓', color: '#0ea5e9', title: 'Australia Maritime Ports' },
  'default': { icon: '📍', color: '#6b7280', title: 'POI' }
};

// Color uniqueness system for point features
// Palette of distinct colors that are visually different
const UNIQUE_COLOR_PALETTE = [
  '#dc2626', '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e',
  '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#2563eb', '#6366f1',
  '#7c3aed', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e', '#8b5cf6',
  '#9333ea', '#7e22ce', '#6b21a8', '#581c87', '#4c1d95', '#3730a3', '#312e81',
  '#1e1b4b', '#1e3a8a', '#1e40af', '#1d4ed8', '#2563eb', '#3b82f6', '#60a5fa',
  '#38bdf8', '#22d3ee', '#06b6d4', '#0891b2', '#0e7490', '#155e75', '#164e63',
  '#075985', '#0c4a6e', '#082f49', '#172554', '#1e293b', '#334155', '#475569',
  '#64748b', '#94a3b8', '#cbd5e1', '#e2e8f0', '#f1f5f9', '#f8fafc', '#ffffff'
];

// Track used colors for point features to ensure uniqueness
const usedColors = new Map<string, string>(); // Maps POI key to color
const colorUsage = new Map<string, string[]>(); // Maps color to array of POI keys using it

// Track used colors for polygon layers to ensure uniqueness
const usedPolygonColors = new Map<string, string>(); // Maps layer key to color
const polygonColorUsage = new Map<string, string[]>(); // Maps color to array of layer keys using it

/**
 * Reset the color tracking system (call at start of each map render)
 */
function resetColorTracking(): void {
  usedColors.clear();
  colorUsage.clear();
  usedPolygonColors.clear();
  polygonColorUsage.clear();
}

/**
 * Get a unique color for a point feature, ensuring no duplicates
 */
function getUniqueColorForPointFeature(poiKey: string, defaultColor: string): string {
  // Check if this POI already has an assigned color
  if (usedColors.has(poiKey)) {
    return usedColors.get(poiKey)!;
  }

  // Check if default color is already used
  const currentUsers = colorUsage.get(defaultColor) || [];
  
  if (currentUsers.length === 0) {
    // Color is available, use it
    usedColors.set(poiKey, defaultColor);
    colorUsage.set(defaultColor, [poiKey]);
    return defaultColor;
  }

  // Color is already used, find a unique one from palette
  for (const candidateColor of UNIQUE_COLOR_PALETTE) {
    const users = colorUsage.get(candidateColor) || [];
    if (users.length === 0) {
      // Found an unused color
      usedColors.set(poiKey, candidateColor);
      colorUsage.set(candidateColor, [poiKey]);
      console.log(`🎨 Assigned unique color ${candidateColor} to ${poiKey} (default ${defaultColor} was already used)`);
      return candidateColor;
    }
  }

  // All colors used? Generate a random one (shouldn't happen in practice)
  const randomColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
  usedColors.set(poiKey, randomColor);
  colorUsage.set(randomColor, [poiKey]);
  console.warn(`⚠️ All palette colors used, generated random color ${randomColor} for ${poiKey}`);
  return randomColor;
}

/**
 * Get a unique color for a polygon layer, ensuring no duplicates across all polygon layers
 */
function getUniqueColorForPolygonLayer(layerKey: string, defaultColor: string): string {
  // Check if this layer already has an assigned color
  if (usedPolygonColors.has(layerKey)) {
    return usedPolygonColors.get(layerKey)!;
  }

  // Check if default color is already used by another polygon layer
  const currentUsers = polygonColorUsage.get(defaultColor) || [];
  
  if (currentUsers.length === 0) {
    // Color is available, use it
    usedPolygonColors.set(layerKey, defaultColor);
    polygonColorUsage.set(defaultColor, [layerKey]);
    return defaultColor;
  }

  // Color is already used, find a unique one from palette
  // Skip very light colors (near white) as they're hard to see on maps
  const visiblePalette = UNIQUE_COLOR_PALETTE.filter(color => {
    // Filter out very light colors (last few in palette)
    return !['#f8fafc', '#ffffff', '#f1f5f9', '#e2e8f0'].includes(color);
  });

  for (const candidateColor of visiblePalette) {
    const users = polygonColorUsage.get(candidateColor) || [];
    if (users.length === 0) {
      // Found an unused color
      usedPolygonColors.set(layerKey, candidateColor);
      polygonColorUsage.set(candidateColor, [layerKey]);
      console.log(`🎨 Assigned unique polygon color ${candidateColor} to ${layerKey} (default ${defaultColor} was already used)`);
      return candidateColor;
    }
  }

  // All colors used? Generate a distinct color using hash of layer key
  let hash = 0;
  for (let i = 0; i < layerKey.length; i++) {
    hash = layerKey.charCodeAt(i) + ((hash << 5) - hash);
  }
  // Generate a color in the visible range (avoid too light or too dark)
  const hue = Math.abs(hash) % 360;
  const saturation = 60 + (Math.abs(hash) % 30); // 60-90%
  const lightness = 40 + (Math.abs(hash) % 20); // 40-60%
  const generatedColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  
  usedPolygonColors.set(layerKey, generatedColor);
  polygonColorUsage.set(generatedColor, [layerKey]);
  console.warn(`⚠️ All palette colors used, generated color ${generatedColor} for polygon layer ${layerKey}`);
  return generatedColor;
}

/**
 * Filter out personal names from display text
 * Removes patterns like "Home of [Name]" or similar personal information
 */
function filterPersonalNames(text: string | null | undefined): string | null {
  if (!text || typeof text !== 'string') {
    return text || null;
  }
  
  // Remove patterns like "Home of [Name]" or "Home of [Name] & [Name]"
  const personalNamePatterns = [
    /^Home\s+of\s+[^,]+(?:,\s*[^,]+)*/i, // "Home of Name" or "Home of Name & Name"
    /^Home\s+of\s+[^&]+(?:\s*&\s*[^&]+)*/i, // "Home of Name & Name"
  ];
  
  let filtered = text;
  for (const pattern of personalNamePatterns) {
    filtered = filtered.replace(pattern, '').trim();
  }
  
  // If the entire text was just a personal name pattern, return null
  if (!filtered || filtered.length === 0) {
    return null;
  }
  
  return filtered;
}

// Create custom POI marker icons
const createPOIIcon = (emoji: string, color: string, isMobile: boolean = false) => {
  // Auto-detect mobile if not explicitly passed
  const isMobileDevice = isMobile || (typeof window !== 'undefined' && window.innerWidth <= 768);
  
  // For mobile, use simpler styling without thick white border to avoid white space issues
  if (isMobileDevice) {
    return L.divIcon({
      html: `<div style="
        background-color: ${color};
        border: 1px solid rgba(255,255,255,0.9);
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        box-shadow: none;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        line-height: 1;
        position: relative;
        z-index: 10;
      ">${emoji}</div>`,
      className: 'poi-marker poi-marker-mobile',
      iconSize: [28, 28],
      iconAnchor: [14, 14],
      popupAnchor: [0, -14]
      // Note: L.divIcon doesn't use shadowUrl, but we ensure it's null in global options above
    });
  }
  
  return L.divIcon({
    html: `<div style="
      background-color: ${color};
      border: 2px solid white;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      line-height: 1;
    ">${emoji}</div>`,
    className: 'poi-marker',
    iconSize: [32, 32],
    iconAnchor: [16, 16],
    popupAnchor: [0, -16]
  });
};

/**
 * Generate deep links to popular mapping platforms for a given location
 */
const generateMappingLinks = (lat: number, lon: number, name?: string): string => {
  const encodedName = name ? encodeURIComponent(name) : '';
  const encodedLocation = `${lat},${lon}`;
  
  const links = [
    {
      label: 'Google Maps',
      url: `https://www.google.com/maps/search/?api=1&query=${encodedLocation}${encodedName ? `&query_place_id=${encodedName}` : ''}`,
      icon: '🗺️'
    },
    {
      label: 'Apple Maps',
      url: `https://maps.apple.com/?q=${encodedLocation}${encodedName ? `&ll=${encodedLocation}` : ''}`,
      icon: '🍎'
    },
    {
      label: 'Waze',
      url: `https://waze.com/ul?ll=${encodedLocation}&navigate=yes`,
      icon: '🚗'
    },
    {
      label: 'OpenStreetMap',
      url: `https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}&zoom=15`,
      icon: '🌍'
    }
  ];
  
  return links.map(link => `
    <a 
      href="${link.url}" 
      target="_blank" 
      rel="noopener noreferrer"
      style="
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background-color: #f3f4f6;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        color: #374151;
        text-decoration: none;
        font-size: 11px;
        font-weight: 500;
        white-space: nowrap;
        transition: background-color 0.2s;
      "
      onmouseover="this.style.backgroundColor='#e5e7eb'"
      onmouseout="this.style.backgroundColor='#f3f4f6'"
    >
      <span>${link.icon}</span>
      <span>${link.label}</span>
    </a>
  `).join('');
};

/**
 * Helper function to extract coordinates from a feature object using common field patterns
 */
const extractCoordinates = (feature: any): { lat: number | undefined; lon: number | undefined } => {
  // Try various common field name patterns for coordinates
  const lat = feature.lat || feature.latitude || feature.y || feature.LAT || feature.LATITUDE || feature.Y ||
              feature.geometry?.y || feature.geometry?.coordinates?.[1] || feature.coordinates?.[1];
  const lon = feature.lon || feature.longitude || feature.x || feature.LON || feature.LONGITUDE || feature.X ||
              feature.geometry?.x || feature.geometry?.coordinates?.[0] || feature.coordinates?.[0];
  
  // Validate coordinates
  if (lat !== undefined && lon !== undefined && !isNaN(Number(lat)) && !isNaN(Number(lon))) {
    return { lat: Number(lat), lon: Number(lon) };
  }
  
  return { lat: undefined, lon: undefined };
};

/**
 * Helper function to add mapping links to popup content for point features
 * Can accept either explicit coordinates or a feature object to extract coordinates from
 */
const addMappingLinksToPopup = (
  content: string, 
  latOrFeature?: number | any, 
  lon?: number, 
  name?: string
): string => {
  let lat: number | undefined;
  let actualLon: number | undefined;
  
  // If first parameter is an object, extract coordinates from it
  if (typeof latOrFeature === 'object' && latOrFeature !== null) {
    const coords = extractCoordinates(latOrFeature);
    lat = coords.lat;
    actualLon = coords.lon;
    // Try to extract name from feature if not provided
    if (!name) {
      name = latOrFeature.name || latOrFeature.title || latOrFeature.facility || 
             latOrFeature.feature || latOrFeature.NAME || latOrFeature.TITLE || '';
    }
  } else {
    lat = latOrFeature;
    actualLon = lon;
  }
  
  if (!lat || !actualLon || isNaN(lat) || isNaN(actualLon)) return content;
  
  const mappingLinks = generateMappingLinks(lat, actualLon, name);
  const mappingSection = `
    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
      <div style="margin-bottom: 4px; font-size: 11px; font-weight: 600; color: #374151;">Open in Maps:</div>
      <div style="display: flex; flex-wrap: wrap; gap: 4px;">
        ${mappingLinks}
      </div>
    </div>`;
  
  // Find the last </div> before the closing backtick and insert mapping section before it
  const lastDivIndex = content.lastIndexOf('</div>');
  if (lastDivIndex !== -1) {
    return content.slice(0, lastDivIndex) + mappingSection + content.slice(lastDivIndex);
  }
  return content + mappingSection;
};

const createPOIPopupContent = (poi: any, legendTitle: string, key: string): string => {
    // Extract coordinates - try multiple possible field names
    const lat = poi.lat || poi.latitude || poi.y || poi.coordinates?.[1] || poi.geometry?.coordinates?.[1];
    const lon = poi.lon || poi.longitude || poi.x || poi.coordinates?.[0] || poi.geometry?.coordinates?.[0];
    const hasCoordinates = lat !== undefined && lon !== undefined && !isNaN(lat) && !isNaN(lon);
    
    // Helper to add mapping links if coordinates are available
    const addMappingLinks = (content: string, name?: string): string => {
      if (!hasCoordinates) return content;
      const mappingLinks = generateMappingLinks(lat, lon, name);
      // Insert mapping links before the final closing </div> tag
      const mappingSection = `
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
                    <div style="margin-bottom: 4px; font-size: 11px; font-weight: 600; color: #374151;">Open in Maps:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                      ${mappingLinks}
                    </div>
                  </div>`;
      // Find the last </div> before the closing backtick and insert mapping section before it
      const lastDivIndex = content.lastIndexOf('</div>');
      if (lastDivIndex !== -1) {
        return content.slice(0, lastDivIndex) + mappingSection + content.slice(lastDivIndex);
      }
      return content;
    };
    
    // Handle PADUS features specially
    if (key && key.includes('padus_')) {
      const name = poi.unitName || poi.boundaryName || poi.name || 'Unnamed Public Land';
      const categoryInfo = poi.category || poi.featureClass || '';
      const manager = poi.managerName || poi.managerType || 'Unknown';
      const access = poi.publicAccess || 'Unknown';
      const acres = poi.acres ? `${poi.acres.toLocaleString()} acres` : '';
      const state = poi.state || '';
      
      let content = `
        <div style="min-width: 250px; max-width: 350px;">
          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">${name}</h3>
          <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
            <div><strong>Category:</strong> ${categoryInfo}</div>
            ${manager ? `<div><strong>Manager:</strong> ${manager}</div>` : ''}
            ${access ? `<div><strong>Access:</strong> ${access}</div>` : ''}
            ${acres ? `<div><strong>Size:</strong> ${acres}</div>` : ''}
            ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
            ${poi.gapStatus ? `<div><strong>GAP Status:</strong> ${poi.gapStatus}</div>` : ''}
            ${poi.iucnCategory ? `<div><strong>IUCN Category:</strong> ${poi.iucnCategory}</div>` : ''}
          </div>
        </div>
      `;
      return addMappingLinks(content, name);
    }

    if (key === 'poi_ebird_hotspots') {
      const name = poi.name || poi.locName || legendTitle || 'Birding Hotspot';
      const speciesCount = poi.numSpeciesAllTime;
      const latestObservation = poi.latestObsDt
        ? new Date(poi.latestObsDt).toLocaleString()
        : null;
      const distance = poi.distance_miles ?? poi.distanceMiles ?? 'Unknown';
      const url = poi.url;

      let content = `
        <div style="min-width: 260px; max-width: 360px;">
          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">${name}</h3>
          <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
            📍 ${distance} miles away
          </div>
          <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
            🐦 Species recorded: ${speciesCount ?? 'Unknown'}
          </div>
          ${latestObservation ? `<div style="margin: 4px 0; font-size: 12px; color: #6b7280;">🗓️ Latest observation: ${latestObservation}</div>` : ''}
          ${url ? `<div style="margin-top: 8px;"><a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #1d4ed8; text-decoration: underline; font-size: 12px;">View hotspot on eBird</a></div>` : ''}
        </div>
      `;
      return addMappingLinks(content, name);
    }

    if (key === 'ebird_recent_observations') {
      const speciesName = poi.species_common_name || poi.comName || poi.name || 'Bird Observation';
      const scientificName = poi.species_scientific_name || poi.sciName || null;
      const count = poi.howMany ?? 1;
      const observationDate = poi.obsDt ? new Date(poi.obsDt).toLocaleString() : null;
      const locationName = poi.location_name || poi.locName || null;
      const distance = poi.distance_miles ?? 'Unknown';
      const checklistUrl = poi.checklistId ? `https://ebird.org/checklist/${poi.checklistId}` : poi.url;

      let content = `
        <div style="min-width: 260px; max-width: 360px;">
          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">${speciesName}</h3>
        ${scientificName ? `<div style="margin: 4px 0; font-size: 12px; color: #6b7280;"><em>${scientificName}</em></div>` : ''}
          <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
            📍 ${distance} miles away${locationName ? ` • ${locationName}` : ''}
          </div>
          <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
            👥 Count observed: ${count}
          </div>
          ${observationDate ? `<div style="margin: 4px 0; font-size: 12px; color: #6b7280;">🗓️ Observed: ${observationDate}</div>` : ''}
          ${checklistUrl ? `<div style="margin-top: 8px;"><a href="${checklistUrl}" target="_blank" rel="noopener noreferrer" style="color: #1d4ed8; text-decoration: underline; font-size: 12px;">View checklist</a></div>` : ''}
        </div>
      `;
      return addMappingLinks(content, locationName || speciesName);
    }

    // Handle Ireland Centres of Population
    if (key === 'ireland_centres_of_population' || key.includes('ireland_centres_of_population')) {
      const irishName = poi.irishName || poi.Irish_Name || poi.IRISH_NAME || '';
      const county = poi.county || poi.County || poi.COUNTY || '';
      const englishName = poi.englishName || poi.English_Na || poi.ENGLISH_NA || '';
      const distance = poi.distance_miles !== null && poi.distance_miles !== undefined ? poi.distance_miles : 0;
      
      // Use Irish Name as primary title if available, otherwise English Name
      const displayName = irishName || englishName || 'Unknown Centre';
      
      let content = `
        <div style="min-width: 250px; max-width: 400px;">
          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
            🏘️ ${displayName}
          </h3>
          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
            ${irishName ? `<div><strong>Irish Name:</strong> ${irishName}</div>` : ''}
            ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
            ${englishName && englishName !== displayName ? `<div><strong>English Name:</strong> ${englishName}</div>` : ''}
            ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
          </div>
        </div>
      `;
      return addMappingLinks(content, displayName);
    }
    
    const name = poi.tags?.name || poi.name || poi.title || 'Unnamed POI';
    const amenity = poi.tags?.amenity || poi.tags?.shop || poi.tags?.tourism || 'POI';
    const distance = poi.distance_miles || 'Unknown';
    
    let content = `
      <div style="min-width: 250px; max-width: 350px;">
        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">${name}</h3>
        <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
          📍 ${legendTitle} • ${distance} miles away
        </div>
        <div style="margin: 4px 0; font-size: 12px; color: #6b7280;">
          🏷️ Type: ${amenity}
        </div>
      </div>
    `;
    return addMappingLinks(content, name);
  };

const formatPopupFieldName = (key: string): string => {
  return key
    .replace(/^poi_/g, 'POI ')
    .replace(/^at_/g, 'AT ')
    .replace(/^pct_/g, 'PCT ')
    .replace(/nws/g, 'NWS')
    .replace(/fws/g, 'FWS')
    .replace(/_/g, ' ')
    .replace(/\b\w/g, l => l.toUpperCase());
};

const formatPopupValue = (value: any, key: string): string => {
  if (value === null || value === undefined) return '';
  if (typeof value === 'boolean') return value ? 'Yes' : 'No';
  if (typeof value === 'number') {
    if (key.includes('elevation') || key.includes('elev')) {
      return `${value.toLocaleString()} ft`;
    }
    if (key.includes('radius_km')) {
      return `${value.toLocaleString()} km`;
    }
    if (key.includes('radius') || key.includes('miles')) {
      return `${value} miles`;
    }
    if (key.includes('income') || key.includes('median_income')) {
      return `$${value.toLocaleString()}`;
    }
    return value.toLocaleString();
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return 'None found';
    if (key.includes('_all_pois') || key.includes('_detailed') || key.includes('_elements') || key.includes('_features')) {
      return `${value.length} found (see map/CSV for details)`;
    }
    return `${value.length} items`;
  }
  if (typeof value === 'object') {
    if (value.name) return String(value.name);
    if (value.title) return String(value.title);
    if (value.value) return String(value.value);

    if (key.includes('padus_') && (key.includes('_counts') || key.includes('_count'))) {
      const entries = Object.entries(value).map(([k, v]) => `${k}: ${v}`);
      return entries.join(', ');
    }

    // Exclude geometry and other large/unusable fields when stringifying objects
    const sanitized = { ...value };
    delete sanitized.geometry;
    delete sanitized.__geometry;
    delete sanitized.rings;
    delete sanitized.paths;
    delete sanitized.coordinates;
    delete sanitized.attributes; // Skip raw attributes object
    
    // If object is now empty or only has metadata, return a simple message
    const remainingKeys = Object.keys(sanitized);
    if (remainingKeys.length === 0) {
      return 'Feature data (see map/CSV for details)';
    }
    
    // Only stringify if there are meaningful fields left
    return JSON.stringify(sanitized);
  }
  return String(value);
};

const buildPopupSections = (enrichments: Record<string, any>): Array<{ category: string; items: { label: string; value: string }[] }> => {
  const sections: Record<string, { label: string; value: string }[]> = {};

  const shouldSkipField = (key: string) => (
    key.includes('_all_pois') ||
    key.includes('_detailed') ||
    key.includes('_elements') ||
    key.includes('_features') ||
    key.endsWith('_all') ||
    key.toLowerCase().includes('all_pois') ||
    key.toLowerCase().includes('_geometry') ||
    key.toLowerCase().includes('_raw') ||
    key.toLowerCase().includes('_geojson') ||
    key.includes('_attributes') || // Skip attributes fields (raw JSON data)
    key === 'nh_parcels_all' || // Skip parcels array (handled separately for map drawing)
    key === 'nh_recreation_trails_all' || // Skip trails array (handled separately for map drawing)
    key === 'nh_dot_roads_all' || // Skip roads array (handled separately for map drawing)
    key === 'nh_railroads_all' || // Skip railroads array (handled separately for map drawing)
    key === 'nh_transmission_pipelines_all' || // Skip transmission/pipelines array (handled separately for map drawing)
    key === 'nh_cell_towers_all' || // Skip cell towers array (handled separately for map drawing)
    key === 'nh_underground_storage_tanks_all' || // Skip underground storage tanks array (handled separately for map drawing)
    key === 'nh_water_wells_all' || // Skip water wells array (handled separately for map drawing)
    key === 'nh_public_water_supply_wells_all' || // Skip public water supply wells array (handled separately for map drawing)
    key === 'nh_remediation_sites_all' || // Skip remediation sites array (handled separately for map drawing)
    key === 'nh_automobile_salvage_yards_all' || // Skip automobile salvage yards array (handled separately for map drawing)
    key === 'nh_solid_waste_facilities_all' || // Skip solid waste facilities array (handled separately for map drawing)
    key === 'nh_source_water_protection_area_geometry' || // Skip geometry field (handled separately for map drawing)
    key === 'nh_nwi_plus_geometry' || // Skip geometry field (handled separately for map drawing)
    key === 'nh_nwi_plus_all' || // Skip wetlands array (handled separately for map drawing)
    key === 'nh_ssurgo_all' || // Skip SSURGO soils array (handled separately for map drawing)
    key === 'nh_bedrock_geology_all' || // Skip Bedrock Geology array (handled separately for map drawing)
    key === 'nh_geographic_names_all' || // Skip Geographic Names array (handled separately for map drawing)
    key === 'padus_public_access_all' || // Skip PAD-US public access array (handled separately for map drawing)
    key === 'padus_protection_status_all' || // Skip PAD-US protection status array (handled separately for map drawing)
    key === 'usgs_trails_all' || // Skip USGS Trails array (handled separately for map drawing)
    (key.startsWith('usgs_transportation_') && key.endsWith('_all')) || // Skip USGS Transportation arrays (handled separately for map drawing)
    (key.startsWith('usgs_geonames_') && key.endsWith('_all')) || // Skip USGS GeoNames arrays (handled separately for map drawing)
    (key.startsWith('usgs_selectable_polygons_') && key.endsWith('_all')) || // Skip USGS Selectable Polygons arrays (handled separately for map drawing)
    (key.startsWith('dc_utc_') && key.endsWith('_all')) || // Skip DC Urban Tree Canopy arrays (handled separately for map drawing)
    (key.startsWith('dc_bike_') && key.endsWith('_all')) || // Skip DC Bike Trails arrays (handled separately for map drawing)
    (key.startsWith('dc_property_') && key.endsWith('_all')) || // Skip DC Property and Land arrays (handled separately for map drawing)
    key === 'blm_national_trails_all' || // Skip BLM National Trails array (handled separately for map drawing)
    key === 'blm_national_motorized_trails_all' || // Skip BLM National Motorized Trails array (handled separately for map drawing)
    key === 'blm_national_nonmotorized_trails_all' || // Skip BLM National Nonmotorized Trails array (handled separately for map drawing)
    key === 'blm_national_limited_motorized_roads_all' || // Skip BLM National Limited Motorized Roads array (handled separately for map drawing)
    key === 'blm_national_public_motorized_roads_all' || // Skip BLM National Public Motorized Roads array (handled separately for map drawing)
    key === 'blm_national_grazing_pastures_all' || // Skip BLM National Grazing Pastures array (handled separately for map drawing)
    key === 'blm_national_acec_all' || // Skip BLM National ACEC array (handled separately for map drawing)
    key === 'blm_national_sheep_goat_grazing_all' || // Skip BLM National Sheep/Goat Billed Grazing Allotments array (handled separately for map drawing)
    key === 'blm_national_sheep_goat_authorized_grazing_all' || // Skip BLM National Sheep/Goat Authorized Grazing Allotments array (handled separately for map drawing)
    key === 'blm_national_nlcs_monuments_ncas_all' || // Skip BLM National NLCS Monuments/NCAs array (handled separately for map drawing)
    key === 'blm_national_wild_horse_burro_herd_areas_all' || // Skip BLM National Wild Horse/Burro Herd Areas array (handled separately for map drawing)
    key === 'blm_national_recreation_sites_all' || // Skip BLM National Recreation Sites array (handled separately for map drawing)
    key === 'blm_national_fire_perimeters_all' || // Skip BLM National Fire Perimeters array (handled separately for map drawing)
    key === 'blm_national_lwcf_all' || // Skip BLM National LWCF Polygons array (handled separately for map drawing)
    key === 'usfs_forest_boundaries_all' || // Skip USFS Forest Boundaries array (handled separately for map drawing)
    key === 'usfs_wilderness_areas_all' || // Skip USFS Wilderness Areas array (handled separately for map drawing)
    key === 'chinook_salmon_ranges_all' || // Skip Chinook Salmon Ranges array (handled separately for map drawing)
    key === 'tx_school_districts_2024_all' || // Skip TX School Districts 2024 array (handled separately for map drawing)
    key === 'wri_aqueduct_water_risk_future_annual_all' || // Skip WRI Aqueduct Water Risk Future Annual array (handled separately for map drawing)
    key === 'wri_aqueduct_water_risk_baseline_annual_all' || // Skip WRI Aqueduct Water Risk Baseline Annual array (handled separately for map drawing)
    key === 'wri_aqueduct_water_risk_baseline_monthly_all' || // Skip WRI Aqueduct Water Risk Baseline Monthly array (handled separately for map drawing)
    key.startsWith('acs_') && key.endsWith('_all') || // Skip all ACS boundary arrays (handled separately for map drawing)
    key === 'pr_hydrology_all' || // Skip Puerto Rico Hydrology array (handled separately for map drawing)
    key === 'sc_trout_streams_all' || // Skip SC Trout Streams array (handled separately for map drawing)
    key === 'sc_scenic_rivers_all' || // Skip SC Scenic Rivers array (handled separately for map drawing)
    key === 'sc_game_zones_all' || // Skip SC Game Zones array (handled separately for map drawing)
    key === 'sc_coastal_ponds_all' || // Skip SC Coastal Ponds array (handled separately for map drawing)
    key === 'sc_lakes_reservoirs_all' || // Skip SC Lakes and Reservoirs array (handled separately for map drawing)
    key === 'sc_coastal_well_inventory_all' || // Skip SC Coastal Well Inventory array (handled separately for map drawing)
    key === 'usfws_final_critical_habitat_all' || // Skip USFWS Final Critical Habitat array (handled separately for map drawing)
    key === 'usfws_proposed_critical_habitat_all' || // Skip USFWS Proposed Critical Habitat array (handled separately for map drawing)
    key === 'national_aquatic_barrier_dams_all' || // Skip National Aquatic Barrier Dam Inventory array (handled separately for map drawing)
    key === 'american_eel_current_range_all' || // Skip American Eel Current Range array (handled separately for map drawing)
    key === 'bighorn_sheep_captures_releases_all' || // Skip Bighorn Sheep Captures and Releases array (handled separately for map drawing)
    key === 'orlando_christmas_lights_all' || // Skip Orlando Christmas Lights array (handled separately for map drawing)
    key === 'us_drilling_platforms_all' || // Skip US Drilling Platforms array (handled separately for map drawing)
    key === 'guam_villages_all' || // Skip Guam Villages array (handled separately for map drawing)
    key === 'guam_state_boundary_all' || // Skip Guam State Boundary array (handled separately for map drawing)
    key === 'nps_national_parks_all' || // Skip NPS National Parks array (handled separately for map drawing)
    key === 'usfs_national_grasslands_all' || // Skip USFS National Grasslands array (handled separately for map drawing)
    key === 'usfs_hazardous_sites_all' || // Skip USFS Hazardous Sites array (handled separately for map drawing)
    key === 'usfs_office_locations_all' || // Skip USFS Office Locations array (handled separately for map drawing)
    key === 'usfs_special_uses_communications_sites_all' || // Skip USFS Special Uses Communications Sites array (handled separately for map drawing)
    key === 'usfs_administrative_boundaries_all' || // Skip USFS Administrative Boundaries array (handled separately for map drawing)
    key === 'usfs_recreation_opportunities_all' || // Skip USFS Recreation Opportunities array (handled separately for map drawing)
    key === 'usfs_recreation_area_activities_all' || // Skip USFS Recreation Area Activities array (handled separately for map drawing)
    key === 'usfs_roads_closed_to_motorized_all' || // Skip USFS Roads Closed to Motorized Uses array (handled separately for map drawing)
    key === 'usfs_system_roads_all' || // Skip USFS System Roads array (handled separately for map drawing)
    key === 'usfs_mvum_all' || // Skip USFS MVUM array (handled separately for map drawing)
    key === 'usfs_co_roadless_areas_all' || // Skip USFS Colorado Roadless Areas array (handled separately for map drawing)
    key === 'ma_regional_planning_agencies_all' || // Skip MA Regional Planning Agencies array (handled separately for map drawing)
    key === 'ma_acecs_all' || // Skip MA ACECs array (handled separately for map drawing)
    key === 'ma_parcels_all' || // Skip MA parcels array (handled separately for map drawing)
    key === 'ct_parcels_all' || // Skip CT parcels array (handled separately for map drawing)
    key === 'de_parcels_all' || // Skip DE parcels array (handled separately for map drawing)
    key === 'de_lulc_2007_all' || // Skip DE LULC arrays (handled separately for map drawing)
    key === 'de_lulc_2007_revised_all' || // Skip DE LULC arrays (handled separately for map drawing)
    key === 'de_lulc_2012_all' || // Skip DE LULC arrays (handled separately for map drawing)
    key === 'de_lulc_2017_all' || // Skip DE LULC arrays (handled separately for map drawing)
    key === 'de_lulc_2022_all' || // Skip DE LULC arrays (handled separately for map drawing)
    key === 'de_child_care_centers_all' || // Skip DE Child Care Centers array (handled separately for map drawing)
    key === 'de_fishing_access_all' || // Skip DE Fishing Access array (handled separately for map drawing)
    key === 'de_trout_streams_all' || // Skip DE Trout Streams array (handled separately for map drawing)
    key === 'de_public_schools_all' || // Skip DE Public Schools array (handled separately for map drawing)
    key === 'de_private_schools_all' || // Skip DE Private Schools array (handled separately for map drawing)
    key === 'de_votech_districts_all' || // Skip DE VoTech Districts array (handled separately for map drawing)
    key === 'de_school_districts_all' || // Skip DE School Districts array (handled separately for map drawing)
    key === 'de_stands_blinds_fields_all' || // Skip DE Stands Blinds Fields array (handled separately for map drawing)
    key === 'de_boat_ramps_all' || // Skip DE Boat Ramps array (handled separately for map drawing)
    key === 'de_facilities_all' || // Skip DE Facilities array (handled separately for map drawing)
    key === 'de_parking_all' || // Skip DE Parking array (handled separately for map drawing)
    key === 'de_restrooms_all' || // Skip DE Restrooms array (handled separately for map drawing)
    key === 'de_safety_zones_all' || // Skip DE Safety Zones array (handled separately for map drawing)
    key === 'de_wildlife_management_zones_all' || // Skip DE Wildlife Management Zones array (handled separately for map drawing)
    key === 'de_rail_lines_all' || // Skip DE Rail Lines array (handled separately for map drawing)
    key === 'nj_parcels_all' || // Skip NJ Parcels array (handled separately for map drawing)
    key === 'nj_address_points_all' || // Skip NJ Address Points array (handled separately for map drawing)
    key === 'nj_bus_stops_all' || // Skip NJ Bus Stops array (handled separately for map drawing)
    key === 'nj_safety_service_patrol_all' || // Skip NJ Safety Service Patrol array (handled separately for map drawing)
    key === 'nj_service_areas_all' || // Skip NJ Service Areas array (handled separately for map drawing)
    key === 'nj_roadway_network_all' || // Skip NJ Roadway Network array (handled separately for map drawing)
    key === 'nj_known_contaminated_sites_all' || // Skip NJ Known Contaminated Sites array (handled separately for map drawing)
    key === 'nj_alternative_fuel_stations_all' || // Skip NJ Alternative Fuel Stations array (handled separately for map drawing)
    key === 'nj_power_plants_all' || // Skip NJ Power Plants array (handled separately for map drawing)
    key === 'nj_public_solar_facilities_all' || // Skip NJ Public Solar Facilities array (handled separately for map drawing)
    key === 'nj_public_places_to_keep_cool_all' || // Skip NJ Public Places to Keep Cool array (handled separately for map drawing)
    key === 'ct_building_footprints_all' || // Skip CT building footprints array (handled separately for map drawing)
    key === 'ct_roads_all' || // Skip CT roads array (handled separately for map drawing)
    key === 'ct_urgent_care_all' || // Skip CT urgent care array (handled separately for map drawing)
    key === 'ct_deep_properties_all' || // Skip CT DEEP properties array (handled separately for map drawing)
    key === 'ct_tribal_lands_all' || // Skip CT Tribal Lands array (handled separately for map drawing)
    key === 'ct_drinking_water_watersheds_all' || // Skip CT Drinking Water Watersheds array (handled separately for map drawing)
    key === 'ct_broadband_availability_all' || // Skip CT Broadband Availability array (handled separately for map drawing)
    key === 'ct_water_pollution_control_all' || // Skip CT Water Pollution Control array (handled separately for map drawing)
    key === 'ct_boat_launches_all' || // Skip CT Boat Launches array (handled separately for map drawing)
    key === 'ct_federal_open_space_all' || // Skip CT Federal Open Space array (handled separately for map drawing)
    key === 'ct_huc_watersheds_all' || // Skip CT HUC Watersheds array (handled separately for map drawing)
    key === 'ct_soils_parent_material_all' || // Skip CT Soils Parent Material array (handled separately for map drawing)
    key === 'ca_power_outage_areas_all' || // Skip CA Power Outage Areas array (handled separately for map drawing)
    key === 'ca_fire_perimeters_all_all' || // Skip CA Fire Perimeters (All) array (handled separately for map drawing)
    key === 'ca_fire_perimeters_recent_large_all' || // Skip CA Recent Large Fire Perimeters array (handled separately for map drawing)
    key === 'ca_fire_perimeters_1950_all' || // Skip CA Fire Perimeters (1950+) array (handled separately for map drawing)
    key === 'ca_land_ownership_all' || // Skip CA Land Ownership array (handled separately for map drawing)
    key === 'ca_cgs_landslide_zones_all' || // Skip CA CGS Landslide Zones array (handled separately for map drawing)
    key === 'ca_cgs_liquefaction_zones_all' || // Skip CA CGS Liquefaction Zones array (handled separately for map drawing)
    key === 'ca_wildland_fire_direct_protection_all' || // Skip CA Wildland Fire Direct Protection Areas array (handled separately for map drawing)
    key === 'ca_calvtp_treatment_areas_all' || // Skip CA CalVTP Treatment Areas array (handled separately for map drawing)
    key === 'ca_postfire_damage_inspections_all' || // Skip CA Post-Fire Damage Inspections array (handled separately for map drawing)
    key === 'ca_medium_heavy_duty_infrastructure_all' || // Skip CA Medium and Heavy Duty Infrastructure array (handled separately for map drawing)
    key === 'ca_frap_facilities_all' || // Skip CA FRAP Facilities array (handled separately for map drawing)
    key === 'ca_solar_footprints_all' || // Skip CA Solar Footprints array (handled separately for map drawing)
    key === 'ca_natural_gas_service_areas_all' || // Skip CA Natural Gas Service Areas array (handled separately for map drawing)
    key === 'ca_plss_sections_all' || // Skip CA PLSS Sections array (handled separately for map drawing)
    key === 'ca_geothermal_wells_all' || // Skip CA Geothermal Wells array (handled separately for map drawing)
    key === 'ca_oil_gas_wells_all' || // Skip CA Oil and Gas Wells array (handled separately for map drawing)
    key === 'ca_eco_regions_all' || // Skip CA Eco Regions array (handled separately for map drawing)
    key === 'ca_la_zoning_all' || // Skip City of Los Angeles Zoning array (handled separately for map drawing)
    key === 'la_county_arts_recreation_all' || // Skip LA County Arts and Recreation array (handled separately for map drawing)
    key === 'la_county_education_all' || // Skip LA County Education array (handled separately for map drawing)
    key === 'la_county_hospitals_all' || // Skip LA County Hospitals array (handled separately for map drawing)
    key === 'la_county_municipal_services_all' || // Skip LA County Municipal Services array (handled separately for map drawing)
    key === 'la_county_physical_features_all' || // Skip LA County Physical Features array (handled separately for map drawing)
    key === 'la_county_public_safety_all' || // Skip LA County Public Safety array (handled separately for map drawing)
    key === 'la_county_transportation_all' || // Skip LA County Transportation array (handled separately for map drawing)
    key === 'la_county_fire_hydrants_all' || // Skip LA County Fire Hydrants array (handled separately for map drawing)
    key === 'chicago_311_all' || // Skip Chicago 311 array (handled separately for map drawing)
    key === 'chicago_building_footprints_all' || // Skip Chicago Building Footprints array (handled separately for map drawing)
    key === 'lake_county_building_footprints_all' || // Skip Lake County Building Footprints array (handled separately for map drawing)
    key === 'lake_county_pavement_boundaries_all' || // Skip Lake County Pavement Boundaries array (handled separately for map drawing)
    key === 'lake_county_parcel_points_all' || // Skip Lake County Parcel Points array (handled separately for map drawing)
    key === 'lake_county_parcels_all' || // Skip Lake County Parcels array (handled separately for map drawing)
    key === 'lake_county_facility_site_polygons_all' || // Skip Lake County Facility Site Polygons array (handled separately for map drawing)
    key === 'lake_county_high_school_districts_all' || // Skip Lake County High School Districts array (handled separately for map drawing)
    (key.startsWith('nws_') && key.endsWith('_all') && key !== 'nws_drought_current_all') || // Skip NWS layers arrays (handled separately for map drawing), except drought current
    key === 'nws_drought_current_all' || // Skip NWS Current Drought Conditions array (handled separately for map drawing)
    key === 'chicago_traffic_crashes_all' || // Skip Chicago Traffic Crashes array (handled separately for map drawing)
    key === 'chicago_speed_cameras_all' || // Skip Chicago Speed Cameras array (handled separately for map drawing)
    key === 'chicago_red_light_cameras_all' || // Skip Chicago Red Light Cameras array (handled separately for map drawing)
    key === 'nyc_mappluto_all' || // Skip NYC MapPLUTO array (handled separately for map drawing)
    key === 'nyc_mappluto_commercial_mixed_use_all' || // Skip NYC MapPLUTO Commercial + Mixed Use array (handled separately for map drawing)
    key === 'nyc_mappluto_retail_all' || // Skip NYC MapPLUTO Retail array (handled separately for map drawing)
    key === 'nyc_mappluto_office_all' || // Skip NYC MapPLUTO Office array (handled separately for map drawing)
    key === 'nyc_mappluto_industrial_all' || // Skip NYC MapPLUTO Industrial array (handled separately for map drawing)
    key === 'nyc_mappluto_warehouses_all' || // Skip NYC MapPLUTO Warehouses array (handled separately for map drawing)
    key === 'nyc_mappluto_hotels_all' || // Skip NYC MapPLUTO Hotels array (handled separately for map drawing)
    key === 'nyc_mappluto_auto_commercial_all' || // Skip NYC MapPLUTO Auto Commercial array (handled separately for map drawing)
    key === 'nyc_mappluto_large_commercial_all' || // Skip NYC MapPLUTO Large Commercial array (handled separately for map drawing)
    key === 'nyc_mappluto_residential_all' || // Skip NYC MapPLUTO Residential array (handled separately for map drawing)
    key === 'scotland_transport_gritter_locations_all' || // Skip Scotland Gritter Locations array (handled separately for map drawing)
    key === 'scotland_transport_trunk_road_height_all' || // Skip Scotland Trunk Road Height array (handled separately for map drawing)
    key === 'miami_business_fd_inspected_all' || // Skip Miami Business FD Inspected array (handled separately for map drawing)
    key === 'miami_public_schools_all' || // Skip Miami Public Schools array (handled separately for map drawing)
    key === 'miami_private_schools_all' || // Skip Miami Private Schools array (handled separately for map drawing)
    key === 'miami_water_bodies_all' || // Skip Miami Water Bodies array (handled separately for map drawing)
    key === 'fldot_bike_routes_all' || // Skip FLDOT Bike Routes array (handled separately for map drawing)
    key === 'fldot_real_time_traffic_all' || // Skip FLDOT Real-Time Traffic array (handled separately for map drawing)
    key === 'fldot_facilities_all' || // Skip FLDOT Facilities array (handled separately for map drawing)
    key === 'fldot_bike_slots_all' || // Skip FLDOT Bike Slots array (handled separately for map drawing)
    key === 'fldot_bike_lanes_all' || // Skip FLDOT Bike Lanes array (handled separately for map drawing)
    key === 'fldot_railroad_crossings_all' || // Skip FLDOT Railroad Crossings array (handled separately for map drawing)
    key === 'fldot_number_of_lanes_all' || // Skip FLDOT Number of Lanes array (handled separately for map drawing)
    key === 'fldot_rest_areas_all' || // Skip FLDOT Rest Areas array (handled separately for map drawing)
    key === 'fldot_functional_classification_all' || // Skip FLDOT Functional Classification array (handled separately for map drawing)
    key === 'wy_bighorn_sheep_crucial_range_all' || // Skip WY Bighorn Sheep Crucial Range array (handled separately for map drawing)
    key === 'nyc_bike_routes_all' || // Skip NYC Bike Routes array (handled separately for map drawing)
    key === 'nyc_neighborhoods_all' || // Skip NYC Neighborhoods array (handled separately for map drawing)
    key === 'nyc_zoning_districts_all' || // Skip NYC Zoning Districts array (handled separately for map drawing)
    key === 'nyc_waterfront_hpb_launch_site_all' || // Skip NYC HPB Launch Site array (handled separately for map drawing)
    key === 'nyc_waterfront_parks_all' || // Skip NYC Waterfront Parks array (handled separately for map drawing)
    key === 'nyc_waterfront_paws_all' || // Skip NYC PAWS array (handled separately for map drawing)
    key === 'nyc_business_improvement_districts_all' || // Skip NYC Business Improvement Districts array (handled separately for map drawing)
    key === 'nyc_community_districts_all' || // Skip NYC Community Districts array (handled separately for map drawing)
    key === 'houston_neighborhoods_all' || // Skip Houston Neighborhoods array (handled separately for map drawing)
    key === 'houston_neighborhoods_2021_all' || // Skip Houston Neighborhoods 2021 array (handled separately for map drawing)
    key === 'houston_site_addresses_all' || // Skip Houston Site Addresses array (handled separately for map drawing)
    key === 'houston_roads_centerline_all' || // Skip Houston Roads Centerline array (handled separately for map drawing)
    key === 'houston_metro_bus_routes_all' || // Skip Houston Metro Bus Routes array (handled separately for map drawing)
    key === 'houston_metro_park_and_ride_all' || // Skip Houston METRO Park and Ride Locations array (handled separately for map drawing)
    key === 'houston_metro_transit_centers_all' || // Skip Houston METRO Transit Centers array (handled separately for map drawing)
    key === 'houston_metro_rail_stations_all' || // Skip Houston METRO Rail Stations array (handled separately for map drawing)
    key === 'houston_airports_all' || // Skip Houston Airports array (handled separately for map drawing)
    key === 'houston_bikeways_all' || // Skip Houston Bikeways array (handled separately for map drawing)
    key === 'houston_olc_grid_6digit_all' || // Skip Houston OLC Grid 6-digit array (handled separately for map drawing)
    key === 'houston_olc_grid_8digit_all' || // Skip Houston OLC Grid 8-digit array (handled separately for map drawing)
    key === 'houston_fire_stations_all' || // Skip Houston Fire Stations array (handled separately for map drawing)
    key === 'houston_fire_hydrants_all' || // Skip Houston Fire Hydrants array (handled separately for map drawing)
    key === 'houston_tirz_all' || // Skip Houston TIRZ array (handled separately for map drawing)
    key === 'houston_affordability_all' || // Skip Houston Affordability array (handled separately for map drawing)
    key === 'la_county_historic_cultural_monuments_all' || // Skip LA County Historic Cultural Monuments array (handled separately for map drawing)
    key === 'la_county_housing_lead_risk_all' || // Skip LA County Housing Lead Risk array (handled separately for map drawing)
    key === 'la_county_school_district_boundaries_all' || // Skip LA County School District Boundaries array (handled separately for map drawing)
    key === 'la_county_metro_lines_all' || // Skip LA County Metro Lines array (handled separately for map drawing)
    key === 'la_county_street_inventory_all' || // Skip LA County Street Inventory array (handled separately for map drawing)
    key === 'la_county_fire_hazards_all' || // Skip LA County Hazards arrays (handled separately for map drawing)
    key === 'la_county_fire_hazard_responsibility_areas_all' ||
    key === 'la_county_fire_hazard_severity_zones_all' ||
    key === 'la_county_fire_hazard_severity_zones_lra_all' ||
    key === 'la_county_fire_hazard_severity_zones_sra_all' ||
    key === 'la_county_earthquake_hazards_all' ||
    key === 'la_county_alquist_priolo_fault_traces_all' ||
    key === 'la_county_alquist_priolo_fault_zones_all' ||
    key === 'la_county_usgs_faults_all' ||
    key === 'la_county_tsunami_inundation_runup_line_all' ||
    key === 'la_county_tsunami_inundation_zones_all' ||
    key === 'la_county_landslide_zones_all' ||
    key === 'la_county_liquefaction_zones_all' ||
    key === 'la_county_flood_hazards_all' ||
    key === 'la_county_100_year_flood_plain_all' ||
    key === 'la_county_500_year_flood_plain_all' ||
    key === 'la_county_dam_inundation_eta_all' ||
    key === 'la_county_dam_inundation_areas_all' ||
    key === 'la_county_us_national_grid_all' || // Skip LA County Basemaps and Grids arrays (handled separately for map drawing)
    key === 'la_county_usng_100k_all' ||
    key === 'la_county_usng_10000m_all' ||
    key === 'la_county_usng_1000m_all' ||
    key === 'la_county_usng_100m_all' ||
    key === 'us_national_grid_usng_6x8_zones_all' || // Skip US National Grid arrays (handled separately for map drawing)
    key === 'us_national_grid_usng_100000m_all' ||
    key === 'us_national_grid_usng_10000m_all' ||
    key === 'us_national_grid_usng_1000m_all' ||
    key === 'us_national_grid_usng_100m_all' ||
    key === 'us_historical_cultural_political_points_all' || // Skip US Historical Cultural Political Points array (handled separately for map drawing)
    key === 'us_historical_hydrographic_points_all' || // Skip US Historical Hydrographic Points array (handled separately for map drawing)
    key === 'us_historical_physical_points_all' || // Skip US Historical Physical Points array (handled separately for map drawing)
    key === 'hurricane_evacuation_routes_all' || // Skip Hurricane Evacuation Routes array (handled separately for map drawing)
    key === 'hurricane_evacuation_routes_hazards_all' || // Skip Hurricane Evacuation Routes (Natural Hazards) array (handled separately for map drawing)
    key.startsWith('usgs_gov_') && key.endsWith('_all') || // Skip USGS Government Units arrays (handled separately for map drawing)
    key === 'tnm_structures_all' || // Skip TNM Structures array (handled separately for map drawing)
    key === 'la_county_township_range_section_rancho_boundaries_all' ||
    key.startsWith('la_county_hydrology_') && key.endsWith('_all') || // Skip LA County Hydrology arrays (handled separately for map drawing)
    key.startsWith('la_county_infrastructure_') && key.endsWith('_all') || // Skip LA County Infrastructure arrays (handled separately for map drawing)
    key.startsWith('la_county_admin_boundaries_') && key.endsWith('_all') || // Skip LA County Administrative Boundaries arrays (handled separately for map drawing)
    key.startsWith('la_county_elevation_') && key.endsWith('_all') || // Skip LA County Elevation arrays (handled separately for map drawing)
    key.startsWith('la_county_elevation_') && key.endsWith('_enabled') || // Skip LA County Elevation raster layer flags (handled separately)
    key.startsWith('la_county_demographics_') && key.endsWith('_all') || // Skip LA County Demographics arrays (handled separately for map drawing)
    (key.startsWith('la_county_redistricting_') && key.endsWith('_all')) || // Skip LA County Redistricting arrays (handled separately for map drawing)
    (key.startsWith('la_county_transportation') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_milepost_markers') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_rail_transportation') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_freeways') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_disaster_routes') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_highway_shields') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_metro_park_ride') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_metro_stations') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_metrolink') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_metro_lines') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    (key.startsWith('la_county_railroads') && key.endsWith('_all')) || // Skip LA County Transportation arrays (handled separately for map drawing)
    key === 'ca_state_parks_entry_points_all' || // Skip CA State Parks Entry Points array (handled separately for map drawing)
    key === 'ca_state_parks_parking_lots_all' || // Skip CA State Parks Parking Lots array (handled separately for map drawing)
    key === 'ca_state_parks_boundaries_all' || // Skip CA State Parks Boundaries array (handled separately for map drawing)
    key === 'ca_state_parks_campgrounds_all' || // Skip CA State Parks Campgrounds array (handled separately for map drawing)
    key === 'ca_state_parks_recreational_routes_all' || // Skip CA State Parks Recreational Routes array (handled separately for map drawing)
    key === 'ca_condor_range_all' || // Skip CA Condor Range array (handled separately for map drawing)
    key === 'ca_black_bear_range_all' || // Skip CA Black Bear Range array (handled separately for map drawing)
    key === 'ca_brush_rabbit_range_all' || // Skip CA Brush Rabbit Range array (handled separately for map drawing)
    key === 'ca_great_gray_owl_range_all' || // Skip CA Great Gray Owl Range array (handled separately for map drawing)
    key === 'ca_sandhill_crane_range_all' || // Skip CA Sandhill Crane Range array (handled separately for map drawing)
    key === 'ca_highway_rest_areas_all' || // Skip CA Highway Rest Areas array (handled separately for map drawing)
    key === 'ca_marine_oil_terminals_all' || // Skip CA Marine Oil Terminals array (handled separately for map drawing)
    key === 'national_marine_sanctuaries_all' || // Skip National Marine Sanctuaries array (handled separately for map drawing)
    key === 'nri_rivers_all' || // Skip NRI Rivers array (handled separately for map drawing)
    key === 'nps_nrhp_locations_all' || // Skip NPS NRHP Locations array (handled separately for map drawing)
    key === 'tiger_primary_roads_interstates_5m_all' || // Skip TIGER Primary Roads Interstates 5M array (handled separately for map drawing)
    key === 'tiger_primary_roads_2_1m_all' || // Skip TIGER Primary Roads 2_1M array (handled separately for map drawing)
    key === 'tiger_primary_roads_all' || // Skip TIGER Primary Roads array (handled separately for map drawing)
    key === 'tiger_secondary_roads_interstates_us_all' || // Skip TIGER Secondary Roads Interstates and US Highways array (handled separately for map drawing)
    key === 'tiger_secondary_roads_578k_all' || // Skip TIGER Secondary Roads 578k array (handled separately for map drawing)
    key === 'tiger_secondary_roads_289_144k_all' || // Skip TIGER Secondary Roads 289_144k array (handled separately for map drawing)
    key === 'tiger_secondary_roads_72_1k_all' || // Skip TIGER Secondary Roads 72_1k array (handled separately for map drawing)
    key === 'tiger_local_roads_72k_all' || // Skip TIGER Local Roads 72k array (handled separately for map drawing)
    key === 'tiger_local_roads_all' || // Skip TIGER Local Roads array (handled separately for map drawing)
    key === 'tiger_railroads_all' || // Skip TIGER Railroads array (handled separately for map drawing)
    key === 'tiger_unified_school_districts_containing' || // Skip TIGER Unified School Districts containing (handled separately for map drawing)
    key === 'tiger_unified_school_districts_all' || // Skip TIGER Unified School Districts array (handled separately for map drawing)
    key === 'tiger_secondary_school_districts_containing' || // Skip TIGER Secondary School Districts containing (handled separately for map drawing)
    key === 'tiger_secondary_school_districts_all' || // Skip TIGER Secondary School Districts array (handled separately for map drawing)
    key === 'tiger_elementary_school_districts_containing' || // Skip TIGER Elementary School Districts containing (handled separately for map drawing)
    key === 'tiger_elementary_school_districts_all' || // Skip TIGER Elementary School Districts array (handled separately for map drawing)
    key === 'tiger_school_district_admin_areas_containing' || // Skip TIGER School District Administrative Areas containing (handled separately for map drawing)
    key === 'tiger_school_district_admin_areas_all' || // Skip TIGER School District Administrative Areas array (handled separately for map drawing)
    key === 'tiger_bas2025_unified_school_districts_containing' || // Skip TIGER BAS 2025 Unified School Districts containing (handled separately for map drawing)
    key === 'tiger_bas2025_unified_school_districts_all' || // Skip TIGER BAS 2025 Unified School Districts array (handled separately for map drawing)
    key === 'tiger_bas2025_secondary_school_districts_containing' || // Skip TIGER BAS 2025 Secondary School Districts containing (handled separately for map drawing)
    key === 'tiger_bas2025_secondary_school_districts_all' || // Skip TIGER BAS 2025 Secondary School Districts array (handled separately for map drawing)
    key === 'tiger_bas2025_elementary_school_districts_containing' || // Skip TIGER BAS 2025 Elementary School Districts containing (handled separately for map drawing)
    key === 'tiger_bas2025_elementary_school_districts_all' || // Skip TIGER BAS 2025 Elementary School Districts array (handled separately for map drawing)
    key === 'tiger_bas2025_school_district_admin_areas_containing' || // Skip TIGER BAS 2025 School District Administrative Areas containing (handled separately for map drawing)
    key === 'tiger_bas2025_school_district_admin_areas_all' || // Skip TIGER BAS 2025 School District Administrative Areas array (handled separately for map drawing)
    key === 'tiger_acs2024_unified_school_districts_containing' || // Skip TIGER ACS 2024 Unified School Districts containing (handled separately for map drawing)
    key === 'tiger_acs2024_unified_school_districts_all' || // Skip TIGER ACS 2024 Unified School Districts array (handled separately for map drawing)
    key === 'tiger_acs2024_secondary_school_districts_containing' || // Skip TIGER ACS 2024 Secondary School Districts containing (handled separately for map drawing)
    key === 'tiger_acs2024_secondary_school_districts_all' || // Skip TIGER ACS 2024 Secondary School Districts array (handled separately for map drawing)
    key === 'tiger_acs2024_elementary_school_districts_containing' || // Skip TIGER ACS 2024 Elementary School Districts containing (handled separately for map drawing)
    key === 'tiger_acs2024_elementary_school_districts_all' || // Skip TIGER ACS 2024 Elementary School Districts array (handled separately for map drawing)
    key === 'tiger_acs2024_school_district_admin_areas_containing' || // Skip TIGER ACS 2024 School District Administrative Areas containing (handled separately for map drawing)
    key === 'tiger_acs2024_school_district_admin_areas_all' || // Skip TIGER ACS 2024 School District Administrative Areas array (handled separately for map drawing)
    key === 'tiger_census2020_unified_school_districts_containing' || // Skip TIGER Census 2020 Unified School Districts containing (handled separately for map drawing)
    key === 'tiger_census2020_unified_school_districts_all' || // Skip TIGER Census 2020 Unified School Districts array (handled separately for map drawing)
    key === 'tiger_census2020_secondary_school_districts_containing' || // Skip TIGER Census 2020 Secondary School Districts containing (handled separately for map drawing)
    key === 'tiger_census2020_secondary_school_districts_all' || // Skip TIGER Census 2020 Secondary School Districts array (handled separately for map drawing)
    key === 'tiger_census2020_elementary_school_districts_containing' || // Skip TIGER Census 2020 Elementary School Districts containing (handled separately for map drawing)
    key === 'tiger_census2020_elementary_school_districts_all' || // Skip TIGER Census 2020 Elementary School Districts array (handled separately for map drawing)
    key === 'tiger_nps_areas_containing' || // Skip TIGER National Park Service Areas containing (handled separately for map drawing)
    key === 'tiger_nps_areas_all' || // Skip TIGER National Park Service Areas array (handled separately for map drawing)
    key === 'tiger_correctional_facilities_containing' || // Skip TIGER Correctional Facilities containing (handled separately for map drawing)
    key === 'tiger_correctional_facilities_all' || // Skip TIGER Correctional Facilities array (handled separately for map drawing)
    key === 'tiger_colleges_universities_containing' || // Skip TIGER Colleges and Universities containing (handled separately for map drawing)
    key === 'tiger_colleges_universities_all' || // Skip TIGER Colleges and Universities array (handled separately for map drawing)
    key === 'tiger_military_installations_containing' || // Skip TIGER Military Installations containing (handled separately for map drawing)
    key === 'tiger_military_installations_all' || // Skip TIGER Military Installations array (handled separately for map drawing)
    // TIGER Native Lands skip list - Base layers
    key === 'tiger_anrc_containing' || key === 'tiger_anrc_all' ||
    key === 'tiger_tribal_subdivisions_containing' || key === 'tiger_tribal_subdivisions_all' ||
    key === 'tiger_federal_air_containing' || key === 'tiger_federal_air_all' ||
    key === 'tiger_off_reservation_trust_containing' || key === 'tiger_off_reservation_trust_all' ||
    key === 'tiger_state_air_containing' || key === 'tiger_state_air_all' ||
    key === 'tiger_hhl_containing' || key === 'tiger_hhl_all' ||
    key === 'tiger_anvsa_containing' || key === 'tiger_anvsa_all' ||
    key === 'tiger_otsa_containing' || key === 'tiger_otsa_all' ||
    key === 'tiger_sdtsa_containing' || key === 'tiger_sdtsa_all' ||
    key === 'tiger_tdsa_containing' || key === 'tiger_tdsa_all' ||
    key === 'tiger_aijua_containing' || key === 'tiger_aijua_all' ||
    // TIGER Native Lands skip list - BAS 2025
    key === 'tiger_bas2025_anrc_containing' || key === 'tiger_bas2025_anrc_all' ||
    key === 'tiger_bas2025_tribal_subdivisions_containing' || key === 'tiger_bas2025_tribal_subdivisions_all' ||
    key === 'tiger_bas2025_federal_air_containing' || key === 'tiger_bas2025_federal_air_all' ||
    key === 'tiger_bas2025_off_reservation_trust_containing' || key === 'tiger_bas2025_off_reservation_trust_all' ||
    key === 'tiger_bas2025_state_air_containing' || key === 'tiger_bas2025_state_air_all' ||
    key === 'tiger_bas2025_hhl_containing' || key === 'tiger_bas2025_hhl_all' ||
    key === 'tiger_bas2025_anvsa_containing' || key === 'tiger_bas2025_anvsa_all' ||
    key === 'tiger_bas2025_otsa_containing' || key === 'tiger_bas2025_otsa_all' ||
    key === 'tiger_bas2025_sdtsa_containing' || key === 'tiger_bas2025_sdtsa_all' ||
    key === 'tiger_bas2025_tdsa_containing' || key === 'tiger_bas2025_tdsa_all' ||
    key === 'tiger_bas2025_aijua_containing' || key === 'tiger_bas2025_aijua_all' ||
    // TIGER Native Lands skip list - ACS 2024
    key === 'tiger_acs2024_anrc_containing' || key === 'tiger_acs2024_anrc_all' ||
    key === 'tiger_acs2024_tribal_subdivisions_containing' || key === 'tiger_acs2024_tribal_subdivisions_all' ||
    key === 'tiger_acs2024_federal_air_containing' || key === 'tiger_acs2024_federal_air_all' ||
    key === 'tiger_acs2024_off_reservation_trust_containing' || key === 'tiger_acs2024_off_reservation_trust_all' ||
    key === 'tiger_acs2024_state_air_containing' || key === 'tiger_acs2024_state_air_all' ||
    key === 'tiger_acs2024_hhl_containing' || key === 'tiger_acs2024_hhl_all' ||
    key === 'tiger_acs2024_anvsa_containing' || key === 'tiger_acs2024_anvsa_all' ||
    key === 'tiger_acs2024_otsa_containing' || key === 'tiger_acs2024_otsa_all' ||
    key === 'tiger_acs2024_sdtsa_containing' || key === 'tiger_acs2024_sdtsa_all' ||
    key === 'tiger_acs2024_tdsa_containing' || key === 'tiger_acs2024_tdsa_all' ||
    key === 'tiger_acs2024_aijua_containing' || key === 'tiger_acs2024_aijua_all' ||
    // TIGER Native Lands skip list - Census 2020
    key === 'tiger_census2020_anrc_containing' || key === 'tiger_census2020_anrc_all' ||
    key === 'tiger_census2020_tribal_subdivisions_containing' || key === 'tiger_census2020_tribal_subdivisions_all' ||
    key === 'tiger_census2020_federal_air_containing' || key === 'tiger_census2020_federal_air_all' ||
    key === 'tiger_census2020_off_reservation_trust_containing' || key === 'tiger_census2020_off_reservation_trust_all' ||
    key === 'tiger_census2020_state_air_containing' || key === 'tiger_census2020_state_air_all' ||
    key === 'tiger_census2020_hhl_containing' || key === 'tiger_census2020_hhl_all' ||
    key === 'tiger_census2020_anvsa_containing' || key === 'tiger_census2020_anvsa_all' ||
    key === 'tiger_census2020_otsa_containing' || key === 'tiger_census2020_otsa_all' ||
    key === 'tiger_census2020_sdtsa_containing' || key === 'tiger_census2020_sdtsa_all' ||
    key === 'tiger_census2020_tdsa_containing' || key === 'tiger_census2020_tdsa_all' ||
    key === 'tiger_census2020_aijua_containing' || key === 'tiger_census2020_aijua_all' ||
    // TIGER CBSA skip list - Base layers
    key === 'tiger_cbsa_combined_statistical_areas_containing' || key === 'tiger_cbsa_combined_statistical_areas_all' ||
    key === 'tiger_cbsa_metro_micropolitan_statistical_areas_containing' || key === 'tiger_cbsa_metro_micropolitan_statistical_areas_all' ||
    key === 'tiger_cbsa_metropolitan_divisions_containing' || key === 'tiger_cbsa_metropolitan_divisions_all' ||
    key === 'tiger_cbsa_metropolitan_statistical_areas_containing' || key === 'tiger_cbsa_metropolitan_statistical_areas_all' ||
    key === 'tiger_cbsa_micropolitan_statistical_areas_containing' || key === 'tiger_cbsa_micropolitan_statistical_areas_all' ||
    // TIGER CBSA skip list - BAS 2025
    key === 'tiger_bas2025_cbsa_combined_statistical_areas_containing' || key === 'tiger_bas2025_cbsa_combined_statistical_areas_all' ||
    key === 'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas_containing' || key === 'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas_all' ||
    key === 'tiger_bas2025_cbsa_metropolitan_divisions_containing' || key === 'tiger_bas2025_cbsa_metropolitan_divisions_all' ||
    key === 'tiger_bas2025_cbsa_metropolitan_statistical_areas_containing' || key === 'tiger_bas2025_cbsa_metropolitan_statistical_areas_all' ||
    key === 'tiger_bas2025_cbsa_micropolitan_statistical_areas_containing' || key === 'tiger_bas2025_cbsa_micropolitan_statistical_areas_all' ||
    // TIGER CBSA skip list - ACS 2024
    key === 'tiger_acs2024_cbsa_combined_statistical_areas_containing' || key === 'tiger_acs2024_cbsa_combined_statistical_areas_all' ||
    key === 'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas_containing' || key === 'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas_all' ||
    key === 'tiger_acs2024_cbsa_metropolitan_divisions_containing' || key === 'tiger_acs2024_cbsa_metropolitan_divisions_all' ||
    key === 'tiger_acs2024_cbsa_metropolitan_statistical_areas_containing' || key === 'tiger_acs2024_cbsa_metropolitan_statistical_areas_all' ||
    key === 'tiger_acs2024_cbsa_micropolitan_statistical_areas_containing' || key === 'tiger_acs2024_cbsa_micropolitan_statistical_areas_all' ||
    // TIGER CBSA skip list - Census 2020
    key === 'tiger_census2020_cbsa_combined_new_england_city_town_areas_containing' || key === 'tiger_census2020_cbsa_combined_new_england_city_town_areas_all' ||
    key === 'tiger_census2020_cbsa_new_england_city_town_areas_containing' || key === 'tiger_census2020_cbsa_new_england_city_town_areas_all' ||
    key === 'tiger_census2020_cbsa_new_england_city_town_area_divisions_containing' || key === 'tiger_census2020_cbsa_new_england_city_town_area_divisions_all' ||
    key === 'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas_containing' || key === 'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas_all' ||
    key === 'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas_containing' || key === 'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas_all' ||
    key === 'tiger_census2020_cbsa_combined_statistical_areas_containing' || key === 'tiger_census2020_cbsa_combined_statistical_areas_all' ||
    key === 'tiger_census2020_cbsa_metro_micropolitan_statistical_areas_containing' || key === 'tiger_census2020_cbsa_metro_micropolitan_statistical_areas_all' ||
    key === 'tiger_census2020_cbsa_metropolitan_divisions_containing' || key === 'tiger_census2020_cbsa_metropolitan_divisions_all' ||
    key === 'tiger_census2020_cbsa_metropolitan_statistical_areas_containing' || key === 'tiger_census2020_cbsa_metropolitan_statistical_areas_all' ||
    key === 'tiger_census2020_cbsa_micropolitan_statistical_areas_containing' || key === 'tiger_census2020_cbsa_micropolitan_statistical_areas_all' || // Skip TIGER CBSA arrays (handled separately for map drawing)
    // TIGER Places and County Subdivisions skip list - Base layers (0-5)
    key === 'tiger_places_estates_layer0_containing' || key === 'tiger_places_estates_layer0_nearby_features' || key === 'tiger_places_estates_layer0_all' ||
    key === 'tiger_places_county_subdivisions_layer1_containing' || key === 'tiger_places_county_subdivisions_layer1_nearby_features' || key === 'tiger_places_county_subdivisions_layer1_all' ||
    key === 'tiger_places_subbarrios_layer2_containing' || key === 'tiger_places_subbarrios_layer2_nearby_features' || key === 'tiger_places_subbarrios_layer2_all' ||
    key === 'tiger_places_consolidated_cities_layer3_containing' || key === 'tiger_places_consolidated_cities_layer3_nearby_features' || key === 'tiger_places_consolidated_cities_layer3_all' ||
    key === 'tiger_places_incorporated_places_layer4_containing' || key === 'tiger_places_incorporated_places_layer4_nearby_features' || key === 'tiger_places_incorporated_places_layer4_all' ||
    key === 'tiger_places_census_designated_places_layer5_containing' || key === 'tiger_places_census_designated_places_layer5_nearby_features' || key === 'tiger_places_census_designated_places_layer5_all' ||
    // TIGER Places and County Subdivisions skip list - BAS 2025 (6-12)
    key === 'tiger_places_bas2025_group_layer6_containing' || key === 'tiger_places_bas2025_group_layer6_nearby_features' || key === 'tiger_places_bas2025_group_layer6_all' ||
    key === 'tiger_places_bas2025_estates_layer7_containing' || key === 'tiger_places_bas2025_estates_layer7_nearby_features' || key === 'tiger_places_bas2025_estates_layer7_all' ||
    key === 'tiger_places_bas2025_county_subdivisions_layer8_containing' || key === 'tiger_places_bas2025_county_subdivisions_layer8_nearby_features' || key === 'tiger_places_bas2025_county_subdivisions_layer8_all' ||
    key === 'tiger_places_bas2025_subbarrios_layer9_containing' || key === 'tiger_places_bas2025_subbarrios_layer9_nearby_features' || key === 'tiger_places_bas2025_subbarrios_layer9_all' ||
    key === 'tiger_places_bas2025_consolidated_cities_layer10_containing' || key === 'tiger_places_bas2025_consolidated_cities_layer10_nearby_features' || key === 'tiger_places_bas2025_consolidated_cities_layer10_all' ||
    key === 'tiger_places_bas2025_incorporated_places_layer11_containing' || key === 'tiger_places_bas2025_incorporated_places_layer11_nearby_features' || key === 'tiger_places_bas2025_incorporated_places_layer11_all' ||
    key === 'tiger_places_bas2025_census_designated_places_layer12_containing' || key === 'tiger_places_bas2025_census_designated_places_layer12_nearby_features' || key === 'tiger_places_bas2025_census_designated_places_layer12_all' ||
    // TIGER Places and County Subdivisions skip list - ACS 2024 (13-19)
    key === 'tiger_places_acs2024_group_layer13_containing' || key === 'tiger_places_acs2024_group_layer13_nearby_features' || key === 'tiger_places_acs2024_group_layer13_all' ||
    key === 'tiger_places_acs2024_estates_layer14_containing' || key === 'tiger_places_acs2024_estates_layer14_nearby_features' || key === 'tiger_places_acs2024_estates_layer14_all' ||
    key === 'tiger_places_acs2024_county_subdivisions_layer15_containing' || key === 'tiger_places_acs2024_county_subdivisions_layer15_nearby_features' || key === 'tiger_places_acs2024_county_subdivisions_layer15_all' ||
    key === 'tiger_places_acs2024_subbarrios_layer16_containing' || key === 'tiger_places_acs2024_subbarrios_layer16_nearby_features' || key === 'tiger_places_acs2024_subbarrios_layer16_all' ||
    key === 'tiger_places_acs2024_consolidated_cities_layer17_containing' || key === 'tiger_places_acs2024_consolidated_cities_layer17_nearby_features' || key === 'tiger_places_acs2024_consolidated_cities_layer17_all' ||
    key === 'tiger_places_acs2024_incorporated_places_layer18_containing' || key === 'tiger_places_acs2024_incorporated_places_layer18_nearby_features' || key === 'tiger_places_acs2024_incorporated_places_layer18_all' ||
    key === 'tiger_places_acs2024_census_designated_places_layer19_containing' || key === 'tiger_places_acs2024_census_designated_places_layer19_nearby_features' || key === 'tiger_places_acs2024_census_designated_places_layer19_all' ||
    // TIGER Places and County Subdivisions skip list - Census 2020 (20-26)
    key === 'tiger_places_census2020_group_layer20_containing' || key === 'tiger_places_census2020_group_layer20_nearby_features' || key === 'tiger_places_census2020_group_layer20_all' ||
    key === 'tiger_places_census2020_estates_layer21_containing' || key === 'tiger_places_census2020_estates_layer21_nearby_features' || key === 'tiger_places_census2020_estates_layer21_all' ||
    key === 'tiger_places_census2020_county_subdivisions_layer22_containing' || key === 'tiger_places_census2020_county_subdivisions_layer22_nearby_features' || key === 'tiger_places_census2020_county_subdivisions_layer22_all' ||
    key === 'tiger_places_census2020_subbarrios_layer23_containing' || key === 'tiger_places_census2020_subbarrios_layer23_nearby_features' || key === 'tiger_places_census2020_subbarrios_layer23_all' ||
    key === 'tiger_places_census2020_consolidated_cities_layer24_containing' || key === 'tiger_places_census2020_consolidated_cities_layer24_nearby_features' || key === 'tiger_places_census2020_consolidated_cities_layer24_all' ||
    key === 'tiger_places_census2020_incorporated_places_layer25_containing' || key === 'tiger_places_census2020_incorporated_places_layer25_nearby_features' || key === 'tiger_places_census2020_incorporated_places_layer25_all' ||
    key === 'tiger_places_census2020_census_designated_places_layer26_containing' || key === 'tiger_places_census2020_census_designated_places_layer26_nearby_features' || key === 'tiger_places_census2020_census_designated_places_layer26_all' ||
    // Ireland skip list
    key === 'ireland_provinces_containing' || key === 'ireland_provinces_nearby_features' || key === 'ireland_provinces_all' ||
    key === 'uk_local_authority_districts_containing' || key === 'uk_local_authority_districts_nearby' || key === 'uk_local_authority_districts_all' ||
    key === 'ireland_built_up_areas_containing' || key === 'ireland_built_up_areas_nearby_features' || key === 'ireland_built_up_areas_all' ||
    key === 'ireland_vegetation_areas_containing' || key === 'ireland_vegetation_areas_nearby_features' || key === 'ireland_vegetation_areas_all' ||
    key === 'ireland_small_areas_containing' || key === 'ireland_small_areas_nearby_features' || key === 'ireland_small_areas_all' ||
    key === 'ireland_electoral_divisions_containing' || key === 'ireland_electoral_divisions_nearby_features' || key === 'ireland_electoral_divisions_all' ||
    key === 'ireland_nuts3_boundaries_containing' || key === 'ireland_nuts3_boundaries_nearby_features' || key === 'ireland_nuts3_boundaries_all' ||
    key === 'ireland_civil_parishes_containing' || key === 'ireland_civil_parishes_nearby_features' || key === 'ireland_civil_parishes_all' ||
    key === 'ireland_buildings_residential_containing' || key === 'ireland_buildings_residential_nearby_features' || key === 'ireland_buildings_residential_all' ||
    key === 'ireland_buildings_residential_commercial_containing' || key === 'ireland_buildings_residential_commercial_nearby_features' || key === 'ireland_buildings_residential_commercial_all' ||
    key === 'ireland_buildings_commercial_containing' || key === 'ireland_buildings_commercial_nearby_features' || key === 'ireland_buildings_commercial_all' ||
    key === 'ireland_mountains_all' ||
        key === 'ireland_centres_of_population_all' ||
        key === 'ireland_high_water_marks_all' ||
        key === 'ireland_pois_all' ||
        key === 'australia_railways_all' ||
        key === 'australia_trams_all' ||
        key === 'australia_national_roads_all' ||
        key === 'australia_major_roads_all' ||
        key === 'australia_bushfires_all' ||
        key === 'australia_bushfires_containing' ||
        key === 'australia_bushfires_nearby_features' ||
        key === 'australia_built_up_areas_all' ||
        key === 'australia_built_up_areas_containing' ||
        key === 'australia_built_up_areas_nearby_features' ||
        key === 'australia_operating_mines_all_pois' ||
        key === 'australia_developing_mines_all_pois' ||
        key === 'australia_care_maintenance_mines_all_pois' ||
        key === 'australia_npi_facilities_all_pois' // Skip arrays (handled separately for map drawing)
  );

  const categorizeField = (key: string) => {
    if (key.includes('elev')) return 'Elevation & Terrain';
    if (key.includes('airq') || key.includes('air_quality')) return 'Air Quality';
    if (key.includes('fips') || key.includes('census') || key.includes('demographic') || key.includes('acs_')) return 'Demographics & Census';
    if (key.includes('fws_')) return 'FWS Species & Wildlife';
    if (key.includes('weather') || key.includes('climate')) return 'Weather & Climate';
    if (key.includes('school') || key.includes('education')) return 'Education';
    if (key.includes('hospital') || key.includes('healthcare') || key.includes('clinic') || key.includes('health')) return 'Healthcare';
    if (key.includes('crime') || key.includes('safety')) return 'Safety & Crime';
    if (key.includes('transport') || key.includes('transit')) return 'Transportation';
    if (key.includes('poi_') && key.includes('count') && !key.includes('wildfire')) return 'Points of Interest Nearby';
    if (key.includes('fema_nfhl_') || key.includes('wildfire') || key.includes('usda_') || key.includes('poi_fema_flood_zones') || key.includes('poi_wetlands') || key.includes('poi_earthquakes') || key.includes('poi_volcanoes') || key.includes('poi_flood_reference_points') || key.includes('poi_animal_vehicle_collisions')) return 'Natural Hazards';
    if (key.includes('poi_epa_') || key.includes('epa_') || key.includes('tri_')) return 'Human Caused Hazards';
    if (key.includes('padus_')) return 'Public Lands & Protected Areas';
    if (key.includes('walkability')) return 'Livability & Walkability';
    if (key.includes('poi_usda_')) return 'Local Food & Agriculture';
    return 'Other';
  };

  Object.entries(enrichments).forEach(([key, value]) => {
    if (shouldSkipField(key)) return;

    const formattedValue = formatPopupValue(value, key);
    if (!formattedValue) return;

    const label = formatPopupFieldName(key);
    const category = categorizeField(key);

    if (!sections[category]) {
      sections[category] = [];
    }

    sections[category].push({ label, value: formattedValue });
  });

  return Object.entries(sections)
    .map(([category, items]) => ({ category, items }))
    .filter(section => section.items.length > 0);
};

// Create popup content for main location
const createPopupContent = (result: EnrichmentResult, isMobile: boolean = false): string => {
    const { location, enrichments } = result;
    
    // Use single column layout on mobile, multi-column on desktop
    const containerStyle = isMobile 
      ? 'min-width: 0; max-width: 100%; width: 100%;'
      : 'min-width: 400px; max-width: 600px;';
    const gridStyle = isMobile
      ? 'display: flex; flex-direction: column; gap: 8px; font-size: 12px;'
      : 'display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 12px;';
    
    let content = `
      <div style="${containerStyle}">
        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
          <img src="/assets/new-logo.webp" alt="The Location Is Everything Co" style="width: 48px; height: 48px; border-radius: 50%;" />
          <h3 style="margin: 0; color: #1f2937; font-weight: 600; font-size: 16px;">${location.name}</h3>
        </div>
        <p style="margin: 0 0 12px 0; color: #6b7280; font-size: 12px;">
          📍 ${location.lat.toFixed(6)}, ${location.lon.toFixed(6)}<br>
          🔍 Source: ${location.source}${location.confidence ? ` • Confidence: ${location.confidence}%` : ''}
        </p>
        
        <!-- Key Summary Values -->
        <div style="margin: 12px 0; padding: 12px; background-color: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
          <div style="${gridStyle}">
    `;
    
    // Add summary values if they exist
    if (enrichments.elevation_ft) {
      content += `
        <div style="text-align: center;">
          <div style="font-weight: 600; color: #374151; font-size: 10px;">Elevation</div>
          <div style="color: #1f2937; font-weight: 600;">${enrichments.elevation_ft.toLocaleString()} ft</div>
        </div>
      `;
    }
    
    if (enrichments.acs_population) {
      content += `
        <div style="text-align: center;">
          <div style="font-weight: 600; color: #374151; font-size: 10px;">Population</div>
          <div style="color: #1f2937; font-weight: 600;">${enrichments.acs_population.toLocaleString()}</div>
        </div>
      `;
    }
    
    if (enrichments.acs_median_income) {
      content += `
        <div style="text-align: center;">
          <div style="font-weight: 600; color: #374151; font-size: 10px;">Median Income</div>
          <div style="color: #1f2937; font-weight: 600;">$${enrichments.acs_median_income.toLocaleString()}</div>
        </div>
      `;
    }
    
    if (enrichments.fips_state) {
      content += `
        <div style="text-align: center;">
          <div style="font-weight: 600; color: #374151; font-size: 10px;">State</div>
          <div style="color: #1f2937; font-weight: 600;">${enrichments.fips_state}</div>
        </div>
      `;
    }
    
    if (enrichments.fips_county) {
      content += `
        <div style="text-align: center;">
          <div style="font-weight: 600; color: #374151; font-size: 10px;">County</div>
          <div style="color: #1f2937; font-weight: 600;">${enrichments.fips_county}</div>
        </div>
      `;
    }
    
    content += `
          </div>
        </div>
    `;
    
    // Add summary/attribution information from enrichments
    const summaryFields: string[] = [];
    
    // PADUS summaries
    if (enrichments.padus_public_access_summary) {
      summaryFields.push(enrichments.padus_public_access_summary);
    }
    if (enrichments.padus_protection_status_summary) {
      summaryFields.push(enrichments.padus_protection_status_summary);
    }
    
    // FWS summary
    if (enrichments.fws_species_count !== undefined) {
      summaryFields.push(`FWS Species: ${enrichments.fws_species_count} species found within ${enrichments.fws_search_radius_miles || 5} miles`);
    }
    
    // Weather summary
    if (enrichments.weather_summary) {
      summaryFields.push(`Weather: ${enrichments.weather_summary}`);
    }
    
    // Wildfire summary
    if (enrichments.poi_wildfires_count !== undefined) {
      summaryFields.push(`Wildfires: ${enrichments.poi_wildfires_count} active fires within ${enrichments.poi_wildfires_proximity_distance || 50} miles`);
    }
    
    // USDA Wildfire Risk
    if (enrichments.usda_wildfire_hazard_potential !== undefined) {
      const riskLevel = enrichments.usda_wildfire_hazard_potential_label || `Level ${enrichments.usda_wildfire_hazard_potential}/5`;
      summaryFields.push(`USDA Wildfire Risk: ${riskLevel}`);
    }
    
    // Add summary section if we have any summaries
    if (summaryFields.length > 0) {
      content += `
        <div style="margin: 12px 0; padding: 12px; background-color: #eff6ff; border-radius: 8px; border: 1px solid #bfdbfe;">
          <h4 style="margin: 0 0 8px 0; color: #1e40af; font-weight: 600; font-size: 12px;">📍 Location Summary</h4>
          <div style="font-size: 11px; color: #1e3a8a; line-height: 1.6;">
      `;
      summaryFields.forEach(summary => {
        content += `<div style="margin-bottom: 6px;">• ${summary}</div>`;
      });
      content += `
          </div>
        </div>
      `;
    }
    
    // Add detailed enrichment sections similar to summary form
    const enrichmentSections = buildPopupSections(enrichments);

    // Use single column layout on mobile for enrichment sections
    const enrichmentGridStyle = isMobile
      ? 'display: flex; flex-direction: column; gap: 8px; font-size: 11px; color: #1f2937;'
      : 'display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; font-size: 11px; color: #1f2937;';
    
    enrichmentSections.forEach(section => {
      content += `
        <div style="margin: 12px 0; padding: 12px; background-color: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb;">
          <h4 style="margin: 0 0 8px 0; color: #111827; font-weight: 600; font-size: 12px;">${section.category}</h4>
          <div style="${enrichmentGridStyle}">
      `;

      section.items.forEach(item => {
        content += `
            <div>
              <div style="font-weight: 600; color: #374151; font-size: 10px; text-transform: uppercase; letter-spacing: 0.03em;">${item.label}</div>
              <div style="color: #111827; font-size: 11px;">${item.value}</div>
            </div>
        `;
      });

      content += `
          </div>
        </div>
      `;
    });

    // Add data source attribution
    const dataSources: string[] = [];
    if (enrichments.padus_public_access_summary || enrichments.padus_protection_status_summary) {
      dataSources.push('PAD-US (Protected Areas Database)');
    }
    if (enrichments.fws_species_count !== undefined) {
      dataSources.push('USFWS (U.S. Fish & Wildlife Service)');
    }
    if (enrichments.poi_wildfires_count !== undefined) {
      dataSources.push('USGS (U.S. Geological Survey)');
    }
    if (enrichments.usda_wildfire_hazard_potential !== undefined) {
      dataSources.push('USDA (U.S. Department of Agriculture)');
    }
    if (enrichments.weather_summary || enrichments.weather_current) {
      dataSources.push('Open-Meteo Weather API');
    }
    if (enrichments.acs_population || enrichments.acs_median_income) {
      dataSources.push('U.S. Census Bureau (ACS)');
    }
    
    if (dataSources.length > 0) {
      content += `
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e2e8f0;">
          <p style="margin: 0; color: #6b7280; font-size: 10px; font-style: italic;">
            Data Sources: ${dataSources.join(', ')}
          </p>
        </div>
      `;
    }
    
    // Add mapping platform links
    content += `
      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e2e8f0;">
        <div style="margin-bottom: 6px; font-size: 11px; font-weight: 600; color: #374151;">Open in Maps:</div>
        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
          ${generateMappingLinks(location.lat, location.lon, location.name)}
        </div>
      </div>
    `;
    
    content += `
      </div>
    `;
    
    return content;
  };

const MapView: React.FC<MapViewProps> = ({
  results,
  onBackToConfig,
  isMobile = false,
  previousViewMode: _previousViewMode,
  initialCenter,
  initialZoom,
  poiRadii = {},
}) => {
  const mapRef = useRef<HTMLDivElement | null>(null);
  const mapInstanceRef = useRef<L.Map | null>(null);
  const layerGroupsRef = useRef<{ primary: L.LayerGroup; poi: L.LayerGroup } | null>(null);
  
  // Helper function to get radius from poiRadii, trying multiple key variations
  // Falls back to POI config defaultRadius if poiRadii is empty
  const getRadiusForLegendKey = (legendKey: string): number | undefined => {
    // Try exact match first
    if (poiRadii[legendKey] !== undefined) {
      return poiRadii[legendKey];
    }
    
    // Try with _all suffix
    if (poiRadii[`${legendKey}_all`] !== undefined) {
      return poiRadii[`${legendKey}_all`];
    }
    
    // Try without _all if key ends with it
    if (legendKey.endsWith('_all')) {
      const keyWithoutAll = legendKey.replace(/_all$/, '');
      if (poiRadii[keyWithoutAll] !== undefined) {
        return poiRadii[keyWithoutAll];
      }
    }
    
    // Try common variations
    const variations = [
      legendKey.replace(/_all_pois$/, ''),
      legendKey.replace(/_detailed$/, ''),
      legendKey.replace(/_elements$/, ''),
      legendKey.replace(/_features$/, ''),
      legendKey.replace(/_facilities$/, ''),
    ];
    
    for (const variation of variations) {
      if (variation !== legendKey && poiRadii[variation] !== undefined) {
        return poiRadii[variation];
      }
    }
    
    // Fallback: Always try to get default radius from POI config if not found in poiRadii
    // This ensures we show proximity values even when user hasn't explicitly set a radius
    const poiMeta = poiConfigManager.getPOIType(legendKey);
    if (poiMeta && poiMeta.defaultRadius !== undefined && poiMeta.defaultRadius > 0) {
      return poiMeta.defaultRadius;
    }
    // Also try without _all suffix
    const keyWithoutAll = legendKey.replace(/_all$/, '');
    if (keyWithoutAll !== legendKey) {
      const poiMetaWithoutAll = poiConfigManager.getPOIType(keyWithoutAll);
      if (poiMetaWithoutAll && poiMetaWithoutAll.defaultRadius !== undefined && poiMetaWithoutAll.defaultRadius > 0) {
        return poiMetaWithoutAll.defaultRadius;
      }
    }
    
    return undefined;
  };

  // Helper function to format radius display
  const formatRadiusDisplay = (legendKey: string, radius: number | undefined): string | undefined => {
    if (radius === undefined) return undefined;
    
    if (legendKey === 'boston_approved_building_permits') {
      // Convert to feet and round to nearest 100
      const feet = Math.round(Math.round(radius * 5280) / 100) * 100;
      return `${feet}ft`;
    } else {
      // Format as miles
      return Number.isInteger(radius) ? `${radius} ${radius === 1 ? 'mile' : 'miles'}` : `${radius.toFixed(1)} miles`;
    }
  };
  // MapLibre GL Leaflet layer instance (plugin adds `L.maplibreGL`, type not in Leaflet typings)
  const basemapLayerRef = useRef<any>(null); // Base map (OpenFreeMap)
  const overlayLayerRef = useRef<any>(null); // Overlay layer (WMS/tile on top of base)
  const [legendItems, setLegendItems] = useState<LegendItem[]>([]);
  const [showBatchSuccess, setShowBatchSuccess] = useState(false);
  const [isMapReady, setIsMapReady] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  // Store feature metadata for tabbed popup functionality
  const featuresMetadataRef = useRef<Array<{
    layer: L.Layer;
    layerType: string;
    layerTitle: string;
    featureData: any;
    geometry: 'point' | 'polyline' | 'polygon';
  }>>([]);
  // Basemap selection state (OpenFreeMap styles)
  // On mobile, always use OpenFreeMap liberty basemap (no selector needed)
  // Separate base basemap (from "Basemaps" section) from thematic overlay (from other sections)
  // Simplified: Always show ONE basemap from "Basemaps" section (last selected or default) unless toggled off
  // Thematic basemaps are always optional overlays on top
  const [selectedBaseBasemap, setSelectedBaseBasemap] = useState<string>(isMobile ? 'liberty' : 'liberty'); // Base basemap from "Basemaps" section
  const [selectedThematicBasemap, setSelectedThematicBasemap] = useState<string | null>(null); // Thematic basemap from other sections (WMS, tile, etc.) - optional overlay
  const [showBaseBasemap, setShowBaseBasemap] = useState<boolean>(true); // Toggle to show/hide base basemap layers
  const [showWeatherRadar, setShowWeatherRadar] = useState<boolean>(false);
  const [showBasemapInfo, setShowBasemapInfo] = useState<boolean>(false); // Info tooltip state
  const basemapInfoRef = useRef<HTMLDivElement>(null);
  // Collapsible basemap sections state
  const [expandedBasemapSections, setExpandedBasemapSections] = useState<Record<string, boolean>>({
    'Basemaps': true, // Default to expanded
    'USGS National Map': false,
    'USFS': false,
    'Alaska': false,
  });
  const [showThematicThemes, setShowThematicThemes] = useState<boolean>(false); // Toggle to show/hide thematic themes list
  const weatherRadarOverlayRef = useRef<L.ImageOverlay | null>(null);
  // Removed viewportHeight and viewportWidth - not needed and were causing issues

  /**
   * Determine which regional NEXRAD WMS layer to use based on location
   */
  const getRegionalWMSLayer = (lat: number, lon: number): string => {
    // Alaska: lat 49-72, lon -175 to -125
    if (lat >= 49 && lat <= 72 && lon >= -175 && lon <= -125) {
      return 'alaska_base_reflectivity_mosaic';
    }
    // Hawaii: lat 15-26, lon -164 to -151
    if (lat >= 15 && lat <= 26 && lon >= -164 && lon <= -151) {
      return 'hawaii_base_reflectivity_mosaic';
    }
    // Caribbean: lat 10-25, lon -90 to -60 (includes Puerto Rico, USVI)
    if (lat >= 10 && lat <= 25 && lon >= -90 && lon <= -60) {
      return 'caribbean_base_reflectivity_mosaic';
    }
    // Guam: lat 9-18, lon 140-150
    if (lat >= 9 && lat <= 18 && lon >= 140 && lon <= 150) {
      return 'guam_base_reflectivity_mosaic';
    }
    // CONUS (Continental US): default for all other locations
    return 'conus_base_reflectivity_mosaic';
  };

  /**
   * Get WMS GetMap URL for weather radar overlay
   */
  const getWeatherRadarWMSUrl = (bounds: L.LatLngBounds, layerName: string): string => {
    const baseUrl = 'https://nowcoast.noaa.gov/geoserver/observations/weather_radar/ows';
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    
    // WMS 1.3.0 with CRS:84 uses BBOX as: minx,miny,maxx,maxy (lon,lat,lon,lat)
    // CRS:84 is equivalent to EPSG:4326 but uses lon,lat axis order
    const bbox = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
    
    // Get current time in ISO8601 format (nearest 4-minute interval)
    const now = new Date();
    const minutes = now.getMinutes();
    const roundedMinutes = Math.floor(minutes / 4) * 4;
    const time = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), roundedMinutes, 0);
    const timeStr = time.toISOString();
    
    // Get map size based on bounds (calculate appropriate size for good quality)
    const latDiff = ne.lat - sw.lat;
    const lonDiff = ne.lng - sw.lng;
    // Use larger size for better quality, but cap at reasonable limit
    const size = Math.min(1024, Math.max(256, Math.floor(Math.max(latDiff, lonDiff) * 1000)));
    
    const params = new URLSearchParams({
      SERVICE: 'WMS',
      VERSION: '1.3.0',
      REQUEST: 'GetMap',
      LAYERS: layerName,
      STYLES: 'weather_radar_base_reflectivity',
      CRS: 'CRS:84', // Use CRS:84 for lon,lat axis order
      BBOX: bbox,
      WIDTH: size.toString(),
      HEIGHT: size.toString(),
      FORMAT: 'image/png',
      TRANSPARENT: 'true',
      TIME: timeStr
    });
    
    return `${baseUrl}?${params.toString()}`;
  };

  /**
   * Update weather radar overlay based on current map bounds
   */
  const updateWeatherRadarOverlay = () => {
    if (!mapInstanceRef.current || !showWeatherRadar) {
      return;
    }
    
    const map = mapInstanceRef.current;
    
    // Use result location if available, otherwise use map center
    let lat: number;
    let lon: number;
    
    if (results && results.length > 0 && results[0]?.location) {
      lat = results[0].location.lat;
      lon = results[0].location.lon;
    } else {
      // Use map center when no results (e.g., when opening map directly for basemap exploration)
      const mapCenter = map.getCenter();
      if (!mapCenter) {
        return;
      }
      lat = mapCenter.lat;
      lon = mapCenter.lng;
    }
    
    // Determine which regional layer to use
    const layerName = getRegionalWMSLayer(lat, lon);
    
    // Get current map bounds (with some padding for better coverage)
    const bounds = map.getBounds();
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    
    // Add padding to bounds (10% on each side)
    const latPadding = (ne.lat - sw.lat) * 0.1;
    const lonPadding = (ne.lng - sw.lng) * 0.1;
    const paddedBounds = L.latLngBounds(
      [sw.lat - latPadding, sw.lng - lonPadding],
      [ne.lat + latPadding, ne.lng + lonPadding]
    );
    
    // Remove existing overlay if present
    if (weatherRadarOverlayRef.current) {
      map.removeLayer(weatherRadarOverlayRef.current);
      weatherRadarOverlayRef.current = null;
    }
    
    // Create WMS GetMap URL
    const wmsUrl = getWeatherRadarWMSUrl(paddedBounds, layerName);
    
    // Create image overlay
    const overlay = L.imageOverlay(wmsUrl, paddedBounds, {
      opacity: 0.7,
      interactive: false,
      zIndex: 300 // Below markers but above basemap
    });
    
    overlay.addTo(map);
    weatherRadarOverlayRef.current = overlay;
    
    // Handle errors (e.g., if WMS service is unavailable)
    overlay.on('error', () => {
      console.warn('Weather radar overlay failed to load');
      if (map.hasLayer(overlay)) {
        map.removeLayer(overlay);
      }
      weatherRadarOverlayRef.current = null;
    });
  };

  // MapLibre (OpenFreeMap) basemap needs explicit resize calls on mobile after Leaflet container size changes.
  // WMS basemaps don't need this, so we check if it's a MapLibre layer first.
  const resizeMaplibreBasemap = () => {
    try {
      const layer: any = basemapLayerRef.current;
      // Only resize MapLibre layers, not WMS layers
      if (layer && typeof layer.getMaplibreMap === 'function') {
        const ml =
          (layer?.getMaplibreMap && layer.getMaplibreMap()) ||
          layer?._maplibreMap ||
          layer?._map;
        if (ml && typeof ml.resize === 'function') {
          ml.resize();
        }
      }
    } catch {
      // ignore
    }
  };

  // On mobile, NEVER rely on hardcoded header heights. Always derive the map container size from the
  // actual layout (parent/main container) to keep the map fitting the screen and allow MapLibre to render.
  const sizeMapContainerToParent = (container: HTMLDivElement): boolean => {
    // Prefer the nearest MAIN/flex-1 container (this is the real "available map area" in your layout)
    let parent: HTMLElement | null = container.parentElement;
    let mainContainer: HTMLElement | null = null;
    while (parent) {
      if (parent.tagName === 'MAIN' || parent.classList.contains('flex-1')) {
        mainContainer = parent;
        break;
      }
      parent = parent.parentElement;
    }

    const target = mainContainer || container.parentElement;
    if (target) {
      const rect = target.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        container.style.height = `${rect.height}px`;
        container.style.width = `${rect.width}px`;
        container.style.minHeight = '0';
        container.style.flex = '1 1 auto';
        container.style.position = 'relative';
        container.style.top = '0';
        container.style.left = '0';
        container.style.touchAction = 'pan-x pan-y pinch-zoom';
        return true;
      }
    }

    // Last resort: use visualViewport if available (still better than hardcoding a header height)
    const vv = window.visualViewport;
    const h = vv?.height || window.innerHeight || window.screen.height;
    const w = vv?.width || window.innerWidth || window.screen.width;
    if (h > 0 && w > 0) {
      const fallbackHeight = Math.max(h, 400);
      container.style.height = `${fallbackHeight}px`;
      container.style.width = `${w}px`;
      container.style.minHeight = '0';
      container.style.flex = '1 1 auto';
      container.style.position = 'relative';
      container.style.top = '0';
      container.style.left = '0';
      container.style.touchAction = 'pan-x pan-y pinch-zoom';
      return true;
    }

    return false;
  };

  useEffect(() => {
    if (!mapRef.current || mapInstanceRef.current) {
      return;
    }

    // Disable Leaflet's default marker shadows globally to prevent white ovals on mobile
    // CRITICAL: Must explicitly set shadowUrl to null (not undefined) - mobile browsers render white fallback if undefined
    if (isMobile) {
      L.Icon.Default.mergeOptions({
        shadowUrl: null, // Explicitly null, not undefined
        shadowSize: [0, 0],
        shadowAnchor: [0, 0]
      });
      
      // Also ensure divIcon doesn't create shadows
      if ((L as any).DivIcon) {
        (L as any).DivIcon.prototype.options = (L as any).DivIcon.prototype.options || {};
        (L as any).DivIcon.prototype.options.shadowUrl = null;
      }
    }

    // Wait for container to be fully rendered before initializing map
    // This prevents twitchy behavior when transitioning to map view
    const initializeMap = () => {
      if (!mapRef.current) return;

      // Ensure container has dimensions (don't check opacity as it may start at 0 for fade-in)
      const container = mapRef.current;
      
      // For mobile, ensure container has explicit height from parent
      if (isMobile) {
        // If layout isn't ready yet, retry; do not hardcode header math.
        const ok = sizeMapContainerToParent(container);
        if (!ok) {
          setTimeout(initializeMap, 100);
          return;
        }
      }
      
      const rect = container.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(container);
      // Only check if display is none or visibility is hidden, not opacity (allows fade-in)
      const isHidden = computedStyle.display === 'none' || computedStyle.visibility === 'hidden';
      
      if (rect.width === 0 || rect.height === 0 || isHidden) {
        // Container not ready yet, retry after a short delay
        setTimeout(initializeMap, isMobile ? 100 : 50);
        return;
      }

      // Simple, direct initialization - map starts at geocoded location immediately
      // Use provided initialCenter/initialZoom if available, otherwise use results or default to US center
      const mapCenter: [number, number] = initialCenter || (results && results.length > 0 && results[0]?.location
        ? [results[0].location.lat, results[0].location.lon] as [number, number]
        : [37.0902, -95.7129] as [number, number]);
      
      // Check if any Boston Open Data layers are present - use closer zoom for Boston
      const hasBostonLayers = results && results.some(result => {
        if (!result.enrichments) return false;
        return Object.keys(result.enrichments).some(key => 
          key.startsWith('boston_') && key.endsWith('_all')
        );
      });
      
      // Use closer initial zoom (15) for Boston layers, otherwise use standard zoom (13)
      const defaultZoom = hasBostonLayers ? 15 : (results && results.length > 0 && results[0]?.location ? 13 : 4);
      const mapZoom = initialZoom !== undefined ? initialZoom : defaultZoom;
      
      // For mobile, disable fade animation which can cause rendering issues
      const map = L.map(mapRef.current, {
        center: mapCenter,
        zoom: mapZoom,
        zoomControl: !isMobile, // Disable zoom controls on mobile to avoid overlap with Back button
        attributionControl: true,
        fadeAnimation: !isMobile, // Disable on mobile to prevent white screen
        zoomAnimation: !isMobile, // Disable on mobile
        zoomAnimationThreshold: 4,
        preferCanvas: false, // Use SVG for better mobile compatibility
      });
      
      // On mobile, completely disable shadow pane to prevent white ovals
      if (isMobile) {
        // Hide the entire shadow pane
        const shadowPane = map.getPane('shadowPane');
        if (shadowPane) {
          shadowPane.style.display = 'none';
          shadowPane.style.visibility = 'hidden';
          shadowPane.style.pointerEvents = 'none';
        }
        
        // Also ensure no shadow images are loaded by intercepting any shadow creation
        // This prevents mobile browsers from creating fallback white ovals
        const originalCreateShadow = (L.Marker.prototype as any)._setPos;
        if (originalCreateShadow && !(map as any).__shadowDisabled) {
          (map as any).__shadowDisabled = true;
        }
      }

      // Initialize basemap system: OpenFreeMap base + optional overlay
      // On mobile, always use OpenFreeMap liberty basemap
      let basemapLayer: any = null;
      let overlayLayer: any = null;
      
      // On mobile, use simple OSM tile layer (reliable fallback). On desktop, use OpenFreeMap if enabled.
      if (isMobile) {
        // Use simple OSM tile layer for mobile - guaranteed to work, no WebGL required
        console.log('🗺️ [MOBILE BASEMAP] Using OSM tile layer for mobile');
        basemapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors',
          maxZoom: 19,
          minZoom: 1,
        });
        basemapLayer.addTo(map);
        console.log('🗺️ [MOBILE BASEMAP] OSM tile layer added successfully');
      } else {
        // Desktop: Show basemap from "Basemaps" section + optional thematic overlay (if showBaseBasemap is true)
        // If showBaseBasemap is false, only show thematic overlays
        if (showBaseBasemap) {
          const baseBasemapConfig = BASEMAP_CONFIGS[selectedBaseBasemap] || BASEMAP_CONFIGS.liberty;
          
          // "Basemaps" section selection is the base layer (full opacity)
          if (baseBasemapConfig.type === 'maplibre') {
          basemapLayer = (L as any).maplibreGL({
            style: baseBasemapConfig.styleUrl,
            attribution: baseBasemapConfig.attribution,
            interactive: false,
          });
          basemapLayer.addTo(map);
        } else if (baseBasemapConfig.type === 'tile') {
          if (baseBasemapConfig.exportMapLayerId !== undefined && baseBasemapConfig.tileUrl) {
            // MapServer ExportMap endpoint
            basemapLayer = createExportMapTileLayer(
              baseBasemapConfig.tileUrl,
              baseBasemapConfig.exportMapLayerId,
              {
                attribution: baseBasemapConfig.attribution,
                maxZoom: 15,
                minZoom: 4,
                noWrap: true,
                opacity: 1.0, // Full opacity - this is the base
                tileSize: 256,
              }
            ).addTo(map);
          } else if (baseBasemapConfig.exportImageRasterFunction && baseBasemapConfig.tileUrl) {
            // ImageServer ExportImage endpoint
            basemapLayer = createExportImageTileLayer(
              baseBasemapConfig.tileUrl,
              baseBasemapConfig.exportImageRasterFunction,
              {
                attribution: baseBasemapConfig.attribution,
                maxZoom: 15,
                minZoom: 4,
                noWrap: true,
                opacity: 1.0, // Full opacity - this is the base
                tileSize: 256,
              }
            ).addTo(map);
          } else {
            // Standard tile layer
            basemapLayer = L.tileLayer(baseBasemapConfig.tileUrl!, {
              attribution: baseBasemapConfig.attribution,
              maxZoom: 15,
              minZoom: 4,
              noWrap: true,
              opacity: 1.0, // Full opacity - this is the base
            }).addTo(map);
          }
        } else if (baseBasemapConfig.type === 'wms') {
          const wmsOptions: any = {
            format: baseBasemapConfig.wmsFormat || 'image/png',
            transparent: true,
            attribution: baseBasemapConfig.attribution,
            crs: baseBasemapConfig.wmsCrs === 'EPSG4326' ? L.CRS.EPSG4326 : L.CRS.EPSG3857,
            version: baseBasemapConfig.wmsVersion || '1.3.0',
            opacity: 1.0, // Full opacity - this is the base
          };
          
          if (baseBasemapConfig.wmsUppercase === true) {
            wmsOptions.uppercase = true;
          }
          
          if (baseBasemapConfig.wmsLayers !== undefined && baseBasemapConfig.wmsLayers.trim() !== '') {
            wmsOptions.layers = baseBasemapConfig.wmsLayers;
          }
          
          if (baseBasemapConfig.wmsRasterFunction !== undefined && baseBasemapConfig.wmsRasterFunction.trim() !== '') {
            wmsOptions.rasterFunction = baseBasemapConfig.wmsRasterFunction;
          }
          
          basemapLayer = L.tileLayer.wms(baseBasemapConfig.wmsUrl!, wmsOptions);
          basemapLayer.addTo(map);
        }
        } else {
          // Base basemap toggle is OFF - no base layer
          basemapLayer = null;
        }
        
        // Add thematic basemap as optional overlay on top (if selected)
        // Thematic overlay persists when switching basemaps from "Basemaps" section
        if (selectedThematicBasemap) {
          const thematicConfig = BASEMAP_CONFIGS[selectedThematicBasemap];
          // Thematic basemaps can be tile, wms, or maplibre (vector tiles) from other sections
          // Exclude base basemaps from "Basemaps" section (usa_topo_maps, natgeo_world_map, and maplibre base basemaps like liberty, bright, positron)
          const isBaseBasemap = selectedThematicBasemap === 'usa_topo_maps' || selectedThematicBasemap === 'natgeo_world_map' || 
                                 selectedThematicBasemap === 'liberty' || selectedThematicBasemap === 'bright' || selectedThematicBasemap === 'positron';
          if (thematicConfig && !isBaseBasemap) {
            if (thematicConfig.type === 'maplibre') {
              // Vector tile overlay using MapLibre GL
              // For ArcGIS VectorTileServer, fetch and transform style JSON to fix relative URLs
              (async () => {
                try {
                  console.log('🔍 [DEBUG] Fetching and transforming style:', thematicConfig.styleUrl);
                  const transformedStyle = await fetchAndTransformVectorTileStyle(thematicConfig.styleUrl!);
                  console.log('🔍 [DEBUG] Transformed style sprite URL:', transformedStyle.sprite);
                  console.log('🔍 [DEBUG] Transformed style glyphs URL:', transformedStyle.glyphs);
                  
                  // Create a custom pane for vector tile overlays to ensure they're above basemaps
                  if (!map.getPane('vectorTileOverlayPane')) {
                    const vectorTilePane = map.createPane('vectorTileOverlayPane');
                    vectorTilePane.style.zIndex = '450'; // Above tilePane (200) and overlayPane (400), below markers (600+)
                  }
                  
                  // The maplibreGL plugin accepts either a style URL or a style object
                  // Since we've already transformed it, pass the object directly
                  overlayLayer = (L as any).maplibreGL({
                    style: transformedStyle, // Pass the transformed style object, not the URL
                    attribution: thematicConfig.attribution,
                    interactive: false,
                  });
                  
                  overlayLayer.addTo(map);
                  
                  // After adding to map, ensure the container is above basemaps but same z-index as other thematic overlays
                  // Use setTimeout to ensure the container is created
                  setTimeout(() => {
                    if (overlayLayer && overlayLayer.getContainer) {
                      const container = overlayLayer.getContainer();
                      if (container) {
                        container.style.opacity = '0.7';
                        // Use same z-index as overlayPane (400) but ensure it's in overlayPane which is above tilePane
                        // This ensures it's above basemaps but doesn't prevent replacement by other thematic overlays
                        container.style.zIndex = '400';
                        container.style.position = 'absolute';
                        // Ensure it's in the overlayPane which is above tilePane (where basemaps are)
                        const overlayPane = map.getPane('overlayPane');
                        if (overlayPane && container.parentNode !== overlayPane) {
                          overlayPane.appendChild(container);
                        }
                      }
                    }
                  }, 100);
                  
                  overlayLayerRef.current = overlayLayer;
                } catch (error) {
                  console.error('❌ Error loading MapLibre vector tile overlay:', error);
                }
              })();
            } else if (thematicConfig.type === 'tile') {
              if (thematicConfig.exportMapLayerId !== undefined && thematicConfig.tileUrl) {
                // MapServer ExportMap endpoint
                overlayLayer = createExportMapTileLayer(
                  thematicConfig.tileUrl,
                  thematicConfig.exportMapLayerId,
                  {
                    attribution: thematicConfig.attribution,
                    maxZoom: 15,
                    minZoom: 4,
                    noWrap: true,
                    opacity: 0.7, // Transparent overlay
                    tileSize: 256,
                  }
                ).addTo(map);
              } else if (thematicConfig.exportImageRasterFunction && thematicConfig.tileUrl) {
                // ImageServer ExportImage endpoint
                overlayLayer = createExportImageTileLayer(
                  thematicConfig.tileUrl,
                  thematicConfig.exportImageRasterFunction,
                  {
                    attribution: thematicConfig.attribution,
                    maxZoom: 15,
                    minZoom: 4,
                    noWrap: true,
                    opacity: 0.7, // Transparent overlay
                    tileSize: 256,
                  }
                ).addTo(map);
              } else {
                // Standard tile layer
                overlayLayer = L.tileLayer(thematicConfig.tileUrl!, {
                  attribution: thematicConfig.attribution,
                  maxZoom: 15,
                  minZoom: 4,
                  noWrap: true,
                  opacity: 0.7, // Transparent overlay
                }).addTo(map);
              }
            } else if (thematicConfig.type === 'wms') {
              const wmsOptions: any = {
                format: thematicConfig.wmsFormat || 'image/png',
                transparent: true,
                attribution: thematicConfig.attribution,
                crs: thematicConfig.wmsCrs === 'EPSG4326' ? L.CRS.EPSG4326 : L.CRS.EPSG3857,
                version: thematicConfig.wmsVersion || '1.3.0',
                opacity: 0.7, // Transparent overlay
              };
              
              if (thematicConfig.wmsUppercase === true) {
                wmsOptions.uppercase = true;
              }
              
              if (thematicConfig.wmsLayers !== undefined && thematicConfig.wmsLayers.trim() !== '') {
                wmsOptions.layers = thematicConfig.wmsLayers;
              }
              
              if (thematicConfig.wmsRasterFunction !== undefined && thematicConfig.wmsRasterFunction.trim() !== '') {
                wmsOptions.rasterFunction = thematicConfig.wmsRasterFunction;
              }
              
              overlayLayer = L.tileLayer.wms(thematicConfig.wmsUrl!, wmsOptions);
              overlayLayer.addTo(map);
            }
            
            if (overlayLayer) {
              overlayLayerRef.current = overlayLayer;
            } else {
              overlayLayerRef.current = null;
            }
          } else {
            overlayLayerRef.current = null;
          }
        } else {
          // No thematic selected - clear overlay reference
          overlayLayerRef.current = null;
        }
      }
      
      basemapLayerRef.current = basemapLayer;
      
      // OSM tile layer on mobile loads normally - no special handling needed

      const primary = L.layerGroup().addTo(map);
      const poi = L.layerGroup().addTo(map);
      
      // Create a custom pane for the location marker with higher z-index to keep it on top
      if (!map.getPane('locationMarkerPane')) {
        const locationMarkerPane = map.createPane('locationMarkerPane');
        locationMarkerPane.style.zIndex = '650'; // Higher than default markerPane (600) and overlayPane (400)
      }

      mapInstanceRef.current = map;
      layerGroupsRef.current = { primary, poi };
      
      // Mark as initialized immediately so other useEffects can proceed
      setIsInitialized(true);

      // After map is initialized, invalidate size to ensure proper rendering
      // For mobile, use aggressive invalidation with multiple attempts
      if (isMobile) {
        // First attempt - immediate
        requestAnimationFrame(() => {
          if (mapInstanceRef.current && mapRef.current) {
            sizeMapContainerToParent(mapRef.current);
            mapInstanceRef.current.invalidateSize(true);
            resizeMaplibreBasemap();
          }
        });
        
        // Second attempt - after delay
        setTimeout(() => {
          if (mapInstanceRef.current && mapRef.current) {
            sizeMapContainerToParent(mapRef.current);
            mapInstanceRef.current.invalidateSize(true);
            resizeMaplibreBasemap();
            
            // Note: MapLibre GL basemap doesn't expose Leaflet TileLayer redraw()
            
            // Center on location
            if (results && results.length > 0 && results[0]?.location) {
              mapInstanceRef.current.setView(
                [results[0].location.lat, results[0].location.lon],
                13,
                { animate: false }
              );
            }
            resizeMaplibreBasemap();
            setIsMapReady(true);
          }
        }, 500);
      } else {
        const delay = 100;
        requestAnimationFrame(() => {
          setTimeout(() => {
            if (mapInstanceRef.current && mapRef.current) {
              mapInstanceRef.current.invalidateSize(true);
              setIsMapReady(true);
            }
          }, delay);
        });
      }
      
      // Additional invalidation for mobile after a longer delay (critical for mobile)
      if (isMobile) {
        setTimeout(() => {
          if (mapInstanceRef.current && mapRef.current) {
            sizeMapContainerToParent(mapRef.current);
            // Critical: invalidateSize again after delay to ensure proper rendering
            mapInstanceRef.current.invalidateSize(true);
            resizeMaplibreBasemap();
            setTimeout(resizeMaplibreBasemap, 50);
            setTimeout(resizeMaplibreBasemap, 250);
            
            // Center map on geocoded location if we have results
            if (results && results.length > 0 && results[0]?.location) {
              mapInstanceRef.current.setView(
                [results[0].location.lat, results[0].location.lon],
                13,
                { animate: false }
              );
            }
          }
        }, 500);
      }
    };

    // Small delay to ensure container is rendered in DOM
    setTimeout(initializeMap, 50);

    return () => {
      if (mapInstanceRef.current) {
        try {
          // Remove weather radar overlay if present
          if (weatherRadarOverlayRef.current) {
            try {
              if (mapInstanceRef.current.hasLayer(weatherRadarOverlayRef.current)) {
                mapInstanceRef.current.removeLayer(weatherRadarOverlayRef.current);
              }
            } catch (e) {
              // Layer might already be removed
            }
            weatherRadarOverlayRef.current = null;
          }
          
          // Clean up basemap layers before removing map
          if (basemapLayerRef.current) {
            try {
              if (mapInstanceRef.current.hasLayer(basemapLayerRef.current)) {
                mapInstanceRef.current.removeLayer(basemapLayerRef.current);
              }
            } catch (e) {
              // Layer might already be removed
            }
            basemapLayerRef.current = null;
          }
          
          if (overlayLayerRef.current) {
            try {
              const oldOverlay = overlayLayerRef.current;
              // For maplibre layers, we need defensive cleanup to prevent stacking
              // MapLibre layers create canvas elements that can persist even after layer removal
              if (oldOverlay._maplibreMap || oldOverlay.getMaplibreMap || oldOverlay._container) {
                try {
                  // First, try to get the maplibre map instance
                  const mlMap = oldOverlay.getMaplibreMap ? oldOverlay.getMaplibreMap() : oldOverlay._maplibreMap;
                  if (mlMap) {
                    // Clean up maplibre map instance first (this handles most cleanup)
                    if (typeof mlMap.remove === 'function') {
                      try {
                        mlMap.remove();
                      } catch (e) {
                        // MapLibre might have already been cleaned up, continue
                      }
                    }
                  }
                } catch (e) {
                  // Continue with normal removal even if maplibre cleanup fails
                }
              }
              if (mapInstanceRef.current.hasLayer(oldOverlay)) {
                mapInstanceRef.current.removeLayer(oldOverlay);
              }
            } catch (e) {
              // Layer might already be removed
            }
            overlayLayerRef.current = null;
          }
          
          // Remove map instance
          mapInstanceRef.current.remove();
        } catch (e) {
          // Map might already be removed or in an invalid state
          console.warn('Error during map cleanup:', e);
        }
        mapInstanceRef.current = null;
        layerGroupsRef.current = null;
      }
      setIsMapReady(false);
      setIsInitialized(false);
    };
  }, [isMobile]);

  // Handle weather radar overlay toggle
  useEffect(() => {
    if (!mapInstanceRef.current || !isInitialized) {
      return;
    }
    
    if (showWeatherRadar) {
      updateWeatherRadarOverlay();
      
      // Update overlay when map moves or zooms
      const map = mapInstanceRef.current;
      const updateOverlay = () => {
        if (showWeatherRadar) {
          updateWeatherRadarOverlay();
        }
      };
      
      map.on('moveend', updateOverlay);
      map.on('zoomend', updateOverlay);
      
      return () => {
        map.off('moveend', updateOverlay);
        map.off('zoomend', updateOverlay);
      };
    } else {
      // Remove overlay when toggled off
      if (weatherRadarOverlayRef.current && mapInstanceRef.current) {
        mapInstanceRef.current.removeLayer(weatherRadarOverlayRef.current);
        weatherRadarOverlayRef.current = null;
      }
    }
  }, [showWeatherRadar, isInitialized, results]);

  // Handle basemap changes and OpenFreeMap toggle
  useEffect(() => {
    // On mobile, don't allow basemap changes - always use OpenFreeMap liberty
    if (isMobile) {
      return;
    }
    
    // Only handle basemap changes if map is already initialized
    // Initial basemap is set during map initialization
    // Note: basemapLayerRef.current might be null during layer switches, so we don't check it here
    if (!mapInstanceRef.current || !isInitialized) {
      return;
    }

    const map = mapInstanceRef.current;
    
    // Remove old layers FIRST to ensure clean state
    // This ensures only one basemap from "Basemaps" section is ever visible
    // CRITICAL: Must remove all layers completely before adding new ones to prevent stacking
    // Remove ALL tile layers that might be basemaps to prevent any stacking
    if (basemapLayerRef.current) {
      try {
        const oldLayer = basemapLayerRef.current;
        // For maplibre layers, we need defensive cleanup to prevent stacking
        // MapLibre layers create canvas elements that can persist even after layer removal
        if (oldLayer._maplibreMap || oldLayer.getMaplibreMap || oldLayer._container) {
          try {
            // First, try to get the maplibre map instance
            const mlMap = oldLayer.getMaplibreMap ? oldLayer.getMaplibreMap() : oldLayer._maplibreMap;
            if (mlMap) {
              // Clean up maplibre map instance first (this handles most cleanup)
              if (typeof mlMap.remove === 'function') {
                try {
                  mlMap.remove();
                } catch (e) {
                  // MapLibre might have already been cleaned up, continue
                }
              }
            }
          } catch (e) {
            // Continue with normal removal even if maplibre cleanup fails
          }
        }
        // Remove the layer from the map
        if (map.hasLayer(oldLayer)) {
          map.removeLayer(oldLayer);
        }
        // Double-check that layer is fully removed (especially important for maplibre)
        if (map.hasLayer(oldLayer)) {
          map.removeLayer(oldLayer);
        }
      } catch (e) {
        // Layer might already be removed, continue
      }
      basemapLayerRef.current = null;
    }
    
    // Remove overlay layer - but preserve the state so it can be recreated
    // CRITICAL: For MapLibre vector tile overlays (like Alaska theme), we need special cleanup
    // to prevent them from persisting when switching themes
    if (overlayLayerRef.current) {
      try {
        const oldOverlay = overlayLayerRef.current;
        // For maplibre layers, we need defensive cleanup to prevent stacking
        // MapLibre layers create canvas elements that can persist even after layer removal
        if (oldOverlay._maplibreMap || oldOverlay.getMaplibreMap || oldOverlay._container) {
          try {
            // First, try to get the maplibre map instance
            const mlMap = oldOverlay.getMaplibreMap ? oldOverlay.getMaplibreMap() : oldOverlay._maplibreMap;
            if (mlMap) {
              // Clean up maplibre map instance first (this handles most cleanup)
              if (typeof mlMap.remove === 'function') {
                try {
                  mlMap.remove();
                } catch (e) {
                  // MapLibre might have already been cleaned up, continue
                }
              }
            }
          } catch (e) {
            // Continue with normal removal even if maplibre cleanup fails
          }
        }
        // Remove the layer from the map
        if (map.hasLayer(oldOverlay)) {
          map.removeLayer(oldOverlay);
        }
        // Double-check that layer is fully removed (especially important for maplibre)
        if (map.hasLayer(oldOverlay)) {
          map.removeLayer(oldOverlay);
        }
      } catch (e) {
        // Layer might already be removed, continue
      }
      overlayLayerRef.current = null;
    }

    let newBasemapLayer: any = null;
    let newOverlayLayer: any = null;
    
    // SIMPLIFIED: Show ONE basemap from "Basemaps" section + optional thematic overlay (if showBaseBasemap is true)
    // If showBaseBasemap is false, only show thematic overlays
    // CRITICAL: Use selectedBaseBasemap exactly as-is - NEVER reset or change it
    
    // Step 1: Add base basemap from "Basemaps" section (if toggle is ON)
    if (showBaseBasemap) {
      const baseBasemapConfig = BASEMAP_CONFIGS[selectedBaseBasemap];
      if (!baseBasemapConfig) {
        console.warn('Base basemap config not found for:', selectedBaseBasemap, 'using liberty as fallback');
      }
      const finalBaseConfig = baseBasemapConfig || BASEMAP_CONFIGS.liberty;
      
      // "Basemaps" section selection is the base layer (full opacity)
      // This includes maplibre (OpenFreeMap), tile (USA Topo, NatGeo), and wms types
      // CRITICAL: All basemaps in "Basemaps" section are treated identically - they REPLACE each other, never stack
      if (finalBaseConfig.type === 'maplibre') {
        newBasemapLayer = (L as any).maplibreGL({
          style: finalBaseConfig.styleUrl,
          attribution: finalBaseConfig.attribution,
          interactive: false,
        }).addTo(map);
      } else if (finalBaseConfig.type === 'tile') {
        // Tile basemaps (USA Topo, NatGeo) - these REPLACE maplibre basemaps, not stack on top
        if (finalBaseConfig.exportMapLayerId !== undefined && finalBaseConfig.tileUrl) {
          // MapServer ExportMap endpoint
          newBasemapLayer = createExportMapTileLayer(
            finalBaseConfig.tileUrl,
            finalBaseConfig.exportMapLayerId,
            {
              attribution: finalBaseConfig.attribution,
              maxZoom: 15,
              minZoom: 4,
              noWrap: true,
              opacity: 1.0, // Full opacity - this is the base, replaces any previous basemap
              tileSize: 256,
            }
          ).addTo(map);
        } else if (finalBaseConfig.exportImageRasterFunction && finalBaseConfig.tileUrl) {
          // ImageServer ExportImage endpoint
          newBasemapLayer = createExportImageTileLayer(
            finalBaseConfig.tileUrl,
            finalBaseConfig.exportImageRasterFunction,
            {
              attribution: finalBaseConfig.attribution,
              maxZoom: 15,
              minZoom: 4,
              noWrap: true,
              opacity: 1.0, // Full opacity - this is the base, replaces any previous basemap
              tileSize: 256,
            }
          ).addTo(map);
        } else {
          // Standard tile layer
          newBasemapLayer = L.tileLayer(finalBaseConfig.tileUrl!, {
            attribution: finalBaseConfig.attribution,
            maxZoom: 15,
            minZoom: 4,
            noWrap: true,
            opacity: 1.0, // Full opacity - this is the base, replaces any previous basemap
          }).addTo(map);
        }
      } else if (finalBaseConfig.type === 'wms') {
        const wmsOptions: any = {
          format: finalBaseConfig.wmsFormat || 'image/png',
          transparent: true,
          attribution: finalBaseConfig.attribution,
          crs: finalBaseConfig.wmsCrs === 'EPSG4326' ? L.CRS.EPSG4326 : L.CRS.EPSG3857,
          version: finalBaseConfig.wmsVersion || '1.3.0',
          opacity: 1.0, // Full opacity - this is the base, replaces any previous basemap
        };
        
        if (finalBaseConfig.wmsUppercase === true) {
          wmsOptions.uppercase = true;
        }
        
        if (finalBaseConfig.wmsLayers !== undefined && finalBaseConfig.wmsLayers.trim() !== '') {
          wmsOptions.layers = finalBaseConfig.wmsLayers;
        }
        
        if (finalBaseConfig.wmsRasterFunction !== undefined && finalBaseConfig.wmsRasterFunction.trim() !== '') {
          wmsOptions.rasterFunction = finalBaseConfig.wmsRasterFunction;
        }
        
        newBasemapLayer = L.tileLayer.wms(finalBaseConfig.wmsUrl!, wmsOptions);
        newBasemapLayer.addTo(map);
      }
    } else {
      // Base basemap toggle is OFF - no base layer
      newBasemapLayer = null;
    }
    
    // Step 2: Add thematic basemap as optional overlay on top (if selected)
    // CRITICAL: selectedThematicBasemap state is independent - it should NEVER be affected by selectedBaseBasemap changes
    // Thematic overlay persists when switching basemaps from "Basemaps" section
    if (selectedThematicBasemap) {
      const thematicConfig = BASEMAP_CONFIGS[selectedThematicBasemap];
      // Thematic basemaps can be tile, wms, or maplibre (vector tiles) from other sections
      // Make sure we're not accidentally treating "Basemaps" section basemaps as thematic
      // Note: usa_topo_maps and natgeo_world_map are in "Basemaps" section, so they should never be in selectedThematicBasemap
      const isBaseBasemap = selectedThematicBasemap === 'usa_topo_maps' || selectedThematicBasemap === 'natgeo_world_map' || 
                             selectedThematicBasemap === 'liberty' || selectedThematicBasemap === 'bright' || selectedThematicBasemap === 'positron';
      if (thematicConfig && !isBaseBasemap) {
          // Thematic basemap as overlay (with opacity)
          if (thematicConfig.type === 'maplibre') {
            // Vector tile overlay using MapLibre GL
            // For ArcGIS VectorTileServer, fetch and transform style JSON to fix relative URLs
            (async () => {
              try {
                console.log('🔍 [DEBUG] Fetching and transforming style:', thematicConfig.styleUrl);
                const transformedStyle = await fetchAndTransformVectorTileStyle(thematicConfig.styleUrl!);
                
                // The maplibreGL plugin accepts either a style URL or a style object
                // Since we've already transformed it, pass the object directly
                // Note: maplibreGL plugin may internally fetch resources, so ensure all URLs are absolute
                console.log('🔍 [DEBUG] Creating MapLibre GL layer with transformed style');
                
                // Before creating the layer, verify critical URLs are accessible
                if (transformedStyle.sprite) {
                  console.log('🔍 [DEBUG] Sprite URL to be used:', transformedStyle.sprite);
                }
                if (transformedStyle.glyphs) {
                  console.log('🔍 [DEBUG] Glyphs URL to be used:', transformedStyle.glyphs);
                }
                if (transformedStyle.sources) {
                  for (const [sourceKey, source] of Object.entries(transformedStyle.sources as any)) {
                    if ((source as any).url) {
                      console.log(`🔍 [DEBUG] Source "${sourceKey}" URL:`, (source as any).url);
                    }
                    if ((source as any).tiles) {
                      console.log(`🔍 [DEBUG] Source "${sourceKey}" tiles:`, (source as any).tiles);
                    }
                  }
                }
                
                newOverlayLayer = (L as any).maplibreGL({
                  style: transformedStyle, // Pass the transformed style object, not the URL
                  attribution: thematicConfig.attribution,
                  interactive: false,
                });
                
                newOverlayLayer.addTo(map);
                
                // Add error handlers to catch any resource loading failures
                if (newOverlayLayer) {
                  // Wait for the map to be initialized before accessing _glMap
                  setTimeout(() => {
                    if (newOverlayLayer && newOverlayLayer._glMap) {
                      newOverlayLayer._glMap.on('error', (e: any) => {
                        console.error('❌ MapLibre GL error:', e);
                        if (e.error && e.error.message) {
                          console.error('❌ Error message:', e.error.message);
                        }
                      });
                      newOverlayLayer._glMap.on('data', (e: any) => {
                        if (e.dataType === 'source' && e.isSourceLoaded === false && e.error) {
                          console.error('❌ Source failed to load:', e.sourceId, e.error);
                        }
                      });
                    }
                    
                    // After adding to map, ensure the container is above basemaps but same z-index as other thematic overlays
                    if (newOverlayLayer && newOverlayLayer.getContainer) {
                      const container = newOverlayLayer.getContainer();
                      if (container) {
                        container.style.opacity = '0.7';
                        // Use same z-index as overlayPane (400) but ensure it's in overlayPane which is above tilePane
                        // This ensures it's above basemaps but doesn't prevent replacement by other thematic overlays
                        container.style.zIndex = '400';
                        container.style.position = 'absolute';
                        // Ensure it's in the overlayPane which is above tilePane (where basemaps are)
                        const overlayPane = map.getPane('overlayPane');
                        if (overlayPane && container.parentNode !== overlayPane) {
                          overlayPane.appendChild(container);
                        }
                      }
                    }
                  }, 100);
                }
                
                overlayLayerRef.current = newOverlayLayer;
              } catch (error) {
                console.error('❌ Error loading MapLibre vector tile overlay:', error);
              }
            })();
          } else if (thematicConfig.type === 'tile') {
            if (thematicConfig.exportMapLayerId !== undefined && thematicConfig.tileUrl) {
              // MapServer ExportMap endpoint
              newOverlayLayer = createExportMapTileLayer(
                thematicConfig.tileUrl,
                thematicConfig.exportMapLayerId,
                {
                  attribution: thematicConfig.attribution,
                  maxZoom: 15,
                  minZoom: 4,
                  noWrap: true,
                  opacity: 0.7, // Transparent overlay
                  tileSize: 256,
                }
              ).addTo(map);
            } else if (thematicConfig.exportImageRasterFunction && thematicConfig.tileUrl) {
              // ImageServer ExportImage endpoint
              newOverlayLayer = createExportImageTileLayer(
                thematicConfig.tileUrl,
                thematicConfig.exportImageRasterFunction,
                {
                  attribution: thematicConfig.attribution,
                  maxZoom: 15,
                  minZoom: 4,
                  noWrap: true,
                  opacity: 0.7, // Transparent overlay
                  tileSize: 256,
                }
              ).addTo(map);
            } else {
              // Standard tile layer
              newOverlayLayer = L.tileLayer(thematicConfig.tileUrl!, {
                attribution: thematicConfig.attribution,
                maxZoom: 15,
                minZoom: 4,
                noWrap: true,
                opacity: 0.7, // Transparent overlay
              }).addTo(map);
            }
            
            newOverlayLayer.on('tileerror', (_error: any, tile: any) => {
              if (tile && tile.src) {
                const img = tile as HTMLImageElement;
                if (img.naturalWidth === 0 && img.naturalHeight === 0) {
                  return;
                }
              }
            });
          } else if (thematicConfig.type === 'wms') {
            const wmsOptions: any = {
              format: thematicConfig.wmsFormat || 'image/png',
              transparent: true,
              attribution: thematicConfig.attribution,
              crs: thematicConfig.wmsCrs === 'EPSG4326' ? L.CRS.EPSG4326 : L.CRS.EPSG3857,
              version: thematicConfig.wmsVersion || '1.3.0',
              opacity: 0.7, // Transparent overlay
            };
            
            if (thematicConfig.wmsUppercase === true) {
              wmsOptions.uppercase = true;
            }
            
            if (thematicConfig.wmsLayers !== undefined && thematicConfig.wmsLayers.trim() !== '') {
              wmsOptions.layers = thematicConfig.wmsLayers;
            }
            
            if (thematicConfig.wmsRasterFunction !== undefined && thematicConfig.wmsRasterFunction.trim() !== '') {
              wmsOptions.rasterFunction = thematicConfig.wmsRasterFunction;
            }
            
            newOverlayLayer = L.tileLayer.wms(thematicConfig.wmsUrl!, wmsOptions);
            newOverlayLayer.on('tileerror', (_error: any, tile: any) => {
              if (tile && tile.src) {
                const img = tile as HTMLImageElement;
                if (img.naturalWidth === 0 && img.naturalHeight === 0) {
                  return;
                }
              }
            });
            newOverlayLayer.addTo(map);
          }
        }
        
        // Set overlay reference if we created one
        // CRITICAL: Always recreate thematic overlay when selectedThematicBasemap exists
        if (newOverlayLayer) {
          overlayLayerRef.current = newOverlayLayer;
        } else {
          // If selectedThematicBasemap exists but overlay wasn't created, log for debugging
          // The state will remain, so it will retry on next render
          console.warn('Thematic overlay not created for:', selectedThematicBasemap);
          overlayLayerRef.current = null;
        }
      } else {
        // No thematic selected - clear overlay reference
        overlayLayerRef.current = null;
      }
      
    // CRITICAL: Ensure basemap layer reference is set after creating base layer
    // This must happen AFTER base layer creation to ensure proper layer order
    if (newBasemapLayer) {
      basemapLayerRef.current = newBasemapLayer;
    } else {
      console.warn('Base basemap layer not created for:', selectedBaseBasemap);
    }
  }, [selectedBaseBasemap, selectedThematicBasemap, showBaseBasemap, isInitialized]);

  // Close basemap info tooltip when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (basemapInfoRef.current && !basemapInfoRef.current.contains(event.target as Node)) {
        setShowBasemapInfo(false);
      }
    };

    if (showBasemapInfo) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showBasemapInfo]);

  useEffect(() => {
    if (typeof window === 'undefined') {
      return;
    }

    const updateViewportDimensions = () => {
      // Viewport dimensions no longer tracked - was causing unnecessary invalidateSize calls
      // Map handles sizing naturally
    };

    updateViewportDimensions();

    window.addEventListener('resize', updateViewportDimensions);
    window.addEventListener('orientationchange', updateViewportDimensions);
    const visualViewport = window.visualViewport;
    visualViewport?.addEventListener('resize', updateViewportDimensions);

    return () => {
      window.removeEventListener('resize', updateViewportDimensions);
      window.removeEventListener('orientationchange', updateViewportDimensions);
      visualViewport?.removeEventListener('resize', updateViewportDimensions);
    };
  }, []);

  // Handle map size invalidation when view becomes visible
  useEffect(() => {
    if (!mapInstanceRef.current || !isInitialized) {
      return;
    }

    // When map view is first shown, ensure proper sizing
    // Use a small delay to allow CSS transitions to complete
    // For mobile, use longer delay and force container sizing
    const delay = isMobile ? 500 : 300;
    const timeoutId = setTimeout(() => {
      if (mapInstanceRef.current && mapRef.current) {
        // For mobile, ensure container has explicit dimensions
        if (isMobile) {
          const parent = mapRef.current.parentElement;
          if (parent) {
            const parentRect = parent.getBoundingClientRect();
            if (parentRect.height > 0 && parentRect.width > 0) {
              mapRef.current.style.height = `${parentRect.height}px`;
              mapRef.current.style.width = `${parentRect.width}px`;
            }
          }
        }
        
        const rect = mapRef.current.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          mapInstanceRef.current.invalidateSize(true); // Force recalculation on mobile
        }
      }
    }, delay);

    return () => {
      clearTimeout(timeoutId);
    };
  }, [isInitialized, isMobile]);

  useEffect(() => {
    if (!mapRef.current || !mapInstanceRef.current || typeof ResizeObserver === 'undefined') {
      return;
    }

    // ResizeObserver to handle container size changes
    // Only call invalidateSize when container actually changes size significantly
    let resizeTimeout: NodeJS.Timeout | null = null;
    let lastWidth = 0;
    let lastHeight = 0;
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (!entry) return;
      
      const { width, height } = entry.contentRect;
      
      // Only invalidateSize if size changed significantly (more than 10px difference)
      // This prevents twitching from minor size fluctuations
      if (Math.abs(width - lastWidth) > 10 || Math.abs(height - lastHeight) > 10) {
        lastWidth = width;
        lastHeight = height;
        
        // Debounce to avoid excessive calls
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        resizeTimeout = setTimeout(() => {
          if (mapInstanceRef.current) {
            mapInstanceRef.current.invalidateSize(false);
          }
        }, 150);
      }
    });

    observer.observe(mapRef.current);

    return () => {
      observer.disconnect();
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
    };
  }, []);

  useEffect(() => {
    console.log('🔍 [DEBUG START] useEffect triggered', {
      hasMap: !!mapInstanceRef.current,
      hasLayerGroups: !!layerGroupsRef.current,
      resultsCount: results?.length || 0,
      timestamp: new Date().toISOString()
    });

    // CRITICAL FIX: Wait for map to be initialized before proceeding
    // The map initializes in a separate useEffect, so we need to wait for it
    if (!mapInstanceRef.current || !layerGroupsRef.current) {
      console.log('🔍 [DEBUG] Map not ready yet, setting up retry mechanism');
      
      let attempts = 0;
      const maxAttempts = 100; // 10 seconds max wait
      const checkMapReady = setInterval(() => {
        attempts++;
        if (mapInstanceRef.current && layerGroupsRef.current) {
          console.log(`🔍 [DEBUG] Map is now ready after ${attempts} attempts, proceeding`);
          clearInterval(checkMapReady);
          // Map is ready, proceed with adding features
          setTimeout(() => {
            if (mapInstanceRef.current && layerGroupsRef.current && results && results.length > 0) {
              addFeaturesToMap();
            }
          }, 200); // Give map a moment to fully initialize
        } else if (attempts >= maxAttempts) {
          console.error('🔍 [DEBUG ERROR] Map never became ready after 100 attempts');
          clearInterval(checkMapReady);
        }
      }, 100);
      
      return () => {
        clearInterval(checkMapReady);
      };
    }
    
    // Map is ready, proceed immediately
    addFeaturesToMap();
    
    function addFeaturesToMap() {
    if (!mapInstanceRef.current || !layerGroupsRef.current) {
      console.warn('🔍 [DEBUG] Map or layer groups not ready, skipping feature addition');
      return;
    }

    const map = mapInstanceRef.current;
    const { primary, poi } = layerGroupsRef.current;

    // Debug initial map state
    const initialContainer = map.getContainer();
    console.log('🔍 [DEBUG] Initial map state', {
      containerExists: !!initialContainer,
      containerWidth: initialContainer?.offsetWidth || 0,
      containerHeight: initialContainer?.offsetHeight || 0,
      containerDisplay: initialContainer ? window.getComputedStyle(initialContainer).display : 'N/A',
      containerVisibility: initialContainer ? window.getComputedStyle(initialContainer).visibility : 'N/A',
      mapCenter: map.getCenter().toString(),
      mapZoom: map.getZoom(),
      primaryLayerCount: primary.getLayers().length,
      poiLayerCount: poi.getLayers().length,
      primaryInMap: map.hasLayer(primary),
      poiInMap: map.hasLayer(poi)
    });

    if (!results || results.length === 0) {
      console.log('🔍 [DEBUG] No results, clearing layers');
      primary.clearLayers();
      poi.clearLayers();
      setLegendItems([]);
      setShowBatchSuccess(false);
      return;
    }

    // Clear layers and add features - simple and direct
    primary.clearLayers();
    poi.clearLayers();
    // Clear feature metadata for tabbed popup
    featuresMetadataRef.current = [];
    
    // Add location marker (larger blue pin)
    if (results[0]?.location) {
      // Create a simpler icon for mobile, complex pin for desktop
      const locationIcon = isMobile 
        ? L.divIcon({
            className: 'custom-location-marker-mobile',
            html: `<div style="
              width: 32px;
              height: 32px;
              background-color: #3b82f6;
              border: 3px solid white;
              border-radius: 50%;
              box-shadow: none;
              display: flex;
              align-items: center;
              justify-content: center;
              box-sizing: border-box;
              line-height: 1;
              margin: 0;
              padding: 0;
            ">
              <div style="
                width: 12px;
                height: 12px;
                background-color: white;
                border-radius: 50%;
                margin: 0;
                padding: 0;
              "></div>
            </div>`,
            iconSize: [32, 32],
            iconAnchor: [16, 16],
            popupAnchor: [0, -16]
          })
        : L.divIcon({
            className: 'custom-location-marker',
            html: `<div style="
              width: 40px;
              height: 40px;
              background-color: #3b82f6;
              border: 4px solid white;
              border-radius: 50% 50% 50% 0;
              transform: rotate(-45deg);
              box-shadow: 0 3px 10px rgba(0,0,0,0.4);
              display: flex;
              align-items: center;
              justify-content: center;
            ">
              <div style="
                transform: rotate(45deg);
                width: 16px;
                height: 16px;
                background-color: white;
                border-radius: 50%;
              "></div>
            </div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 40],
            popupAnchor: [0, -40]
          });
      
      const locationMarker = L.marker([results[0].location.lat, results[0].location.lon], {
        title: results[0].location.name,
        icon: locationIcon,
        pane: 'locationMarkerPane' // Use custom pane with higher z-index
      });
      locationMarker.bindPopup(createPopupContent(results[0], isMobile), { 
        maxWidth: isMobile ? 280 : 540,
        className: isMobile ? 'mobile-popup' : undefined
      });
      locationMarker.addTo(primary);
      
      // Store reference to location marker so we can bring it to front after all features are added
      (locationMarker as any).__isLocationMarker = true;
    }
    
    // Add all enrichment features - use requestAnimationFrame for smooth rendering
    requestAnimationFrame(() => {
        console.log('🗺️ STEP 2: Inside setTimeout, starting to draw features');
        // Reset color tracking to ensure unique colors for this map render
        resetColorTracking();
        const bounds = L.latLngBounds([]);
        const legendAccumulator: Record<string, LegendItem> = {};
        
        // Track drawn schools and businesses across ALL results to prevent duplicates
        const drawnPrivateSchoolIds = new Set<string>();
        const drawnPublicSchoolIds = new Set<string>();
        const drawnBusinessIds = new Set<string>();
        const drawnTrafficIds = new Set<string>();
        
        // Track total counts of unique schools, businesses, routes, and traffic points drawn (not per result)
        let totalPublicSchoolCount = 0;
        let totalPrivateSchoolCount = 0;
        let totalBusinessCount = 0;
        let totalBikeRouteCount = 0;
        let totalTrafficPointCount = 0;
        let totalFacilityPointCount = 0;
        let totalBikeSlotCount = 0;
        let totalBikeLaneCount = 0;
        let totalRailroadCrossingCount = 0;
        let totalNumberOfLanesCount = 0;
        let totalRestAreaCount = 0;
        let totalFunctionalClassificationCount = 0;
        const laneCountStats: Record<number, number> = {}; // Track lane count distribution for legend
        const funclassStats: Record<string, number> = {}; // Track functional class distribution for legend
        
        // Re-add location marker to bounds (already added above, but need for bounds calculation)
        if (results[0]?.location) {
          bounds.extend(L.latLng(results[0].location.lat, results[0].location.lon));
        }
        
    results.forEach((result) => {
      const { location, enrichments } = result;
      if (!location) {
        return;
      }

      const latLng = L.latLng(location.lat, location.lon);
      bounds.extend(latLng);

      // Location marker already added in STEP 1 above, just extend bounds here

      // Draw NH EMS facilities as markers on the map
      if (enrichments.nh_ems_all && Array.isArray(enrichments.nh_ems_all)) {
        enrichments.nh_ems_all.forEach((facility: any) => {
          if (facility.lat && facility.lon) {
            try {
              const facilityLat = facility.lat;
              const facilityLon = facility.lon;
              const facilityName = facility.name || facility.NAME || facility.Name || 'Unknown EMS Facility';
              const facilityType = facility.type || facility.TYPE || facility.Type || 'Unknown Type';
              
              // Create a custom icon for EMS facilities
              const icon = createPOIIcon('🚑', '#ef4444', isMobile); // Red icon for emergency services
              
              const marker = L.marker([facilityLat, facilityLon], { icon });
              
              // Build popup content with all EMS facility attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚑 ${facilityName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${facilityType}</div>
                    ${facility.address ? `<div><strong>Address:</strong> ${facility.address}</div>` : ''}
                    ${facility.city ? `<div><strong>City:</strong> ${facility.city}</div>` : ''}
                    ${facility.telephone ? `<div><strong>Phone:</strong> ${facility.telephone}</div>` : ''}
                    ${facility.owner ? `<div><strong>Owner:</strong> ${facility.owner}</div>` : ''}
                    ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all EMS facility attributes (excluding internal fields)
              const excludeFields = ['name', 'type', 'address', 'city', 'state', 'zip', 'telephone', 'owner', 'lat', 'lon', 'distance_miles'];
              Object.entries(facility).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              // Add mapping platform links
              popupContent += `
                  </div>
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
                    <div style="margin-bottom: 4px; font-size: 11px; font-weight: 600; color: #374151;">Open in Maps:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                      ${generateMappingLinks(facilityLat, facilityLon, facilityName)}
                    </div>
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this EMS facility
              bounds.extend([facilityLat, facilityLon]);
            } catch (error) {
              console.error('Error drawing NH EMS facility marker:', error);
            }
          }
        });
      }

      // Draw Wikipedia articles as markers on the map
      if (enrichments.poi_wikipedia_articles && Array.isArray(enrichments.poi_wikipedia_articles)) {
        enrichments.poi_wikipedia_articles.forEach((article: any) => {
          if (article.lat && article.lon) {
            try {
              const articleLat = article.lat;
              const articleLon = article.lon;
              const articleTitle = article.title || 'Unnamed Article';
              const distanceMiles = article.distance_miles !== null && article.distance_miles !== undefined ? article.distance_miles : null;
              const articleUrl = article.url || null;
              const categories = article.categories || [];
              
              // Create a custom icon for Wikipedia articles
              const icon = createPOIIcon('📖', '#1d4ed8', isMobile); // Blue icon for Wikipedia articles
              
              const marker = L.marker([articleLat, articleLon], { icon });
              
              // Build popup content with article details
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    📖 ${articleTitle}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${distanceMiles !== null ? `<div><strong>Distance:</strong> ${distanceMiles.toFixed(2)} miles</div>` : ''}
                    ${categories.length > 0 ? `<div><strong>Categories:</strong> ${categories.join(', ')}</div>` : ''}
                    ${articleUrl ? `<div style="margin-top: 8px;"><a href="${articleUrl}" target="_blank" rel="noopener noreferrer" style="color: #1d4ed8; text-decoration: underline; font-size: 12px;">View on Wikipedia</a></div>` : ''}
                  </div>
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
                    <div style="margin-bottom: 4px; font-size: 11px; font-weight: 600; color: #374151;">Open in Maps:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                      ${generateMappingLinks(articleLat, articleLon, articleTitle)}
                    </div>
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this article
              bounds.extend([articleLat, articleLon]);
              
              // Add to legend accumulator
              if (!legendAccumulator['poi_wikipedia']) {
                const radius = getRadiusForLegendKey('poi_wikipedia');
                const radiusDisplay = formatRadiusDisplay('poi_wikipedia', radius);
                legendAccumulator['poi_wikipedia'] = {
                  icon: '📖',
                  color: '#1d4ed8',
                  title: 'Wikipedia Articles',
                  count: 0,
                  radius: radius,
                  radiusDisplay: radiusDisplay,
                };
              }
              legendAccumulator['poi_wikipedia'].count += 1;
            } catch (error) {
              console.error('Error drawing Wikipedia article marker:', error);
            }
          }
        });
      }

      // Draw NH Places of Worship as markers on the map
      if (enrichments.nh_places_of_worship_all && Array.isArray(enrichments.nh_places_of_worship_all)) {
        enrichments.nh_places_of_worship_all.forEach((place: any) => {
          if (place.lat && place.lon) {
            try {
              const placeLat = place.lat;
              const placeLon = place.lon;
              const placeName = place.name || place.NAME || place.Name || 'Unknown Place of Worship';
              const subtype = place.subtype || place.SUBTYPE || place.Subtype || 'Unknown Type';
              const denom = place.denom || place.DENOM || place.Denom || '';
              
              // Create a custom icon for places of worship
              const icon = createPOIIcon('🕌', '#7c3aed', isMobile); // Purple icon for places of worship
              
              const marker = L.marker([placeLat, placeLon], { icon });
              
              // Build popup content with all place of worship attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🕌 ${placeName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${subtype}${denom ? ` - ${denom}` : ''}</div>
                    ${place.address ? `<div><strong>Address:</strong> ${place.address}</div>` : ''}
                    ${place.city ? `<div><strong>City:</strong> ${place.city}</div>` : ''}
                    ${place.telephone ? `<div><strong>Phone:</strong> ${place.telephone}</div>` : ''}
                    ${place.attendance !== null && place.attendance !== undefined ? `<div><strong>Attendance:</strong> ${place.attendance}</div>` : ''}
                    ${place.distance_miles !== null && place.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${place.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all place of worship attributes (excluding internal fields)
              const excludeFields = ['name', 'subtype', 'denom', 'address', 'city', 'state', 'zip', 'telephone', 'attendance', 'lat', 'lon', 'distance_miles'];
              Object.entries(place).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              popupContent = addMappingLinksToPopup(popupContent, placeLat, placeLon, placeName);
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this place of worship
              bounds.extend([placeLat, placeLon]);
            } catch (error) {
              console.error('Error drawing NH Place of Worship marker:', error);
            }
          }
        });
      }

      // Draw NH Access Sites to Public Waters as markers on the map
      if (enrichments.nh_public_waters_access_all && Array.isArray(enrichments.nh_public_waters_access_all)) {
        enrichments.nh_public_waters_access_all.forEach((site: any) => {
          if (site.lat && site.lon) {
            try {
              const siteLat = site.lat;
              const siteLon = site.lon;
              const facilityName = site.facility || site.FACILITY || site.Facility || 'Unknown Access Site';
              const waterBody = site.water_body || site.WATER_BODY || site.WaterBody || 'Unknown Water Body';
              const wbType = site.wb_type || site.WB_TYPE || site.WbType || '';
              const accessTyp = site.access_typ || site.ACCESS_TYP || site.AccessTyp || '';
              
              // Create a custom icon for water access sites
              const icon = createPOIIcon('🌊', '#0ea5e9', isMobile); // Blue icon for water access
              
              const marker = L.marker([siteLat, siteLon], { icon });
              
              // Build popup content with all access site attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🌊 ${facilityName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Water Body:</strong> ${waterBody}${wbType ? ` (${wbType})` : ''}</div>
                    ${accessTyp ? `<div><strong>Access Type:</strong> ${accessTyp}</div>` : ''}
                    ${site.town ? `<div><strong>Town:</strong> ${site.town}</div>` : ''}
                    ${site.county ? `<div><strong>County:</strong> ${site.county}</div>` : ''}
                    ${site.ownership ? `<div><strong>Ownership:</strong> ${site.ownership}</div>` : ''}
                    <div><strong>Amenities:</strong> ${[
                      site.boat === 'Yes' ? 'Boat' : null,
                      site.swim === 'Yes' ? 'Swim' : null,
                      site.fish === 'Yes' ? 'Fish' : null,
                      site.picnic === 'Yes' ? 'Picnic' : null,
                      site.camp === 'Yes' ? 'Camp' : null
                    ].filter(Boolean).join(', ') || 'None'}</div>
                    ${site.distance_miles !== null && site.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${site.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all access site attributes (excluding internal fields)
              const excludeFields = ['facility', 'water_body', 'wb_type', 'access_typ', 'town', 'county', 'ownership', 'boat', 'swim', 'fish', 'picnic', 'camp', 'lat', 'lon', 'distance_miles'];
              Object.entries(site).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              popupContent = addMappingLinksToPopup(popupContent, siteLat, siteLon, facilityName);
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this access site
              bounds.extend([siteLat, siteLon]);
            } catch (error) {
              console.error('Error drawing NH Access Site to Public Waters marker:', error);
            }
          }
        });
      }

      // Draw NH Law Enforcement facilities as markers on the map
      if (enrichments.nh_law_enforcement_all && Array.isArray(enrichments.nh_law_enforcement_all)) {
        enrichments.nh_law_enforcement_all.forEach((facility: any) => {
          if (facility.lat && facility.lon) {
            try {
              const facilityLat = facility.lat;
              const facilityLon = facility.lon;
              const facilityName = facility.name || facility.NAME || facility.Name || 'Unknown Law Enforcement Facility';
              const facilityType = facility.type || facility.TYPE || facility.Type || 'Unknown Type';
              
              // Create a custom icon for law enforcement
              const icon = createPOIIcon('🚔', '#1e40af'); // Blue icon for law enforcement
              
              const marker = L.marker([facilityLat, facilityLon], { icon });
              
              // Build popup content with all law enforcement facility attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚔 ${facilityName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${facilityType}</div>
                    ${facility.address ? `<div><strong>Address:</strong> ${facility.address}</div>` : ''}
                    ${facility.city ? `<div><strong>City:</strong> ${facility.city}</div>` : ''}
                    ${facility.telephone ? `<div><strong>Phone:</strong> ${facility.telephone}</div>` : ''}
                    ${facility.owner ? `<div><strong>Owner:</strong> ${facility.owner}</div>` : ''}
                    ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all law enforcement facility attributes (excluding internal fields)
              const excludeFields = ['name', 'type', 'address', 'city', 'state', 'zip', 'telephone', 'owner', 'lat', 'lon', 'distance_miles'];
              Object.entries(facility).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this law enforcement facility
              bounds.extend([facilityLat, facilityLon]);
            } catch (error) {
              console.error('Error drawing NH Law Enforcement facility marker:', error);
            }
          }
        });
      }

      // Draw NH Recreation Trails as polylines on the map
      if (enrichments.nh_recreation_trails_all && Array.isArray(enrichments.nh_recreation_trails_all)) {
        let trailCount = 0;
        enrichments.nh_recreation_trails_all.forEach((trail: any) => {
          if (trail.geometry && trail.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              // ESRI polylines have paths (array of coordinate arrays)
              const paths = trail.geometry.paths;
              if (paths && paths.length > 0) {
                trailCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const trailName = trail.name || trail.NAME || trail.Name || 'Unknown Trail';
                  const trailType = trail.trail_type || trail.TRAIL_TYPE || trail.TrailType || trail.type || trail.TYPE || 'Unknown Type';
                  const lengthMiles = trail.length_miles || trail.LENGTH_MILES || trail.LengthMiles || trail.length || trail.LENGTH || null;

                  // Create polyline with green color for trails
                  const polyline = L.polyline(latlngs, {
                    color: '#059669', // Green color for trails
                    weight: 4,
                    opacity: 0.8,
                    smoothFactor: 1
                  });

                  // Build popup content with all trail attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🥾 ${trailName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${trailType ? `<div><strong>Type:</strong> ${trailType}</div>` : ''}
                        ${lengthMiles !== null && lengthMiles !== undefined ? `<div><strong>Length:</strong> ${lengthMiles} miles</div>` : ''}
                        ${trail.distance_miles !== null && trail.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${trail.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all trail attributes (excluding internal fields)
                  const excludeFields = ['name', 'trail_type', 'type', 'length_miles', 'length', 'geometry', 'distance_miles'];
                  Object.entries(trail).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing NH Recreation Trail polyline:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (trailCount > 0) {
          if (!legendAccumulator['nh_recreation_trails']) {
            const radius = getRadiusForLegendKey('nh_recreation_trails');
            const radiusDisplay = formatRadiusDisplay('nh_recreation_trails', radius);
            legendAccumulator['nh_recreation_trails'] = {
              icon: '🥾',
              color: '#059669',
              title: 'NH Recreation Trails',
              count: 0,
              radius: radius,
              radiusDisplay: radiusDisplay,
            };
          }
          legendAccumulator['nh_recreation_trails'].count += trailCount;
        }
      }

      // Draw NH Stone Walls as polylines on the map
      if (enrichments.nh_stone_walls_all && Array.isArray(enrichments.nh_stone_walls_all)) {
        let wallCount = 0;
        enrichments.nh_stone_walls_all.forEach((wall: any) => {
          if (wall.geometry && wall.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = wall.geometry.paths;
              if (paths && paths.length > 0) {
                wallCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const town = wall.TOWN || wall.town || 'Unknown Town';
                  const user = wall.USER_ || wall.user || null;
                  const shapeLength = wall.Shape__Length || wall.shapeLength || null;

                  // Create polyline with brown/tan color for stone walls
                  const polyline = L.polyline(latlngs, {
                    color: '#8b7355', // Brown/tan color for stone walls
                    weight: 2,
                    opacity: 0.8,
                    smoothFactor: 1
                  });

                  // Build popup content with all stone wall attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🧱 Stone Wall
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${town ? `<div><strong>Town:</strong> ${town}</div>` : ''}
                        ${user ? `<div><strong>Mapped by:</strong> ${user}</div>` : ''}
                        ${shapeLength ? `<div><strong>Length:</strong> ${(shapeLength * 3.28084).toFixed(1)} ft</div>` : ''}
                        ${wall.distance_miles !== null && wall.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${wall.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all stone wall attributes (excluding internal fields)
                  const excludeFields = ['TOWN', 'town', 'USER_', 'user', 'Shape__Length', 'shapeLength', 'geometry', 'distance_miles'];
                  Object.entries(wall).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing NH Stone Wall polyline:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (wallCount > 0) {
          if (!legendAccumulator['nh_stone_walls']) {
            const radius = getRadiusForLegendKey('nh_stone_walls');
            const radiusDisplay = formatRadiusDisplay('nh_stone_walls', radius);
            legendAccumulator['nh_stone_walls'] = {
              icon: '🧱',
              color: '#8b7355',
              title: 'NH Stone Walls',
              count: 0,
              radius: radius,
              radiusDisplay: radiusDisplay,
            };
          }
          legendAccumulator['nh_stone_walls'].count += wallCount;
        }
      }

      // Draw NH DOT Roads as polylines on the map
      if (enrichments.nh_dot_roads_all && Array.isArray(enrichments.nh_dot_roads_all)) {
        let roadCount = 0;
        enrichments.nh_dot_roads_all.forEach((road: any) => {
          if (road.geometry && road.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              // ESRI polylines have paths (array of coordinate arrays)
              const paths = road.geometry.paths;
              if (paths && paths.length > 0) {
                roadCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const streetName = road.Street || road.STREET || road.street || 'Unknown Road';
                  const roadType = road.road_type || road.ROAD_TYPE || road.RoadType || road.type || road.TYPE || road.fclass || road.FCLASS || 'Unknown Type';
                  const routeNumber = road.route_number || road.ROUTE_NUMBER || road.RouteNumber || road.route || road.ROUTE || road.rt_number || road.RT_NUMBER || null;

                  // Create polyline with yellow color for roads
                  const polyline = L.polyline(latlngs, {
                    color: '#fbbf24', // Yellow color for roads (better visibility on imagery basemap)
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1
                  });

                  // Build popup content with all road attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🛣️ ${streetName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${roadType ? `<div><strong>Type:</strong> ${roadType}</div>` : ''}
                        ${routeNumber ? `<div><strong>Route Number:</strong> ${routeNumber}</div>` : ''}
                        ${road.distance_miles !== null && road.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${road.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all road attributes (excluding internal fields)
                  const excludeFields = ['name', 'road_name', 'street_name', 'road_type', 'type', 'fclass', 'route_number', 'route', 'rt_number', 'geometry', 'distance_miles'];
                  Object.entries(road).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing NH DOT Road polyline:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (roadCount > 0) {
          if (!legendAccumulator['nh_dot_roads']) {
            const radius = getRadiusForLegendKey('nh_dot_roads');
            const radiusDisplay = formatRadiusDisplay('nh_dot_roads', radius);
            legendAccumulator['nh_dot_roads'] = {
              icon: '🛣️',
              color: '#fbbf24',
              title: 'NH DOT Roads',
              count: 0,
              radius: radius,
              radiusDisplay: radiusDisplay,
            };
          }
          legendAccumulator['nh_dot_roads'].count += roadCount;
        }
      }

      // Draw NH Railroads as polylines on the map
      if (enrichments.nh_railroads_all && Array.isArray(enrichments.nh_railroads_all)) {
        let railroadCount = 0;
        enrichments.nh_railroads_all.forEach((railroad: any) => {
          if (railroad.geometry && railroad.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              // ESRI polylines have paths (array of coordinate arrays)
              const paths = railroad.geometry.paths;
              if (paths && paths.length > 0) {
                railroadCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const railroadName = railroad.name || railroad.NAME || railroad.Name || railroad._name || 'Unknown Railroad';
                  const status = railroad.status || railroad.STATUS || railroad.Status || railroad._status || '';
                  const ownership = railroad.ownership || railroad.OWNERSHIP || railroad.Ownership || railroad._ownership || '';
                  const operator = railroad.operator || railroad.OPERATOR || railroad.Operator || railroad._operator || '';
                  const lengthMiles = railroad.length_miles || railroad.LENGTH_MILES || railroad.LengthMiles || railroad._length_miles || railroad.length || railroad.LENGTH || null;

                  // Create polyline with brown color for railroads
                  // Use different color/style for active vs abandoned
                  const isActive = status && status.toLowerCase().includes('active');
                  const color = isActive ? '#92400e' : '#78716c'; // Brown for active, gray-brown for abandoned
                  const weight = isActive ? 4 : 3;
                  const opacity = isActive ? 0.8 : 0.6;

                  const polyline = L.polyline(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    smoothFactor: 1
                  });

                  // Build popup content with all railroad attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🚂 ${railroadName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${ownership ? `<div><strong>Ownership:</strong> ${ownership}</div>` : ''}
                        ${operator ? `<div><strong>Operator:</strong> ${operator}</div>` : ''}
                        ${lengthMiles !== null && lengthMiles !== undefined ? `<div><strong>Length:</strong> ${lengthMiles} miles</div>` : ''}
                        ${railroad.distance_miles !== null && railroad.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${railroad.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all railroad attributes (excluding internal fields)
                  const excludeFields = ['name', 'status', 'ownership', 'operator', 'length_miles', 'length', 'geometry', 'distance_miles'];
                  Object.entries(railroad).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing NH Railroad polyline:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (railroadCount > 0) {
          if (!legendAccumulator['nh_railroads']) {
            const radius = getRadiusForLegendKey('nh_railroads');
            const radiusDisplay = formatRadiusDisplay('nh_railroads', radius);
            legendAccumulator['nh_railroads'] = {
              icon: '🚂',
              color: '#92400e',
              title: 'NH Railroads',
              count: 0,
              radius: radius,
              radiusDisplay: radiusDisplay,
            };
          }
          legendAccumulator['nh_railroads'].count += railroadCount;
        }
      }

      // Draw NH Transmission/Pipelines as polylines on the map
      if (enrichments.nh_transmission_pipelines_all && Array.isArray(enrichments.nh_transmission_pipelines_all)) {
        let tpCount = 0;
        enrichments.nh_transmission_pipelines_all.forEach((tp: any) => {
          if (tp.geometry && tp.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              // ESRI polylines have paths (array of coordinate arrays)
              const paths = tp.geometry.paths;
              if (paths && paths.length > 0) {
                tpCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const tpType = tp.type || tp.TYPE || tp.Type || tp._type || tp.pipeline_type || tp.PIPELINE_TYPE || 'Unknown Type';
                  const pia = tp.pia || tp.PIA || tp._pia || null;
                  const granitid = tp.granitid || tp.GRANITID || tp.GranitId || tp._granitid || null;

                  // Create polyline with orange color for transmission/pipelines
                  const polyline = L.polyline(latlngs, {
                    color: '#f97316', // Orange color for transmission/pipelines
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1
                  });

                  // Build popup content with all transmission/pipeline attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ⚡ ${tpType || 'Transmission/Pipeline'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${tpType ? `<div><strong>Type:</strong> ${tpType}</div>` : ''}
                        ${pia !== null && pia !== undefined ? `<div><strong>PIA:</strong> ${pia}</div>` : ''}
                        ${granitid ? `<div><strong>GRANIT ID:</strong> ${granitid}</div>` : ''}
                        ${tp.distance_miles !== null && tp.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${tp.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all transmission/pipeline attributes (excluding internal fields)
                  const excludeFields = ['type', 'pia', 'granitid', 'geometry', 'distance_miles'];
                  Object.entries(tp).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing NH Transmission/Pipeline polyline:', error);
            }
          } else {
          }
        });
        
        
        // Add to legend accumulator
        if (tpCount > 0) {
          if (!legendAccumulator['nh_transmission_pipelines']) {
            legendAccumulator['nh_transmission_pipelines'] = {
              icon: '⚡',
              color: '#f97316',
              title: 'NH Transmission/Pipelines',
              count: 0,
            };
          }
          legendAccumulator['nh_transmission_pipelines'].count += tpCount;
        }
      } else {
      }

      // Draw NH Cell Towers as markers on the map
      if (enrichments.nh_cell_towers_all && Array.isArray(enrichments.nh_cell_towers_all)) {
        let cellTowerCount = 0;
        enrichments.nh_cell_towers_all.forEach((tower: any) => {
          if (tower.lat && tower.lon) {
            try {
              cellTowerCount++;
              const towerLat = tower.lat;
              const towerLon = tower.lon;
              const entityName = tower.entity_name || tower.ENTITY_NAM || tower.EntityName || tower._entity_nam || tower.owner || tower.OWNER || 'Unknown Cell Tower';
              const structureType = tower.structure_type || tower.STRUCTURE_TYPE || tower.StrTyp || tower.str_typ || tower.STR_TYP || tower._str_typ || 'Unknown Type';
              const city = tower.city || tower.CITY || tower.City || tower._city || tower.gismunic || tower.GISMUNIC || '';
              const address = tower.address || tower.ADDRESS || tower.Address || tower.street || tower.STREET || tower.str_street || tower.STR_STREET || '';
              
              // Create a custom icon for cell towers
              const icon = createPOIIcon('📡', '#8b5cf6'); // Purple icon for cell towers
              
              const marker = L.marker([towerLat, towerLon], { icon });
              
              // Build popup content with all cell tower attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    📡 ${entityName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${structureType ? `<div><strong>Structure Type:</strong> ${structureType}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${tower.height_above_ground_ft !== null && tower.height_above_ground_ft !== undefined ? `<div><strong>Height Above Ground:</strong> ${tower.height_above_ground_ft} ft</div>` : ''}
                    ${tower.elevation_ft !== null && tower.elevation_ft !== undefined ? `<div><strong>Elevation:</strong> ${tower.elevation_ft} ft</div>` : ''}
                    ${tower.distance_miles !== null && tower.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${tower.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all cell tower attributes (excluding internal fields)
              const excludeFields = ['entity_name', 'structure_type', 'city', 'state', 'address', 'height_above_ground_ft', 'elevation_ft', 'lat', 'lon', 'distance_miles'];
              Object.entries(tower).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this cell tower
              bounds.extend([towerLat, towerLon]);
            } catch (error) {
              console.error('Error drawing NH Cell Tower marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (cellTowerCount > 0) {
          if (!legendAccumulator['nh_cell_towers']) {
            legendAccumulator['nh_cell_towers'] = {
              icon: '📡',
              color: '#8b5cf6',
              title: 'NH Personal Wireless Service Facilities',
              count: 0,
            };
          }
          legendAccumulator['nh_cell_towers'].count += cellTowerCount;
        }
      }

      // Draw NH Underground Storage Tank Sites as markers on the map
      if (enrichments.nh_underground_storage_tanks_all && Array.isArray(enrichments.nh_underground_storage_tanks_all)) {
        let ustCount = 0;
        enrichments.nh_underground_storage_tanks_all.forEach((site: any) => {
          if (site.lat && site.lon) {
            try {
              ustCount++;
              const siteLat = site.lat;
              const siteLon = site.lon;
              const facilityName = site.facility_name || site.FACILITY_NAME || site.FacilityName || site._facility_name || site.name || site.NAME || site.Name || 'Unknown Facility';
              const facilityAddress = site.facility_address || site.FACILITY_ADDRESS || site.FacilityAddress || site._facility_address || site.address || site.ADDRESS || site.Address || site.street || site.STREET || '';
              const city = site.city || site.CITY || site.City || site._city || site.gismunic || site.GISMUNIC || '';
              const tankCount = site.tank_count || site.TANK_COUNT || site.TankCount || site._tank_count || site.num_tanks || site.NUM_TANKS || site.count || site.COUNT || null;
              
              // Create a custom icon for UST sites
              const icon = createPOIIcon('🛢️', '#dc2626'); // Red icon for UST sites
              
              const marker = L.marker([siteLat, siteLon], { icon });
              
              // Build popup content with all UST site attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🛢️ ${facilityName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${facilityAddress ? `<div><strong>Address:</strong> ${facilityAddress}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${tankCount !== null && tankCount !== undefined ? `<div><strong>Tank Count:</strong> ${tankCount}</div>` : ''}
                    ${site.distance_miles !== null && site.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${site.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all UST site attributes (excluding internal fields)
              const excludeFields = ['facility_name', 'facility_address', 'city', 'state', 'tank_count', 'lat', 'lon', 'distance_miles'];
              Object.entries(site).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this UST site
              bounds.extend([siteLat, siteLon]);
            } catch (error) {
              console.error('Error drawing NH Underground Storage Tank Site marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (ustCount > 0) {
          if (!legendAccumulator['nh_underground_storage_tanks']) {
            legendAccumulator['nh_underground_storage_tanks'] = {
              icon: '🛢️',
              color: '#dc2626',
              title: 'NH Underground Storage Tank Sites',
              count: 0,
            };
          }
          legendAccumulator['nh_underground_storage_tanks'].count += ustCount;
        }
      }

      // Draw NH Water Well Inventory as markers on the map
      if (enrichments.nh_water_wells_all && Array.isArray(enrichments.nh_water_wells_all)) {
        let wellCount = 0;
        enrichments.nh_water_wells_all.forEach((well: any) => {
          if (well.lat && well.lon) {
            try {
              wellCount++;
              const wellLat = well.lat;
              const wellLon = well.lon;
              const wellId = well.well_id || well.WELL_ID || well.WellId || well._well_id || well.id || well.ID || well.Id || well.objectid || well.OBJECTID || 'Unknown Well';
              const ownerName = well.owner_name || well.OWNER_NAME || well.OwnerName || well._owner_name || well.owner || well.OWNER || well.Owner || '';
              const address = well.address || well.ADDRESS || well.Address || well._address || well.street || well.STREET || well.street_address || well.STREET_ADDRESS || '';
              const city = well.city || well.CITY || well.City || well._city || well.gismunic || well.GISMUNIC || well.municipality || well.MUNICIPALITY || '';
              const wellDepthFt = well.well_depth_ft || well.WELL_DEPTH_FT || well.WellDepthFt || well._well_depth_ft || well.depth || well.DEPTH || well.well_depth || well.WELL_DEPTH || null;
              const waterDepthFt = well.water_depth_ft || well.WATER_DEPTH_FT || well.WaterDepthFt || well._water_depth_ft || well.water_depth || well.WATER_DEPTH || well.static_water_level || well.STATIC_WATER_LEVEL || null;
              
              // Create a custom icon for water wells
              const icon = createPOIIcon('💧', '#0284c7'); // Blue icon for water wells
              
              const marker = L.marker([wellLat, wellLon], { icon });
              
              // Build popup content with all water well attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    💧 Well ID: ${wellId ? String(wellId) : 'Unknown'}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${wellDepthFt !== null && wellDepthFt !== undefined ? `<div><strong>Well Depth:</strong> ${wellDepthFt} ft</div>` : ''}
                    ${waterDepthFt !== null && waterDepthFt !== undefined ? `<div><strong>Water Depth:</strong> ${waterDepthFt} ft</div>` : ''}
                    ${well.distance_miles !== null && well.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${well.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all water well attributes (excluding internal fields)
              const excludeFields = ['well_id', 'owner_name', 'address', 'city', 'state', 'well_depth_ft', 'water_depth_ft', 'lat', 'lon', 'distance_miles'];
              Object.entries(well).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this water well
              bounds.extend([wellLat, wellLon]);
            } catch (error) {
              console.error('Error drawing NH Water Well marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (wellCount > 0) {
          if (!legendAccumulator['nh_water_wells']) {
            legendAccumulator['nh_water_wells'] = {
              icon: '💧',
              color: '#0284c7',
              title: 'NH Water Well Inventory',
              count: 0,
            };
          }
          legendAccumulator['nh_water_wells'].count += wellCount;
        }
      }

      // Draw NH Public Water Supply Wells as markers on the map
      if (enrichments.nh_public_water_supply_wells_all && Array.isArray(enrichments.nh_public_water_supply_wells_all)) {
        let publicWellCount = 0;
        enrichments.nh_public_water_supply_wells_all.forEach((well: any) => {
          if (well.lat && well.lon) {
            try {
              publicWellCount++;
              const wellLat = well.lat;
              const wellLon = well.lon;
              const wellId = well.well_id || well.WELL_ID || well.WellId || well._well_id || well.id || well.ID || well.Id || well.objectid || well.OBJECTID || 'Unknown Well';
              const facilityName = well.facility_name || well.FACILITY_NAME || well.FacilityName || well._facility_name || well.name || well.NAME || well.Name || '';
              const ownerName = well.owner_name || well.OWNER_NAME || well.OwnerName || well._owner_name || well.owner || well.OWNER || well.Owner || '';
              const address = well.address || well.ADDRESS || well.Address || well._address || well.street || well.STREET || well.street_address || well.STREET_ADDRESS || '';
              const city = well.city || well.CITY || well.City || well._city || well.gismunic || well.GISMUNIC || well.municipality || well.MUNICIPALITY || '';
              const wellDepthFt = well.well_depth_ft || well.WELL_DEPTH_FT || well.WellDepthFt || well._well_depth_ft || well.depth || well.DEPTH || well.well_depth || well.WELL_DEPTH || null;
              const waterDepthFt = well.water_depth_ft || well.WATER_DEPTH_FT || well.WaterDepthFt || well._water_depth_ft || well.water_depth || well.WATER_DEPTH || well.static_water_level || well.STATIC_WATER_LEVEL || null;
              
              // Create a custom icon for public water supply wells
              const icon = createPOIIcon('🚰', '#0ea5e9'); // Sky blue icon for public water supply wells
              
              const marker = L.marker([wellLat, wellLon], { icon });
              
              // Build popup content with all public water supply well attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚰 ${facilityName || (wellId ? `Well ID: ${String(wellId)}` : 'Public Water Supply Well')}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${wellId ? `<div><strong>Well ID:</strong> ${String(wellId)}</div>` : ''}
                    ${wellDepthFt !== null && wellDepthFt !== undefined ? `<div><strong>Well Depth:</strong> ${wellDepthFt} ft</div>` : ''}
                    ${waterDepthFt !== null && waterDepthFt !== undefined ? `<div><strong>Water Depth:</strong> ${waterDepthFt} ft</div>` : ''}
                    ${well.distance_miles !== null && well.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${well.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all public water supply well attributes (excluding internal fields)
              const excludeFields = ['well_id', 'facility_name', 'owner_name', 'address', 'city', 'state', 'well_depth_ft', 'water_depth_ft', 'lat', 'lon', 'distance_miles'];
              Object.entries(well).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this public water supply well
              bounds.extend([wellLat, wellLon]);
            } catch (error) {
              console.error('Error drawing NH Public Water Supply Well marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (publicWellCount > 0) {
          if (!legendAccumulator['nh_public_water_supply_wells']) {
            legendAccumulator['nh_public_water_supply_wells'] = {
              icon: '🚰',
              color: '#0ea5e9',
              title: 'NH Public Water Supply Wells',
              count: 0,
            };
          }
          legendAccumulator['nh_public_water_supply_wells'].count += publicWellCount;
        }
      }

      // Draw NH Remediation Sites as markers on the map
      if (enrichments.nh_remediation_sites_all && Array.isArray(enrichments.nh_remediation_sites_all)) {
        let remediationCount = 0;
        enrichments.nh_remediation_sites_all.forEach((site: any) => {
          if (site.lat && site.lon) {
            try {
              remediationCount++;
              const siteLat = site.lat;
              const siteLon = site.lon;
              const siteId = site.site_id || site.SITE_ID || site.SiteId || site._site_id || site.id || site.ID || site.Id || site.objectid || site.OBJECTID || 'Unknown Site';
              const siteName = site.site_name || site.SITE_NAME || site.SiteName || site._site_name || site.name || site.NAME || site.Name || '';
              const facilityName = site.facility_name || site.FACILITY_NAME || site.FacilityName || site._facility_name || site.facility || site.FACILITY || '';
              const address = site.address || site.ADDRESS || site.Address || site._address || site.street || site.STREET || site.street_address || site.STREET_ADDRESS || '';
              const city = site.city || site.CITY || site.City || site._city || site.gismunic || site.GISMUNIC || site.municipality || site.MUNICIPALITY || '';
              const siteStatus = site.site_status || site.SITE_STATUS || site.SiteStatus || site._site_status || site.status || site.STATUS || site.Status || '';
              
              // Create a custom icon for remediation sites
              const icon = createPOIIcon('🔧', '#f59e0b'); // Amber/orange icon for remediation sites
              
              const marker = L.marker([siteLat, siteLon], { icon });
              
              // Build popup content with all remediation site attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🔧 ${siteName || facilityName || (siteId ? `Site ID: ${String(siteId)}` : 'Remediation Site')}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${siteId ? `<div><strong>Site ID:</strong> ${String(siteId)}</div>` : ''}
                    ${facilityName ? `<div><strong>Facility:</strong> ${facilityName}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${siteStatus ? `<div><strong>Status:</strong> ${siteStatus}</div>` : ''}
                    ${site.distance_miles !== null && site.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${site.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all remediation site attributes (excluding internal fields)
              const excludeFields = ['site_id', 'site_name', 'facility_name', 'address', 'city', 'state', 'site_status', 'lat', 'lon', 'distance_miles'];
              Object.entries(site).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this remediation site
              bounds.extend([siteLat, siteLon]);
            } catch (error) {
              console.error('Error drawing NH Remediation Site marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (remediationCount > 0) {
          if (!legendAccumulator['nh_remediation_sites']) {
            legendAccumulator['nh_remediation_sites'] = {
              icon: '🔧',
              color: '#f59e0b',
              title: 'NH Remediation Sites',
              count: 0,
            };
          }
          legendAccumulator['nh_remediation_sites'].count += remediationCount;
        }
      }

      // Draw NH Automobile Salvage Yards as markers on the map
      if (enrichments.nh_automobile_salvage_yards_all && Array.isArray(enrichments.nh_automobile_salvage_yards_all)) {
        let salvageYardCount = 0;
        enrichments.nh_automobile_salvage_yards_all.forEach((yard: any) => {
          if (yard.lat && yard.lon) {
            try {
              salvageYardCount++;
              const yardLat = yard.lat;
              const yardLon = yard.lon;
              const facilityId = yard.facility_id || yard.FACILITY_ID || yard.FacilityId || yard._facility_id || yard.id || yard.ID || yard.Id || 'Unknown Facility';
              const siteName = yard.site_name || yard.SITE_NAME || yard.SiteName || yard._site_name || yard.name || yard.NAME || yard.Name || '';
              const address = yard.address || yard.ADDRESS || yard.Address || yard._address || yard.street || yard.STREET || '';
              const address2 = yard.address2 || yard.ADD2 || yard.Add2 || yard._add2 || yard.address2 || yard.ADDRESS2 || yard.Address2 || '';
              const town = yard.town || yard.TOWN || yard.Town || yard._town || yard.city || yard.CITY || yard.City || yard.municipality || yard.MUNICIPALITY || '';
              const status = yard.status || yard.STATUS || yard.Status || yard._status || yard.site_status || yard.SITE_STATUS || '';
              const onestopLink = yard.onestop_link || yard.ONESTOP_LINK || yard.OneStopLink || yard._onestop_link || '';
              
              // Create a custom icon for automobile salvage yards
              const icon = createPOIIcon('🚗', '#ef4444'); // Red icon for salvage yards
              
              const marker = L.marker([yardLat, yardLon], { icon });
              
              // Build popup content with all salvage yard attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚗 ${siteName || (facilityId ? `Facility ID: ${String(facilityId)}` : 'Automobile Salvage Yard')}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${facilityId ? `<div><strong>Facility ID:</strong> ${String(facilityId)}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${address2 ? `<div><strong>Address 2:</strong> ${address2}</div>` : ''}
                    ${town ? `<div><strong>Town:</strong> ${town}</div>` : ''}
                    ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                    ${onestopLink ? `<div><strong>OneStop Link:</strong> <a href="${onestopLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline;">View Details</a></div>` : ''}
                    ${yard.distance_miles !== null && yard.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${yard.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all salvage yard attributes (excluding internal fields)
              const excludeFields = ['facility_id', 'site_name', 'address', 'address2', 'town', 'state', 'status', 'onestop_link', 'lat', 'lon', 'distance_miles'];
              Object.entries(yard).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this salvage yard
              bounds.extend([yardLat, yardLon]);
            } catch (error) {
              console.error('Error drawing NH Automobile Salvage Yard marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (salvageYardCount > 0) {
          if (!legendAccumulator['nh_automobile_salvage_yards']) {
            legendAccumulator['nh_automobile_salvage_yards'] = {
              icon: '🚗',
              color: '#ef4444',
              title: 'NH Automobile Salvage Yards',
              count: 0,
            };
          }
          legendAccumulator['nh_automobile_salvage_yards'].count += salvageYardCount;
        }
      }

      // Draw NH Solid Waste Facilities as markers on the map
      if (enrichments.nh_solid_waste_facilities_all && Array.isArray(enrichments.nh_solid_waste_facilities_all)) {
        let facilityCount = 0;
        enrichments.nh_solid_waste_facilities_all.forEach((facility: any) => {
          if (facility.lat && facility.lon) {
            try {
              facilityCount++;
              const facilityLat = facility.lat;
              const facilityLon = facility.lon;
              const swfLid = facility.swf_lid || facility.SWF_LID || facility.SwfLid || facility._swf_lid || facility.facility_id || facility.FACILITY_ID || facility.id || facility.ID || facility.Id || 'Unknown Facility';
              const swfName = facility.swf_name || facility.SWF_NAME || facility.SwfName || facility._swf_name || facility.name || facility.NAME || facility.Name || '';
              const swfType = facility.swf_type || facility.SWF_TYPE || facility.SwfType || facility._swf_type || facility.type || facility.TYPE || facility.Type || '';
              const swfStatus = facility.swf_status || facility.SWF_STATUS || facility.SwfStatus || facility._swf_status || facility.status || facility.STATUS || facility.Status || '';
              const swfPermit = facility.swf_permit || facility.SWF_PERMIT || facility.SwfPermit || facility._swf_permit || facility.permit || facility.PERMIT || '';
              const address = facility.address || facility.ADDRESS || facility.Address || facility._address || facility.swf_add_1 || facility.SWF_ADD_1 || facility.street || facility.STREET || '';
              const address2 = facility.address2 || facility.ADDRESS2 || facility.Address2 || facility._address2 || facility.swf_add_2 || facility.SWF_ADD_2 || facility.add2 || facility.ADD2 || '';
              const city = facility.city || facility.CITY || facility.City || facility._city || facility.swf_city || facility.SWF_CITY || facility.town || facility.TOWN || facility.municipality || facility.MUNICIPALITY || '';
              const onestopLink = facility.onestop_link || facility.ONESTOP_LINK || facility.OneStopLink || facility._onestop_link || '';
              
              // Create a custom icon for solid waste facilities
              const icon = createPOIIcon('🗑️', '#16a34a'); // Green icon for solid waste facilities
              
              const marker = L.marker([facilityLat, facilityLon], { icon });
              
              // Build popup content with all solid waste facility attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🗑️ ${swfName || (swfLid ? `Facility ID: ${String(swfLid)}` : 'Solid Waste Facility')}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${swfLid ? `<div><strong>Facility ID:</strong> ${String(swfLid)}</div>` : ''}
                    ${swfType ? `<div><strong>Type:</strong> ${swfType}</div>` : ''}
                    ${swfStatus ? `<div><strong>Status:</strong> ${swfStatus}</div>` : ''}
                    ${swfPermit ? `<div><strong>Permit:</strong> ${swfPermit}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${address2 ? `<div><strong>Address 2:</strong> ${address2}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${onestopLink ? `<div><strong>OneStop Link:</strong> <a href="${onestopLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline;">View Details</a></div>` : ''}
                    ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all solid waste facility attributes (excluding internal fields)
              const excludeFields = ['swf_lid', 'swf_name', 'swf_type', 'swf_status', 'swf_permit', 'address', 'address2', 'city', 'state', 'onestop_link', 'lat', 'lon', 'distance_miles'];
              Object.entries(facility).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this solid waste facility
              bounds.extend([facilityLat, facilityLon]);
            } catch (error) {
              console.error('Error drawing NH Solid Waste Facility marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (facilityCount > 0) {
          if (!legendAccumulator['nh_solid_waste_facilities']) {
            legendAccumulator['nh_solid_waste_facilities'] = {
              icon: '🗑️',
              color: '#16a34a',
              title: 'NH Solid Waste Facilities',
              count: 0,
            };
          }
          legendAccumulator['nh_solid_waste_facilities'].count += facilityCount;
        }
      }

      // Draw NH Source Water Protection Area polygon on the map
      if (enrichments.nh_source_water_protection_area_geometry) {
        try {
          const geometry = enrichments.nh_source_water_protection_area_geometry;
          if (geometry && geometry.rings) {
            // Convert ESRI polygon rings to Leaflet LatLng array
            // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
            const rings = geometry.rings;
            if (rings && rings.length > 0) {
              const outerRing = rings[0]; // First ring is the outer boundary
              const latlngs = outerRing.map((coord: number[]) => {
                // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                // Since we requested outSR=4326, coordinates should already be in WGS84
                // Convert [lon, lat] to [lat, lon] for Leaflet
                return [coord[1], coord[0]] as [number, number];
              });

              const name = enrichments.nh_source_water_protection_area_name || 'Source Water Protection Area';
              const systemId = enrichments.nh_source_water_protection_area_system_id;
              const allid = enrichments.nh_source_water_protection_area_allid;
              const address = enrichments.nh_source_water_protection_area_address;
              const town = enrichments.nh_source_water_protection_area_town;
              const systemAct = enrichments.nh_source_water_protection_area_system_act;
              const systemTyp = enrichments.nh_source_water_protection_area_system_typ;
              const systemCat = enrichments.nh_source_water_protection_area_system_cat;
              const population = enrichments.nh_source_water_protection_area_population;
              const dwpaType = enrichments.nh_source_water_protection_area_dwpa_type;
              const dwpaRad = enrichments.nh_source_water_protection_area_dwpa_rad;

              // Create polygon with blue color for water protection areas
              const polygon = L.polygon(latlngs, {
                color: '#0284c7', // Blue color for water protection areas
                weight: 3,
                opacity: 0.7,
                fillColor: '#0284c7',
                fillOpacity: 0.2
              });

              // Build popup content with all protection area attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    💧 ${name}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${systemId ? `<div><strong>System ID:</strong> ${String(systemId)}</div>` : ''}
                    ${allid ? `<div><strong>ALLID:</strong> ${String(allid)}</div>` : ''}
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${town ? `<div><strong>Town:</strong> ${town}</div>` : ''}
                    ${systemAct ? `<div><strong>System Activity:</strong> ${systemAct}</div>` : ''}
                    ${systemTyp ? `<div><strong>System Type:</strong> ${systemTyp}</div>` : ''}
                    ${systemCat ? `<div><strong>System Category:</strong> ${systemCat}</div>` : ''}
                    ${population !== null && population !== undefined ? `<div><strong>Population:</strong> ${population.toLocaleString()}</div>` : ''}
                    ${dwpaType ? `<div><strong>DWPA Type:</strong> ${dwpaType}</div>` : ''}
                    ${dwpaRad !== null && dwpaRad !== undefined ? `<div><strong>DWPA Radius:</strong> ${dwpaRad}</div>` : ''}
                  </div>
                </div>
              `;

              polygon.bindPopup(popupContent, { maxWidth: 400 });
              polygon.addTo(primary); // Add to primary layer group (like parcels)
              bounds.extend(polygon.getBounds());
              
              // Add to legend accumulator
              if (!legendAccumulator['nh_source_water_protection_areas']) {
                legendAccumulator['nh_source_water_protection_areas'] = {
                  icon: '💧',
                  color: '#0284c7',
                  title: 'NH Source Water Protection Area',
                  count: 1,
                };
              }
            }
          }
        } catch (error) {
          console.error('Error drawing NH Source Water Protection Area polygon:', error);
        }
      }

      // Draw NH NWI Plus wetlands as polygons on the map
      // Priority: Draw from nh_nwi_plus_all array if it exists (proximity query with radius)
      // Otherwise, draw from nh_nwi_plus_geometry (point-in-polygon only, no radius)
      if (enrichments.nh_nwi_plus_all && Array.isArray(enrichments.nh_nwi_plus_all)) {
        enrichments.nh_nwi_plus_all.forEach((wetland: any) => {
          if (wetland.geometry && wetland.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = wetland.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = wetland.isContaining;
                const color = isContaining ? '#14b8a6' : '#06b6d4'; // Teal for containing, cyan for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all wetland attributes
                const wetlandId = wetland.wetland_id;
                const wetlandType = wetland.wetland_type;
                const wetlandClass = wetland.wetland_class;
                const distance = wetland.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🌊 Containing Wetland' : '🌊 Nearby Wetland'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; max-height: 400px; overflow-y: auto;">
                `;
                
                // Add wetland ID, type, class, and distance
                if (wetlandId) {
                  popupContent += `<div style="margin-bottom: 4px;"><strong>Wetland ID:</strong> ${String(wetlandId)}</div>`;
                }
                if (wetlandType) {
                  popupContent += `<div style="margin-bottom: 4px;"><strong>Wetland Type:</strong> ${wetlandType}</div>`;
                }
                if (wetlandClass) {
                  popupContent += `<div style="margin-bottom: 4px;"><strong>Wetland Class:</strong> ${wetlandClass}</div>`;
                }
                if (distance !== null && distance !== undefined) {
                  popupContent += `<div style="margin-bottom: 4px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>`;
                }
                
                // Add all other wetland attributes (excluding internal fields)
                const excludeFields = ['wetland_id', 'wetland_type', 'wetland_class', 'isContaining', 'distance_miles', 'geometry'];
                Object.entries(wetland).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary); // Add to primary layer group
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['nh_nwi_plus']) {
                  legendAccumulator['nh_nwi_plus'] = {
                    icon: '🌊',
                    color: '#14b8a6',
                    title: 'NH NWI Plus Wetlands',
                    count: 0,
                  };
                }
                legendAccumulator['nh_nwi_plus'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing NH NWI Plus wetland polygon:', error);
            }
          }
        });
      } else if (enrichments.nh_nwi_plus_geometry && !enrichments.nh_nwi_plus_all) {
        // Fallback: Draw single wetland from point-in-polygon query (no radius, no _all array)
        // Only draw if nh_nwi_plus_all doesn't exist to avoid duplicates
      }

      // Draw NH SSURGO soils as polygons on the map (only the polygon containing the point)
      if (enrichments.nh_ssurgo_all && Array.isArray(enrichments.nh_ssurgo_all)) {
        enrichments.nh_ssurgo_all.forEach((soil: any) => {
          if (soil.geometry && soil.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = soil.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                // Brown color for soils
                const color = '#92400e';
                const weight = 3;
                const opacity = 0.8;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with soil attributes
                const areasymbol = soil.areasymbol || 'N/A';
                const muname = soil.muname || 'N/A';
                const mukey = soil.mukey;
                const musym = soil.musym;
                const hydgrpdcd = soil.hydgrpdcd;
                const drclassdcd = soil.drclassdcd;
                const slopegradd = soil.slopegradd;
                const farmlndcl = soil.farmlndcl;
                const acres = soil.acres;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌱 ${areasymbol} - ${muname}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${mukey ? `<div><strong>Map Unit Key:</strong> ${mukey}</div>` : ''}
                      ${musym ? `<div><strong>Map Unit Symbol:</strong> ${musym}</div>` : ''}
                      ${hydgrpdcd ? `<div><strong>Hydrologic Group:</strong> ${hydgrpdcd}</div>` : ''}
                      ${drclassdcd ? `<div><strong>Drainage Class:</strong> ${drclassdcd}</div>` : ''}
                      ${slopegradd !== null && slopegradd !== undefined ? `<div><strong>Slope Grade:</strong> ${slopegradd}%</div>` : ''}
                      ${farmlndcl ? `<div><strong>Farmland Classification:</strong> ${farmlndcl}</div>` : ''}
                      ${acres ? `<div><strong>Area:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other soil attributes (excluding internal fields)
                const excludeFields = ['areasymbol', 'muname', 'mukey', 'musym', 'hydgrpdcd', 'drclassdcd', 'slopegradd', 'farmlndcl', 'acres', 'geometry', 'distance_miles', 'objectId'];
                Object.entries(soil).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary); // Add to primary layer group
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['nh_ssurgo']) {
                  legendAccumulator['nh_ssurgo'] = {
                    icon: '🌱',
                    color: '#92400e',
                    title: 'NH SSURGO Soils',
                    count: 0,
                  };
                }
                legendAccumulator['nh_ssurgo'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing NH SSURGO soil polygon:', error);
            }
          }
        });
      }

      // Draw NH Bedrock Geology formations as polygons on the map (only the polygon containing the point)
      if (enrichments.nh_bedrock_geology_all && Array.isArray(enrichments.nh_bedrock_geology_all)) {
        enrichments.nh_bedrock_geology_all.forEach((formation: any) => {
          if (formation.geometry && formation.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = formation.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                // Gray color for bedrock geology
                const color = '#6b7280';
                const weight = 3;
                const opacity = 0.8;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with formation attributes
                const code = formation.code || 'N/A';
                const fullname = formation.fullname || '';
                const major = formation.major || '';
                const formation1 = formation.formation1 || '';
                const formation2 = formation.formation2 || '';
                const plutonAge = formation.pluton_age || '';
                const rockType = formation.rock_type || '';
                const geologicHistory = formation.geologichistory || '';
                const lithology = formation.lithology || '';
                const source = formation.source || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🪨 ${code}${fullname ? ` - ${fullname}` : ''}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${major ? `<div><strong>Major:</strong> ${major}</div>` : ''}
                      ${formation1 ? `<div><strong>Formation 1:</strong> ${formation1}</div>` : ''}
                      ${formation2 ? `<div><strong>Formation 2:</strong> ${formation2}</div>` : ''}
                      ${plutonAge ? `<div><strong>Pluton Age:</strong> ${plutonAge}</div>` : ''}
                      ${rockType ? `<div><strong>Rock Type:</strong> ${rockType}</div>` : ''}
                      ${geologicHistory ? `<div><strong>Geologic History:</strong> ${geologicHistory}</div>` : ''}
                      ${lithology ? `<div><strong>Lithology:</strong> ${lithology}</div>` : ''}
                      ${source ? `<div><strong>Source:</strong> ${source}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other formation attributes (excluding internal fields)
                const excludeFields = ['code', 'major', 'formation1', 'formation2', 'pluton_age', 'rock_type', 'fullname', 'geologichistory', 'lithology', 'source', 'geometry', 'distance_miles', 'objectId'];
                Object.entries(formation).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary); // Add to primary layer group
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['nh_bedrock_geology']) {
                  legendAccumulator['nh_bedrock_geology'] = {
                    icon: '🪨',
                    color: '#6b7280',
                    title: 'NH Bedrock Geology',
                    count: 0,
                  };
                }
                legendAccumulator['nh_bedrock_geology'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing NH Bedrock Geology polygon:', error);
            }
          }
        });
      }

      // Draw DE State Forest polygons on the map
      if (enrichments.de_state_forest_all && Array.isArray(enrichments.de_state_forest_all)) {
        enrichments.de_state_forest_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = feature.isContaining;
                const color = isContaining ? '#16a34a' : '#22c55e';
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                const county = feature.COUNTY || feature.county || '';
                const acres = feature.ACRES || feature.acres;
                const tract = feature.TRACT || feature.tract || '';
                const forest = feature.FOREST || feature.forest || '';
                const label = feature.LABEL || feature.label || '';
                const distance = feature.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌲 ${isContaining ? 'State Forest' : 'Nearby State Forest'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280;">
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${acres !== null && acres !== undefined ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                      ${tract ? `<div><strong>Tract:</strong> ${tract}</div>` : ''}
                      ${forest ? `<div><strong>Forest:</strong> ${forest}</div>` : ''}
                      ${label ? `<div><strong>Label:</strong> ${label}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());

                if (!legendAccumulator['de_state_forest']) {
                  legendAccumulator['de_state_forest'] = {
                    icon: '🌲',
                    color: '#16a34a',
                    title: 'DE State Forest',
                    count: 0,
                  };
                }
                legendAccumulator['de_state_forest'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE State Forest polygon:', error);
            }
          }
        });
      }

      // Draw DE Pine Plantations polygons on the map
      if (enrichments.de_pine_plantations_all && Array.isArray(enrichments.de_pine_plantations_all)) {
        enrichments.de_pine_plantations_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = feature.isContaining;
                const color = isContaining ? '#15803d' : '#16a34a';
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌲 ${isContaining ? 'Pine Plantation' : 'Nearby Pine Plantation'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280;">
                      ${acres !== null && acres !== undefined ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());

                if (!legendAccumulator['de_pine_plantations']) {
                  legendAccumulator['de_pine_plantations'] = {
                    icon: '🌲',
                    color: '#15803d',
                    title: 'DE Pine Plantations',
                    count: 0,
                  };
                }
                legendAccumulator['de_pine_plantations'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Pine Plantations polygon:', error);
            }
          }
        });
      }

      // Draw DE Urban Tree Canopy polygons on the map
      if (enrichments.de_urban_tree_canopy_all && Array.isArray(enrichments.de_urban_tree_canopy_all)) {
        enrichments.de_urban_tree_canopy_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = feature.isContaining;
                const color = isContaining ? '#22c55e' : '#4ade80';
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                const name = feature.NAME || feature.name || '';
                const totalAcres = feature.TOTALACRES || feature.totalAcres || feature.TotalAcres;
                const canopyAcres = feature.CANOPYACRES || feature.canopyAcres || feature.CanopyAcres;
                const canopyPercent = feature.CANOPYPERCENT || feature.canopyPercent || feature.CanopyPercent;
                const areaType = feature.AREATYPE || feature.areaType || feature.AreaType;
                const distance = feature.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌳 ${isContaining ? 'Urban Tree Canopy' : 'Nearby Urban Tree Canopy'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280;">
                      ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                      ${totalAcres !== null && totalAcres !== undefined ? `<div><strong>Total Acres:</strong> ${totalAcres.toLocaleString()}</div>` : ''}
                      ${canopyAcres !== null && canopyAcres !== undefined ? `<div><strong>Canopy Acres:</strong> ${canopyAcres.toLocaleString()}</div>` : ''}
                      ${canopyPercent !== null && canopyPercent !== undefined ? `<div><strong>Canopy Percent:</strong> ${canopyPercent.toFixed(1)}%</div>` : ''}
                      ${areaType !== null && areaType !== undefined ? `<div><strong>Area Type:</strong> ${areaType === 0 ? 'Municipality' : areaType === 1 ? 'Community' : areaType === 2 ? 'Park' : areaType}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());

                if (!legendAccumulator['de_urban_tree_canopy']) {
                  legendAccumulator['de_urban_tree_canopy'] = {
                    icon: '🌳',
                    color: '#22c55e',
                    title: 'DE Urban Tree Canopy',
                    count: 0,
                  };
                }
                legendAccumulator['de_urban_tree_canopy'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Urban Tree Canopy polygon:', error);
            }
          }
        });
      }

      // Draw DE Forest Cover 2007 polygons on the map
      if (enrichments.de_forest_cover_2007_all && Array.isArray(enrichments.de_forest_cover_2007_all)) {
        enrichments.de_forest_cover_2007_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = feature.isContaining;
                const color = isContaining ? '#166534' : '#15803d';
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                const type = feature.TYPE || feature.type || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌲 ${isContaining ? 'Forest Cover 2007' : 'Nearby Forest Cover 2007'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${acres !== null && acres !== undefined ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());

                if (!legendAccumulator['de_forest_cover_2007']) {
                  legendAccumulator['de_forest_cover_2007'] = {
                    icon: '🌲',
                    color: '#166534',
                    title: 'DE Forest Cover 2007',
                    count: 0,
                  };
                }
                legendAccumulator['de_forest_cover_2007'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Forest Cover 2007 polygon:', error);
            }
          }
        });
      }

      // Draw DE No Build Points - Bay as markers
      if (enrichments.de_no_build_points_bay_all && Array.isArray(enrichments.de_no_build_points_bay_all)) {
        enrichments.de_no_build_points_bay_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE;
              const lon = feature.geometry.x || feature.LONGITUDE;
              if (lat && lon) {
                const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'custom-marker', html: '🚫', iconSize: [20, 20] }) });
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>No Build Point - Bay</strong>${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                popupContent = addMappingLinksToPopup(popupContent, lat, lon, 'No Build Point - Bay');
                marker.bindPopup(popupContent);
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_no_build_points_bay']) {
                  legendAccumulator['de_no_build_points_bay'] = { icon: '🚫', color: '#ef4444', title: 'DE No Build Points - Bay', count: 0 };
                }
                legendAccumulator['de_no_build_points_bay'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE No Build Points Bay:', error);
            }
          }
        });
      }

      // Draw DE No Build Line - Bay as polylines
      if (enrichments.de_no_build_line_bay_all && Array.isArray(enrichments.de_no_build_line_bay_all)) {
        enrichments.de_no_build_line_bay_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.paths) {
            try {
              feature.geometry.paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const polyline = L.polyline(latlngs, { color: '#ef4444', weight: 3, opacity: 0.8 });
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>No Build Line - Bay</strong>${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polyline.bindPopup(popupContent);
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
              if (!legendAccumulator['de_no_build_line_bay']) {
                legendAccumulator['de_no_build_line_bay'] = { icon: '🚫', color: '#ef4444', title: 'DE No Build Line - Bay', count: 0 };
              }
              legendAccumulator['de_no_build_line_bay'].count += 1;
            } catch (error) {
              console.error('Error drawing DE No Build Line Bay:', error);
            }
          }
        });
      }

      // Draw DE No Build Points - Ocean as markers
      if (enrichments.de_no_build_points_ocean_all && Array.isArray(enrichments.de_no_build_points_ocean_all)) {
        enrichments.de_no_build_points_ocean_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE;
              const lon = feature.geometry.x || feature.LONGITUDE;
              if (lat && lon) {
                const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'custom-marker', html: '🚫', iconSize: [20, 20] }) });
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>No Build Point - Ocean</strong>${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                popupContent = addMappingLinksToPopup(popupContent, lat, lon, 'No Build Point - Ocean');
                marker.bindPopup(popupContent);
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_no_build_points_ocean']) {
                  legendAccumulator['de_no_build_points_ocean'] = { icon: '🚫', color: '#ef4444', title: 'DE No Build Points - Ocean', count: 0 };
                }
                legendAccumulator['de_no_build_points_ocean'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE No Build Points Ocean:', error);
            }
          }
        });
      }

      // Draw DE No Build Line - Ocean as polylines
      if (enrichments.de_no_build_line_ocean_all && Array.isArray(enrichments.de_no_build_line_ocean_all)) {
        enrichments.de_no_build_line_ocean_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.paths) {
            try {
              feature.geometry.paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const polyline = L.polyline(latlngs, { color: '#ef4444', weight: 3, opacity: 0.8 });
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>No Build Line - Ocean</strong>${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polyline.bindPopup(popupContent);
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
              if (!legendAccumulator['de_no_build_line_ocean']) {
                legendAccumulator['de_no_build_line_ocean'] = { icon: '🚫', color: '#ef4444', title: 'DE No Build Line - Ocean', count: 0 };
              }
              legendAccumulator['de_no_build_line_ocean'].count += 1;
            } catch (error) {
              console.error('Error drawing DE No Build Line Ocean:', error);
            }
          }
        });
      }

      // Draw NOAA Critical Fisheries Habitat as polygons
      if (enrichments.noaa_critical_fisheries_habitat_all && Array.isArray(enrichments.noaa_critical_fisheries_habitat_all)) {
        enrichments.noaa_critical_fisheries_habitat_all.forEach((habitat: any) => {
          if (habitat.geometry && habitat.geometry.rings) {
            try {
              const rings = habitat.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                
                const isContaining = habitat.isContaining;
                const color = isContaining ? '#10b981' : '#06b6d4'; // Green for containing, cyan for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const distance = habitat.distance_miles;
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🐟 Containing Critical Fisheries Habitat' : '🐟 Nearby Critical Fisheries Habitat'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add attributes to popup
                const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'isContaining'];
                Object.entries(habitat).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `</div></div>`;
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                if (!legendAccumulator['noaa_critical_fisheries_habitat']) {
                  legendAccumulator['noaa_critical_fisheries_habitat'] = { icon: '🐟', color: '#10b981', title: 'NOAA Critical Fisheries Habitat', count: 0 };
                }
                legendAccumulator['noaa_critical_fisheries_habitat'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing NOAA Critical Fisheries Habitat:', error);
            }
          }
        });
      }

      // Draw NOAA Weather Radar Impact Zones as polygons
      if (enrichments.noaa_weather_radar_impact_zones_all && Array.isArray(enrichments.noaa_weather_radar_impact_zones_all)) {
        enrichments.noaa_weather_radar_impact_zones_all.forEach((zone: any) => {
          if (zone.geometry && zone.geometry.rings) {
            try {
              const rings = zone.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                
                const isContaining = zone.isContaining;
                const impactZone = zone.impactzone || 'Unknown';
                
                // Color based on impact zone type
                let color = '#6b7280'; // Default gray
                if (impactZone === 'No Build Zone') {
                  color = isContaining ? '#ef4444' : '#f87171'; // Red
                } else if (impactZone === 'Mitigation Zone') {
                  color = isContaining ? '#f97316' : '#fb923c'; // Orange
                } else if (impactZone === 'Consultation Zone') {
                  color = isContaining ? '#eab308' : '#facc15'; // Yellow
                } else if (impactZone === 'Notification Zone') {
                  color = isContaining ? '#22c55e' : '#4ade80'; // Green
                }
                
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const distance = zone.distance_miles;
                const siteName = zone.sitename || 'Unknown Site';
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? `🌩️ Containing ${impactZone}` : `🌩️ Nearby ${impactZone}`}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Site Name:</strong> ${siteName}</div>
                      ${zone.siteidentifier ? `<div><strong>Site Identifier:</strong> ${zone.siteidentifier}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                if (!legendAccumulator['noaa_weather_radar_impact_zones']) {
                  legendAccumulator['noaa_weather_radar_impact_zones'] = { icon: '🌩️', color: color, title: 'NOAA Weather Radar Impact Zones', count: 0 };
                }
                legendAccumulator['noaa_weather_radar_impact_zones'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing NOAA Weather Radar Impact Zones:', error);
            }
          }
        });
      }

      // Draw NOAA West Coast EFH as polygons
      const noaaWestCoastEFHLayers = [
        { key: 'noaa_west_coast_efh_hapc', name: 'HAPC', color: '#10b981' },
        { key: 'noaa_west_coast_efh_efha', name: 'EFHA', color: '#06b6d4' },
        { key: 'noaa_west_coast_efh_salmon', name: 'EFH Salmon', color: '#3b82f6' },
        { key: 'noaa_west_coast_efh_hms_cps_gfish', name: 'EFH HMS/CPS/Groundfish', color: '#8b5cf6' }
      ];

      noaaWestCoastEFHLayers.forEach(layer => {
        if (enrichments[`${layer.key}_all`] && Array.isArray(enrichments[`${layer.key}_all`])) {
          enrichments[`${layer.key}_all`].forEach((habitat: any) => {
            if (habitat.geometry && habitat.geometry.rings) {
              try {
                const rings = habitat.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  
                  const isContaining = habitat.isContaining;
                  const color = isContaining ? layer.color : layer.color;
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const distance = habitat.distance_miles;
                  const displayLayerName = habitat.layerName || layer.name;
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? `🐟 Containing ${displayLayerName}` : `🐟 Nearby ${displayLayerName}`}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add attributes to popup
                  const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'isContaining', 'layerId', 'layerName'];
                  Object.entries(habitat).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `</div></div>`;
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  
                  if (!legendAccumulator[layer.key]) {
                    legendAccumulator[layer.key] = { icon: '🐟', color: layer.color, title: `NOAA West Coast EFH - ${layer.name}`, count: 0 };
                  }
                  legendAccumulator[layer.key].count += 1;
                }
              } catch (error) {
                console.error(`Error drawing NOAA West Coast EFH ${layer.name}:`, error);
              }
            }
          });
        }
      });

      // Draw NOAA ESA Species Ranges as polygons
      // Handle all layers dynamically by checking for the pattern
      Object.keys(enrichments).forEach(key => {
        if (key.startsWith('noaa_esa_species_ranges_') && key.endsWith('_all') && Array.isArray(enrichments[key])) {
          const layerKey = key.replace('_all', '');
          enrichments[key].forEach((habitat: any) => {
            if (habitat.geometry && habitat.geometry.rings) {
              try {
                const rings = habitat.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  
                  const isContaining = habitat.isContaining;
                  // Use a consistent color for all ESA layers (blue-green)
                  const color = isContaining ? '#10b981' : '#06b6d4';
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const distance = habitat.distance_miles;
                  const displayLayerName = habitat.layerName || layerKey.replace('noaa_esa_species_ranges_', '').replace(/_/g, ' ');
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? `🐟 Containing ${displayLayerName}` : `🐟 Nearby ${displayLayerName}`}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add attributes to popup
                  const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'isContaining', 'layerId', 'layerName'];
                  Object.entries(habitat).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `</div></div>`;
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  
                  if (!legendAccumulator[layerKey]) {
                    legendAccumulator[layerKey] = { icon: '🐟', color: color, title: `NOAA ESA - ${displayLayerName}`, count: 0 };
                  }
                  legendAccumulator[layerKey].count += 1;
                }
              } catch (error) {
                console.error(`Error drawing NOAA ESA Species Ranges ${layerKey}:`, error);
              }
            }
          });
        }
      });

      // Draw NOAA Maritime Limits and Boundaries layers (polylines)
      const noaaMaritimeLayers = [
        { key: 'noaa_maritime_overview', name: 'Overview', color: '#3b82f6' },
        { key: 'noaa_maritime_12nm', name: '12NM Territorial Sea', color: '#06b6d4' },
        { key: 'noaa_maritime_24nm', name: '24NM Contiguous Zone', color: '#10b981' },
        { key: 'noaa_maritime_200nm', name: '200NM EEZ and Maritime Boundaries', color: '#8b5cf6' },
        { key: 'noaa_maritime_us_canada_boundary', name: 'US/Canada Land Boundary', color: '#f59e0b' }
      ];

      noaaMaritimeLayers.forEach(layer => {
        if (enrichments[`${layer.key}_all`] && Array.isArray(enrichments[`${layer.key}_all`])) {
          enrichments[`${layer.key}_all`].forEach((boundary: any) => {
            if (boundary.geometry && boundary.geometry.paths) {
              try {
                const paths = boundary.geometry.paths;
                if (paths && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                      
                      const distance = boundary.distance_miles;
                      const displayLayerName = boundary.layerName || layer.name;
                      
                      const polyline = L.polyline(latlngs, {
                        color: layer.color,
                        weight: 3,
                        opacity: 0.8
                      });
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🌊 ${displayLayerName}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;
                      
                      // Add attributes to popup
                      const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                      Object.entries(boundary).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                          popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                        }
                      });
                      
                      popupContent += `</div></div>`;
                      polyline.bindPopup(popupContent, { maxWidth: 400 });
                      polyline.addTo(primary);
                      bounds.extend(polyline.getBounds());
                      
                      if (!legendAccumulator[layer.key]) {
                        legendAccumulator[layer.key] = { icon: '🌊', color: layer.color, title: `NOAA Maritime - ${layer.name}`, count: 0 };
                      }
                      legendAccumulator[layer.key].count += 1;
                    }
                  });
                }
              } catch (error) {
                console.error(`Error drawing NOAA Maritime Limits ${layer.name}:`, error);
              }
            }
          });
        }
      });

      // Draw NOAA NMFS Critical Habitat layers (polygons and polylines)
      Object.keys(enrichments).forEach((key) => {
        if (key.startsWith('noaa_nmfs_critical_habitat_') && key.endsWith('_all') && Array.isArray(enrichments[key])) {
          const layerKey = key.replace('_all', '');
          enrichments[key].forEach((habitat: any) => {
            if (habitat.geometry) {
              try {
                const isContaining = habitat.isContaining;
                const geometryType = habitat.geometryType || (habitat.geometry.rings ? 'polygon' : 'polyline');
                const distance = habitat.distance_miles;
                const displayLayerName = habitat.layerName || layerKey.replace('noaa_nmfs_critical_habitat_', '').replace(/_/g, ' ');
                
                // Handle polygons (including multipart polygons)
                if (geometryType === 'polygon' && habitat.geometry.rings) {
                  const rings = habitat.geometry.rings;
                  if (rings && rings.length > 0) {
                    // Helper function to calculate polygon area (using shoelace formula)
                    const calculateRingArea = (ring: number[][]): number => {
                      if (!ring || ring.length < 3) return 0;
                      let area = 0;
                      for (let i = 0; i < ring.length - 1; i++) {
                        area += ring[i][0] * ring[i + 1][1]; // lon1 * lat2
                        area -= ring[i + 1][0] * ring[i][1]; // lon2 * lat1
                      }
                      return Math.abs(area) / 2;
                    };
                    
                    // Convert all rings to lat/lng arrays and calculate areas
                    const ringData = rings.map((ring: number[][]) => ({
                      latlngs: ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number]),
                      area: calculateRingArea(ring)
                    }));
                    
                    // Sort by area (largest first) to prioritize larger parts
                    ringData.sort((a: { latlngs: [number, number][], area: number }, b: { latlngs: [number, number][], area: number }) => b.area - a.area);
                    
                    // Render all parts as separate polygons (preferred) or use largest if needed
                    // For multipart polygons, we'll render each part separately so all are visible
                    ringData.forEach((ringInfo: { latlngs: [number, number][], area: number }, index: number) => {
                      const color = isContaining ? '#10b981' : '#06b6d4';
                      const weight = isContaining ? 3 : 2;
                      const opacity = isContaining ? 0.8 : 0.5;
                      
                      const polygon = L.polygon(ringInfo.latlngs, {
                        color: color,
                        weight: weight,
                        opacity: opacity,
                        fillColor: color,
                        fillOpacity: 0.2
                      });
                      
                      // Only add popup to the first (largest) part to avoid duplicate popups
                      if (index === 0) {
                        let popupContent = `
                          <div style="min-width: 250px; max-width: 400px;">
                            <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                              ${isContaining ? `🐟 Containing ${displayLayerName}` : `🐟 Nearby ${displayLayerName}`}
                            </h3>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                              ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                              ${rings.length > 1 ? `<div><strong>Parts:</strong> ${rings.length} (multipart polygon)</div>` : ''}
                            </div>
                            <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                        `;
                        
                        // Add attributes to popup
                        const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'isContaining', 'layerId', 'layerName', 'geometryType'];
                        Object.entries(habitat).forEach(([key, value]) => {
                          if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                            const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                          }
                        });
                        
                        popupContent += `</div></div>`;
                        polygon.bindPopup(popupContent, { maxWidth: 400 });
                      }
                      
                      polygon.addTo(primary);
                      bounds.extend(polygon.getBounds());
                    });
                    
                    // Only count once per feature (not per part)
                    if (!legendAccumulator[layerKey]) {
                      legendAccumulator[layerKey] = { icon: '🐟', color: isContaining ? '#10b981' : '#06b6d4', title: `NOAA NMFS - ${displayLayerName}`, count: 0 };
                    }
                    legendAccumulator[layerKey].count += 1;
                  }
                }
                // Handle polylines
                else if (geometryType === 'polyline' && habitat.geometry.paths) {
                  const paths = habitat.geometry.paths;
                  if (paths && paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      if (path && path.length > 0) {
                        const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                        
                        const color = '#06b6d4';
                        const weight = 2;
                        const opacity = 0.7;
                        
                        const polyline = L.polyline(latlngs, {
                          color: color,
                          weight: weight,
                          opacity: opacity
                        });
                        
                        let popupContent = `
                          <div style="min-width: 250px; max-width: 400px;">
                            <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                              🐟 Nearby ${displayLayerName}
                            </h3>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                              ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                            </div>
                            <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                        `;
                        
                        // Add attributes to popup
                        const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'isContaining', 'layerId', 'layerName', 'geometryType'];
                        Object.entries(habitat).forEach(([key, value]) => {
                          if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                            const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                          }
                        });
                        
                        popupContent += `</div></div>`;
                        polyline.bindPopup(popupContent, { maxWidth: 400 });
                        polyline.addTo(primary);
                        bounds.extend(polyline.getBounds());
                        
                        if (!legendAccumulator[layerKey]) {
                          legendAccumulator[layerKey] = { icon: '🐟', color: color, title: `NOAA NMFS - ${displayLayerName}`, count: 0 };
                        }
                        legendAccumulator[layerKey].count += 1;
                      }
                    });
                  }
                }
              } catch (error) {
                console.error(`Error drawing NOAA NMFS Critical Habitat ${layerKey}:`, error);
              }
            }
          });
        }
      });

      // Draw NOAA Water Temperature Contours as polylines
      const noaaWaterTempMonths = [
        { key: 'noaa_water_temp_january', name: 'January', color: '#0ea5e9' },
        { key: 'noaa_water_temp_february', name: 'February', color: '#3b82f6' },
        { key: 'noaa_water_temp_march', name: 'March', color: '#6366f1' },
        { key: 'noaa_water_temp_april', name: 'April', color: '#8b5cf6' },
        { key: 'noaa_water_temp_may', name: 'May', color: '#a855f7' },
        { key: 'noaa_water_temp_june', name: 'June', color: '#d946ef' },
        { key: 'noaa_water_temp_july', name: 'July', color: '#ec4899' },
        { key: 'noaa_water_temp_august', name: 'August', color: '#f43f5e' },
        { key: 'noaa_water_temp_september', name: 'September', color: '#ef4444' },
        { key: 'noaa_water_temp_october', name: 'October', color: '#f97316' },
        { key: 'noaa_water_temp_november', name: 'November', color: '#fb923c' },
        { key: 'noaa_water_temp_december', name: 'December', color: '#fbbf24' }
      ];

      noaaWaterTempMonths.forEach(month => {
        if (enrichments[`${month.key}_all`] && Array.isArray(enrichments[`${month.key}_all`])) {
          enrichments[`${month.key}_all`].forEach((feature: any) => {
            if (feature.geometry && feature.geometry.paths) {
              try {
                feature.geometry.paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  const polyline = L.polyline(latlngs, {
                    color: month.color,
                    weight: 2,
                    opacity: 0.7
                  });
                  const distance = feature.distance_miles;
                  let popupContent = `<div><strong>NOAA Water Temperature - ${month.name}</strong>${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                  
                  // Add attributes to popup
                  const excludeFields = ['geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      popupContent += `<div><strong>${displayKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  polyline.bindPopup(popupContent);
                  polyline.addTo(primary);
                  bounds.extend(polyline.getBounds());
                });
                if (!legendAccumulator[month.key]) {
                  legendAccumulator[month.key] = { icon: '🌊', color: month.color, title: `NOAA Water Temperature - ${month.name}`, count: 0 };
                }
                legendAccumulator[month.key].count += 1;
              } catch (error) {
                console.error(`Error drawing NOAA Water Temperature ${month.name}:`, error);
              }
            }
          });
        }
      });

      // Draw DE Park Facilities as markers
      if (enrichments.de_park_facilities_all && Array.isArray(enrichments.de_park_facilities_all)) {
        enrichments.de_park_facilities_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE;
              const lon = feature.geometry.x || feature.LONGITUDE;
              if (lat && lon) {
                const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'custom-marker', html: '🏞️', iconSize: [20, 20] }) });
                const park = feature.PARK || feature.park || '';
                const facility = feature.FACILITY || feature.facility || '';
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${park || 'Park Facility'}</strong>${facility ? `<br>Facility: ${facility}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                popupContent = addMappingLinksToPopup(popupContent, lat, lon, park || facility || 'Park Facility');
                marker.bindPopup(popupContent);
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_park_facilities']) {
                  legendAccumulator['de_park_facilities'] = { icon: '🏞️', color: '#10b981', title: 'DE Park Facilities', count: 0 };
                }
                legendAccumulator['de_park_facilities'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Park Facilities:', error);
            }
          }
        });
      }

      // Draw DE Child Care Centers as markers
      if (enrichments.de_child_care_centers_all && Array.isArray(enrichments.de_child_care_centers_all)) {
        enrichments.de_child_care_centers_all.forEach((center: any) => {
          if (center.geometry) {
            try {
              const lat = center.geometry.y || center.LATITUDE || center.latitude;
              const lon = center.geometry.x || center.LONGITUDE || center.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🏫', '#f59e0b');
                const marker = L.marker([lat, lon], { icon });
                const name = center.name || center.RSR_RESO_1 || center.rsr_reso_1 || 'Child Care Center';
                const type = center.type || center.RSR_TYPE_T || center.rsr_type_t || '';
                const address = center.address || center.ADR_STREET || center.adr_street || '';
                const city = center.city || center.ADR_CITYNA || center.adr_cityna || '';
                const state = center.state || center.ADR_STAECO || center.adr_staeco || '';
                const zip = center.zip || center.ADR_ZIP || center.ZIPCODE || center.zipcode || '';
                const phone = center.phone || center.ADR_PHONE_ || center.adr_phone_ || '';
                const county = center.county || center.ADR_COUNTY || center.adr_county || '';
                const capacity = center.capacity || center.RSR_CPCT_N || center.rsr_cpct_n || null;
                const starLevel = center.starLevel || center.DSI_STAR_LEVEL || center.dsi_star_level || center.STARLEVEL || center.starlevel || null;
                const ageRange = center.ageRange || center.RSR_AGE_RA || center.rsr_age_ra || center.AGE_GROUP || center.age_group || '';
                const opens = center.opens || center.RSR_OPENS_ || center.rsr_opens_ || '';
                const closes = center.closes || center.RSR_CLOSES || center.rsr_closes || '';
                const distance = center.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏫 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}${city ? `, ${city}` : ''}${state ? ` ${state}` : ''}${zip ? ` ${zip}` : ''}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${capacity !== null ? `<div><strong>Capacity:</strong> ${capacity}</div>` : ''}
                      ${starLevel !== null ? `<div><strong>Star Level:</strong> ${starLevel}</div>` : ''}
                      ${ageRange ? `<div><strong>Age Range:</strong> ${ageRange}</div>` : ''}
                      ${opens && closes ? `<div><strong>Hours:</strong> ${opens} - ${closes}</div>` : ''}
                    </div>
                  </div>
                `;
                popupContent = addMappingLinksToPopup(popupContent, lat, lon, name);
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_child_care_centers']) {
                  legendAccumulator['de_child_care_centers'] = { icon: '🏫', color: '#f59e0b', title: 'DE Child Care Centers', count: 0 };
                }
                legendAccumulator['de_child_care_centers'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Child Care Center:', error);
            }
          }
        });
      }

      // Draw DE Fishing Access as markers
      if (enrichments.de_fishing_access_all && Array.isArray(enrichments.de_fishing_access_all)) {
        enrichments.de_fishing_access_all.forEach((access: any) => {
          if (access.geometry) {
            try {
              const lat = access.geometry.y || access.LATITUDE || access.latitude;
              const lon = access.geometry.x || access.LONGITUDE || access.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🎣', '#0284c7');
                const marker = L.marker([lat, lon], { icon });
                const name = access.name || access.GNIS_NAME || access.gnis_name || 'Fishing Access';
                const facility = access.facility || access.FACILITY || access.facility || '';
                const division = access.division || access.DIVISION || access.division || '';
                const county = access.county || access.COUNTY || access.county || '';
                const tidal = access.tidal || access.TIDAL || access.tidal || '';
                const distance = access.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎣 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${facility ? `<div><strong>Facility Type:</strong> ${facility}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${division ? `<div><strong>Division:</strong> ${division}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${tidal ? `<div><strong>Tidal:</strong> ${tidal}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                const excludeFields = ['accessId', 'name', 'GNIS_NAME', 'gnis_name', 'facility', 'FACILITY', 'division', 'DIVISION', 'county', 'COUNTY', 'tidal', 'TIDAL', 'geometry', 'distance_miles', 'OBJECTID', 'objectid'];
                Object.entries(access).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_fishing_access']) {
                  legendAccumulator['de_fishing_access'] = { icon: '🎣', color: '#0284c7', title: 'DE Fishing Access', count: 0 };
                }
                legendAccumulator['de_fishing_access'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Fishing Access:', error);
            }
          }
        });
      }

      // Draw DE Trout Streams as polylines
      if (enrichments.de_trout_streams_all && Array.isArray(enrichments.de_trout_streams_all)) {
        let streamCount = 0;
        enrichments.de_trout_streams_all.forEach((stream: any) => {
          if (stream.geometry && stream.geometry.paths) {
            try {
              const paths = stream.geometry.paths;
              if (paths && paths.length > 0) {
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 2) {
                    console.warn('DE Trout Stream polyline has less than 2 coordinates, skipping');
                    return;
                  }

                  const waterBodyName = stream.waterBodyName || stream.WATERBODYNAME || stream.waterBodyName || 'Trout Stream';
                  const restriction = stream.restriction || stream.RESTRICTION || stream.restriction || '';
                  const description = stream.description || stream.DESCRIPTION || stream.description || '';
                  const gnisName = stream.gnisName || stream.GNIS_NAME || stream.gnis_name || '';
                  
                  // Use different colors based on restriction type
                  let color = '#0ea5e9'; // Default blue
                  if (restriction.includes('Fly Fishing Only')) {
                    color = '#fbbf24'; // Yellow for fly fishing only
                  }
                  
                  const polyline = L.polyline(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.8
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐟 ${waterBodyName || 'Trout Stream'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${restriction ? `<div><strong>Restriction:</strong> ${restriction}</div>` : ''}
                        ${stream.distance_miles !== null && stream.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${stream.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${description ? `<div><strong>Description:</strong> ${description}</div>` : ''}
                        ${gnisName ? `<div><strong>GNIS Name:</strong> ${gnisName}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['streamId', 'waterBodyName', 'WATERBODYNAME', 'restriction', 'RESTRICTION', 'description', 'DESCRIPTION', 'gnisName', 'GNIS_NAME', 'gnis_id', 'GNIS_ID', 'isContaining', 'geometry', 'distance_miles', 'OBJECTID', 'objectid'];
                  Object.entries(stream).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  
                  try {
                    bounds.extend(polyline.getBounds());
                    streamCount++;
                  } catch (boundsError) {
                    console.warn('Error extending bounds for DE Trout Stream polyline:', boundsError);
                  }
                });
              }
            } catch (error) {
              console.error('Error drawing DE Trout Stream:', error);
            }
          }
        });
        
        if (streamCount > 0) {
          if (!legendAccumulator['de_trout_streams']) {
            legendAccumulator['de_trout_streams'] = {
              icon: '🐟',
              color: '#0ea5e9',
              title: 'DE Trout Streams',
              count: 0,
            };
          }
          legendAccumulator['de_trout_streams'].count += streamCount;
        }
      }

      // Draw DE Public Schools as markers
      if (enrichments.de_public_schools_all && Array.isArray(enrichments.de_public_schools_all)) {
        enrichments.de_public_schools_all.forEach((school: any) => {
          if (school.geometry) {
            try {
              const lat = school.geometry.y || school.LATITUDE || school.latitude;
              const lon = school.geometry.x || school.LONGITUDE || school.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🏫', '#3b82f6');
                const marker = L.marker([lat, lon], { icon });
                const name = school.name || school.NAME || school.SCHOOL_NAME || school.school_name || 'Public School';
                const schoolType = school.schoolType || school.TYPE || school.SCHOOL_TYPE || school.school_type || '';
                const district = school.district || school.DISTRICT || school.DISTRICT_NAME || school.district_name || '';
                const address = school.address || school.ADDRESS || school.STREET || school.street || '';
                const city = school.city || school.CITY || '';
                const state = school.state || school.STATE || 'DE';
                const zip = school.zip || school.ZIP || school.ZIP_CODE || school.zip_code || '';
                const phone = school.phone || school.PHONE || school.TELEPHONE || school.telephone || '';
                const distance = school.distance_miles;
                const fullAddress = [address, city, state, zip].filter(Boolean).join(', ');
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏫 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${schoolType ? `<div><strong>Type:</strong> ${schoolType}</div>` : ''}
                      ${district ? `<div><strong>District:</strong> ${district}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${fullAddress ? `<div><strong>Address:</strong> ${fullAddress}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_public_schools']) {
                  legendAccumulator['de_public_schools'] = { icon: '🏫', color: '#3b82f6', title: 'DE Public Schools', count: 0 };
                }
                legendAccumulator['de_public_schools'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Public School:', error);
            }
          }
        });
      }

      // Draw DE Private Schools as markers
      if (enrichments.de_private_schools_all && Array.isArray(enrichments.de_private_schools_all)) {
        enrichments.de_private_schools_all.forEach((school: any) => {
          if (school.geometry) {
            try {
              const lat = school.geometry.y || school.LATITUDE || school.latitude;
              const lon = school.geometry.x || school.LONGITUDE || school.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🏛️', '#6366f1');
                const marker = L.marker([lat, lon], { icon });
                const name = school.name || school.NAME || school.SCHOOL_NAME || school.school_name || 'Private School';
                const schoolType = school.schoolType || school.TYPE || school.SCHOOL_TYPE || school.school_type || '';
                const district = school.district || school.DISTRICT || school.DISTRICT_NAME || school.district_name || '';
                const address = school.address || school.ADDRESS || school.STREET || school.street || '';
                const city = school.city || school.CITY || '';
                const state = school.state || school.STATE || 'DE';
                const zip = school.zip || school.ZIP || school.ZIP_CODE || school.zip_code || '';
                const phone = school.phone || school.PHONE || school.TELEPHONE || school.telephone || '';
                const distance = school.distance_miles;
                const fullAddress = [address, city, state, zip].filter(Boolean).join(', ');
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏛️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${schoolType ? `<div><strong>Type:</strong> ${schoolType}</div>` : ''}
                      ${district ? `<div><strong>District:</strong> ${district}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${fullAddress ? `<div><strong>Address:</strong> ${fullAddress}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_private_schools']) {
                  legendAccumulator['de_private_schools'] = { icon: '🏛️', color: '#6366f1', title: 'DE Private Schools', count: 0 };
                }
                legendAccumulator['de_private_schools'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Private School:', error);
            }
          }
        });
      }

      // Draw DE VoTech Districts as polygons
      if (enrichments.de_votech_districts_all && Array.isArray(enrichments.de_votech_districts_all)) {
        enrichments.de_votech_districts_all.forEach((district: any) => {
          if (district.geometry && district.geometry.rings) {
            try {
              const rings = district.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                if (latlngs.length < 3) {
                  console.warn('DE VoTech District polygon has less than 3 coordinates, skipping');
                  return;
                }

                const name = district.name || district.NAME || district.DISTRICT_NAME || district.district_name || 'VoTech District';
                const isContaining = district.isContaining || false;
                
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#5b21b6' : '#8b5cf6',
                  weight: 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#7c3aed' : '#a78bfa',
                  fillOpacity: 0.3
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎓 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> VoTech School District</div>
                      ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                } catch (boundsError) {
                  console.warn('Error extending bounds for DE VoTech District:', boundsError);
                }
                
                if (!legendAccumulator['de_votech_districts']) {
                  legendAccumulator['de_votech_districts'] = {
                    icon: '🎓',
                    color: '#8b5cf6',
                    title: 'DE VoTech Districts',
                    count: 0,
                  };
                }
                legendAccumulator['de_votech_districts'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE VoTech District:', error);
            }
          }
        });
      }

      // Draw DE School Districts as polygons
      if (enrichments.de_school_districts_all && Array.isArray(enrichments.de_school_districts_all)) {
        enrichments.de_school_districts_all.forEach((district: any) => {
          if (district.geometry && district.geometry.rings) {
            try {
              const rings = district.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                if (latlngs.length < 3) {
                  console.warn('DE School District polygon has less than 3 coordinates, skipping');
                  return;
                }

                const name = district.name || district.NAME || district.DISTRICT_NAME || district.district_name || 'School District';
                const isContaining = district.isContaining || false;
                
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#5b21b6' : '#7c3aed',
                  weight: 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#6d28d9' : '#8b5cf6',
                  fillOpacity: 0.3
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      📚 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Public School District</div>
                      ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                } catch (boundsError) {
                  console.warn('Error extending bounds for DE School District:', boundsError);
                }
                
                if (!legendAccumulator['de_school_districts']) {
                  legendAccumulator['de_school_districts'] = {
                    icon: '📚',
                    color: '#7c3aed',
                    title: 'DE School Districts',
                    count: 0,
                  };
                }
                legendAccumulator['de_school_districts'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE School District:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Stands Blinds and Fields as markers
      if (enrichments.de_stands_blinds_fields_all && Array.isArray(enrichments.de_stands_blinds_fields_all)) {
        enrichments.de_stands_blinds_fields_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE || feature.latitude;
              const lon = feature.geometry.x || feature.LONGITUDE || feature.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🎯', '#16a34a');
                const marker = L.marker([lat, lon], { icon });
                const name = feature.name || feature.NAME || 'Stands/Blinds/Fields';
                const type = feature.type || feature.TYPE || '';
                const distance = feature.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎯 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_stands_blinds_fields']) {
                  legendAccumulator['de_stands_blinds_fields'] = { icon: '🎯', color: '#16a34a', title: 'DE Wildlife Areas Stands Blinds Fields', count: 0 };
                }
                legendAccumulator['de_stands_blinds_fields'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Stands Blinds Fields:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Boat Ramps as markers
      if (enrichments.de_boat_ramps_all && Array.isArray(enrichments.de_boat_ramps_all)) {
        enrichments.de_boat_ramps_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE || feature.latitude;
              const lon = feature.geometry.x || feature.LONGITUDE || feature.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🚤', '#0284c7');
                const marker = L.marker([lat, lon], { icon });
                const name = feature.name || feature.NAME || 'Boat Ramp';
                const type = feature.type || feature.TYPE || '';
                const distance = feature.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚤 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_boat_ramps']) {
                  legendAccumulator['de_boat_ramps'] = { icon: '🚤', color: '#0284c7', title: 'DE Wildlife Areas Boat Ramps', count: 0 };
                }
                legendAccumulator['de_boat_ramps'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Boat Ramp:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Facilities as markers
      if (enrichments.de_facilities_all && Array.isArray(enrichments.de_facilities_all)) {
        enrichments.de_facilities_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE || feature.latitude;
              const lon = feature.geometry.x || feature.LONGITUDE || feature.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🏢', '#dc2626');
                const marker = L.marker([lat, lon], { icon });
                const name = feature.name || feature.NAME || 'Facility';
                const type = feature.type || feature.TYPE || '';
                const distance = feature.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏢 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_facilities']) {
                  legendAccumulator['de_facilities'] = { icon: '🏢', color: '#dc2626', title: 'DE Wildlife Areas Facilities', count: 0 };
                }
                legendAccumulator['de_facilities'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Facility:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Parking as markers
      if (enrichments.de_parking_all && Array.isArray(enrichments.de_parking_all)) {
        enrichments.de_parking_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE || feature.latitude;
              const lon = feature.geometry.x || feature.LONGITUDE || feature.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🅿️', '#f59e0b');
                const marker = L.marker([lat, lon], { icon });
                const name = feature.name || feature.NAME || 'Parking';
                const type = feature.type || feature.TYPE || '';
                const distance = feature.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🅿️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_parking']) {
                  legendAccumulator['de_parking'] = { icon: '🅿️', color: '#f59e0b', title: 'DE Wildlife Areas Parking', count: 0 };
                }
                legendAccumulator['de_parking'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Parking:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Restrooms as markers
      if (enrichments.de_restrooms_all && Array.isArray(enrichments.de_restrooms_all)) {
        enrichments.de_restrooms_all.forEach((feature: any) => {
          if (feature.geometry) {
            try {
              const lat = feature.geometry.y || feature.LATITUDE || feature.latitude;
              const lon = feature.geometry.x || feature.LONGITUDE || feature.longitude;
              if (lat && lon) {
                const icon = createPOIIcon('🚻', '#8b5cf6');
                const marker = L.marker([lat, lon], { icon });
                const name = feature.name || feature.NAME || 'Restroom';
                const type = feature.type || feature.TYPE || '';
                const distance = feature.distance_miles;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚻 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                if (!legendAccumulator['de_restrooms']) {
                  legendAccumulator['de_restrooms'] = { icon: '🚻', color: '#8b5cf6', title: 'DE Wildlife Areas Restrooms', count: 0 };
                }
                legendAccumulator['de_restrooms'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Restroom:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Areas Safety Zones as polygons
      if (enrichments.de_safety_zones_all && Array.isArray(enrichments.de_safety_zones_all)) {
        enrichments.de_safety_zones_all.forEach((zone: any) => {
          if (zone.geometry && zone.geometry.rings) {
            try {
              const rings = zone.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                if (latlngs.length < 3) {
                  console.warn('DE Safety Zone polygon has less than 3 coordinates, skipping');
                  return;
                }

                const name = zone.name || zone.NAME || 'Safety Zone';
                const type = zone.type || zone.TYPE || '';
                const isContaining = zone.isContaining || false;
                
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#dc2626' : '#ef4444',
                  weight: 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#ef4444' : '#f87171',
                  fillOpacity: 0.3
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ⚠️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                } catch (boundsError) {
                  console.warn('Error extending bounds for DE Safety Zone:', boundsError);
                }
                
                if (!legendAccumulator['de_safety_zones']) {
                  legendAccumulator['de_safety_zones'] = {
                    icon: '⚠️',
                    color: '#ef4444',
                    title: 'DE Wildlife Areas Safety Zones',
                    count: 0,
                  };
                }
                legendAccumulator['de_safety_zones'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Safety Zone:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Management Zones as polygons
      if (enrichments.de_wildlife_management_zones_all && Array.isArray(enrichments.de_wildlife_management_zones_all)) {
        enrichments.de_wildlife_management_zones_all.forEach((zone: any) => {
          if (zone.geometry && zone.geometry.rings) {
            try {
              const rings = zone.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                if (latlngs.length < 3) {
                  console.warn('DE Wildlife Management Zone polygon has less than 3 coordinates, skipping');
                  return;
                }

                const name = zone.name || zone.NAME || zone.ZONE || zone.zone || 'Wildlife Management Zone';
                const type = zone.type || zone.TYPE || zone.ZONE_TYPE || zone.zone_type || '';
                const isContaining = zone.isContaining || false;
                
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#047857' : '#059669',
                  weight: 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#059669' : '#10b981',
                  fillOpacity: 0.3
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🦌 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                } catch (boundsError) {
                  console.warn('Error extending bounds for DE Wildlife Management Zone:', boundsError);
                }
                
                if (!legendAccumulator['de_wildlife_management_zones']) {
                  legendAccumulator['de_wildlife_management_zones'] = {
                    icon: '🦌',
                    color: '#059669',
                    title: 'DE Wildlife Management Zones',
                    count: 0,
                  };
                }
                legendAccumulator['de_wildlife_management_zones'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Wildlife Management Zone:', error);
            }
          }
        });
      }

      // Draw DE Rail Lines as polylines
      if (enrichments.de_rail_lines_all && Array.isArray(enrichments.de_rail_lines_all)) {
        let railLineCount = 0;
        enrichments.de_rail_lines_all.forEach((railLine: any) => {
          if (railLine.geometry && railLine.geometry.paths) {
            try {
              const paths = railLine.geometry.paths;
              if (paths && paths.length > 0) {
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 2) {
                    console.warn('DE Rail Line polyline has less than 2 coordinates, skipping');
                    return;
                  }

                  const railId = railLine.railId || railLine.RAIL_ID || railLine.rail_id || '';
                  const trackType = railLine.trackType || railLine.TRACK_TYPE || railLine.track_type || '';
                  const status = railLine.status || railLine.STATUS || railLine.status || '';
                  const lineId = railLine.lineId || railLine.LINE_ID || railLine.line_id || '';
                  const owner = railLine.owner || railLine.OWNER || railLine.owner || '';
                  const operators = railLine.operators || [];
                  
                  const polyline = L.polyline(latlngs, {
                    color: '#1f2937',
                    weight: 3,
                    opacity: 0.8
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🚂 Rail Line${railId ? ` ${railId}` : ''}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${lineId ? `<div><strong>Line ID:</strong> ${lineId}</div>` : ''}
                        ${trackType ? `<div><strong>Track Type:</strong> ${trackType}</div>` : ''}
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                        ${operators.length > 0 ? `<div><strong>Operator${operators.length > 1 ? 's' : ''}:</strong> ${operators.join(', ')}</div>` : ''}
                        ${railLine.distance_miles !== null && railLine.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${railLine.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['railId', 'RAIL_ID', 'rail_id', 'trackType', 'TRACK_TYPE', 'track_type', 'status', 'STATUS', 'lineId', 'LINE_ID', 'line_id', 'owner', 'OWNER', 'operators', 'OPERATOR1', 'OPERATOR2', 'OPERATOR3', 'OPERATOR4', 'geometry', 'distance_miles', 'OBJECTID', 'objectid'];
                  Object.entries(railLine).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  
                  try {
                    bounds.extend(polyline.getBounds());
                    railLineCount++;
                  } catch (boundsError) {
                    console.warn('Error extending bounds for DE Rail Line polyline:', boundsError);
                  }
                });
              }
            } catch (error) {
              console.error('Error drawing DE Rail Line:', error);
            }
          }
        });
        
        if (railLineCount > 0) {
          if (!legendAccumulator['de_rail_lines']) {
            legendAccumulator['de_rail_lines'] = {
              icon: '🚂',
              color: '#1f2937',
              title: 'DE Rail Lines',
              count: 0,
            };
          }
          legendAccumulator['de_rail_lines'].count += railLineCount;
        }
      }

      // Draw DE Natural Areas polygons
      if (enrichments.de_natural_areas_all && Array.isArray(enrichments.de_natural_areas_all)) {
        enrichments.de_natural_areas_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#a855f7' : '#c084fc',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#a855f7' : '#c084fc',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Natural Area' : 'Nearby Natural Area'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_natural_areas']) {
                  legendAccumulator['de_natural_areas'] = { icon: '🌿', color: '#a855f7', title: 'DE Natural Areas', count: 0 };
                }
                legendAccumulator['de_natural_areas'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Natural Areas:', error);
            }
          }
        });
      }

      // Draw DE Outdoor Recreation, Parks and Trails Program Lands polygons
      if (enrichments.de_outdoor_recreation_parks_trails_lands_all && Array.isArray(enrichments.de_outdoor_recreation_parks_trails_lands_all)) {
        enrichments.de_outdoor_recreation_parks_trails_lands_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#a855f7' : '#c084fc',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#a855f7' : '#c084fc',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Parks & Trails Program Land' : 'Nearby Parks & Trails Program Land'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_outdoor_recreation_parks_trails_lands']) {
                  legendAccumulator['de_outdoor_recreation_parks_trails_lands'] = { icon: '🏕️', color: '#a855f7', title: 'DE Parks & Trails Program Lands', count: 0 };
                }
                legendAccumulator['de_outdoor_recreation_parks_trails_lands'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Outdoor Recreation Parks Trails Lands:', error);
            }
          }
        });
      }

      // Draw DE Land and Water Conservation Fund polygons
      if (enrichments.de_land_water_conservation_fund_all && Array.isArray(enrichments.de_land_water_conservation_fund_all)) {
        enrichments.de_land_water_conservation_fund_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#ec4899' : '#f472b6',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#ec4899' : '#f472b6',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Land & Water Conservation Fund' : 'Nearby Land & Water Conservation Fund'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_land_water_conservation_fund']) {
                  legendAccumulator['de_land_water_conservation_fund'] = { icon: '💧', color: '#ec4899', title: 'DE Land & Water Conservation Fund', count: 0 };
                }
                legendAccumulator['de_land_water_conservation_fund'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Land and Water Conservation Fund:', error);
            }
          }
        });
      }

      // Draw DE Nature Preserves polygons
      if (enrichments.de_nature_preserves_all && Array.isArray(enrichments.de_nature_preserves_all)) {
        enrichments.de_nature_preserves_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#aa5cf7' : '#c084fc',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#aa5cf7' : '#c084fc',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Nature Preserve' : 'Nearby Nature Preserve'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_nature_preserves']) {
                  legendAccumulator['de_nature_preserves'] = { icon: '🌳', color: '#aa5cf7', title: 'DE Nature Preserves', count: 0 };
                }
                legendAccumulator['de_nature_preserves'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Nature Preserves:', error);
            }
          }
        });
      }

      // Draw DE Outdoor Recreation Areas polygons
      if (enrichments.de_outdoor_recreation_areas_all && Array.isArray(enrichments.de_outdoor_recreation_areas_all)) {
        enrichments.de_outdoor_recreation_areas_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#10b981' : '#34d399',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#10b981' : '#34d399',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Outdoor Recreation Area' : 'Nearby Outdoor Recreation Area'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_outdoor_recreation_areas']) {
                  legendAccumulator['de_outdoor_recreation_areas'] = { icon: '🏞️', color: '#10b981', title: 'DE Outdoor Recreation Areas', count: 0 };
                }
                legendAccumulator['de_outdoor_recreation_areas'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Outdoor Recreation Areas:', error);
            }
          }
        });
      }

      // Draw DE Outdoor Recreation, Parks and Trails Program Open Space polygons
      if (enrichments.de_outdoor_recreation_parks_trails_open_space_all && Array.isArray(enrichments.de_outdoor_recreation_parks_trails_open_space_all)) {
        enrichments.de_outdoor_recreation_parks_trails_open_space_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#10b981' : '#34d399',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#10b981' : '#34d399',
                  fillOpacity: 0.2
                });
                const agency = feature.AGENCY || feature.agency || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Parks & Trails Open Space' : 'Nearby Parks & Trails Open Space'}</strong>${agency ? `<br>Agency: ${agency}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_outdoor_recreation_parks_trails_open_space']) {
                  legendAccumulator['de_outdoor_recreation_parks_trails_open_space'] = { icon: '🌳', color: '#10b981', title: 'DE Parks & Trails Open Space', count: 0 };
                }
                legendAccumulator['de_outdoor_recreation_parks_trails_open_space'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Outdoor Recreation Parks Trails Open Space:', error);
            }
          }
        });
      }

      // Draw DE Public Protected Lands polygons
      if (enrichments.de_public_protected_lands_all && Array.isArray(enrichments.de_public_protected_lands_all)) {
        enrichments.de_public_protected_lands_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#10b981' : '#34d399',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#10b981' : '#34d399',
                  fillOpacity: 0.2
                });
                const name = feature.NAME || feature.name || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Public Protected Land' : 'Nearby Public Protected Land'}</strong>${name ? `<br>Name: ${name}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_public_protected_lands']) {
                  legendAccumulator['de_public_protected_lands'] = { icon: '🛡️', color: '#10b981', title: 'DE Public Protected Lands', count: 0 };
                }
                legendAccumulator['de_public_protected_lands'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Public Protected Lands:', error);
            }
          }
        });
      }

      // Draw DE Conservation Easements polygons
      if (enrichments.de_conservation_easements_all && Array.isArray(enrichments.de_conservation_easements_all)) {
        enrichments.de_conservation_easements_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#10b981' : '#34d399',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#10b981' : '#34d399',
                  fillOpacity: 0.2
                });
                const grantor = feature.GRANTOR || feature.grantor || '';
                const acres = feature.ACRES || feature.acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Conservation Easement' : 'Nearby Conservation Easement'}</strong>${grantor ? `<br>Grantor: ${grantor}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_conservation_easements']) {
                  legendAccumulator['de_conservation_easements'] = { icon: '🌿', color: '#10b981', title: 'DE Conservation Easements', count: 0 };
                }
                legendAccumulator['de_conservation_easements'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Conservation Easements:', error);
            }
          }
        });
      }

      // Draw DE Trails and Pathways as polylines
      if (enrichments.de_trails_pathways_all && Array.isArray(enrichments.de_trails_pathways_all)) {
        enrichments.de_trails_pathways_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.paths) {
            try {
              feature.geometry.paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const polyline = L.polyline(latlngs, { color: '#f59e0b', weight: 3, opacity: 0.8 });
                const trailName = feature.TRAIL_NAME || feature.trailName || feature.trail_name || '';
                const managedUse = feature.MANAGED_USE || feature.managedUse || feature.managed_use || '';
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${trailName || 'Trail'}</strong>${managedUse ? `<br>Use: ${managedUse}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polyline.bindPopup(popupContent);
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
              if (!legendAccumulator['de_trails_pathways']) {
                legendAccumulator['de_trails_pathways'] = { icon: '🛤️', color: '#f59e0b', title: 'DE Trails and Pathways', count: 0 };
              }
              legendAccumulator['de_trails_pathways'].count += 1;
            } catch (error) {
              console.error('Error drawing DE Trails and Pathways:', error);
            }
          }
        });
      }

      // Draw DE Seasonal Restricted Areas polygons
      if (enrichments.de_seasonal_restricted_areas_all && Array.isArray(enrichments.de_seasonal_restricted_areas_all)) {
        enrichments.de_seasonal_restricted_areas_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#eab308' : '#facc15',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#eab308' : '#facc15',
                  fillOpacity: 0.2
                });
                const park = feature.PARK || feature.park || '';
                const closure = feature.CLOSURE || feature.closure || '';
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Seasonal Restricted Area' : 'Nearby Seasonal Restricted Area'}</strong>${park ? `<br>Park: ${park}` : ''}${closure ? `<br>Closure: ${closure}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_seasonal_restricted_areas']) {
                  legendAccumulator['de_seasonal_restricted_areas'] = { icon: '⚠️', color: '#eab308', title: 'DE Seasonal Restricted Areas', count: 0 };
                }
                legendAccumulator['de_seasonal_restricted_areas'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Seasonal Restricted Areas:', error);
            }
          }
        });
      }

      // Draw DE Permanent Restricted Areas polygons
      if (enrichments.de_permanent_restricted_areas_all && Array.isArray(enrichments.de_permanent_restricted_areas_all)) {
        enrichments.de_permanent_restricted_areas_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#eab308' : '#facc15',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#eab308' : '#facc15',
                  fillOpacity: 0.2
                });
                const park = feature.PARK || feature.park || '';
                const closure = feature.CLOSURE || feature.closure || '';
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Permanent Restricted Area' : 'Nearby Permanent Restricted Area'}</strong>${park ? `<br>Park: ${park}` : ''}${closure ? `<br>Closure: ${closure}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_permanent_restricted_areas']) {
                  legendAccumulator['de_permanent_restricted_areas'] = { icon: '🚫', color: '#eab308', title: 'DE Permanent Restricted Areas', count: 0 };
                }
                legendAccumulator['de_permanent_restricted_areas'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Permanent Restricted Areas:', error);
            }
          }
        });
      }

      // Draw DE Wildlife Area Boundaries polygons
      if (enrichments.de_wildlife_area_boundaries_all && Array.isArray(enrichments.de_wildlife_area_boundaries_all)) {
        enrichments.de_wildlife_area_boundaries_all.forEach((feature: any) => {
          if (feature.geometry && feature.geometry.rings) {
            try {
              const rings = feature.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                const isContaining = feature.isContaining;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#fbbf24' : '#fcd34d',
                  weight: isContaining ? 3 : 2,
                  opacity: 0.8,
                  fillColor: isContaining ? '#fbbf24' : '#fcd34d',
                  fillOpacity: 0.2
                });
                const areaName = feature.AREA_NAME || feature.areaName || feature.area_name || '';
                const tractName = feature.TRACT_NAME || feature.tractName || feature.tract_name || '';
                const acres = feature.GIS_ACRES || feature.gisAcres || feature.gis_acres;
                const distance = feature.distance_miles;
                let popupContent = `<div><strong>${isContaining ? 'Wildlife Area' : 'Nearby Wildlife Area'}</strong>${areaName ? `<br>Area: ${areaName}` : ''}${tractName ? `<br>Tract: ${tractName}` : ''}${acres !== null && acres !== undefined ? `<br>Acres: ${acres.toLocaleString()}` : ''}${distance !== null && distance !== undefined ? `<br>Distance: ${distance.toFixed(2)} miles` : ''}</div>`;
                polygon.bindPopup(popupContent);
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                if (!legendAccumulator['de_wildlife_area_boundaries']) {
                  legendAccumulator['de_wildlife_area_boundaries'] = { icon: '🦌', color: '#fbbf24', title: 'DE Wildlife Area Boundaries', count: 0 };
                }
                legendAccumulator['de_wildlife_area_boundaries'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing DE Wildlife Area Boundaries:', error);
            }
          }
        });
      }

      // Draw NH Geographic Names as markers on the map
      if (enrichments.nh_geographic_names_all && Array.isArray(enrichments.nh_geographic_names_all)) {
        enrichments.nh_geographic_names_all.forEach((place: any) => {
          const placeLat = place.lat;
          const placeLon = place.lon;
          
          if (placeLat && placeLon) {
            try {
              const placeName = place.feature || 'Unknown Place';
              const featType = place.feattype || '';
              const county = place.county || '';
              const quad = place.quad || '';
              const distance = place.distance_miles !== null && place.distance_miles !== undefined ? place.distance_miles.toFixed(2) : '';
              
              // Create a custom icon for geographic names
              const icon = createPOIIcon('📍', '#8b5cf6'); // Purple icon for geographic names
              
              const marker = L.marker([placeLat, placeLon], { icon });
              
              // Build popup content with all place attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    📍 ${placeName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${featType ? `<div><strong>Type:</strong> ${featType}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${quad ? `<div><strong>Quad:</strong> ${quad}</div>` : ''}
                    ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all other place attributes (excluding internal fields)
              const excludeFields = ['feature', 'feattype', 'county', 'quad', 'lat', 'lon', 'distance_miles', 'geometry', 'objectId', 'featid'];
              Object.entries(place).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              popupContent = addMappingLinksToPopup(popupContent, placeLat, placeLon, placeName);
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this place
              bounds.extend([placeLat, placeLon]);
              
              // Add to legend accumulator
              if (!legendAccumulator['nh_geographic_names']) {
                legendAccumulator['nh_geographic_names'] = {
                  icon: '📍',
                  color: '#8b5cf6',
                  title: 'NH Geographic Names',
                  count: 0,
                };
              }
              legendAccumulator['nh_geographic_names'].count += 1;
            } catch (error) {
              console.error('Error drawing NH Geographic Name marker:', error);
            }
          }
        });
      }

      // Draw FLDEP Landuse as polygons on the map
      if (enrichments.fldep_landuse_all && Array.isArray(enrichments.fldep_landuse_all)) {
        enrichments.fldep_landuse_all.forEach((landuse: any) => {
          if (landuse.geometry && landuse.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = landuse.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = landuse.isContaining || landuse.distance_miles === 0 || landuse.distance_miles === null;
                const color = isContaining ? '#10b981' : '#34d399'; // Green for containing, lighter green for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all landuse attributes
                const description = landuse.DESCRIPTION || landuse.description || '';
                const level3Value = landuse.LEVEL3_VALUE !== null && landuse.LEVEL3_VALUE !== undefined ? landuse.LEVEL3_VALUE : landuse.level3Value;
                const ldi = landuse.LDI !== null && landuse.LDI !== undefined ? landuse.LDI : landuse.ldi;
                const lsi = landuse.LSI !== null && landuse.LSI !== undefined ? landuse.LSI : landuse.lsi;
                const wmdDistrict = landuse.WMD_DISTRICT || landuse.wmdDistrict || '';
                const landuseYear = landuse.LANDUSE_YEAR !== null && landuse.LANDUSE_YEAR !== undefined ? landuse.LANDUSE_YEAR : landuse.landuseYear;
                const shapeArea = landuse['SHAPE.AREA'] !== null && landuse['SHAPE.AREA'] !== undefined ? landuse['SHAPE.AREA'] : landuse.shapeArea;
                const distance = landuse.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🌳 Containing Landuse' : '🌳 Nearby Landuse'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${description ? `<div><strong>Description:</strong> ${description}</div>` : ''}
                      ${level3Value !== null && level3Value !== undefined ? `<div><strong>Level 3 Value:</strong> ${level3Value}</div>` : ''}
                      ${ldi !== null && ldi !== undefined ? `<div><strong>LDI (Landscape Development Intensity):</strong> ${ldi.toFixed(2)}</div>` : ''}
                      ${lsi !== null && lsi !== undefined ? `<div><strong>LSI (Landscape Support Index):</strong> ${lsi.toFixed(2)}</div>` : ''}
                      ${wmdDistrict ? `<div><strong>WMD District:</strong> ${wmdDistrict}</div>` : ''}
                      ${landuseYear ? `<div><strong>Landuse Year:</strong> ${landuseYear}</div>` : ''}
                      ${shapeArea !== null && shapeArea !== undefined ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other landuse attributes (excluding internal fields)
                const excludeFields = ['DESCRIPTION', 'description', 'LEVEL3_VALUE', 'level3Value', 'LDI', 'ldi', 'LSI', 'lsi', 'WMD_DISTRICT', 'wmdDistrict', 'LANDUSE_YEAR', 'landuseYear', 'SHAPE.AREA', 'shapeArea', 'SHAPE.LEN', 'shapeLength', 'geometry', 'distance_miles', 'isContaining', 'OBJECTID', 'objectId'];
                Object.entries(landuse).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['fldep_landuse']) {
                  legendAccumulator['fldep_landuse'] = {
                    icon: '🌳',
                    color: '#10b981',
                    title: 'FLDEP Landuse',
                    count: 0,
                    radius: enrichments.fldep_landuse_search_radius_miles,
                    radiusDisplay: enrichments.fldep_landuse_search_radius_miles ? `${enrichments.fldep_landuse_search_radius_miles.toFixed(1)} mi` : undefined
                  };
                }
                legendAccumulator['fldep_landuse'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing FLDEP Landuse polygon:', error);
            }
          }
        });
      }

      // Draw WY Bighorn Sheep Crucial Range as polygons on the map
      if (enrichments.wy_bighorn_sheep_crucial_range_all && Array.isArray(enrichments.wy_bighorn_sheep_crucial_range_all)) {
        enrichments.wy_bighorn_sheep_crucial_range_all.forEach((range: any) => {
          if (range.geometry && range.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = range.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = range.isContaining || range.distance_miles === 0 || range.distance_miles === null;
                const color = isContaining ? '#f59e0b' : '#fbbf24'; // Amber for containing, lighter amber for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all range attributes
                const species = range.SPECIES || range.species || '';
                const rangeType = range.RANGE || range.range || '';
                const acres = range.Acres !== null && range.Acres !== undefined ? range.Acres : range.acres;
                const sqMiles = range.SQMiles !== null && range.SQMiles !== undefined ? range.SQMiles : range.sqMiles;
                const shapeArea = range['Shape__Area'] !== null && range['Shape__Area'] !== undefined ? range['Shape__Area'] : range.shapeArea;
                const shapeLength = range['Shape__Length'] !== null && range['Shape__Length'] !== undefined ? range['Shape__Length'] : range.shapeLength;
                const distance = range.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🐑 Containing Bighorn Sheep Crucial Range' : '🐑 Nearby Bighorn Sheep Crucial Range'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${species ? `<div><strong>Species:</strong> ${species}</div>` : ''}
                      ${rangeType ? `<div><strong>Range Type:</strong> ${rangeType}</div>` : ''}
                      ${acres !== null && acres !== undefined ? `<div><strong>Acres:</strong> ${acres.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>` : ''}
                      ${sqMiles !== null && sqMiles !== undefined ? `<div><strong>Square Miles:</strong> ${sqMiles.toLocaleString(undefined, { maximumFractionDigits: 2 })}</div>` : ''}
                      ${shapeArea !== null && shapeArea !== undefined ? `<div><strong>Shape Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      ${shapeLength !== null && shapeLength !== undefined ? `<div><strong>Shape Length:</strong> ${shapeLength.toLocaleString()} units</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other range attributes (excluding internal fields)
                const excludeFields = ['SPECIES', 'species', 'RANGE', 'range', 'Acres', 'acres', 'SQMiles', 'sqMiles', 'Shape__Area', 'shapeArea', 'Shape__Length', 'shapeLength', 'geometry', 'distance_miles', 'isContaining', 'OBJECTID', 'objectId', 'lat', 'lon'];
                Object.entries(range).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['wy_bighorn_sheep_crucial_range']) {
                  legendAccumulator['wy_bighorn_sheep_crucial_range'] = {
                    icon: '🐑',
                    color: '#f59e0b',
                    title: 'WY Bighorn Sheep Crucial Range',
                    count: 0,
                    radius: enrichments.wy_bighorn_sheep_crucial_range_search_radius_miles,
                    radiusDisplay: enrichments.wy_bighorn_sheep_crucial_range_search_radius_miles ? `${enrichments.wy_bighorn_sheep_crucial_range_search_radius_miles.toFixed(1)} mi` : undefined
                  };
                }
                legendAccumulator['wy_bighorn_sheep_crucial_range'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing WY Bighorn Sheep Crucial Range polygon:', error);
            }
          }
        });
      }

      // Draw MA DEP Wetlands as polygons on the map
      if (enrichments.ma_dep_wetlands_all && Array.isArray(enrichments.ma_dep_wetlands_all)) {
        enrichments.ma_dep_wetlands_all.forEach((wetland: any) => {
          if (wetland.geometry && wetland.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = wetland.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = wetland.distance_miles === 0 || wetland.distance_miles === null;
                const color = isContaining ? '#14b8a6' : '#06b6d4'; // Teal for containing, cyan for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all wetland attributes
                const wetCode = wetland.WETCODE || wetland.wetCode;
                const itValDesc = wetland.IT_VALDESC || wetland.itValDesc;
                const itValc = wetland.IT_VALC || wetland.itValc;
                const polyCode = wetland.POLY_CODE || wetland.polyCode;
                const source = wetland.SOURCE || wetland.source;
                const areaAcres = wetland.AREAACRES || wetland.areaAcres;
                const distance = wetland.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🌊 Containing Wetland' : '🌊 Nearby Wetland'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${itValDesc ? `<div><strong>Type:</strong> ${itValDesc}</div>` : ''}
                      ${itValc ? `<div><strong>Code:</strong> ${itValc}</div>` : ''}
                      ${wetCode ? `<div><strong>Wet Code:</strong> ${wetCode}</div>` : ''}
                      ${polyCode ? `<div><strong>Poly Code:</strong> ${polyCode}</div>` : ''}
                      ${source ? `<div><strong>Source:</strong> ${source}</div>` : ''}
                      ${areaAcres ? `<div><strong>Area:</strong> ${areaAcres.toFixed(2)} acres</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other wetland attributes (excluding internal fields)
                const excludeFields = ['WETCODE', 'wetCode', 'IT_VALC', 'itValc', 'IT_VALDESC', 'itValDesc', 'POLY_CODE', 'polyCode', 'SOURCE', 'source', 'AREAACRES', 'areaAcres', 'AREASQMI', 'areaSqMi', 'geometry', 'distance_miles'];
                Object.entries(wetland).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['ma_dep_wetlands']) {
                  legendAccumulator['ma_dep_wetlands'] = {
                    icon: '🌊',
                    color: '#14b8a6',
                    title: 'MA DEP Wetlands',
                    count: 0,
                  };
                }
                legendAccumulator['ma_dep_wetlands'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing MA DEP Wetland polygon:', error);
            }
          }
        });
      }

      // Draw MA Open Space as polygons on the map
      if (enrichments.ma_open_space_all && Array.isArray(enrichments.ma_open_space_all)) {
        console.log(`🗺️ Drawing MA Open Space: ${enrichments.ma_open_space_all.length} features`);
        enrichments.ma_open_space_all.forEach((openSpace: any, index: number) => {
          console.log(`🗺️ MA Open Space ${index}:`, {
            hasGeometry: !!openSpace.geometry,
            geometryType: openSpace.geometry?.type || openSpace.geometry?.rings ? 'rings' : 'unknown',
            hasRings: !!openSpace.geometry?.rings,
            ringsLength: openSpace.geometry?.rings?.length
          });
          if (openSpace.geometry && openSpace.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = openSpace.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = openSpace.distance_miles === 0 || openSpace.distance_miles === null;
                const color = isContaining ? '#059669' : '#10b981'; // Green for containing, lighter green for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all open space attributes
                const siteName = openSpace.SITE_NAME || openSpace.siteName || openSpace.SiteName || 'Unknown Open Space';
                const siteType = openSpace.SITE_TYPE || openSpace.siteType || openSpace.SiteType || '';
                const ownerType = openSpace.OWNER_TYPE || openSpace.ownerType || openSpace.OwnerType || '';
                const ownerName = openSpace.OWNER_NAME || openSpace.ownerName || openSpace.OwnerName || '';
                const acres = openSpace.ACRES || openSpace.acres || openSpace.Acres;
                const distance = openSpace.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏞️ Containing Open Space' : '🏞️ Nearby Open Space'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Name:</strong> ${siteName}</div>
                      ${siteType ? `<div><strong>Type:</strong> ${siteType}</div>` : ''}
                      ${ownerType ? `<div><strong>Owner Type:</strong> ${ownerType}</div>` : ''}
                      ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                      ${acres ? `<div><strong>Area:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other open space attributes (excluding internal fields)
                const excludeFields = ['SITE_NAME', 'siteName', 'SiteName', 'SITE_TYPE', 'siteType', 'SiteType', 'OWNER_TYPE', 'ownerType', 'OwnerType', 'OWNER_NAME', 'ownerName', 'OwnerName', 'ACRES', 'acres', 'Acres', 'geometry', 'distance_miles'];
                Object.entries(openSpace).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['ma_open_space']) {
                  legendAccumulator['ma_open_space'] = {
                    icon: '🏞️',
                    color: '#059669',
                    title: 'MA Open Space',
                    count: 0,
                  };
                }
                legendAccumulator['ma_open_space'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing MA Open Space polygon:', error);
            }
          }
        });
      }

      // Draw Cape Cod Zoning as polygons on the map
      if (enrichments.cape_cod_zoning_all && Array.isArray(enrichments.cape_cod_zoning_all)) {
        enrichments.cape_cod_zoning_all.forEach((zoning: any) => {
          if (zoning.geometry && zoning.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = zoning.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = zoning.distance_miles === 0 || zoning.distance_miles === null;
                const color = isContaining ? '#7c3aed' : '#a78bfa'; // Purple for containing, lighter purple for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with ZONECODE at the top
                const zoneCode = zoning.ZONECODE || zoning.ZoneCode || zoning.zonecode || 'Unknown Zone';
                const primUse = zoning.PRIM_USE || zoning.Prim_Use || zoning.prim_use || '';
                const townCode = zoning.TOWNCODE || zoning.TownCode || zoning.towncode || '';
                const primUse2 = zoning.PRIM_USE2 || zoning.Prim_Use2 || zoning.prim_use2 || '';
                const acres = zoning.ACRES || zoning.Acres || zoning.acres;
                const townId = zoning.TOWN_ID || zoning.Town_ID || zoning.town_id;
                const distance = zoning.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏘️ Containing Zoning District' : '🏘️ Nearby Zoning District'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div style="font-weight: 600; font-size: 13px; color: #1f2937; margin-bottom: 4px;"><strong>Zone Code:</strong> ${zoneCode}</div>
                      ${primUse ? `<div><strong>Primary Use:</strong> ${primUse}</div>` : ''}
                      ${primUse2 ? `<div><strong>Primary Use 2:</strong> ${primUse2}</div>` : ''}
                      ${townCode ? `<div><strong>Town Code:</strong> ${townCode}</div>` : ''}
                      ${townId ? `<div><strong>Town ID:</strong> ${townId}</div>` : ''}
                      ${acres ? `<div><strong>Area:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other zoning attributes (excluding internal fields and ZONECODE since it's already shown)
                const excludeFields = ['ZONECODE', 'ZoneCode', 'zonecode', 'PRIM_USE', 'Prim_Use', 'prim_use', 'PRIM_USE2', 'Prim_Use2', 'prim_use2', 'TOWNCODE', 'TownCode', 'towncode', 'TOWN_ID', 'Town_ID', 'town_id', 'ACRES', 'Acres', 'acres', 'geometry', 'distance_miles'];
                Object.entries(zoning).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['cape_cod_zoning']) {
                  legendAccumulator['cape_cod_zoning'] = {
                    icon: '🏘️',
                    color: '#7c3aed',
                    title: 'Cape Cod Zoning',
                    count: 0,
                  };
                }
                legendAccumulator['cape_cod_zoning'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing Cape Cod Zoning polygon:', error);
            }
          }
        });
      }

      // Draw PAD-US Public Access as polygons on the map
      if (enrichments.padus_public_access_all && Array.isArray(enrichments.padus_public_access_all)) {
        enrichments.padus_public_access_all.forEach((land: any, index: number) => {
          // Check for geometry in __geometry (for summary) or geometry (backward compatibility)
          const geometry = land.__geometry || land.geometry;
          if (!geometry || !geometry.rings) {
            return;
          }
          
          if (geometry && geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = geometry.rings;
              
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                
                if (!outerRing || outerRing.length < 3) {
                  return;
                }
                
                // Check spatial reference - PAD-US might return Web Mercator (3857) or other projection
                const spatialRef = geometry.spatialReference || geometry.spatialref;
                const wkid = spatialRef?.wkid || spatialRef?.latestWkid;
                
                let latlngs: [number, number][];
                
                // If coordinates are in Web Mercator (3857) or look like projected coordinates, convert to WGS84
                if (wkid === 3857 || wkid === 102100 || (!wkid && (Math.abs(outerRing[0]?.[0]) > 180 || Math.abs(outerRing[0]?.[1]) > 90))) {
                  // Convert from Web Mercator to WGS84
                  latlngs = outerRing.map((coord: number[]) => {
                    const x = coord[0];
                    const y = coord[1];
                    // Web Mercator to WGS84 conversion
                    const lon = (x / 20037508.34) * 180;
                    let lat = (y / 20037508.34) * 180;
                    lat = (Math.atan(Math.exp((lat * Math.PI) / 180)) * 360) / Math.PI - 90;
                    return [lat, lon] as [number, number];
                  });
                } else {
                  // Assume WGS84 - coordinates are [lon, lat], convert to [lat, lon] for Leaflet
                  latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                }
                
                const isContaining = land.distance_miles === 0 || land.distance_miles === null || land.distance_miles === undefined;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#16a34a' : '#22c55e', // Darker green for containing, lighter for nearby
                  weight: 2,
                  opacity: 0.7,
                  fillColor: isContaining ? '#16a34a' : '#22c55e',
                  fillOpacity: 0.3
                });

                // Build popup content
                const unitName = land.unitName || land.Unit_Nm || 'Unnamed Public Land';
                const category = land.category || land.Category || '';
                const publicAccess = land.publicAccess || land.Pub_Access || '';
                const managerName = land.managerName || land.MngNm_Desc || '';
                const acres = land.acres || land.GIS_AcrsDb;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏞️ ${unitName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${category ? `<div><strong>Category:</strong> ${category}</div>` : ''}
                      ${publicAccess ? `<div><strong>Public Access:</strong> ${publicAccess}</div>` : ''}
                      ${managerName ? `<div><strong>Manager:</strong> ${managerName}</div>` : ''}
                      ${acres ? `<div><strong>Area:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator (only once per land)
                if (!legendAccumulator['padus_public_access']) {
                  legendAccumulator['padus_public_access'] = {
                    icon: '🏞️',
                    color: '#22c55e',
                    title: 'PAD-US Public Access',
                    count: 0,
                  };
                }
                legendAccumulator['padus_public_access'].count += 1;
              }
            } catch (error) {
              console.error(`❌ Error drawing PAD-US Public Access polygon ${index}:`, error);
            }
          } else {
            console.warn(`⚠️ PAD-US Public Access ${index}: Geometry exists but no rings array`);
          }
        });
      } else {
        console.warn('⚠️ PAD-US Public Access: enrichments.padus_public_access_all is not an array or is missing');
      }

      // Draw PAD-US Protection Status as polygons on the map
      if (enrichments.padus_protection_status_all && Array.isArray(enrichments.padus_protection_status_all)) {
        console.log(`🗺️ Drawing ${enrichments.padus_protection_status_all.length} PAD-US Protection Status features`);
        console.log(`🗺️ Map instance exists:`, !!map);
        console.log(`🗺️ Primary layer group exists:`, !!primary);
        enrichments.padus_protection_status_all.forEach((land: any, index: number) => {
          // Check for geometry in __geometry (for summary) or geometry (backward compatibility)
          const landGeometry = land.__geometry || land.geometry;
          console.log(`🗺️ PAD-US Protection Status ${index}:`, {
            hasGeometry: !!landGeometry,
            geometryType: landGeometry?.type || (landGeometry?.rings ? 'rings' : 'unknown'),
            hasRings: !!landGeometry?.rings,
            ringsLength: landGeometry?.rings?.length,
            fullLand: land // Log full object for debugging
          });
          
          if (!landGeometry) {
            console.warn(`⚠️ PAD-US Protection Status ${index} has no geometry!`);
            return;
          }
          
          if (!landGeometry.rings) {
            console.warn(`⚠️ PAD-US Protection Status ${index} geometry has no rings! Geometry:`, landGeometry);
            return;
          }
          
          if (landGeometry && landGeometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = landGeometry.rings;
              console.log(`🔍 PAD-US Protection Status ${index}: Processing rings, count: ${rings?.length}`);
              
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                console.log(`🔍 PAD-US Protection Status ${index}: Outer ring has ${outerRing?.length} coordinates`);
                
                if (!outerRing || outerRing.length < 3) {
                  console.warn(`⚠️ PAD-US Protection Status ${index}: Outer ring is invalid (needs at least 3 coordinates)`);
                  return;
                }
                
                // Check spatial reference - PAD-US might return Web Mercator (3857) or other projection
                const spatialRef = landGeometry.spatialReference || landGeometry.spatialref;
                const wkid = spatialRef?.wkid || spatialRef?.latestWkid;
                console.log(`🔍 PAD-US Protection Status ${index}: Spatial Reference WKID: ${wkid}, first coord: [${outerRing[0]?.[0]}, ${outerRing[0]?.[1]}]`);
                
                let latlngs: [number, number][];
                
                // If coordinates are in Web Mercator (3857) or look like projected coordinates, convert to WGS84
                if (wkid === 3857 || wkid === 102100 || (!wkid && (Math.abs(outerRing[0]?.[0]) > 180 || Math.abs(outerRing[0]?.[1]) > 90))) {
                  // Convert from Web Mercator to WGS84
                  console.log(`🔍 PAD-US Protection Status ${index}: Converting from Web Mercator to WGS84`);
                  latlngs = outerRing.map((coord: number[]) => {
                    const x = coord[0];
                    const y = coord[1];
                    // Web Mercator to WGS84 conversion
                    const lon = (x / 20037508.34) * 180;
                    let lat = (y / 20037508.34) * 180;
                    lat = (Math.atan(Math.exp((lat * Math.PI) / 180)) * 360) / Math.PI - 90;
                    return [lat, lon] as [number, number];
                  });
                } else {
                  // Assume WGS84 - coordinates are [lon, lat], convert to [lat, lon] for Leaflet
                  latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                }
                
                console.log(`🔍 PAD-US Protection Status ${index}: Created ${latlngs.length} latlng points, first: [${latlngs[0]?.[0]}, ${latlngs[0]?.[1]}]`);

                const polygon = L.polygon(latlngs, {
                  color: '#059669', // Green color for protected areas
                  weight: 2,
                  opacity: 0.7,
                  fillColor: '#059669',
                  fillOpacity: 0.3
                });
                
                console.log(`✅ PAD-US Protection Status ${index}: Polygon created, adding to map`);

                // Build popup content
                const unitName = land.unitName || land.Unit_Nm || 'Unnamed Protected Area';
                const gapStatus = land.gapStatus || land.GAP_Sts || '';
                const iucnCategory = land.iucnCategory || land.IUCN_Cat || '';
                const category = land.category || land.Category || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🛡️ ${unitName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${gapStatus ? `<div><strong>GAP Status:</strong> ${gapStatus}</div>` : ''}
                      ${iucnCategory ? `<div><strong>IUCN Category:</strong> ${iucnCategory}</div>` : ''}
                      ${category ? `<div><strong>Category:</strong> ${category}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                console.log(`✅ PAD-US Protection Status ${index}: Polygon added to map successfully`);
                
                // Add to legend accumulator (only once per land)
                if (!legendAccumulator['padus_protection_status']) {
                  legendAccumulator['padus_protection_status'] = {
                    icon: '🛡️',
                    color: '#059669',
                    title: 'PAD-US Protection Status',
                    count: 0,
                  };
                }
                legendAccumulator['padus_protection_status'].count += 1;
              } else {
                console.warn(`⚠️ PAD-US Protection Status ${index}: No rings found in geometry`);
              }
            } catch (error) {
              console.error(`❌ Error drawing PAD-US Protection Status polygon ${index}:`, error);
              console.error('Error details:', {
                hasGeometry: !!land.geometry,
                hasRings: !!land.geometry?.rings,
                ringsLength: land.geometry?.rings?.length,
                firstRingLength: land.geometry?.rings?.[0]?.length,
                land: land
              });
            }
          } else {
            console.warn(`⚠️ PAD-US Protection Status ${index}: Geometry exists but no rings array`);
          }
        });
      } else {
        console.warn('⚠️ PAD-US Protection Status: enrichments.padus_protection_status_all is not an array or is missing');
      }

      // Draw MA Lakes and Ponds as polygons on the map
      if (enrichments.ma_lakes_and_ponds_all && Array.isArray(enrichments.ma_lakes_and_ponds_all)) {
        console.log(`🗺️ Drawing ${enrichments.ma_lakes_and_ponds_all.length} MA Lakes and Ponds`);
        enrichments.ma_lakes_and_ponds_all.forEach((lake: any, index: number) => {
          const hasGeometry = !!lake.geometry;
          const hasRings = !!lake.geometry?.rings;
          const ringsLength = lake.geometry?.rings?.length;
          
          console.log(`🗺️ MA Lake/Pond ${index}:`, {
            hasGeometry,
            geometryType: lake.geometry?.type || (hasRings ? 'rings' : 'unknown'),
            hasRings,
            ringsLength,
            distance_miles: lake.distance_miles,
            objectId: lake.objectId || lake.OBJECTID,
            fullLake: lake // Log full object for debugging
          });
          
          if (!hasGeometry) {
            console.warn(`⚠️ MA Lake/Pond ${index} has no geometry!`);
            return;
          }
          
          if (!hasRings) {
            console.warn(`⚠️ MA Lake/Pond ${index} geometry has no rings! Geometry:`, lake.geometry);
            return;
          }
          
          if (lake.geometry && lake.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng arrays
              const rings = lake.geometry.rings;
              rings.forEach((ring: number[][]) => {
                const latlngs = ring.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = lake.distance_miles === 0 || lake.distance_miles === null || lake.distance_miles === undefined;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#0284c7' : '#0ea5e9', // Darker blue for containing, lighter for nearby
                  weight: 2,
                  opacity: 0.7,
                  fillColor: isContaining ? '#0284c7' : '#0ea5e9',
                  fillOpacity: 0.3
                });

                // Build popup content with all lake attributes
                const name = lake.NAME || lake.Name || lake.name || 'Unnamed Lake/Pond';
                const type = lake.TYPE || lake.Type || lake.type || '';
                const sqMeters = lake.SQ_METERS || lake.Sq_Meters || lake.sq_meters || lake['SQ.METERS'];
                const distance = lake.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏞️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${sqMeters ? `<div><strong>Area:</strong> ${(sqMeters * 0.000247105).toFixed(2)} acres</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other lake attributes (excluding internal fields)
                const excludeFields = ['NAME', 'Name', 'name', 'TYPE', 'Type', 'type', 'SQ_METERS', 'Sq_Meters', 'sq_meters', 'SQ.METERS', 'FEATURE', 'Feature', 'feature', 'geometry', 'distance_miles'];
                Object.entries(lake).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
              });
              
              // Add to legend accumulator (only once per lake, not per ring)
              if (!legendAccumulator['ma_lakes_and_ponds']) {
                legendAccumulator['ma_lakes_and_ponds'] = {
                  icon: '🏞️',
                  color: '#0284c7',
                  title: 'MA Lakes and Ponds',
                  count: 0,
                };
              }
              legendAccumulator['ma_lakes_and_ponds'].count += 1;
            } catch (error) {
              console.error('Error drawing MA Lake/Pond polygon:', error);
            }
          }
        });
      }

      // Draw MA NHESP Natural Communities as polygons on the map
      if (enrichments.ma_nhesp_natural_communities_all && Array.isArray(enrichments.ma_nhesp_natural_communities_all)) {
        console.log(`🗺️ Drawing ${enrichments.ma_nhesp_natural_communities_all.length} MA NHESP Natural Communities`);
        enrichments.ma_nhesp_natural_communities_all.forEach((community: any) => {
          if (community.geometry && community.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng arrays
              const rings = community.geometry.rings;
              rings.forEach((ring: number[][]) => {
                const latlngs = ring.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = community.distance_miles === 0 || community.distance_miles === null || community.distance_miles === undefined;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#059669' : '#10b981', // Darker green for containing, lighter for nearby
                  weight: 2,
                  opacity: 0.7,
                  fillColor: isContaining ? '#059669' : '#10b981',
                  fillOpacity: 0.3
                });

                // Build popup content with all community attributes
                const communNam = community.COMMUN_NAM || community.Commun_Nam || community.commun_nam || community.communNam || 'Unnamed Community';
                const communRan = community.COMMUN_RAN || community.Commun_Ran || community.commun_ran || community.communRan || '';
                const specificD = community.SPECIFIC_D || community.Specific_D || community.specific_d || community.specificD || '';
                const communDes = community.COMMUN_DES || community.Commun_Des || community.commun_des || community.communDes || '';
                const shapeArea = community['SHAPE.AREA'] || community.Shape_Area || community.shape_area || community.shapeArea;
                const distance = community.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌿 ${communNam}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${communRan ? `<div><strong>Community Rank:</strong> ${communRan}</div>` : ''}
                      ${specificD ? `<div><strong>Specific Occurrence:</strong> ${specificD}</div>` : ''}
                      ${communDes ? `<div><strong>Description:</strong> ${communDes}</div>` : ''}
                      ${shapeArea ? `<div><strong>Area:</strong> ${(shapeArea * 0.000247105).toFixed(2)} acres</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other community attributes (excluding internal fields)
                const excludeFields = ['COMMUN_NAM', 'Commun_Nam', 'commun_nam', 'communNam', 'COMMUN_RAN', 'Commun_Ran', 'commun_ran', 'communRan', 'SPECIFIC_D', 'Specific_D', 'specific_d', 'specificD', 'COMMUN_DES', 'Commun_Des', 'commun_des', 'communDes', 'SHAPE.AREA', 'Shape_Area', 'shape_area', 'shapeArea', 'SHAPE.LEN', 'Shape_Len', 'shape_len', 'geometry', 'distance_miles'];
                Object.entries(community).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
              });
              
              // Add to legend accumulator (only once per community, not per ring)
              if (!legendAccumulator['ma_nhesp_natural_communities']) {
                legendAccumulator['ma_nhesp_natural_communities'] = {
                  icon: '🌿',
                  color: '#059669',
                  title: 'MA NHESP Natural Communities',
                  count: 0,
                };
              }
              legendAccumulator['ma_nhesp_natural_communities'].count += 1;
            } catch (error) {
              console.error('Error drawing MA NHESP Natural Community polygon:', error);
            }
          }
        });
      }

      // Draw MA Rivers and Streams as polylines on the map
      if (enrichments.ma_rivers_and_streams_all && Array.isArray(enrichments.ma_rivers_and_streams_all)) {
        enrichments.ma_rivers_and_streams_all.forEach((river: any) => {
          if (river.geometry && river.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = river.geometry.paths;
              paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const polyline = L.polyline(latlngs, {
                  color: '#0ea5e9', // Blue color for rivers/streams
                  weight: 3,
                  opacity: 0.8
                });

                // Build popup content with all river/stream attributes
                const objectId = river.OBJECTID || river.objectId || '';
                const distance = river.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌊 River/Stream
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${objectId ? `<div><strong>Object ID:</strong> ${objectId}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other river/stream attributes (excluding internal fields)
                const excludeFields = ['OBJECTID', 'objectId', 'geometry', 'distance_miles'];
                Object.entries(river).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polyline.bindPopup(popupContent, { maxWidth: 400 });
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
              
              // Add to legend accumulator (only once per river, not per path)
              if (!legendAccumulator['ma_rivers_and_streams']) {
                legendAccumulator['ma_rivers_and_streams'] = {
                  icon: '🌊',
                  color: '#0ea5e9',
                  title: 'MA Rivers and Streams',
                  count: 0,
                };
              }
              legendAccumulator['ma_rivers_and_streams'].count += 1;
            } catch (error) {
              console.error('Error drawing MA River/Stream polyline:', error);
            }
          }
        });
      }

      // Draw NRI Rivers as polylines on the map
      if (enrichments.nri_rivers_all && Array.isArray(enrichments.nri_rivers_all)) {
        let nriRiverCount = 0;
        enrichments.nri_rivers_all.forEach((river: any) => {
          // Check for geometry in __geometry (for summary) or geometry (backward compatibility)
          const geometry = river.__geometry || river.geometry;
          if (geometry && geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = geometry.paths;
              paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const polyline = L.polyline(latlngs, {
                  color: '#0284c7', // Blue color for NRI rivers
                  weight: 4,
                  opacity: 0.9
                });

                // Build popup content with NRI river attributes
                const riverName = river.river || 'Unknown River';
                const reach = river.reach || null;
                const classification = river.classification || null;
                const orv = river.orv || null;
                const managementAreaName = river.managementAreaName || null;
                const state1 = river.state1 || null;
                const county = river.county || null;
                const originalMiles = river.originalMiles !== null && river.originalMiles !== undefined ? river.originalMiles : null;
                const gisMiles = river.gisMiles !== null && river.gisMiles !== undefined ? river.gisMiles : null;
                const description = river.description || null;
                const distance = river.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌊 ${riverName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${reach ? `<div><strong>Reach:</strong> ${reach}</div>` : ''}
                      ${classification ? `<div><strong>Classification:</strong> ${classification}</div>` : ''}
                      ${orv ? `<div><strong>Outstandingly Remarkable Values:</strong> ${orv}</div>` : ''}
                      ${managementAreaName ? `<div><strong>Management Area:</strong> ${managementAreaName}</div>` : ''}
                      ${state1 ? `<div><strong>State:</strong> ${state1}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${originalMiles !== null ? `<div><strong>Original Miles:</strong> ${originalMiles.toFixed(2)}</div>` : ''}
                      ${gisMiles !== null ? `<div><strong>GIS Miles:</strong> ${gisMiles.toFixed(2)}</div>` : ''}
                      ${description ? `<div style="margin-top: 8px;"><strong>Description:</strong> ${description.substring(0, 200)}${description.length > 200 ? '...' : ''}</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                polyline.bindPopup(popupContent, { maxWidth: 400 });
                polyline.addTo(primary);
                
                // Store metadata for tabbed popup
                (polyline as any).__layerType = 'nri_rivers';
                (polyline as any).__layerTitle = 'NRI Rivers';
                
                bounds.extend(polyline.getBounds());
              });
              
              nriRiverCount++;
            } catch (error) {
              console.error('Error drawing NRI River polyline:', error);
            }
          }
        });
        
        if (nriRiverCount > 0) {
          if (!legendAccumulator['nri_rivers']) {
            legendAccumulator['nri_rivers'] = {
              icon: '🌊',
              color: '#0284c7',
              title: 'NRI Rivers',
              count: 0,
            };
          }
          legendAccumulator['nri_rivers'].count += nriRiverCount;
        }
      }

      // Draw TIGER Transportation layers as polylines on the map
      const tigerTransportationLayers = [
        { key: 'tiger_primary_roads_interstates_5m_all', name: 'TIGER Primary Roads Interstates 5M', color: '#dc2626', icon: '🛣️', layerType: 'tiger_primary_roads_interstates_5m' },
        { key: 'tiger_primary_roads_2_1m_all', name: 'TIGER Primary Roads 2_1M', color: '#dc2626', icon: '🛣️', layerType: 'tiger_primary_roads_2_1m' },
        { key: 'tiger_primary_roads_all', name: 'TIGER Primary Roads', color: '#dc2626', icon: '🛣️', layerType: 'tiger_primary_roads' },
        { key: 'tiger_secondary_roads_interstates_us_all', name: 'TIGER Secondary Roads Interstates and US Highways', color: '#f97316', icon: '🛣️', layerType: 'tiger_secondary_roads_interstates_us' },
        { key: 'tiger_secondary_roads_578k_all', name: 'TIGER Secondary Roads 578k', color: '#f97316', icon: '🛣️', layerType: 'tiger_secondary_roads_578k' },
        { key: 'tiger_secondary_roads_289_144k_all', name: 'TIGER Secondary Roads 289_144k', color: '#f97316', icon: '🛣️', layerType: 'tiger_secondary_roads_289_144k' },
        { key: 'tiger_secondary_roads_72_1k_all', name: 'TIGER Secondary Roads 72_1k', color: '#f97316', icon: '🛣️', layerType: 'tiger_secondary_roads_72_1k' },
        { key: 'tiger_local_roads_72k_all', name: 'TIGER Local Roads 72k', color: '#6b7280', icon: '🛣️', layerType: 'tiger_local_roads_72k' },
        { key: 'tiger_local_roads_all', name: 'TIGER Local Roads', color: '#6b7280', icon: '🛣️', layerType: 'tiger_local_roads' },
        { key: 'tiger_railroads_all', name: 'TIGER Railroads', color: '#92400e', icon: '🚂', layerType: 'tiger_railroads' }
      ];

      tigerTransportationLayers.forEach(({ key, name, color, icon, layerType }) => {
        if (enrichments[key] && Array.isArray(enrichments[key])) {
          let featureCount = 0;
          enrichments[key].forEach((feature: any) => {
            // Check for geometry in __geometry (for summary) or geometry (backward compatibility)
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = geometry.paths;
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    return [coord[1], coord[0]] as [number, number];
                  });

                  // Determine weight based on road type - ensure all are clickable
                  let weight = 2;
                  if (key.includes('railroad')) {
                    weight = 3;
                  } else if (key.includes('primary')) {
                    weight = 4;
                  } else if (key.includes('secondary')) {
                    weight = 3;
                  } else {
                    // Local roads - make thicker for better clickability
                    weight = 2.5;
                  }
                  
                  const polyline = L.polyline(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    interactive: true // Ensure polylines are clickable
                  });

                  // Build popup content with TIGER transportation attributes
                  const fullName = feature.fullName || 'Unknown';
                  const rttyp = feature.rttyp || null;
                  const mtfcc = feature.mtfcc || null;
                  const linearId = feature.linearId || null;
                  const distance = feature.distance_miles;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${fullName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${rttyp ? `<div><strong>Route Type:</strong> ${rttyp}</div>` : ''}
                        ${mtfcc ? `<div><strong>MTFCC:</strong> ${mtfcc}</div>` : ''}
                        ${linearId ? `<div><strong>Linear ID:</strong> ${linearId}</div>` : ''}
                        ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(primary);
                  
                  // Store metadata for tabbed popup
                  (polyline as any).__layerType = layerType;
                  (polyline as any).__layerTitle = name;
                  
                  bounds.extend(polyline.getBounds());
                });
                
                featureCount++;
              } catch (error) {
                console.error(`Error drawing ${name} polyline:`, error);
              }
            }
          });
          
          if (featureCount > 0) {
            if (!legendAccumulator[layerType]) {
              legendAccumulator[layerType] = {
                icon: icon,
                color: color,
                title: name,
                count: 0,
              };
            }
            legendAccumulator[layerType].count += featureCount;
          }
        }
      });

      // Draw TIGER School Districts as polygons on the map
      const tigerSchoolDistrictLayers = [
        { allKey: 'tiger_unified_school_districts_all', containingKey: 'tiger_unified_school_districts_containing', name: 'TIGER Unified School Districts', color: '#3b82f6', icon: '🏫', layerType: 'tiger_unified_school_districts' },
        { allKey: 'tiger_secondary_school_districts_all', containingKey: 'tiger_secondary_school_districts_containing', name: 'TIGER Secondary School Districts', color: '#8b5cf6', icon: '🏫', layerType: 'tiger_secondary_school_districts' },
        { allKey: 'tiger_elementary_school_districts_all', containingKey: 'tiger_elementary_school_districts_containing', name: 'TIGER Elementary School Districts', color: '#ec4899', icon: '🏫', layerType: 'tiger_elementary_school_districts' },
        { allKey: 'tiger_school_district_admin_areas_all', containingKey: 'tiger_school_district_admin_areas_containing', name: 'TIGER School District Administrative Areas', color: '#f59e0b', icon: '🏛️', layerType: 'tiger_school_district_admin_areas' },
        { allKey: 'tiger_bas2025_unified_school_districts_all', containingKey: 'tiger_bas2025_unified_school_districts_containing', name: 'TIGER BAS 2025 Unified School Districts', color: '#3b82f6', icon: '🏫', layerType: 'tiger_bas2025_unified_school_districts' },
        { allKey: 'tiger_bas2025_secondary_school_districts_all', containingKey: 'tiger_bas2025_secondary_school_districts_containing', name: 'TIGER BAS 2025 Secondary School Districts', color: '#8b5cf6', icon: '🏫', layerType: 'tiger_bas2025_secondary_school_districts' },
        { allKey: 'tiger_bas2025_elementary_school_districts_all', containingKey: 'tiger_bas2025_elementary_school_districts_containing', name: 'TIGER BAS 2025 Elementary School Districts', color: '#ec4899', icon: '🏫', layerType: 'tiger_bas2025_elementary_school_districts' },
        { allKey: 'tiger_bas2025_school_district_admin_areas_all', containingKey: 'tiger_bas2025_school_district_admin_areas_containing', name: 'TIGER BAS 2025 School District Administrative Areas', color: '#f59e0b', icon: '🏛️', layerType: 'tiger_bas2025_school_district_admin_areas' },
        { allKey: 'tiger_acs2024_unified_school_districts_all', containingKey: 'tiger_acs2024_unified_school_districts_containing', name: 'TIGER ACS 2024 Unified School Districts', color: '#3b82f6', icon: '🏫', layerType: 'tiger_acs2024_unified_school_districts' },
        { allKey: 'tiger_acs2024_secondary_school_districts_all', containingKey: 'tiger_acs2024_secondary_school_districts_containing', name: 'TIGER ACS 2024 Secondary School Districts', color: '#8b5cf6', icon: '🏫', layerType: 'tiger_acs2024_secondary_school_districts' },
        { allKey: 'tiger_acs2024_elementary_school_districts_all', containingKey: 'tiger_acs2024_elementary_school_districts_containing', name: 'TIGER ACS 2024 Elementary School Districts', color: '#ec4899', icon: '🏫', layerType: 'tiger_acs2024_elementary_school_districts' },
        { allKey: 'tiger_acs2024_school_district_admin_areas_all', containingKey: 'tiger_acs2024_school_district_admin_areas_containing', name: 'TIGER ACS 2024 School District Administrative Areas', color: '#f59e0b', icon: '🏛️', layerType: 'tiger_acs2024_school_district_admin_areas' },
        { allKey: 'tiger_census2020_unified_school_districts_all', containingKey: 'tiger_census2020_unified_school_districts_containing', name: 'TIGER Census 2020 Unified School Districts', color: '#3b82f6', icon: '🏫', layerType: 'tiger_census2020_unified_school_districts' },
        { allKey: 'tiger_census2020_secondary_school_districts_all', containingKey: 'tiger_census2020_secondary_school_districts_containing', name: 'TIGER Census 2020 Secondary School Districts', color: '#8b5cf6', icon: '🏫', layerType: 'tiger_census2020_secondary_school_districts' },
        { allKey: 'tiger_census2020_elementary_school_districts_all', containingKey: 'tiger_census2020_elementary_school_districts_containing', name: 'TIGER Census 2020 Elementary School Districts', color: '#ec4899', icon: '🏫', layerType: 'tiger_census2020_elementary_school_districts' }
      ];

      // Draw TIGER Special Land Use Areas as polygons on the map
      const tigerSpecialLandUseLayers = [
        { containingKey: 'tiger_nps_areas_containing', nearbyKey: 'tiger_nps_areas_nearby_features', name: 'TIGER National Park Service Areas', color: '#10b981', icon: '🏞️', layerType: 'tiger_nps_areas' },
        { containingKey: 'tiger_correctional_facilities_containing', nearbyKey: 'tiger_correctional_facilities_nearby_features', name: 'TIGER Correctional Facilities', color: '#ef4444', icon: '🏛️', layerType: 'tiger_correctional_facilities' },
        { containingKey: 'tiger_colleges_universities_containing', nearbyKey: 'tiger_colleges_universities_nearby_features', name: 'TIGER Colleges and Universities', color: '#8b5cf6', icon: '🎓', layerType: 'tiger_colleges_universities' },
        { containingKey: 'tiger_military_installations_containing', nearbyKey: 'tiger_military_installations_nearby_features', name: 'TIGER Military Installations', color: '#6366f1', icon: '⚔️', layerType: 'tiger_military_installations' }
      ];

      tigerSpecialLandUseLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing polygon
        if (enrichments[containingKey] && (enrichments[containingKey] as any).__geometry) {
          const feature = enrichments[containingKey];
          const geometry = (feature as any).__geometry || (feature as any).geometry;
          if (geometry && geometry.rings) {
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.9,
                  fillColor: color,
                  fillOpacity: 0.4
                });

                const featureName = (feature as any).name || 'Unknown';
                const stateFips = (feature as any).stateFips || '';
                const countyFips = (feature as any).countyFips || '';
                const landUseType = (feature as any).landUseType || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${featureName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing Area</div>
                      ${landUseType ? `<div><strong>Land Use Type:</strong> ${landUseType}</div>` : ''}
                      ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                      ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
                featureCount += 1;
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby features
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const featureName = feature.name || 'Unknown';
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';
                  const stateFips = feature.stateFips || '';
                  const countyFips = feature.countyFips || '';
                  const landUseType = feature.landUseType || '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${landUseType ? `<div><strong>Land Use Type:</strong> ${landUseType}</div>` : ''}
                        ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                        ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw TIGER Native Lands as polygons on the map
      const tigerNativeLandsLayers = [
        // Base layers (0-10)
        { containingKey: 'tiger_anrc_containing', nearbyKey: 'tiger_anrc_nearby_features', name: 'TIGER Alaska Native Regional Corporations', color: '#7c3aed', icon: '🏔️', layerType: 'tiger_anrc' },
        { containingKey: 'tiger_tribal_subdivisions_containing', nearbyKey: 'tiger_tribal_subdivisions_nearby_features', name: 'TIGER Tribal Subdivisions', color: '#a855f7', icon: '🏛️', layerType: 'tiger_tribal_subdivisions' },
        { containingKey: 'tiger_federal_air_containing', nearbyKey: 'tiger_federal_air_nearby_features', name: 'TIGER Federal American Indian Reservations', color: '#9333ea', icon: '🏜️', layerType: 'tiger_federal_air' },
        { containingKey: 'tiger_off_reservation_trust_containing', nearbyKey: 'tiger_off_reservation_trust_nearby_features', name: 'TIGER Off-Reservation Trust Lands', color: '#c084fc', icon: '🌾', layerType: 'tiger_off_reservation_trust' },
        { containingKey: 'tiger_state_air_containing', nearbyKey: 'tiger_state_air_nearby_features', name: 'TIGER State American Indian Reservations', color: '#d946ef', icon: '🏞️', layerType: 'tiger_state_air' },
        { containingKey: 'tiger_hhl_containing', nearbyKey: 'tiger_hhl_nearby_features', name: 'TIGER Hawaiian Home Lands', color: '#ec4899', icon: '🌺', layerType: 'tiger_hhl' },
        { containingKey: 'tiger_anvsa_containing', nearbyKey: 'tiger_anvsa_nearby_features', name: 'TIGER Alaska Native Village Statistical Areas', color: '#f472b6', icon: '❄️', layerType: 'tiger_anvsa' },
        { containingKey: 'tiger_otsa_containing', nearbyKey: 'tiger_otsa_nearby_features', name: 'TIGER Oklahoma Tribal Statistical Areas', color: '#fb7185', icon: '🌾', layerType: 'tiger_otsa' },
        { containingKey: 'tiger_sdtsa_containing', nearbyKey: 'tiger_sdtsa_nearby_features', name: 'TIGER State Designated Tribal Statistical Areas', color: '#fda4af', icon: '🏛️', layerType: 'tiger_sdtsa' },
        { containingKey: 'tiger_tdsa_containing', nearbyKey: 'tiger_tdsa_nearby_features', name: 'TIGER Tribal Designated Statistical Areas', color: '#fbbf24', icon: '🏛️', layerType: 'tiger_tdsa' },
        { containingKey: 'tiger_aijua_containing', nearbyKey: 'tiger_aijua_nearby_features', name: 'TIGER American Indian Joint-Use Areas', color: '#f59e0b', icon: '🤝', layerType: 'tiger_aijua' },
        // BAS 2025 layers (12-22)
        { containingKey: 'tiger_bas2025_anrc_containing', nearbyKey: 'tiger_bas2025_anrc_nearby_features', name: 'TIGER BAS 2025 Alaska Native Regional Corporations', color: '#7c3aed', icon: '🏔️', layerType: 'tiger_bas2025_anrc' },
        { containingKey: 'tiger_bas2025_tribal_subdivisions_containing', nearbyKey: 'tiger_bas2025_tribal_subdivisions_nearby_features', name: 'TIGER BAS 2025 Tribal Subdivisions', color: '#a855f7', icon: '🏛️', layerType: 'tiger_bas2025_tribal_subdivisions' },
        { containingKey: 'tiger_bas2025_federal_air_containing', nearbyKey: 'tiger_bas2025_federal_air_nearby_features', name: 'TIGER BAS 2025 Federal American Indian Reservations', color: '#9333ea', icon: '🏜️', layerType: 'tiger_bas2025_federal_air' },
        { containingKey: 'tiger_bas2025_off_reservation_trust_containing', nearbyKey: 'tiger_bas2025_off_reservation_trust_nearby_features', name: 'TIGER BAS 2025 Off-Reservation Trust Lands', color: '#c084fc', icon: '🌾', layerType: 'tiger_bas2025_off_reservation_trust' },
        { containingKey: 'tiger_bas2025_state_air_containing', nearbyKey: 'tiger_bas2025_state_air_nearby_features', name: 'TIGER BAS 2025 State American Indian Reservations', color: '#d946ef', icon: '🏞️', layerType: 'tiger_bas2025_state_air' },
        { containingKey: 'tiger_bas2025_hhl_containing', nearbyKey: 'tiger_bas2025_hhl_nearby_features', name: 'TIGER BAS 2025 Hawaiian Home Lands', color: '#ec4899', icon: '🌺', layerType: 'tiger_bas2025_hhl' },
        { containingKey: 'tiger_bas2025_anvsa_containing', nearbyKey: 'tiger_bas2025_anvsa_nearby_features', name: 'TIGER BAS 2025 Alaska Native Village Statistical Areas', color: '#f472b6', icon: '❄️', layerType: 'tiger_bas2025_anvsa' },
        { containingKey: 'tiger_bas2025_otsa_containing', nearbyKey: 'tiger_bas2025_otsa_nearby_features', name: 'TIGER BAS 2025 Oklahoma Tribal Statistical Areas', color: '#fb7185', icon: '🌾', layerType: 'tiger_bas2025_otsa' },
        { containingKey: 'tiger_bas2025_sdtsa_containing', nearbyKey: 'tiger_bas2025_sdtsa_nearby_features', name: 'TIGER BAS 2025 State Designated Tribal Statistical Areas', color: '#fda4af', icon: '🏛️', layerType: 'tiger_bas2025_sdtsa' },
        { containingKey: 'tiger_bas2025_tdsa_containing', nearbyKey: 'tiger_bas2025_tdsa_nearby_features', name: 'TIGER BAS 2025 Tribal Designated Statistical Areas', color: '#fbbf24', icon: '🏛️', layerType: 'tiger_bas2025_tdsa' },
        { containingKey: 'tiger_bas2025_aijua_containing', nearbyKey: 'tiger_bas2025_aijua_nearby_features', name: 'TIGER BAS 2025 American Indian Joint-Use Areas', color: '#f59e0b', icon: '🤝', layerType: 'tiger_bas2025_aijua' },
        // ACS 2024 layers (24-34)
        { containingKey: 'tiger_acs2024_anrc_containing', nearbyKey: 'tiger_acs2024_anrc_nearby_features', name: 'TIGER ACS 2024 Alaska Native Regional Corporations', color: '#7c3aed', icon: '🏔️', layerType: 'tiger_acs2024_anrc' },
        { containingKey: 'tiger_acs2024_tribal_subdivisions_containing', nearbyKey: 'tiger_acs2024_tribal_subdivisions_nearby_features', name: 'TIGER ACS 2024 Tribal Subdivisions', color: '#a855f7', icon: '🏛️', layerType: 'tiger_acs2024_tribal_subdivisions' },
        { containingKey: 'tiger_acs2024_federal_air_containing', nearbyKey: 'tiger_acs2024_federal_air_nearby_features', name: 'TIGER ACS 2024 Federal American Indian Reservations', color: '#9333ea', icon: '🏜️', layerType: 'tiger_acs2024_federal_air' },
        { containingKey: 'tiger_acs2024_off_reservation_trust_containing', nearbyKey: 'tiger_acs2024_off_reservation_trust_nearby_features', name: 'TIGER ACS 2024 Off-Reservation Trust Lands', color: '#c084fc', icon: '🌾', layerType: 'tiger_acs2024_off_reservation_trust' },
        { containingKey: 'tiger_acs2024_state_air_containing', nearbyKey: 'tiger_acs2024_state_air_nearby_features', name: 'TIGER ACS 2024 State American Indian Reservations', color: '#d946ef', icon: '🏞️', layerType: 'tiger_acs2024_state_air' },
        { containingKey: 'tiger_acs2024_hhl_containing', nearbyKey: 'tiger_acs2024_hhl_nearby_features', name: 'TIGER ACS 2024 Hawaiian Home Lands', color: '#ec4899', icon: '🌺', layerType: 'tiger_acs2024_hhl' },
        { containingKey: 'tiger_acs2024_anvsa_containing', nearbyKey: 'tiger_acs2024_anvsa_nearby_features', name: 'TIGER ACS 2024 Alaska Native Village Statistical Areas', color: '#f472b6', icon: '❄️', layerType: 'tiger_acs2024_anvsa' },
        { containingKey: 'tiger_acs2024_otsa_containing', nearbyKey: 'tiger_acs2024_otsa_nearby_features', name: 'TIGER ACS 2024 Oklahoma Tribal Statistical Areas', color: '#fb7185', icon: '🌾', layerType: 'tiger_acs2024_otsa' },
        { containingKey: 'tiger_acs2024_sdtsa_containing', nearbyKey: 'tiger_acs2024_sdtsa_nearby_features', name: 'TIGER ACS 2024 State Designated Tribal Statistical Areas', color: '#fda4af', icon: '🏛️', layerType: 'tiger_acs2024_sdtsa' },
        { containingKey: 'tiger_acs2024_tdsa_containing', nearbyKey: 'tiger_acs2024_tdsa_nearby_features', name: 'TIGER ACS 2024 Tribal Designated Statistical Areas', color: '#fbbf24', icon: '🏛️', layerType: 'tiger_acs2024_tdsa' },
        { containingKey: 'tiger_acs2024_aijua_containing', nearbyKey: 'tiger_acs2024_aijua_nearby_features', name: 'TIGER ACS 2024 American Indian Joint-Use Areas', color: '#f59e0b', icon: '🤝', layerType: 'tiger_acs2024_aijua' },
        // Census 2020 layers (36-46)
        { containingKey: 'tiger_census2020_anrc_containing', nearbyKey: 'tiger_census2020_anrc_nearby_features', name: 'TIGER Census 2020 Alaska Native Regional Corporations', color: '#7c3aed', icon: '🏔️', layerType: 'tiger_census2020_anrc' },
        { containingKey: 'tiger_census2020_tribal_subdivisions_containing', nearbyKey: 'tiger_census2020_tribal_subdivisions_nearby_features', name: 'TIGER Census 2020 Tribal Subdivisions', color: '#a855f7', icon: '🏛️', layerType: 'tiger_census2020_tribal_subdivisions' },
        { containingKey: 'tiger_census2020_federal_air_containing', nearbyKey: 'tiger_census2020_federal_air_nearby_features', name: 'TIGER Census 2020 Federal American Indian Reservations', color: '#9333ea', icon: '🏜️', layerType: 'tiger_census2020_federal_air' },
        { containingKey: 'tiger_census2020_off_reservation_trust_containing', nearbyKey: 'tiger_census2020_off_reservation_trust_nearby_features', name: 'TIGER Census 2020 Off-Reservation Trust Lands', color: '#c084fc', icon: '🌾', layerType: 'tiger_census2020_off_reservation_trust' },
        { containingKey: 'tiger_census2020_state_air_containing', nearbyKey: 'tiger_census2020_state_air_nearby_features', name: 'TIGER Census 2020 State American Indian Reservations', color: '#d946ef', icon: '🏞️', layerType: 'tiger_census2020_state_air' },
        { containingKey: 'tiger_census2020_hhl_containing', nearbyKey: 'tiger_census2020_hhl_nearby_features', name: 'TIGER Census 2020 Hawaiian Home Lands', color: '#ec4899', icon: '🌺', layerType: 'tiger_census2020_hhl' },
        { containingKey: 'tiger_census2020_anvsa_containing', nearbyKey: 'tiger_census2020_anvsa_nearby_features', name: 'TIGER Census 2020 Alaska Native Village Statistical Areas', color: '#f472b6', icon: '❄️', layerType: 'tiger_census2020_anvsa' },
        { containingKey: 'tiger_census2020_otsa_containing', nearbyKey: 'tiger_census2020_otsa_nearby_features', name: 'TIGER Census 2020 Oklahoma Tribal Statistical Areas', color: '#fb7185', icon: '🌾', layerType: 'tiger_census2020_otsa' },
        { containingKey: 'tiger_census2020_sdtsa_containing', nearbyKey: 'tiger_census2020_sdtsa_nearby_features', name: 'TIGER Census 2020 State Designated Tribal Statistical Areas', color: '#fda4af', icon: '🏛️', layerType: 'tiger_census2020_sdtsa' },
        { containingKey: 'tiger_census2020_tdsa_containing', nearbyKey: 'tiger_census2020_tdsa_nearby_features', name: 'TIGER Census 2020 Tribal Designated Statistical Areas', color: '#fbbf24', icon: '🏛️', layerType: 'tiger_census2020_tdsa' },
        { containingKey: 'tiger_census2020_aijua_containing', nearbyKey: 'tiger_census2020_aijua_nearby_features', name: 'TIGER Census 2020 American Indian Joint-Use Areas', color: '#f59e0b', icon: '🤝', layerType: 'tiger_census2020_aijua' }
      ];

      tigerNativeLandsLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing polygon
        if (enrichments[containingKey] && (enrichments[containingKey] as any).__geometry) {
          const feature = enrichments[containingKey];
          const geometry = (feature as any).__geometry || (feature as any).geometry;
          if (geometry && geometry.rings) {
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.9,
                  fillColor: color,
                  fillOpacity: 0.4
                });

                const featureName = (feature as any).name || 'Unknown';
                const stateFips = (feature as any).stateFips || '';
                const countyFips = (feature as any).countyFips || '';
                const areaType = (feature as any).areaType || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${featureName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing Area</div>
                      ${areaType ? `<div><strong>Area Type:</strong> ${areaType}</div>` : ''}
                      ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                      ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
                featureCount += 1;
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby features
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const featureName = feature.name || 'Unknown';
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';
                  const stateFips = feature.stateFips || '';
                  const countyFips = feature.countyFips || '';
                  const areaType = feature.areaType || '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${areaType ? `<div><strong>Area Type:</strong> ${areaType}</div>` : ''}
                        ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                        ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw TIGER CBSA as polygons on the map
      const tigerCBSALayers = [
        // Base layers (0-4)
        { containingKey: 'tiger_cbsa_combined_statistical_areas_containing', nearbyKey: 'tiger_cbsa_combined_statistical_areas_nearby_features', name: 'TIGER Combined Statistical Areas', color: '#3b82f6', icon: '🏙️', layerType: 'tiger_cbsa_combined_statistical_areas' },
        { containingKey: 'tiger_cbsa_metro_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_cbsa_metro_micropolitan_statistical_areas_nearby_features', name: 'TIGER Metropolitan and Micropolitan Statistical Areas', color: '#2563eb', icon: '🏙️', layerType: 'tiger_cbsa_metro_micropolitan_statistical_areas' },
        { containingKey: 'tiger_cbsa_metropolitan_divisions_containing', nearbyKey: 'tiger_cbsa_metropolitan_divisions_nearby_features', name: 'TIGER Metropolitan Divisions', color: '#1d4ed8', icon: '🏙️', layerType: 'tiger_cbsa_metropolitan_divisions' },
        { containingKey: 'tiger_cbsa_metropolitan_statistical_areas_containing', nearbyKey: 'tiger_cbsa_metropolitan_statistical_areas_nearby_features', name: 'TIGER Metropolitan Statistical Areas', color: '#1e40af', icon: '🏙️', layerType: 'tiger_cbsa_metropolitan_statistical_areas' },
        { containingKey: 'tiger_cbsa_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_cbsa_micropolitan_statistical_areas_nearby_features', name: 'TIGER Micropolitan Statistical Areas', color: '#1e3a8a', icon: '🏙️', layerType: 'tiger_cbsa_micropolitan_statistical_areas' },
        // BAS 2025 layers (6-10)
        { containingKey: 'tiger_bas2025_cbsa_combined_statistical_areas_containing', nearbyKey: 'tiger_bas2025_cbsa_combined_statistical_areas_nearby_features', name: 'TIGER BAS 2025 Combined Statistical Areas', color: '#3b82f6', icon: '🏙️', layerType: 'tiger_bas2025_cbsa_combined_statistical_areas' },
        { containingKey: 'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas_nearby_features', name: 'TIGER BAS 2025 Metropolitan and Micropolitan Statistical Areas', color: '#2563eb', icon: '🏙️', layerType: 'tiger_bas2025_cbsa_metro_micropolitan_statistical_areas' },
        { containingKey: 'tiger_bas2025_cbsa_metropolitan_divisions_containing', nearbyKey: 'tiger_bas2025_cbsa_metropolitan_divisions_nearby_features', name: 'TIGER BAS 2025 Metropolitan Divisions', color: '#1d4ed8', icon: '🏙️', layerType: 'tiger_bas2025_cbsa_metropolitan_divisions' },
        { containingKey: 'tiger_bas2025_cbsa_metropolitan_statistical_areas_containing', nearbyKey: 'tiger_bas2025_cbsa_metropolitan_statistical_areas_nearby_features', name: 'TIGER BAS 2025 Metropolitan Statistical Areas', color: '#1e40af', icon: '🏙️', layerType: 'tiger_bas2025_cbsa_metropolitan_statistical_areas' },
        { containingKey: 'tiger_bas2025_cbsa_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_bas2025_cbsa_micropolitan_statistical_areas_nearby_features', name: 'TIGER BAS 2025 Micropolitan Statistical Areas', color: '#1e3a8a', icon: '🏙️', layerType: 'tiger_bas2025_cbsa_micropolitan_statistical_areas' },
        // ACS 2024 layers (12-16)
        { containingKey: 'tiger_acs2024_cbsa_combined_statistical_areas_containing', nearbyKey: 'tiger_acs2024_cbsa_combined_statistical_areas_nearby_features', name: 'TIGER ACS 2024 Combined Statistical Areas', color: '#3b82f6', icon: '🏙️', layerType: 'tiger_acs2024_cbsa_combined_statistical_areas' },
        { containingKey: 'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas_nearby_features', name: 'TIGER ACS 2024 Metropolitan and Micropolitan Statistical Areas', color: '#2563eb', icon: '🏙️', layerType: 'tiger_acs2024_cbsa_metro_micropolitan_statistical_areas' },
        { containingKey: 'tiger_acs2024_cbsa_metropolitan_divisions_containing', nearbyKey: 'tiger_acs2024_cbsa_metropolitan_divisions_nearby_features', name: 'TIGER ACS 2024 Metropolitan Divisions', color: '#1d4ed8', icon: '🏙️', layerType: 'tiger_acs2024_cbsa_metropolitan_divisions' },
        { containingKey: 'tiger_acs2024_cbsa_metropolitan_statistical_areas_containing', nearbyKey: 'tiger_acs2024_cbsa_metropolitan_statistical_areas_nearby_features', name: 'TIGER ACS 2024 Metropolitan Statistical Areas', color: '#1e40af', icon: '🏙️', layerType: 'tiger_acs2024_cbsa_metropolitan_statistical_areas' },
        { containingKey: 'tiger_acs2024_cbsa_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_acs2024_cbsa_micropolitan_statistical_areas_nearby_features', name: 'TIGER ACS 2024 Micropolitan Statistical Areas', color: '#1e3a8a', icon: '🏙️', layerType: 'tiger_acs2024_cbsa_micropolitan_statistical_areas' },
        // Census 2020 layers (18-27)
        { containingKey: 'tiger_census2020_cbsa_combined_new_england_city_town_areas_containing', nearbyKey: 'tiger_census2020_cbsa_combined_new_england_city_town_areas_nearby_features', name: 'TIGER Census 2020 Combined New England City and Town Areas', color: '#3b82f6', icon: '🏙️', layerType: 'tiger_census2020_cbsa_combined_new_england_city_town_areas' },
        { containingKey: 'tiger_census2020_cbsa_new_england_city_town_areas_containing', nearbyKey: 'tiger_census2020_cbsa_new_england_city_town_areas_nearby_features', name: 'TIGER Census 2020 New England City and Town Areas', color: '#2563eb', icon: '🏙️', layerType: 'tiger_census2020_cbsa_new_england_city_town_areas' },
        { containingKey: 'tiger_census2020_cbsa_new_england_city_town_area_divisions_containing', nearbyKey: 'tiger_census2020_cbsa_new_england_city_town_area_divisions_nearby_features', name: 'TIGER Census 2020 New England City and Town Area Divisions', color: '#1d4ed8', icon: '🏙️', layerType: 'tiger_census2020_cbsa_new_england_city_town_area_divisions' },
        { containingKey: 'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas_containing', nearbyKey: 'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas_nearby_features', name: 'TIGER Census 2020 Metropolitan New England City and Town Areas', color: '#1e40af', icon: '🏙️', layerType: 'tiger_census2020_cbsa_metropolitan_new_england_city_town_areas' },
        { containingKey: 'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas_containing', nearbyKey: 'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas_nearby_features', name: 'TIGER Census 2020 Micropolitan New England City and Town Areas', color: '#1e3a8a', icon: '🏙️', layerType: 'tiger_census2020_cbsa_micropolitan_new_england_city_town_areas' },
        { containingKey: 'tiger_census2020_cbsa_combined_statistical_areas_containing', nearbyKey: 'tiger_census2020_cbsa_combined_statistical_areas_nearby_features', name: 'TIGER Census 2020 Combined Statistical Areas', color: '#3b82f6', icon: '🏙️', layerType: 'tiger_census2020_cbsa_combined_statistical_areas' },
        { containingKey: 'tiger_census2020_cbsa_metro_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_census2020_cbsa_metro_micropolitan_statistical_areas_nearby_features', name: 'TIGER Census 2020 Metropolitan and Micropolitan Statistical Areas', color: '#2563eb', icon: '🏙️', layerType: 'tiger_census2020_cbsa_metro_micropolitan_statistical_areas' },
        { containingKey: 'tiger_census2020_cbsa_metropolitan_divisions_containing', nearbyKey: 'tiger_census2020_cbsa_metropolitan_divisions_nearby_features', name: 'TIGER Census 2020 Metropolitan Divisions', color: '#1d4ed8', icon: '🏙️', layerType: 'tiger_census2020_cbsa_metropolitan_divisions' },
        { containingKey: 'tiger_census2020_cbsa_metropolitan_statistical_areas_containing', nearbyKey: 'tiger_census2020_cbsa_metropolitan_statistical_areas_nearby_features', name: 'TIGER Census 2020 Metropolitan Statistical Areas', color: '#1e40af', icon: '🏙️', layerType: 'tiger_census2020_cbsa_metropolitan_statistical_areas' },
        { containingKey: 'tiger_census2020_cbsa_micropolitan_statistical_areas_containing', nearbyKey: 'tiger_census2020_cbsa_micropolitan_statistical_areas_nearby_features', name: 'TIGER Census 2020 Micropolitan Statistical Areas', color: '#1e3a8a', icon: '🏙️', layerType: 'tiger_census2020_cbsa_micropolitan_statistical_areas' }
      ];

      tigerCBSALayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing polygon
        if (enrichments[containingKey] && (enrichments[containingKey] as any).__geometry) {
          const feature = enrichments[containingKey];
          const geometry = (feature as any).__geometry || (feature as any).geometry;
          if (geometry && geometry.rings) {
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.9,
                  fillColor: color,
                  fillOpacity: 0.4
                });

                const featureName = (feature as any).name || 'Unknown';
                const stateFips = (feature as any).stateFips || '';
                const countyFips = (feature as any).countyFips || '';
                const cbsaType = (feature as any).cbsaType || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${featureName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing Area</div>
                      ${cbsaType ? `<div><strong>CBSA Type:</strong> ${cbsaType}</div>` : ''}
                      ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                      ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
                featureCount += 1;
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby features
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const featureName = feature.name || 'Unknown';
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';
                  const stateFips = feature.stateFips || '';
                  const countyFips = feature.countyFips || '';
                  const cbsaType = feature.cbsaType || '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${cbsaType ? `<div><strong>CBSA Type:</strong> ${cbsaType}</div>` : ''}
                        ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                        ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw TIGER Places and County Subdivisions as polygons on the map
      const tigerPlacesLayers = [
        // Base layers (0-5)
        { containingKey: 'tiger_places_estates_layer0_containing', nearbyKey: 'tiger_places_estates_layer0_nearby_features', name: 'TIGER Places - Estates', color: '#8b5cf6', icon: '🏘️', layerType: 'tiger_places_estates_layer0' },
        { containingKey: 'tiger_places_county_subdivisions_layer1_containing', nearbyKey: 'tiger_places_county_subdivisions_layer1_nearby_features', name: 'TIGER Places - County Subdivisions', color: '#7c3aed', icon: '🏘️', layerType: 'tiger_places_county_subdivisions_layer1' },
        { containingKey: 'tiger_places_subbarrios_layer2_containing', nearbyKey: 'tiger_places_subbarrios_layer2_nearby_features', name: 'TIGER Places - Subbarrios', color: '#6d28d9', icon: '🏘️', layerType: 'tiger_places_subbarrios_layer2' },
        { containingKey: 'tiger_places_consolidated_cities_layer3_containing', nearbyKey: 'tiger_places_consolidated_cities_layer3_nearby_features', name: 'TIGER Places - Consolidated Cities', color: '#5b21b6', icon: '🏙️', layerType: 'tiger_places_consolidated_cities_layer3' },
        { containingKey: 'tiger_places_incorporated_places_layer4_containing', nearbyKey: 'tiger_places_incorporated_places_layer4_nearby_features', name: 'TIGER Places - Incorporated Places', color: '#4c1d95', icon: '🏙️', layerType: 'tiger_places_incorporated_places_layer4' },
        { containingKey: 'tiger_places_census_designated_places_layer5_containing', nearbyKey: 'tiger_places_census_designated_places_layer5_nearby_features', name: 'TIGER Places - Census Designated Places', color: '#3b0f7a', icon: '🏘️', layerType: 'tiger_places_census_designated_places_layer5' },
        // BAS 2025 layers (6-12)
        { containingKey: 'tiger_places_bas2025_group_layer6_containing', nearbyKey: 'tiger_places_bas2025_group_layer6_nearby_features', name: 'TIGER Places - BAS 2025 Group', color: '#a78bfa', icon: '🏘️', layerType: 'tiger_places_bas2025_group_layer6' },
        { containingKey: 'tiger_places_bas2025_estates_layer7_containing', nearbyKey: 'tiger_places_bas2025_estates_layer7_nearby_features', name: 'TIGER Places - BAS 2025 Estates', color: '#8b5cf6', icon: '🏘️', layerType: 'tiger_places_bas2025_estates_layer7' },
        { containingKey: 'tiger_places_bas2025_county_subdivisions_layer8_containing', nearbyKey: 'tiger_places_bas2025_county_subdivisions_layer8_nearby_features', name: 'TIGER Places - BAS 2025 County Subdivisions', color: '#7c3aed', icon: '🏘️', layerType: 'tiger_places_bas2025_county_subdivisions_layer8' },
        { containingKey: 'tiger_places_bas2025_subbarrios_layer9_containing', nearbyKey: 'tiger_places_bas2025_subbarrios_layer9_nearby_features', name: 'TIGER Places - BAS 2025 Subbarrios', color: '#6d28d9', icon: '🏘️', layerType: 'tiger_places_bas2025_subbarrios_layer9' },
        { containingKey: 'tiger_places_bas2025_consolidated_cities_layer10_containing', nearbyKey: 'tiger_places_bas2025_consolidated_cities_layer10_nearby_features', name: 'TIGER Places - BAS 2025 Consolidated Cities', color: '#5b21b6', icon: '🏙️', layerType: 'tiger_places_bas2025_consolidated_cities_layer10' },
        { containingKey: 'tiger_places_bas2025_incorporated_places_layer11_containing', nearbyKey: 'tiger_places_bas2025_incorporated_places_layer11_nearby_features', name: 'TIGER Places - BAS 2025 Incorporated Places', color: '#4c1d95', icon: '🏙️', layerType: 'tiger_places_bas2025_incorporated_places_layer11' },
        { containingKey: 'tiger_places_bas2025_census_designated_places_layer12_containing', nearbyKey: 'tiger_places_bas2025_census_designated_places_layer12_nearby_features', name: 'TIGER Places - BAS 2025 Census Designated Places', color: '#3b0f7a', icon: '🏘️', layerType: 'tiger_places_bas2025_census_designated_places_layer12' },
        // ACS 2024 layers (13-19)
        { containingKey: 'tiger_places_acs2024_group_layer13_containing', nearbyKey: 'tiger_places_acs2024_group_layer13_nearby_features', name: 'TIGER Places - ACS 2024 Group', color: '#c4b5fd', icon: '🏘️', layerType: 'tiger_places_acs2024_group_layer13' },
        { containingKey: 'tiger_places_acs2024_estates_layer14_containing', nearbyKey: 'tiger_places_acs2024_estates_layer14_nearby_features', name: 'TIGER Places - ACS 2024 Estates', color: '#a78bfa', icon: '🏘️', layerType: 'tiger_places_acs2024_estates_layer14' },
        { containingKey: 'tiger_places_acs2024_county_subdivisions_layer15_containing', nearbyKey: 'tiger_places_acs2024_county_subdivisions_layer15_nearby_features', name: 'TIGER Places - ACS 2024 County Subdivisions', color: '#8b5cf6', icon: '🏘️', layerType: 'tiger_places_acs2024_county_subdivisions_layer15' },
        { containingKey: 'tiger_places_acs2024_subbarrios_layer16_containing', nearbyKey: 'tiger_places_acs2024_subbarrios_layer16_nearby_features', name: 'TIGER Places - ACS 2024 Subbarrios', color: '#7c3aed', icon: '🏘️', layerType: 'tiger_places_acs2024_subbarrios_layer16' },
        { containingKey: 'tiger_places_acs2024_consolidated_cities_layer17_containing', nearbyKey: 'tiger_places_acs2024_consolidated_cities_layer17_nearby_features', name: 'TIGER Places - ACS 2024 Consolidated Cities', color: '#6d28d9', icon: '🏙️', layerType: 'tiger_places_acs2024_consolidated_cities_layer17' },
        { containingKey: 'tiger_places_acs2024_incorporated_places_layer18_containing', nearbyKey: 'tiger_places_acs2024_incorporated_places_layer18_nearby_features', name: 'TIGER Places - ACS 2024 Incorporated Places', color: '#5b21b6', icon: '🏙️', layerType: 'tiger_places_acs2024_incorporated_places_layer18' },
        { containingKey: 'tiger_places_acs2024_census_designated_places_layer19_containing', nearbyKey: 'tiger_places_acs2024_census_designated_places_layer19_nearby_features', name: 'TIGER Places - ACS 2024 Census Designated Places', color: '#4c1d95', icon: '🏘️', layerType: 'tiger_places_acs2024_census_designated_places_layer19' },
        // Census 2020 layers (20-26)
        { containingKey: 'tiger_places_census2020_group_layer20_containing', nearbyKey: 'tiger_places_census2020_group_layer20_nearby_features', name: 'TIGER Places - Census 2020 Group', color: '#ddd6fe', icon: '🏘️', layerType: 'tiger_places_census2020_group_layer20' },
        { containingKey: 'tiger_places_census2020_estates_layer21_containing', nearbyKey: 'tiger_places_census2020_estates_layer21_nearby_features', name: 'TIGER Places - Census 2020 Estates', color: '#c4b5fd', icon: '🏘️', layerType: 'tiger_places_census2020_estates_layer21' },
        { containingKey: 'tiger_places_census2020_county_subdivisions_layer22_containing', nearbyKey: 'tiger_places_census2020_county_subdivisions_layer22_nearby_features', name: 'TIGER Places - Census 2020 County Subdivisions', color: '#a78bfa', icon: '🏘️', layerType: 'tiger_places_census2020_county_subdivisions_layer22' },
        { containingKey: 'tiger_places_census2020_subbarrios_layer23_containing', nearbyKey: 'tiger_places_census2020_subbarrios_layer23_nearby_features', name: 'TIGER Places - Census 2020 Subbarrios', color: '#8b5cf6', icon: '🏘️', layerType: 'tiger_places_census2020_subbarrios_layer23' },
        { containingKey: 'tiger_places_census2020_consolidated_cities_layer24_containing', nearbyKey: 'tiger_places_census2020_consolidated_cities_layer24_nearby_features', name: 'TIGER Places - Census 2020 Consolidated Cities', color: '#7c3aed', icon: '🏙️', layerType: 'tiger_places_census2020_consolidated_cities_layer24' },
        { containingKey: 'tiger_places_census2020_incorporated_places_layer25_containing', nearbyKey: 'tiger_places_census2020_incorporated_places_layer25_nearby_features', name: 'TIGER Places - Census 2020 Incorporated Places', color: '#6d28d9', icon: '🏙️', layerType: 'tiger_places_census2020_incorporated_places_layer25' },
        { containingKey: 'tiger_places_census2020_census_designated_places_layer26_containing', nearbyKey: 'tiger_places_census2020_census_designated_places_layer26_nearby_features', name: 'TIGER Places - Census 2020 Census Designated Places', color: '#5b21b6', icon: '🏘️', layerType: 'tiger_places_census2020_census_designated_places_layer26' }
      ];

      tigerPlacesLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing polygon (only polygon geometry - rings, not paths)
        if (enrichments[containingKey] && (enrichments[containingKey] as any).__geometry) {
          const feature = enrichments[containingKey];
          const geometry = (feature as any).__geometry || (feature as any).geometry;
          if (geometry && geometry.rings && !geometry.paths) { // Only render polygon geometry
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.9,
                  fillColor: color,
                  fillOpacity: 0.4
                });

                const featureName = (feature as any).name || 'Unknown';
                const stateFips = (feature as any).stateFips || '';
                const countyFips = (feature as any).countyFips || '';
                const placeType = (feature as any).placeType || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${featureName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing Area</div>
                      ${placeType ? `<div><strong>Place Type:</strong> ${placeType}</div>` : ''}
                      ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                      ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
                featureCount += 1;
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby features (only polygon geometry - rings, not paths)
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings && !geometry.paths) { // Only render polygon geometry
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const featureName = feature.name || 'Unknown';
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';
                  const stateFips = feature.stateFips || '';
                  const countyFips = feature.countyFips || '';
                  const placeType = feature.placeType || '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${placeType ? `<div><strong>Place Type:</strong> ${placeType}</div>` : ''}
                        ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                        ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend with radius display (show even if no features drawn if counts exist)
        if (featureCount > 0 || (enrichments[`${layerType}_containing_count`] !== undefined || enrichments[`${layerType}_nearby_count`] !== undefined)) {
          if (!legendAccumulator[layerType]) {
            const radius = enrichments[`${layerType}_search_radius_miles`];
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
              radius: radius,
              radiusDisplay: radius ? `${radius.toFixed(1)} mi` : undefined
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Provinces as polygons on the map
      const irelandProvinceLayers = [
        { containingKey: 'ireland_provinces_containing', nearbyKey: 'ireland_provinces_nearby_features', name: 'Ireland Provinces', color: '#10b981', icon: '🇮🇪', layerType: 'ireland_provinces' }
      ];

      // Draw Ireland Built-Up Areas as polygons on the map
      const irelandBuiltUpAreaLayers = [
        { containingKey: 'ireland_built_up_areas_containing', nearbyKey: 'ireland_built_up_areas_nearby_features', name: 'Ireland Built-Up Areas', color: '#3b82f6', icon: '🏘️', layerType: 'ireland_built_up_areas' }
      ];

      // Draw Ireland Small Areas as polygons on the map
      const irelandSmallAreaLayers = [
        { containingKey: 'ireland_small_areas_containing', nearbyKey: 'ireland_small_areas_nearby_features', name: 'Ireland Small Areas', color: '#8b5cf6', icon: '📍', layerType: 'ireland_small_areas' }
      ];

      // Draw Ireland Electoral Divisions as polygons on the map
      const irelandElectoralDivisionLayers = [
        { containingKey: 'ireland_electoral_divisions_containing', nearbyKey: 'ireland_electoral_divisions_nearby_features', name: 'Ireland Electoral Divisions', color: '#a855f7', icon: '🗳️', layerType: 'ireland_electoral_divisions' }
      ];

      // Draw Ireland NUTS3 Boundaries as polygons on the map
      const irelandNUTS3Layers = [
        { containingKey: 'ireland_nuts3_boundaries_containing', nearbyKey: 'ireland_nuts3_boundaries_nearby_features', name: 'Ireland NUTS3 Boundaries', color: '#9333ea', icon: '🗺️', layerType: 'ireland_nuts3_boundaries' }
      ];

      // Draw Ireland Civil Parishes as polygons on the map
      const irelandCivilParishLayers = [
        { containingKey: 'ireland_civil_parishes_containing', nearbyKey: 'ireland_civil_parishes_nearby_features', name: 'Ireland Civil Parishes', color: '#7c3aed', icon: '⛪', layerType: 'ireland_civil_parishes' }
      ];

      // Draw Ireland Buildings as polygons on the map
      const irelandBuildingLayers = [
        { containingKey: 'ireland_buildings_residential_containing', nearbyKey: 'ireland_buildings_residential_nearby_features', name: 'Ireland Buildings - Residential', color: '#6d28d9', icon: '🏠', layerType: 'ireland_buildings_residential' },
        { containingKey: 'ireland_buildings_residential_commercial_containing', nearbyKey: 'ireland_buildings_residential_commercial_nearby_features', name: 'Ireland Buildings - Residential/Commercial', color: '#5b21b6', icon: '🏢', layerType: 'ireland_buildings_residential_commercial' },
        { containingKey: 'ireland_buildings_commercial_containing', nearbyKey: 'ireland_buildings_commercial_nearby_features', name: 'Ireland Buildings - Commercial', color: '#4c1d95', icon: '🏬', layerType: 'ireland_buildings_commercial' }
      ];

      // Draw Ireland Vegetation Areas as polygons on the map
      const irelandVegetationAreaLayers = [
        { containingKey: 'ireland_vegetation_areas_containing', nearbyKey: 'ireland_vegetation_areas_nearby_features', name: 'Ireland Vegetation Areas', color: '#16a34a', icon: '🌿', layerType: 'ireland_vegetation_areas' }
      ];

      // Draw UK Local Authority Districts, Built-Up Areas, and other UK stats polygons on the map
      const ukLocalAuthorityDistrictLayers = [
        { containingKey: 'uk_built_up_areas_2024_containing', nearbyKey: 'uk_built_up_areas_2024_nearby', name: 'UK Built-Up Areas (Dec 2024)', color: '#16a34a', icon: '🏙️', layerType: 'uk_built_up_areas_2024' },
        { containingKey: 'uk_wales_local_health_boards_containing', nearbyKey: 'uk_wales_local_health_boards_nearby', name: 'Wales Local Health Boards', color: '#0ea5e9', icon: '🏥', layerType: 'uk_wales_local_health_boards' },
        { containingKey: 'uk_national_parks_containing', nearbyKey: 'uk_national_parks_nearby', name: 'National Parks (Dec 2022)', color: '#059669', icon: '🏞️', layerType: 'uk_national_parks' },
        { containingKey: 'uk_local_authority_districts_containing', nearbyKey: 'uk_local_authority_districts_nearby', name: 'UK Local Authority Districts', color: '#dc2626', icon: '🇬🇧', layerType: 'uk_local_authority_districts' },
        { containingKey: 'uk_counties_unitary_authorities_containing', nearbyKey: 'uk_counties_unitary_authorities_nearby', name: 'UK Counties & Unitary Authorities', color: '#7c3aed', icon: '🗺️', layerType: 'uk_counties_unitary_authorities' },
        { containingKey: 'uk_cancer_alliances_containing', nearbyKey: 'uk_cancer_alliances_nearby', name: 'Cancer Alliances (July 2023)', color: '#ec4899', icon: '🎗️', layerType: 'uk_cancer_alliances' },
        { containingKey: 'uk_geostat_grid_containing', nearbyKey: 'uk_geostat_grid_nearby', name: 'GEOSTAT Grid (2011)', color: '#22c55e', icon: '📊', layerType: 'uk_geostat_grid' },
        { containingKey: 'uk_fire_rescue_authorities_containing', nearbyKey: 'uk_fire_rescue_authorities_nearby', name: 'Fire & Rescue Authorities (Dec 2023)', color: '#f97316', icon: '🚒', layerType: 'uk_fire_rescue_authorities' },
        { containingKey: 'uk_police_force_areas_containing', nearbyKey: 'uk_police_force_areas_nearby', name: 'Police Force Areas (Dec 2023)', color: '#0ea5e9', icon: '🚓', layerType: 'uk_police_force_areas' },
        { containingKey: 'uk_workplace_zones_containing', nearbyKey: 'uk_workplace_zones_nearby', name: 'Workplace Zones (2011)', color: '#f97316', icon: '🏢', layerType: 'uk_workplace_zones' },
        { containingKey: 'uk_lsoa_2021_ruc_containing', nearbyKey: 'uk_lsoa_2021_ruc_nearby', name: 'Lower Layer Super Output Areas (LSOA 2021)', color: '#0ea5e9', icon: '🧭', layerType: 'uk_lsoa_2021_ruc' },
        { containingKey: 'uk_european_electoral_regions_containing', nearbyKey: 'uk_european_electoral_regions_nearby', name: 'European Electoral Regions (Dec 2018)', color: '#22c55e', icon: '🇪🇺', layerType: 'uk_european_electoral_regions' }
      ];

      // Draw Ireland Provinces as polygons on the map
      irelandProvinceLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;

        // Draw containing province
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((province: any) => {
            const geometry = province.__geometry || province.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (Array.isArray(rings) && rings.length > 0) {
                  // Convert all rings to Leaflet lat/lngs so we draw every part
                  const latlngs = rings.map((ring: number[][]) =>
                    ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number])
                  );

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const provinceName = province.name || 'Unknown Province';
                  const provinceId = province.provinceId || '';
                  const area = province.area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${provinceName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Province</div>
                        ${provinceId ? `<div><strong>Province ID:</strong> ${provinceId}</div>` : ''}
                        ${area ? `<div><strong>Area:</strong> ${area.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other province attributes
                  const excludeFields = ['name', 'provinceId', 'area', 'geometry', '__geometry', 'distance_miles', 'objectId', 'guid', 'centroidX', 'centroidY'];
                  Object.entries(province).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing province:`, error);
              }
            }
          });
        }

        // Draw nearby provinces
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((province: any) => {
            const geometry = province.__geometry || province.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (Array.isArray(rings) && rings.length > 0) {
                  // Convert all rings to Leaflet lat/lngs so we draw every part
                  const latlngs = rings.map((ring: number[][]) =>
                    ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number])
                  );

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 1,
                    opacity: 0.5,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  const provinceName = province.name || 'Unknown Province';
                  const provinceId = province.provinceId || '';
                  const area = province.area || 0;
                  const distance = province.distance_miles ? province.distance_miles.toFixed(2) : 'Unknown';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${provinceName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Nearby Province</div>
                        ${provinceId ? `<div><strong>Province ID:</strong> ${provinceId}</div>` : ''}
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${area ? `<div><strong>Area:</strong> ${area.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other province attributes
                  const excludeFields = ['name', 'provinceId', 'area', 'geometry', '__geometry', 'distance_miles', 'objectId', 'guid', 'centroidX', 'centroidY'];
                  Object.entries(province).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby province:`, error);
              }
            }
          });
        }

        if (featureCount > 0) {
          const existing = legendAccumulator[name];
          if (existing) {
            existing.count += featureCount;
          } else {
            legendAccumulator[name] = {
              icon,
              color,
              title: name,
              count: featureCount
            };
          }
        }
      });

      // Draw UK stats polygons (including Built-Up Areas) on the map
      ukLocalAuthorityDistrictLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing polygon(s) for UK stats layers (including Built-Up Areas)
        const containingFeatures: any[] = Array.isArray(enrichments[containingKey])
          ? enrichments[containingKey]
          : [];

        if (layerType === 'uk_built_up_areas_2024') {
          console.log('UK Built-Up Areas – containing features length:', containingFeatures.length);
        }

        if (containingFeatures.length > 0) {
          containingFeatures.forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (Array.isArray(rings) && rings.length > 0) {
                  let latlngs: L.LatLngExpression[] | L.LatLngExpression[][] = [];

                  if (layerType === 'uk_built_up_areas_2024' || layerType === 'uk_wales_local_health_boards' || layerType === 'uk_national_parks') {
                    // For Built-Up Areas, Wales Local Health Boards, and National Parks, draw ALL rings of the multipart polygon
                    // Convert all rings to latlngs format for multipolygon
                    const allRings = rings.map((ring: number[][]) => {
                      if (!Array.isArray(ring) || ring.length < 3) return [];
                      return ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                    }).filter(ring => ring.length > 0);
                    
                    // Use multipolygon format: array of arrays of coordinates
                    latlngs = allRings as L.LatLngExpression[][];
                  } else {
                    // For other UK stats layers, continue to draw the full polygon (outer ring only).
                    const outerRing = rings[0];
                    latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  }

                  const polygon = L.polygon(latlngs as any, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  // Determine display name / code / type label per UK layer
                  let displayName: string = 'Feature';
                  let displayCode: string | null = null;
                  let typeLabel: string = 'Containing Area';

                  if (layerType === 'uk_built_up_areas_2024') {
                    displayName = feature.bua24nm || feature.BUA24NM || 'Built-Up Area';
                    displayCode = feature.bua24cd || feature.BUA24CD || null;
                    typeLabel = 'Containing Built-Up Area';
                  } else if (layerType === 'uk_wales_local_health_boards') {
                    displayName = feature.lhb23nm || feature.LHB23NM || 'Local Health Board';
                    displayCode = feature.lhb23cd || feature.LHB23CD || null;
                    typeLabel = 'Containing Local Health Board';
                  } else if (layerType === 'uk_national_parks') {
                    displayName = feature.npark22nmw || feature.NPARK22NMW || feature.npark22nm || feature.NPARK22NM || 'National Park';
                    displayCode = feature.npark22cd || feature.NPARK22CD || null;
                    typeLabel = 'Containing National Park';
                  } else if (layerType === 'uk_local_authority_districts') {
                    displayName = feature.lad25nm || feature.LAD25NM || 'Local Authority District';
                    displayCode = feature.lad25cd || feature.LAD25CD || null;
                    typeLabel = 'Containing Local Authority District';
                  } else if (layerType === 'uk_counties_unitary_authorities') {
                    displayName = feature.ctyua21nm || feature.CTYUA21NM || 'County / Unitary Authority';
                    displayCode = feature.ctyua21cd || feature.CTYUA21CD || null;
                    typeLabel = 'Containing County / Unitary Authority';
                  } else if (layerType === 'uk_cancer_alliances') {
                    displayName = feature.cal23nm || feature.CAL23NM || 'Cancer Alliance';
                    displayCode = feature.cal23cd || feature.CAL23CD || null;
                    typeLabel = 'Containing Cancer Alliance';
                  } else if (layerType === 'uk_geostat_grid') {
                    displayName =
                      feature.grd_newid || feature.GRD_NEWID ||
                      feature.grd_fixid || feature.GRD_FIXID ||
                      'GEOSTAT Grid Cell';
                    typeLabel = 'Containing GEOSTAT Grid Cell';
                  } else if (layerType === 'uk_fire_rescue_authorities') {
                    displayName = feature.fra23nm || feature.FRA23NM || 'Fire & Rescue Authority';
                    displayCode = feature.fra23cd || feature.FRA23CD || null;
                    typeLabel = 'Containing Fire & Rescue Authority';
                  } else if (layerType === 'uk_police_force_areas') {
                    displayName = feature.pfa23nm || feature.PFA23NM || 'Police Force Area';
                    displayCode = feature.pfa23cd || feature.PFA23CD || null;
                    typeLabel = 'Containing Police Force Area';
                  } else if (layerType === 'uk_workplace_zones') {
                    displayName = feature.wz11cd || feature.WZ11CD || 'Workplace Zone';
                    displayCode = feature.wz11cd || feature.WZ11CD || null;
                    typeLabel = 'Containing Workplace Zone';
                  } else if (layerType === 'uk_lsoa_2021_ruc') {
                    displayName = feature.lsoa21nm || feature.LSOA21NM || 'LSOA 2021';
                    displayCode = feature.lsoa21cd || feature.LSOA21CD || null;
                    typeLabel = 'Containing LSOA 2021';
                  } else if (layerType === 'uk_european_electoral_regions') {
                    displayName = feature.eurg18nm || feature.EURG18NM || 'European Electoral Region';
                    displayCode = feature.eurg18cd || feature.EURG18CD || null;
                    typeLabel = 'Containing European Electoral Region';
                  }

                  const bngE = feature.bngE || feature.BNG_E || null;
                  const bngN = feature.bngN || feature.BNG_N || null;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${displayName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> ${typeLabel}</div>
                        ${displayCode ? `<div><strong>Code:</strong> ${displayCode}</div>` : ''}
                        ${bngE !== null && bngN !== null ? `<div><strong>BNG Coordinates:</strong> E: ${bngE}, N: ${bngN}</div>` : ''}
                        ${feature.shapeArea ? `<div><strong>Area:</strong> ${feature.shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${feature.shapeLength ? `<div><strong>Perimeter:</strong> ${feature.shapeLength.toFixed(2)} units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other attributes (excluding IDs/geometry already surfaced)
                  const excludeFields = [
                    'lad25nm', 'LAD25NM', 'lad25cd', 'LAD25CD', 'lad25nmw', 'LAD25NMW',
                    'ctyua21nm', 'CTYUA21NM', 'ctyua21cd', 'CTYUA21CD', 'ctyua21nmw', 'CTYUA21NMW',
                    'cal23nm', 'CAL23NM', 'cal23cd', 'CAL23CD',
                    'eurg18nm', 'EURG18NM', 'eurg18cd', 'EURG18CD',
                    'fra23nm', 'FRA23NM', 'fra23cd', 'FRA23CD',
                    'pfa23nm', 'PFA23NM', 'pfa23cd', 'PFA23CD',
                    'wz11cd', 'WZ11CD',
                    'lsoa21nm', 'LSOA21NM', 'lsoa21cd', 'LSOA21CD',
                    'bua24nm', 'BUA24NM', 'bua24cd', 'BUA24CD', 'bua24nmw', 'BUA24NMW',
                    'gsscode', 'GSSCODE',
                    'areahectar',
                    'bngE', 'BNG_E', 'bngN', 'BNG_N',
                    'shapeArea', 'Shape__Area', 'SHAPE__AREA',
                    'shapeLength', 'Shape__Length', 'SHAPE__LENGTH',
                    'geometry', '__geometry', 'distance_miles', 'isContaining',
                    'objectId', 'OBJECTID', 'FID', 'fid', 'ESRI_OID',
                    'GlobalID', 'GLOBALID', 'globalId', 'long', 'LONG', 'lat', 'LAT'
                  ];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby UK stats features
        const nearbyFeatures: any[] = Array.isArray(enrichments[nearbyKey])
          ? enrichments[nearbyKey]
          : [];

        if (nearbyFeatures.length > 0) {
          nearbyFeatures.forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (Array.isArray(rings) && rings.length > 0) {
                  let latlngs: L.LatLngExpression[] | L.LatLngExpression[][] = [];

                  if (layerType === 'uk_built_up_areas_2024' || layerType === 'uk_wales_local_health_boards' || layerType === 'uk_national_parks') {
                    // For Built-Up Areas, Wales Local Health Boards, and National Parks, draw ALL rings of the multipart polygon
                    const allRings = rings.map((ring: number[][]) => {
                      if (!Array.isArray(ring) || ring.length < 3) return [];
                      return ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                    }).filter(ring => ring.length > 0);
                    
                    latlngs = allRings as L.LatLngExpression[][];
                  } else {
                    // For other UK stats layers, draw outer ring only
                    const outerRing = rings[0];
                    latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  }

                  const polygon = L.polygon(latlngs as any, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  // Determine display name / code / type label per UK layer
                  let displayName: string = 'Feature';
                  let displayCode: string | null = null;
                  let typeLabel: string = 'Nearby Area';
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';

                  if (layerType === 'uk_built_up_areas_2024') {
                    displayName = feature.bua24nm || feature.BUA24NM || 'Built-Up Area';
                    displayCode = feature.bua24cd || feature.BUA24CD || null;
                    typeLabel = 'Nearby Built-Up Area';
                  } else if (layerType === 'uk_wales_local_health_boards') {
                    displayName = feature.lhb23nm || feature.LHB23NM || 'Local Health Board';
                    displayCode = feature.lhb23cd || feature.LHB23CD || null;
                    typeLabel = 'Nearby Local Health Board';
                  } else if (layerType === 'uk_national_parks') {
                    displayName = feature.npark22nmw || feature.NPARK22NMW || feature.npark22nm || feature.NPARK22NM || 'National Park';
                    displayCode = feature.npark22cd || feature.NPARK22CD || null;
                    typeLabel = 'Nearby National Park';
                  } else if (layerType === 'uk_local_authority_districts') {
                    displayName = feature.lad25nm || feature.LAD25NM || 'Local Authority District';
                    displayCode = feature.lad25cd || feature.LAD25CD || null;
                    typeLabel = 'Nearby Local Authority District';
                  } else if (layerType === 'uk_counties_unitary_authorities') {
                    displayName = feature.ctyua21nm || feature.CTYUA21NM || 'County / Unitary Authority';
                    displayCode = feature.ctyua21cd || feature.CTYUA21CD || null;
                    typeLabel = 'Nearby County / Unitary Authority';
                  } else if (layerType === 'uk_cancer_alliances') {
                    displayName = feature.cal23nm || feature.CAL23NM || 'Cancer Alliance';
                    displayCode = feature.cal23cd || feature.CAL23CD || null;
                    typeLabel = 'Nearby Cancer Alliance';
                  } else if (layerType === 'uk_geostat_grid') {
                    displayName =
                      feature.grd_newid || feature.GRD_NEWID ||
                      feature.grd_fixid || feature.GRD_FIXID ||
                      'GEOSTAT Grid Cell';
                    typeLabel = 'Nearby GEOSTAT Grid Cell';
                  } else if (layerType === 'uk_fire_rescue_authorities') {
                    displayName = feature.fra23nm || feature.FRA23NM || 'Fire & Rescue Authority';
                    displayCode = feature.fra23cd || feature.FRA23CD || null;
                    typeLabel = 'Nearby Fire & Rescue Authority';
                  } else if (layerType === 'uk_police_force_areas') {
                    displayName = feature.pfa23nm || feature.PFA23NM || 'Police Force Area';
                    displayCode = feature.pfa23cd || feature.PFA23CD || null;
                    typeLabel = 'Nearby Police Force Area';
                  } else if (layerType === 'uk_workplace_zones') {
                    displayName = feature.wz11cd || feature.WZ11CD || 'Workplace Zone';
                    displayCode = feature.wz11cd || feature.WZ11CD || null;
                    typeLabel = 'Nearby Workplace Zone';
                  } else if (layerType === 'uk_lsoa_2021_ruc') {
                    displayName = feature.lsoa21nm || feature.LSOA21NM || 'LSOA 2021';
                    displayCode = feature.lsoa21cd || feature.LSOA21CD || null;
                    typeLabel = 'Nearby LSOA 2021';
                  } else if (layerType === 'uk_european_electoral_regions') {
                    displayName = feature.eurg18nm || feature.EURG18NM || 'European Electoral Region';
                    displayCode = feature.eurg18cd || feature.EURG18CD || null;
                    typeLabel = 'Nearby European Electoral Region';
                  }

                  const bngE = feature.bngE || feature.BNG_E || null;
                  const bngN = feature.bngN || feature.BNG_N || null;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${displayName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> ${typeLabel}</div>
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${displayCode ? `<div><strong>Code:</strong> ${displayCode}</div>` : ''}
                        ${bngE !== null && bngN !== null ? `<div><strong>BNG Coordinates:</strong> E: ${bngE}, N: ${bngN}</div>` : ''}
                        ${feature.shapeArea ? `<div><strong>Area:</strong> ${feature.shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${feature.shapeLength ? `<div><strong>Perimeter:</strong> ${feature.shapeLength.toFixed(2)} units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other attributes (excluding IDs/geometry already surfaced)
                  const excludeFields = [
                    'lad25nm', 'LAD25NM', 'lad25cd', 'LAD25CD', 'lad25nmw', 'LAD25NMW',
                    'ctyua21nm', 'CTYUA21NM', 'ctyua21cd', 'CTYUA21CD', 'ctyua21nmw', 'CTYUA21NMW',
                    'cal23nm', 'CAL23NM', 'cal23cd', 'CAL23CD',
                    'eurg18nm', 'EURG18NM', 'eurg18cd', 'EURG18CD',
                    'fra23nm', 'FRA23NM', 'fra23cd', 'FRA23CD',
                    'pfa23nm', 'PFA23NM', 'pfa23cd', 'PFA23CD',
                    'wz11cd', 'WZ11CD',
                    'lsoa21nm', 'LSOA21NM', 'lsoa21cd', 'LSOA21CD',
                    'bua24nm', 'BUA24NM', 'bua24cd', 'BUA24CD', 'bua24nmw', 'BUA24NMW',
                    'lhb23nm', 'LHB23NM', 'lhb23cd', 'LHB23CD',
                    'npark22nm', 'NPARK22NM', 'npark22nmw', 'NPARK22NMW', 'npark22cd', 'NPARK22CD',
                    'gsscode', 'GSSCODE',
                    'areahectar',
                    'bngE', 'BNG_E', 'bngN', 'BNG_N',
                    'shapeArea', 'Shape__Area', 'SHAPE__AREA',
                    'shapeLength', 'Shape__Length', 'SHAPE__LENGTH',
                    'geometry', '__geometry', 'distance_miles', 'isContaining',
                    'objectId', 'OBJECTID', 'FID', 'fid', 'ESRI_OID',
                    'GlobalID', 'GLOBALID', 'globalId', 'long', 'LONG', 'lat', 'LAT'
                  ];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Built-Up Areas as polygons on the map
      irelandBuiltUpAreaLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing built-up areas
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const fCode = area.fCode || area.F_CODE || '';
                  const fcSubtype = area.fcSubtype !== null && area.fcSubtype !== undefined ? area.fcSubtype : '';
                  const shapeArea = area.shapeArea || area.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Built-Up Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Built-Up Area</div>
                        ${fCode ? `<div><strong>F Code:</strong> ${fCode}</div>` : ''}
                        ${fcSubtype !== '' ? `<div><strong>FC Subtype:</strong> ${fcSubtype}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['fCode', 'F_CODE', 'fcSubtype', 'FCsubtype', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby built-up areas
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const fCode = area.fCode || area.F_CODE || '';
                  const fcSubtype = area.fcSubtype !== null && area.fcSubtype !== undefined ? area.fcSubtype : '';
                  const distance = area.distance_miles ? area.distance_miles.toFixed(2) : 'Unknown';
                  const shapeArea = area.shapeArea || area.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Built-Up Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${fCode ? `<div><strong>F Code:</strong> ${fCode}</div>` : ''}
                        ${fcSubtype !== '' ? `<div><strong>FC Subtype:</strong> ${fcSubtype}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['fCode', 'F_CODE', 'fcSubtype', 'FCsubtype', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Vegetation Areas as polygons on the map
      ukLocalAuthorityDistrictLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing districts / areas
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  // Determine display name / code / type label per UK layer
                  let displayName: string = 'Feature';
                  let displayCode: string | null = null;
                  let typeLabel: string = 'Containing Area';

                  if (layerType === 'uk_built_up_areas_2024') {
                    displayName = feature.bua24nm || feature.BUA24NM || 'Built-Up Area';
                    displayCode = feature.bua24cd || feature.BUA24CD || null;
                    typeLabel = 'Containing Built-Up Area';
                  } else if (layerType === 'uk_wales_local_health_boards') {
                    displayName = feature.lhb23nm || feature.LHB23NM || 'Local Health Board';
                    displayCode = feature.lhb23cd || feature.LHB23CD || null;
                    typeLabel = 'Containing Local Health Board';
                  } else if (layerType === 'uk_local_authority_districts') {
                    displayName = feature.lad25nm || feature.LAD25NM || 'Local Authority District';
                    displayCode = feature.lad25cd || feature.LAD25CD || null;
                    typeLabel = 'Containing Local Authority District';
                  } else if (layerType === 'uk_counties_unitary_authorities') {
                    displayName = feature.ctyua21nm || feature.CTYUA21NM || 'County / Unitary Authority';
                    displayCode = feature.ctyua21cd || feature.CTYUA21CD || null;
                    typeLabel = 'Containing County / Unitary Authority';
                  } else if (layerType === 'uk_cancer_alliances') {
                    displayName = feature.cal23nm || feature.CAL23NM || 'Cancer Alliance';
                    displayCode = feature.cal23cd || feature.CAL23CD || null;
                    typeLabel = 'Containing Cancer Alliance';
                  } else if (layerType === 'uk_geostat_grid') {
                    displayName =
                      feature.grd_newid || feature.GRD_NEWID ||
                      feature.grd_fixid || feature.GRD_FIXID ||
                      'GEOSTAT Grid Cell';
                    typeLabel = 'Containing GEOSTAT Grid Cell';
                  } else if (layerType === 'uk_fire_rescue_authorities') {
                    displayName = feature.fra23nm || feature.FRA23NM || 'Fire & Rescue Authority';
                    displayCode = feature.fra23cd || feature.FRA23CD || null;
                    typeLabel = 'Containing Fire & Rescue Authority';
                  } else if (layerType === 'uk_police_force_areas') {
                    displayName = feature.pfa23nm || feature.PFA23NM || 'Police Force Area';
                    displayCode = feature.pfa23cd || feature.PFA23CD || null;
                    typeLabel = 'Containing Police Force Area';
                  } else if (layerType === 'uk_workplace_zones') {
                    displayName = feature.wz11cd || feature.WZ11CD || 'Workplace Zone';
                    displayCode = feature.wz11cd || feature.WZ11CD || null;
                    typeLabel = 'Containing Workplace Zone';
                  } else if (layerType === 'uk_lsoa_2021_ruc') {
                    displayName = feature.lsoa21nm || feature.LSOA21NM || 'LSOA 2021';
                    displayCode = feature.lsoa21cd || feature.LSOA21CD || null;
                    typeLabel = 'Containing LSOA 2021';
                  } else if (layerType === 'uk_european_electoral_regions') {
                    displayName = feature.eurg18nm || feature.EURG18NM || 'European Electoral Region';
                    displayCode = feature.eurg18cd || feature.EURG18CD || null;
                    typeLabel = 'Containing European Electoral Region';
                  }

                  const bngE = feature.bngE || feature.BNG_E || null;
                  const bngN = feature.bngN || feature.BNG_N || null;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${displayName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> ${typeLabel}</div>
                        ${displayCode ? `<div><strong>Code:</strong> ${displayCode}</div>` : ''}
                        ${bngE !== null && bngN !== null ? `<div><strong>BNG Coordinates:</strong> E: ${bngE}, N: ${bngN}</div>` : ''}
                        ${feature.shapeArea ? `<div><strong>Area:</strong> ${feature.shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${feature.shapeLength ? `<div><strong>Perimeter:</strong> ${feature.shapeLength.toFixed(2)} units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other attributes (excluding IDs/geometry already surfaced)
                  const excludeFields = [
                    'lad25nm', 'LAD25NM', 'lad25cd', 'LAD25CD', 'lad25nmw', 'LAD25NMW',
                    'ctyua21nm', 'CTYUA21NM', 'ctyua21cd', 'CTYUA21CD', 'ctyua21nmw', 'CTYUA21NMW',
                    'cal23nm', 'CAL23NM', 'cal23cd', 'CAL23CD',
                    'eurg18nm', 'EURG18NM', 'eurg18cd', 'EURG18CD',
                    'fra23nm', 'FRA23NM', 'fra23cd', 'FRA23CD',
                    'pfa23nm', 'PFA23NM', 'pfa23cd', 'PFA23CD',
                    'wz11cd', 'WZ11CD',
                    'lsoa21nm', 'LSOA21NM', 'lsoa21cd', 'LSOA21CD',
                    'bua24nm', 'BUA24NM', 'bua24cd', 'BUA24CD', 'bua24nmw', 'BUA24NMW',
                    'gsscode', 'GSSCODE',
                    'areahectar',
                    'bngE', 'BNG_E', 'bngN', 'BNG_N',
                    'shapeArea', 'Shape__Area', 'SHAPE__AREA',
                    'shapeLength', 'Shape__Length', 'SHAPE__LENGTH',
                    'geometry', '__geometry', 'distance_miles', 'isContaining',
                    'objectId', 'OBJECTID', 'FID', 'fid', 'ESRI_OID',
                    'GlobalID', 'GLOBALID', 'globalId', 'long', 'LONG', 'lat', 'LAT'
                  ];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby districts / areas
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((feature: any) => {
            const geometry = feature.__geometry || feature.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (Array.isArray(rings) && rings.length > 0) {
                  let latlngs: L.LatLngExpression[] | L.LatLngExpression[][] = [];

                  if (layerType === 'uk_built_up_areas_2024' || layerType === 'uk_wales_local_health_boards') {
                    // For Built-Up Areas and Wales Local Health Boards (nearby), draw ALL rings of the multipart polygon
                    // Convert all rings to latlngs format for multipolygon
                    const allRings = rings.map((ring: number[][]) => {
                      if (!Array.isArray(ring) || ring.length < 3) return [];
                      return ring.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                    }).filter(ring => ring.length > 0);
                    
                    // Use multipolygon format: array of arrays of coordinates
                    latlngs = allRings as L.LatLngExpression[][];
                  } else {
                    const outerRing = rings[0];
                    latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                  }

                  const polygon = L.polygon(latlngs as any, {
                    color: color,
                    weight: 1,
                    opacity: 0.5,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  // Determine display name / code / type label per UK layer (nearby)
                  let displayName: string = 'Feature';
                  let displayCode: string | null = null;
                  let typeLabel: string = 'Nearby Area';

                  if (layerType === 'uk_built_up_areas_2024') {
                    displayName = feature.bua24nm || feature.BUA24NM || 'Built-Up Area';
                    displayCode = feature.bua24cd || feature.BUA24CD || null;
                    typeLabel = 'Nearby Built-Up Area';
                  } else if (layerType === 'uk_wales_local_health_boards') {
                    displayName = feature.lhb23nm || feature.LHB23NM || 'Local Health Board';
                    displayCode = feature.lhb23cd || feature.LHB23CD || null;
                    typeLabel = 'Nearby Local Health Board';
                  } else if (layerType === 'uk_wales_local_health_boards') {
                    displayName = feature.lhb23nm || feature.LHB23NM || 'Local Health Board';
                    displayCode = feature.lhb23cd || feature.LHB23CD || null;
                    typeLabel = 'Nearby Local Health Board';
                  } else if (layerType === 'uk_local_authority_districts') {
                    displayName = feature.lad25nm || feature.LAD25NM || 'Local Authority District';
                    displayCode = feature.lad25cd || feature.LAD25CD || null;
                    typeLabel = 'Nearby Local Authority District';
                  } else if (layerType === 'uk_counties_unitary_authorities') {
                    displayName = feature.ctyua21nm || feature.CTYUA21NM || 'County / Unitary Authority';
                    displayCode = feature.ctyua21cd || feature.CTYUA21CD || null;
                    typeLabel = 'Nearby County / Unitary Authority';
                  } else if (layerType === 'uk_cancer_alliances') {
                    displayName = feature.cal23nm || feature.CAL23NM || 'Cancer Alliance';
                    displayCode = feature.cal23cd || feature.CAL23CD || null;
                    typeLabel = 'Nearby Cancer Alliance';
                  } else if (layerType === 'uk_geostat_grid') {
                    displayName =
                      feature.grd_newid || feature.GRD_NEWID ||
                      feature.grd_fixid || feature.GRD_FIXID ||
                      'GEOSTAT Grid Cell';
                    typeLabel = 'Nearby GEOSTAT Grid Cell';
                  } else if (layerType === 'uk_fire_rescue_authorities') {
                    displayName = feature.fra23nm || feature.FRA23NM || 'Fire & Rescue Authority';
                    displayCode = feature.fra23cd || feature.FRA23CD || null;
                    typeLabel = 'Nearby Fire & Rescue Authority';
                  } else if (layerType === 'uk_police_force_areas') {
                    displayName = feature.pfa23nm || feature.PFA23NM || 'Police Force Area';
                    displayCode = feature.pfa23cd || feature.PFA23CD || null;
                    typeLabel = 'Nearby Police Force Area';
                  } else if (layerType === 'uk_workplace_zones') {
                    displayName = feature.wz11cd || feature.WZ11CD || 'Workplace Zone';
                    displayCode = feature.wz11cd || feature.WZ11CD || null;
                    typeLabel = 'Nearby Workplace Zone';
                  } else if (layerType === 'uk_lsoa_2021_ruc') {
                    displayName = feature.lsoa21nm || feature.LSOA21NM || 'LSOA 2021';
                    displayCode = feature.lsoa21cd || feature.LSOA21CD || null;
                    typeLabel = 'Nearby LSOA 2021';
                  } else if (layerType === 'uk_european_electoral_regions') {
                    displayName = feature.eurg18nm || feature.EURG18NM || 'European Electoral Region';
                    displayCode = feature.eurg18cd || feature.EURG18CD || null;
                    typeLabel = 'Nearby European Electoral Region';
                  }

                  const bngE = feature.bngE || feature.BNG_E || null;
                  const bngN = feature.bngN || feature.BNG_N || null;
                  const distance = feature.distance_miles ? feature.distance_miles.toFixed(2) : 'Unknown';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${displayName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> ${typeLabel}</div>
                        ${displayCode ? `<div><strong>Code:</strong> ${displayCode}</div>` : ''}
                        ${bngE !== null && bngN !== null ? `<div><strong>BNG Coordinates:</strong> E: ${bngE}, N: ${bngN}</div>` : ''}
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${feature.shapeArea ? `<div><strong>Area:</strong> ${feature.shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${feature.shapeLength ? `<div><strong>Perimeter:</strong> ${feature.shapeLength.toFixed(2)} units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other attributes (excluding IDs/geometry already surfaced)
                  const excludeFields = [
                    'lad25nm', 'LAD25NM', 'lad25cd', 'LAD25CD', 'lad25nmw', 'LAD25NMW',
                    'ctyua21nm', 'CTYUA21NM', 'ctyua21cd', 'CTYUA21CD', 'ctyua21nmw', 'CTYUA21NMW',
                    'cal23nm', 'CAL23NM', 'cal23cd', 'CAL23CD',
                    'eurg18nm', 'EURG18NM', 'eurg18cd', 'EURG18CD',
                    'fra23nm', 'FRA23NM', 'fra23cd', 'FRA23CD',
                    'pfa23nm', 'PFA23NM', 'pfa23cd', 'PFA23CD',
                    'wz11cd', 'WZ11CD',
                    'lsoa21nm', 'LSOA21NM', 'lsoa21cd', 'LSOA21CD',
                    'bua24nm', 'BUA24NM', 'bua24cd', 'BUA24CD', 'bua24nmw', 'BUA24NMW',
                    'gsscode', 'GSSCODE',
                    'areahectar',
                    'bngE', 'BNG_E', 'bngN', 'BNG_N',
                    'shapeArea', 'Shape__Area', 'SHAPE__AREA',
                    'shapeLength', 'Shape__Length', 'SHAPE__LENGTH',
                    'geometry', '__geometry', 'distance_miles', 'isContaining',
                    'objectId', 'OBJECTID', 'FID', 'fid', 'ESRI_OID',
                    'GlobalID', 'GLOBALID', 'globalId', 'long', 'LONG', 'lat', 'LAT'
                  ];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }

        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      irelandVegetationAreaLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing vegetation areas
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const areaName = area.name || area.NAMN1 || area.NAME || 'Vegetation Area';
                  const fcSubtype = area.fcSubtype || area.FCsubtype || area.FCSUBTYPE || null;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${areaName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Vegetation Area</div>
                        ${fcSubtype !== null ? `<div><strong>FC Subtype:</strong> ${fcSubtype}</div>` : ''}
                        ${area.shapeArea ? `<div><strong>Area:</strong> ${area.shapeArea.toFixed(2)} m²</div>` : ''}
                        ${area.shapeLength ? `<div><strong>Perimeter:</strong> ${area.shapeLength.toFixed(2)} m</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['name', 'NAMN1', 'NAME', 'fcSubtype', 'FCsubtype', 'FCSUBTYPE', 'shapeArea', 'Shape__Area', 'SHAPE__AREA', 'shapeLength', 'Shape__Length', 'SHAPE__LENGTH', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID', 'ESRI_OID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby vegetation areas
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 1,
                    opacity: 0.5,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  const areaName = area.name || area.NAMN1 || area.NAME || 'Vegetation Area';
                  const fcSubtype = area.fcSubtype || area.FCsubtype || area.FCSUBTYPE || null;
                  const distance = area.distance_miles ? area.distance_miles.toFixed(2) : 'Unknown';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${areaName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Nearby Vegetation Area</div>
                        ${fcSubtype !== null ? `<div><strong>FC Subtype:</strong> ${fcSubtype}</div>` : ''}
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${area.shapeArea ? `<div><strong>Area:</strong> ${area.shapeArea.toFixed(2)} m²</div>` : ''}
                        ${area.shapeLength ? `<div><strong>Perimeter:</strong> ${area.shapeLength.toFixed(2)} m</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['name', 'NAMN1', 'NAME', 'fcSubtype', 'FCsubtype', 'FCSUBTYPE', 'shapeArea', 'Shape__Area', 'SHAPE__AREA', 'shapeLength', 'Shape__Length', 'SHAPE__LENGTH', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID', 'ESRI_OID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }

        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Small Areas as polygons on the map
      irelandSmallAreaLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing small areas
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const smallArea = area.smallArea || area.SMALL_AREA || '';
                  const countyName = area.countyName || area.COUNTYNAME || '';
                  const edName = area.edName || area.EDNAME || '';
                  const nuts3Name = area.nuts3Name || area.NUTS3NAME || '';
                  const geogId = area.geogId || area.GEOGID || '';
                  const shapeArea = area.shapeArea || area.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Small Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Small Area</div>
                        ${smallArea ? `<div><strong>Small Area:</strong> ${smallArea}</div>` : ''}
                        ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                        ${edName ? `<div><strong>ED Name:</strong> ${edName}</div>` : ''}
                        ${nuts3Name ? `<div><strong>NUTS3:</strong> ${nuts3Name}</div>` : ''}
                        ${geogId ? `<div><strong>GEOGID:</strong> ${geogId}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['smallArea', 'SMALL_AREA', 'countyName', 'COUNTYNAME', 'edName', 'EDNAME', 'nuts3Name', 'NUTS3NAME', 'geogId', 'GEOGID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID_1', 'ESRI_OID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby small areas
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((area: any) => {
            const geometry = area.__geometry || area.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const smallArea = area.smallArea || area.SMALL_AREA || '';
                  const countyName = area.countyName || area.COUNTYNAME || '';
                  const edName = area.edName || area.EDNAME || '';
                  const nuts3Name = area.nuts3Name || area.NUTS3NAME || '';
                  const geogId = area.geogId || area.GEOGID || '';
                  const distance = area.distance_miles ? area.distance_miles.toFixed(2) : 'Unknown';
                  const shapeArea = area.shapeArea || area.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Small Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${smallArea ? `<div><strong>Small Area:</strong> ${smallArea}</div>` : ''}
                        ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                        ${edName ? `<div><strong>ED Name:</strong> ${edName}</div>` : ''}
                        ${nuts3Name ? `<div><strong>NUTS3:</strong> ${nuts3Name}</div>` : ''}
                        ${geogId ? `<div><strong>GEOGID:</strong> ${geogId}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other area attributes
                  const excludeFields = ['smallArea', 'SMALL_AREA', 'countyName', 'COUNTYNAME', 'edName', 'EDNAME', 'nuts3Name', 'NUTS3NAME', 'geogId', 'GEOGID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID_1', 'ESRI_OID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Electoral Divisions as polygons on the map
      irelandElectoralDivisionLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing electoral divisions
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((ed: any) => {
            const geometry = ed.__geometry || ed.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const edId = ed.edId || ed.ED_ID || '';
                  const edEnglish = ed.edEnglish || ed.ED_ENGLISH || '';
                  const edGaeilge = ed.edGaeilge || ed.ED_GAEILGE || '';
                  const county = ed.county || ed.COUNTY || '';
                  const contae = ed.contae || ed.CONTAE || '';
                  const province = ed.province || ed.PROVINCE || '';
                  const shapeArea = ed.shapeArea || ed.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Electoral Division
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Electoral Division</div>
                        ${edId ? `<div><strong>ED ID:</strong> ${edId}</div>` : ''}
                        ${edEnglish ? `<div><strong>English Name:</strong> ${edEnglish}</div>` : ''}
                        ${edGaeilge ? `<div><strong>Gaeilge Name:</strong> ${edGaeilge}</div>` : ''}
                        ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                        ${contae ? `<div><strong>Contae:</strong> ${contae}</div>` : ''}
                        ${province ? `<div><strong>Province:</strong> ${province}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other ED attributes
                  const excludeFields = ['edId', 'ED_ID', 'edEnglish', 'ED_ENGLISH', 'edGaeilge', 'ED_GAEILGE', 'county', 'COUNTY', 'contae', 'CONTAE', 'province', 'PROVINCE', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID_1', 'ESRI_OID', 'centroidX', 'CENTROID_X', 'centroidY', 'CENTROID_Y', 'guid', 'GUID_'];
                  Object.entries(ed).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby electoral divisions
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((ed: any) => {
            const geometry = ed.__geometry || ed.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const edId = ed.edId || ed.ED_ID || '';
                  const edEnglish = ed.edEnglish || ed.ED_ENGLISH || '';
                  const edGaeilge = ed.edGaeilge || ed.ED_GAEILGE || '';
                  const county = ed.county || ed.COUNTY || '';
                  const contae = ed.contae || ed.CONTAE || '';
                  const province = ed.province || ed.PROVINCE || '';
                  const distance = ed.distance_miles ? ed.distance_miles.toFixed(2) : 'Unknown';
                  const shapeArea = ed.shapeArea || ed.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Electoral Division
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${edId ? `<div><strong>ED ID:</strong> ${edId}</div>` : ''}
                        ${edEnglish ? `<div><strong>English Name:</strong> ${edEnglish}</div>` : ''}
                        ${edGaeilge ? `<div><strong>Gaeilge Name:</strong> ${edGaeilge}</div>` : ''}
                        ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                        ${contae ? `<div><strong>Contae:</strong> ${contae}</div>` : ''}
                        ${province ? `<div><strong>Province:</strong> ${province}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other ED attributes
                  const excludeFields = ['edId', 'ED_ID', 'edEnglish', 'ED_ENGLISH', 'edGaeilge', 'ED_GAEILGE', 'county', 'COUNTY', 'contae', 'CONTAE', 'province', 'PROVINCE', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID_1', 'ESRI_OID', 'centroidX', 'CENTROID_X', 'centroidY', 'CENTROID_Y', 'guid', 'GUID_'];
                  Object.entries(ed).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland NUTS3 Boundaries as polygons on the map
      irelandNUTS3Layers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing NUTS3 boundaries
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((nuts3: any) => {
            const geometry = nuts3.__geometry || nuts3.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const nuts3Code = nuts3.nuts3 || nuts3.NUTS3 || '';
                  const nuts3Name = nuts3.nuts3Name || nuts3.NUTS3NAME || '';
                  const nuts2Name = nuts3.nuts2Name || nuts3.NUTS2NAME || '';
                  const nuts1Name = nuts3.nuts1Name || nuts3.NUTS1NAME || '';
                  const shapeArea = nuts3.shapeArea || nuts3.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} NUTS3 Boundary
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing NUTS3 Boundary</div>
                        ${nuts3Name ? `<div><strong>NUTS3 Name:</strong> ${nuts3Name}</div>` : ''}
                        ${nuts3Code ? `<div><strong>NUTS3 Code:</strong> ${nuts3Code}</div>` : ''}
                        ${nuts2Name ? `<div><strong>NUTS2 Name:</strong> ${nuts2Name}</div>` : ''}
                        ${nuts1Name ? `<div><strong>NUTS1 Name:</strong> ${nuts1Name}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other NUTS3 attributes
                  const excludeFields = ['nuts1', 'NUTS1', 'nuts1Name', 'NUTS1NAME', 'nuts2', 'NUTS2', 'nuts2Name', 'NUTS2NAME', 'nuts3', 'NUTS3', 'nuts3Name', 'NUTS3NAME', 'guid', 'GUID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(nuts3).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby NUTS3 boundaries
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((nuts3: any) => {
            const geometry = nuts3.__geometry || nuts3.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const nuts3Code = nuts3.nuts3 || nuts3.NUTS3 || '';
                  const nuts3Name = nuts3.nuts3Name || nuts3.NUTS3NAME || '';
                  const nuts2Name = nuts3.nuts2Name || nuts3.NUTS2NAME || '';
                  const nuts1Name = nuts3.nuts1Name || nuts3.NUTS1NAME || '';
                  const distance = nuts3.distance_miles ? nuts3.distance_miles.toFixed(2) : 'Unknown';
                  const shapeArea = nuts3.shapeArea || nuts3.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} NUTS3 Boundary
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${nuts3Name ? `<div><strong>NUTS3 Name:</strong> ${nuts3Name}</div>` : ''}
                        ${nuts3Code ? `<div><strong>NUTS3 Code:</strong> ${nuts3Code}</div>` : ''}
                        ${nuts2Name ? `<div><strong>NUTS2 Name:</strong> ${nuts2Name}</div>` : ''}
                        ${nuts1Name ? `<div><strong>NUTS1 Name:</strong> ${nuts1Name}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other NUTS3 attributes
                  const excludeFields = ['nuts1', 'NUTS1', 'nuts1Name', 'NUTS1NAME', 'nuts2', 'NUTS2', 'nuts2Name', 'NUTS2NAME', 'nuts3', 'NUTS3', 'nuts3Name', 'NUTS3NAME', 'guid', 'GUID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(nuts3).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Civil Parishes as polygons on the map
      irelandCivilParishLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing civil parishes
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((parish: any) => {
            const geometry = parish.__geometry || parish.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: color,
                    fillOpacity: 0.4
                  });

                  const engName = parish.engName || parish.ENG_NAME_VALUE || '';
                  const gleName = parish.gleName || parish.GLE_NAME_VALUE || '';
                  const gaeltachtArea = parish.gaeltachtArea || parish.GAELTACHT_AREA || '';
                  const shapeArea = parish.shapeArea || parish.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Civil Parish
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Civil Parish</div>
                        ${engName ? `<div><strong>English Name:</strong> ${engName}</div>` : ''}
                        ${gleName ? `<div><strong>Gaeilge Name:</strong> ${gleName}</div>` : ''}
                        ${gaeltachtArea ? `<div><strong>Gaeltacht Area:</strong> ${gaeltachtArea}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other parish attributes
                  const excludeFields = ['engName', 'ENG_NAME_VALUE', 'gleName', 'GLE_NAME_VALUE', 'gaeltachtArea', 'GAELTACHT_AREA', 'guid', 'GUID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(parish).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby civil parishes
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((parish: any) => {
            const geometry = parish.__geometry || parish.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const engName = parish.engName || parish.ENG_NAME_VALUE || '';
                  const gleName = parish.gleName || parish.GLE_NAME_VALUE || '';
                  const gaeltachtArea = parish.gaeltachtArea || parish.GAELTACHT_AREA || '';
                  const distance = parish.distance_miles ? parish.distance_miles.toFixed(2) : 'Unknown';
                  const shapeArea = parish.shapeArea || parish.Shape__Area || 0;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} Civil Parish
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        ${engName ? `<div><strong>English Name:</strong> ${engName}</div>` : ''}
                        ${gleName ? `<div><strong>Gaeilge Name:</strong> ${gleName}</div>` : ''}
                        ${gaeltachtArea ? `<div><strong>Gaeltacht Area:</strong> ${gaeltachtArea}</div>` : ''}
                        ${shapeArea ? `<div><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other parish attributes
                  const excludeFields = ['engName', 'ENG_NAME_VALUE', 'gleName', 'GLE_NAME_VALUE', 'gaeltachtArea', 'GAELTACHT_AREA', 'guid', 'GUID', 'shapeArea', 'Shape__Area', 'shapeLength', 'Shape__Length', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                  Object.entries(parish).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw Ireland Buildings as polygons on the map
      irelandBuildingLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing buildings
        if (enrichments[containingKey] && Array.isArray(enrichments[containingKey]) && enrichments[containingKey].length > 0) {
          enrichments[containingKey].forEach((building: any) => {
            const geometry = building.__geometry || building.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.3
                  });

                  const buildingType = building.buildingType || 'Building';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${buildingType}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Type:</strong> Containing Building</div>
                        <div><strong>Building Type:</strong> ${buildingType}</div>
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other building attributes
                  const excludeFields = ['buildingType', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID', 'ESRI_OID'];
                  Object.entries(building).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} containing polygon:`, error);
              }
            }
          });
        }

        // Draw nearby buildings
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((building: any) => {
            const geometry = building.__geometry || building.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 1,
                    opacity: 0.5,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  const buildingType = building.buildingType || 'Building';
                  const distance = building.distance_miles ? building.distance_miles.toFixed(2) : 'Unknown';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${buildingType}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance} miles</div>
                        <div><strong>Building Type:</strong> ${buildingType}</div>
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all other building attributes
                  const excludeFields = ['buildingType', 'geometry', '__geometry', 'distance_miles', 'objectId', 'OBJECTID', 'ESRI_OID'];
                  Object.entries(building).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      // Draw TIGER Urban Areas as polygons on the map
      const tigerUrbanLayers = [
        { containingKey: 'tiger_urban_2020_urban_areas_containing', nearbyKey: 'tiger_urban_2020_urban_areas_nearby_features', name: 'TIGER 2020 Urban Areas', color: '#8b5cf6', icon: '🏙️', layerType: 'tiger_urban_2020_urban_areas' },
        { containingKey: 'tiger_urban_bas2025_2020_urban_areas_containing', nearbyKey: 'tiger_urban_bas2025_2020_urban_areas_nearby_features', name: 'TIGER BAS 2025 2020 Urban Areas', color: '#7c3aed', icon: '🏙️', layerType: 'tiger_urban_bas2025_2020_urban_areas' },
        { containingKey: 'tiger_urban_acs2024_2020_urban_areas_containing', nearbyKey: 'tiger_urban_acs2024_2020_urban_areas_nearby_features', name: 'TIGER ACS 2024 2020 Urban Areas', color: '#6d28d9', icon: '🏙️', layerType: 'tiger_urban_acs2024_2020_urban_areas' },
        { containingKey: 'tiger_urban_census2020_2020_urban_areas_corrected_containing', nearbyKey: 'tiger_urban_census2020_2020_urban_areas_corrected_nearby_features', name: 'TIGER Census 2020 2020 Urban Areas - Corrected', color: '#5b21b6', icon: '🏙️', layerType: 'tiger_urban_census2020_2020_urban_areas_corrected' },
        { containingKey: 'tiger_urban_census2020_2020_urban_areas_containing', nearbyKey: 'tiger_urban_census2020_2020_urban_areas_nearby_features', name: 'TIGER Census 2020 2020 Urban Areas', color: '#4c1d95', icon: '🏙️', layerType: 'tiger_urban_census2020_2020_urban_areas' },
        { containingKey: 'tiger_urban_urban_areas_containing', nearbyKey: 'tiger_urban_urban_areas_nearby_features', name: 'TIGER Urban Areas', color: '#3b1a7a', icon: '🏙️', layerType: 'tiger_urban_urban_areas' }
      ];

      tigerUrbanLayers.forEach(({ containingKey, nearbyKey, name, color, icon, layerType }) => {
        let featureCount = 0;
        
        // Draw containing area
        if (enrichments[containingKey] && enrichments[containingKey].__geometry) {
          const urban = enrichments[containingKey];
          const geometry = urban.__geometry || urban.geometry;
          if (geometry && geometry.rings) {
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.8,
                  fillColor: color,
                  fillOpacity: 0.3
                });

                const urbanName = urban.name || 'Unknown Urban Area';
                const urbanType = urban.urbanType || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${urbanName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing Urban Area</div>
                      ${urbanType ? `<div><strong>Urban Type:</strong> ${urbanType}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
                featureCount += 1;
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby features
        if (enrichments[nearbyKey] && Array.isArray(enrichments[nearbyKey])) {
          enrichments[nearbyKey].forEach((urban: any) => {
            const geometry = urban.__geometry || urban.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  const urbanName = urban.name || 'Unknown Urban Area';
                  const urbanType = urban.urbanType || '';
                  const distance = urban.distance_miles;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${urbanName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Distance:</strong> ${distance ? distance.toFixed(2) : '0.00'} miles</div>
                        ${urbanType ? `<div><strong>Urban Type:</strong> ${urbanType}</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount += 1;
                }
              } catch (error) {
                console.error(`Error drawing ${name} nearby polygon:`, error);
              }
            }
          });
        }
        
        // Add to legend
        if (featureCount > 0) {
          if (!legendAccumulator[layerType]) {
            legendAccumulator[layerType] = {
              icon: icon,
              color: color,
              title: name,
              count: 0,
            };
          }
          legendAccumulator[layerType].count += featureCount;
        }
      });

      tigerSchoolDistrictLayers.forEach(({ allKey, containingKey, name, color, icon, layerType }) => {
        // Draw containing district
        if (enrichments[containingKey] && enrichments[containingKey].__geometry) {
          const district = enrichments[containingKey];
          const geometry = district.__geometry || district.geometry;
          if (geometry && geometry.rings) {
            try {
              const rings = geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: 3,
                  opacity: 0.8,
                  fillColor: color,
                  fillOpacity: 0.3
                });

                const districtName = district.name || 'Unknown School District';
                const stateFips = district.stateFips || '';
                const countyFips = district.countyFips || '';
                const districtCode = district.districtCode || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${icon} ${districtName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> Containing District</div>
                      ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                      ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                      ${districtCode ? `<div><strong>District Code:</strong> ${districtCode}</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                (polygon as any).__layerType = layerType;
                (polygon as any).__layerTitle = name;
                bounds.extend(polygon.getBounds());
              }
            } catch (error) {
              console.error(`Error drawing ${name} containing polygon:`, error);
            }
          }
        }

        // Draw nearby districts
        if (enrichments[allKey] && Array.isArray(enrichments[allKey])) {
          let featureCount = 0;
          enrichments[allKey].forEach((district: any) => {
            const geometry = district.__geometry || district.geometry;
            if (geometry && geometry.rings) {
              try {
                const rings = geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.15
                  });

                  const districtName = district.name || 'Unknown School District';
                  const stateFips = district.stateFips || '';
                  const countyFips = district.countyFips || '';
                  const districtCode = district.districtCode || '';
                  const distance = district.distance_miles;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${districtName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${stateFips ? `<div><strong>State FIPS:</strong> ${stateFips}</div>` : ''}
                        ${countyFips ? `<div><strong>County FIPS:</strong> ${countyFips}</div>` : ''}
                        ${districtCode ? `<div><strong>District Code:</strong> ${districtCode}</div>` : ''}
                        ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  (polygon as any).__layerType = layerType;
                  (polygon as any).__layerTitle = name;
                  bounds.extend(polygon.getBounds());
                  featureCount++;
                }
              } catch (error) {
                console.error(`Error drawing ${name} polygon:`, error);
              }
            }
          });
          
          if (featureCount > 0 || enrichments[containingKey]) {
            if (!legendAccumulator[layerType]) {
              legendAccumulator[layerType] = {
                icon: icon,
                color: color,
                title: name,
                count: 0,
              };
            }
            if (enrichments[containingKey]) {
              legendAccumulator[layerType].count += 1;
            }
            legendAccumulator[layerType].count += featureCount;
          }
        }
      });

      // Draw MA Regional Planning Agencies as polygons on the map
      if (enrichments.ma_regional_planning_agencies_all && Array.isArray(enrichments.ma_regional_planning_agencies_all)) {
        enrichments.ma_regional_planning_agencies_all.forEach((agency: any) => {
          if (agency.geometry && agency.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = agency.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                const polygon = L.polygon(latlngs, {
                  color: '#8b5cf6', // Purple color for planning agencies
                  weight: 2,
                  opacity: 0.7,
                  fillColor: '#8b5cf6',
                  fillOpacity: 0.2
                });

                // Build popup content
                const rpaName = agency.RPA_NAME || agency.rpa_name || 'Unknown Regional Planning Agency';
                const acronym = agency.ACRONYM || agency.acronym || '';
                const website = agency.WEBSITE || agency.website || '';

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏛️ ${rpaName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${acronym ? `<div><strong>Acronym:</strong> ${acronym}</div>` : ''}
                      ${website ? `<div><strong>Website:</strong> <a href="${website}" target="_blank" rel="noopener noreferrer">${website}</a></div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['ma_regional_planning_agencies']) {
                  legendAccumulator['ma_regional_planning_agencies'] = {
                    icon: '🏛️',
                    color: '#8b5cf6',
                    title: 'MA Regional Planning Agencies',
                    count: 0,
                  };
                }
                legendAccumulator['ma_regional_planning_agencies'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing MA Regional Planning Agency polygon:', error);
            }
          }
        });
      }

      // Draw National Marine Sanctuaries as polygons on the map
      if (enrichments.national_marine_sanctuaries_all && Array.isArray(enrichments.national_marine_sanctuaries_all)) {
        enrichments.national_marine_sanctuaries_all.forEach((sanctuary: any) => {
          if (sanctuary.geometry && sanctuary.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = sanctuary.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                
                // Check if coordinates need conversion from Web Mercator
                const spatialRef = sanctuary.geometry.spatialReference || sanctuary.geometry.spatialref;
                const wkid = spatialRef?.wkid || spatialRef?.latestWkid;
                const firstCoord = outerRing[0];
                const needsConversion = wkid === 3857 || wkid === 102100 || (!wkid && (Math.abs(firstCoord[0]) > 180 || Math.abs(firstCoord[1]) > 90));
                
                let latlngs: [number, number][];
                
                if (needsConversion) {
                  // Convert from Web Mercator to WGS84
                  latlngs = outerRing.map((coord: number[]) => {
                    const x = coord[0];
                    const y = coord[1];
                    const lon = (x / 20037508.34) * 180;
                    let lat = (y / 20037508.34) * 180;
                    lat = (Math.atan(Math.exp((lat * Math.PI) / 180)) * 360) / Math.PI - 90;
                    return [lat, lon] as [number, number];
                  });
                } else {
                  // Assume WGS84 - coordinates are [lon, lat], convert to [lat, lon] for Leaflet
                  latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                }

                const isContaining = sanctuary.distance_miles === 0 || sanctuary.distance_miles === null || sanctuary.distance_miles === undefined;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#0891b2' : '#06b6d4', // Darker cyan for containing, lighter for nearby
                  weight: 2,
                  opacity: 0.7,
                  fillColor: isContaining ? '#0891b2' : '#06b6d4',
                  fillOpacity: 0.2
                });

                // Build popup content
                const siteName = sanctuary.sitename || sanctuary.SITENAME || 'Unknown Marine Sanctuary';
                const unitName = sanctuary.unitname || sanctuary.UNITNAME || '';
                const siteUrl = sanctuary.siteurl || sanctuary.SITEURL || '';
                const citation = sanctuary.citation || sanctuary.CITATION || '';
                const cfrSection = sanctuary.cfrsection || sanctuary.CFRSECTION || '';
                const distance = sanctuary.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌊 ${siteName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${unitName ? `<div><strong>Unit:</strong> ${unitName}</div>` : ''}
                      ${siteUrl ? `<div><strong>Website:</strong> <a href="${siteUrl}" target="_blank" rel="noopener noreferrer">${siteUrl}</a></div>` : ''}
                      ${citation ? `<div><strong>Citation:</strong> ${citation}</div>` : ''}
                      ${cfrSection ? `<div><strong>CFR Section:</strong> ${cfrSection}</div>` : ''}
                      ${distance !== null && distance !== undefined && distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['national_marine_sanctuaries']) {
                  legendAccumulator['national_marine_sanctuaries'] = {
                    icon: '🌊',
                    color: '#0891b2',
                    title: 'National Marine Sanctuaries',
                    count: 0,
                  };
                }
                legendAccumulator['national_marine_sanctuaries'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing National Marine Sanctuary polygon:', error);
            }
          }
        });
      }

      // Draw MA ACECs as polygons on the map
      if (enrichments.ma_acecs_all && Array.isArray(enrichments.ma_acecs_all)) {
        enrichments.ma_acecs_all.forEach((acec: any) => {
          if (acec.geometry && acec.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = acec.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = acec.distance_miles === 0 || acec.distance_miles === null || acec.distance_miles === undefined;
                const polygon = L.polygon(latlngs, {
                  color: isContaining ? '#059669' : '#10b981', // Darker green for containing, lighter for nearby
                  weight: 2,
                  opacity: 0.7,
                  fillColor: isContaining ? '#059669' : '#10b981',
                  fillOpacity: 0.2
                });

                // Build popup content
                const name = acec.NAME || acec.name || 'Unknown ACEC';
                const acecId = acec.ACECID || acec.acecid || '';
                const desDate = acec.DES_DATE || acec.des_date || '';
                const secretary = acec.SECRETARY || acec.secretary || '';
                const adminBy = acec.ADMIN_BY || acec.admin_by || '';
                const region = acec.REGION || acec.region || '';
                const polyAcres = acec.POLY_ACRES || acec.poly_acres || '';
                const acecAcres = acec.ACEC_ACRES || acec.acec_acres || '';
                const distance = acec.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌿 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${acecId ? `<div><strong>ACEC ID:</strong> ${acecId}</div>` : ''}
                      ${desDate ? `<div><strong>Designation Date:</strong> ${desDate}</div>` : ''}
                      ${secretary ? `<div><strong>Secretary:</strong> ${secretary}</div>` : ''}
                      ${adminBy ? `<div><strong>Administered By:</strong> ${adminBy}</div>` : ''}
                      ${region ? `<div><strong>Region:</strong> ${region}</div>` : ''}
                      ${polyAcres ? `<div><strong>Polygon Acres:</strong> ${polyAcres.toLocaleString()}</div>` : ''}
                      ${acecAcres ? `<div><strong>ACEC Acres:</strong> ${acecAcres.toLocaleString()}</div>` : ''}
                      ${distance !== null && distance !== undefined && distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
                
                // Add to legend accumulator
                if (!legendAccumulator['ma_acecs']) {
                  legendAccumulator['ma_acecs'] = {
                    icon: '🌿',
                    color: '#059669',
                    title: 'MA Areas of Critical Environmental Concern',
                    count: 0,
                  };
                }
                legendAccumulator['ma_acecs'].count += 1;
              }
            } catch (error) {
              console.error('Error drawing MA ACEC polygon:', error);
            }
          }
        });
      }

      // Draw MA Trails as polylines on the map
      if (enrichments.ma_trails_all && Array.isArray(enrichments.ma_trails_all)) {
        enrichments.ma_trails_all.forEach((trail: any) => {
          if (trail.geometry && trail.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = trail.geometry.paths;
              paths.forEach((path: number[][]) => {
                const latlngs = path.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [coord[1], coord[0]] as [number, number];
                });

                const polyline = L.polyline(latlngs, {
                  color: '#10b981', // Green color for trails
                  weight: 3,
                  opacity: 0.8
                });

                // Build popup content with all trail attributes
                const trailName = trail.TRAIL_NAME || trail.Trail_Name || trail.trail_name || trail.altName || trail.ALT_NAME || trail.Alt_Name || 'Unnamed Trail';
                const town = trail.TOWN || trail.Town || trail.town || '';
                const siteName = trail.SITE_NAME || trail.Site_Name || trail.site_name || '';
                const shapeLength = trail.Shape__Length || trail.Shape_Length || trail.shape_length;
                const distance = trail.distance_miles;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🥾 ${trailName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${town ? `<div><strong>Town:</strong> ${town}</div>` : ''}
                      ${siteName ? `<div><strong>Site:</strong> ${siteName}</div>` : ''}
                      ${shapeLength ? `<div><strong>Length:</strong> ${(shapeLength * 0.000621371).toFixed(2)} miles</div>` : ''}
                      ${distance !== null && distance !== undefined ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other trail attributes (excluding internal fields)
                const excludeFields = ['TRAIL_NAME', 'Trail_Name', 'trail_name', 'ALT_NAME', 'Alt_Name', 'altName', 'TOWN', 'Town', 'town', 'SITE_NAME', 'Site_Name', 'site_name', 'Shape__Length', 'Shape_Length', 'shape_length', 'geometry', 'distance_miles'];
                Object.entries(trail).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polyline.bindPopup(popupContent, { maxWidth: 400 });
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
              
              // Add to legend accumulator (only once per trail, not per path)
              if (!legendAccumulator['ma_trails']) {
                legendAccumulator['ma_trails'] = {
                  icon: '🥾',
                  color: '#10b981',
                  title: 'MA Trails',
                  count: 0,
                };
              }
              legendAccumulator['ma_trails'].count += 1;
            } catch (error) {
              console.error('Error drawing MA Trail polyline:', error);
            }
          }
        });
      } else if (enrichments.nh_nwi_plus_geometry && !enrichments.nh_nwi_plus_all) {
        // Fallback: Draw single wetland from point-in-polygon query (no radius, no _all array)
        // Only draw if nh_nwi_plus_all doesn't exist to avoid duplicates
        try {
          const geometry = enrichments.nh_nwi_plus_geometry;
          if (geometry && geometry.rings) {
            const rings = geometry.rings;
            if (rings && rings.length > 0) {
              const outerRing = rings[0];
              const latlngs = outerRing.map((coord: number[]) => {
                return [coord[1], coord[0]] as [number, number];
              });

              const wetlandId = enrichments.nh_nwi_plus_wetland_id;
              const wetlandType = enrichments.nh_nwi_plus_wetland_type;
              const wetlandClass = enrichments.nh_nwi_plus_wetland_class;

              const polygon = L.polygon(latlngs, {
                color: '#14b8a6',
                weight: 3,
                opacity: 0.7,
                fillColor: '#14b8a6',
                fillOpacity: 0.2
              });

              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🌊 NH National Wetland Inventory (NWI) Plus
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${wetlandId ? `<div><strong>Wetland ID:</strong> ${String(wetlandId)}</div>` : ''}
                    ${wetlandType ? `<div><strong>Wetland Type:</strong> ${wetlandType}</div>` : ''}
                    ${wetlandClass ? `<div><strong>Wetland Class:</strong> ${wetlandClass}</div>` : ''}
                  </div>
                </div>
              `;

              polygon.bindPopup(popupContent, { maxWidth: 400 });
              polygon.addTo(primary);
              bounds.extend(polygon.getBounds());
              
              if (!legendAccumulator['nh_nwi_plus']) {
                legendAccumulator['nh_nwi_plus'] = {
                  icon: '🌊',
                  color: '#14b8a6',
                  title: 'NH NWI Plus Wetland',
                  count: 1,
                };
              }
            }
          }
        } catch (error) {
          console.error('Error drawing NH NWI Plus wetland polygon:', error);
        }
      }

      // Draw NH Hospitals as markers on the map
      if (enrichments.nh_hospitals_all && Array.isArray(enrichments.nh_hospitals_all)) {
        enrichments.nh_hospitals_all.forEach((hospital: any) => {
          if (hospital.lat && hospital.lon) {
            try {
              const hospitalLat = hospital.lat;
              const hospitalLon = hospital.lon;
              const hospitalName = hospital.name || hospital.NAME || hospital.Name || 'Unknown Hospital';
              const facType = hospital.fac_type || hospital.FAC_TYPE || hospital.FacType || 'Unknown Type';
              
              // Create a custom icon for hospitals
              const icon = createPOIIcon('🏥', '#dc2626'); // Red icon for hospitals
              
              const marker = L.marker([hospitalLat, hospitalLon], { icon });
              
              // Build popup content with all hospital attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🏥 ${hospitalName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${facType}</div>
                    ${hospital.address ? `<div><strong>Address:</strong> ${hospital.address}</div>` : ''}
                    ${hospital.city ? `<div><strong>City:</strong> ${hospital.city}</div>` : ''}
                    ${hospital.telephone ? `<div><strong>Phone:</strong> ${hospital.telephone}</div>` : ''}
                    ${hospital.beds !== null && hospital.beds !== undefined ? `<div><strong>Beds:</strong> ${hospital.beds}</div>` : ''}
                    ${hospital.owner ? `<div><strong>Owner:</strong> ${hospital.owner}</div>` : ''}
                    ${hospital.distance_miles !== null && hospital.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${hospital.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all hospital attributes (excluding internal fields)
              const excludeFields = ['name', 'fac_type', 'address', 'city', 'state', 'zip', 'telephone', 'beds', 'owner', 'lat', 'lon', 'distance_miles'];
              Object.entries(hospital).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this hospital
              bounds.extend([hospitalLat, hospitalLon]);
            } catch (error) {
              console.error('Error drawing NH Hospital marker:', error);
            }
          }
        });
      }

      // Draw NH Fire Stations as markers on the map
      if (enrichments.nh_fire_stations_all && Array.isArray(enrichments.nh_fire_stations_all)) {
        enrichments.nh_fire_stations_all.forEach((station: any) => {
          if (station.lat && station.lon) {
            try {
              const stationLat = station.lat;
              const stationLon = station.lon;
              const stationName = station.name || station.NAME || station.Name || 'Unknown Fire Station';
              const stationType = station.type || station.TYPE || station.Type || 'Unknown Type';
              
              // Create a custom icon for fire stations
              const icon = createPOIIcon('🚒', '#dc2626'); // Red icon for fire stations
              
              const marker = L.marker([stationLat, stationLon], { icon });
              
              // Build popup content with all fire station attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚒 ${stationName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${stationType}</div>
                    ${station.address ? `<div><strong>Address:</strong> ${station.address}</div>` : ''}
                    ${station.city ? `<div><strong>City:</strong> ${station.city}</div>` : ''}
                    ${station.telephone ? `<div><strong>Phone:</strong> ${station.telephone}</div>` : ''}
                    ${station.owner ? `<div><strong>Owner:</strong> ${station.owner}</div>` : ''}
                    ${station.fdid ? `<div><strong>FDID:</strong> ${station.fdid}</div>` : ''}
                    ${station.distance_miles !== null && station.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${station.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all fire station attributes (excluding internal fields)
              const excludeFields = ['name', 'type', 'address', 'city', 'state', 'zip', 'telephone', 'owner', 'fdid', 'lat', 'lon', 'distance_miles'];
              Object.entries(station).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this fire station
              bounds.extend([stationLat, stationLon]);
            } catch (error) {
              console.error('Error drawing NH Fire Station marker:', error);
            }
          }
        });
      }

      // Draw USVI Fire Stations as markers on the map
      if (enrichments.usvi_fire_stations_all && Array.isArray(enrichments.usvi_fire_stations_all)) {
        let fireStationCount = 0;
        enrichments.usvi_fire_stations_all.forEach((station: any) => {
          if (station.lat && station.lon) {
            try {
              const stationLat = station.lat;
              const stationLon = station.lon;
              const stationName = station.fac_name || station.FAC_NAME || station.Fac_Name || 'Unknown Fire Station';
              const stationType = station.fac_type || station.FAC_TYPE || station.Fac_Type || 'Unknown Type';
              
              // Create a custom icon for fire stations
              const icon = createPOIIcon('🚒', '#dc2626'); // Red icon for fire stations
              
              const marker = L.marker([stationLat, stationLon], { icon });
              
              // Build popup content with all fire station attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚒 ${stationName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${stationType}</div>
                    ${station.territory ? `<div><strong>Territory:</strong> ${station.territory}</div>` : ''}
                    ${station.county ? `<div><strong>County:</strong> ${station.county}</div>` : ''}
                    ${station.usng ? `<div><strong>USNG:</strong> ${station.usng}</div>` : ''}
                    ${station.flood_zone ? `<div><strong>Flood Zone:</strong> ${station.flood_zone}</div>` : ''}
                    ${station.distance_miles !== null && station.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${station.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
              `;
              
              // Add all fire station attributes (excluding internal fields)
              const excludeFields = ['fac_name', 'fac_type', 'territory', 'county', 'usng', 'flood_zone', 'x', 'y', 'lat', 'lon', 'distance_miles', 'attributes'];
              Object.entries(station).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              // Also include any nested attributes object
              if (station.attributes && typeof station.attributes === 'object') {
                Object.entries(station.attributes).forEach(([key, value]) => {
                  if (value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
              }
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this fire station
              bounds.extend([stationLat, stationLon]);
              fireStationCount++;
            } catch (error) {
              console.error('Error drawing USVI Fire Station marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (fireStationCount > 0) {
          if (!legendAccumulator['usvi_fire_stations']) {
            legendAccumulator['usvi_fire_stations'] = {
              icon: '🚒',
              color: '#dc2626',
              title: 'USVI Fire Stations',
              count: 0,
            };
          }
          legendAccumulator['usvi_fire_stations'].count += fireStationCount;
        }
      }

      // Draw USVI Police Stations as markers on the map
      if (enrichments.usvi_police_stations_all && Array.isArray(enrichments.usvi_police_stations_all)) {
        let policeStationCount = 0;
        enrichments.usvi_police_stations_all.forEach((station: any) => {
          if (station.lat && station.lon) {
            try {
              const stationLat = station.lat;
              const stationLon = station.lon;
              const stationName = station.fac_name || station.FAC_NAME || station.Fac_Name || 'Unknown Police Station';
              const stationType = station.fac_type || station.FAC_TYPE || station.Fac_Type || 'Unknown Type';
              
              // Create a custom icon for police stations
              const icon = createPOIIcon('🚓', '#1e40af'); // Blue icon for police stations
              
              const marker = L.marker([stationLat, stationLon], { icon });
              
              // Build popup content with all police station attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚓 ${stationName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${stationType}</div>
                    ${station.territory ? `<div><strong>Territory:</strong> ${station.territory}</div>` : ''}
                    ${station.county ? `<div><strong>County:</strong> ${station.county}</div>` : ''}
                    ${station.usng ? `<div><strong>USNG:</strong> ${station.usng}</div>` : ''}
                    ${station.flood_zone ? `<div><strong>Flood Zone:</strong> ${station.flood_zone}</div>` : ''}
                    ${station.distance_miles !== null && station.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${station.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
              `;
              
              // Add all police station attributes (excluding internal fields)
              const excludeFields = ['fac_name', 'fac_type', 'territory', 'county', 'usng', 'flood_zone', 'x', 'y', 'lat', 'lon', 'distance_miles', 'attributes'];
              Object.entries(station).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              // Also include any nested attributes object
              if (station.attributes && typeof station.attributes === 'object') {
                Object.entries(station.attributes).forEach(([key, value]) => {
                  if (value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
              }
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this police station
              bounds.extend([stationLat, stationLon]);
              policeStationCount++;
            } catch (error) {
              console.error('Error drawing USVI Police Station marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (policeStationCount > 0) {
          if (!legendAccumulator['usvi_police_stations']) {
            legendAccumulator['usvi_police_stations'] = {
              icon: '🚓',
              color: '#1e40af',
              title: 'USVI Police Stations',
              count: 0,
            };
          }
          legendAccumulator['usvi_police_stations'].count += policeStationCount;
        }
      }

      // Draw USVI Health Care Facilities as markers on the map
      try {
        if (enrichments.usvi_health_care_facilities_all && Array.isArray(enrichments.usvi_health_care_facilities_all)) {
          let healthCareCount = 0;
          enrichments.usvi_health_care_facilities_all.forEach((facility: any) => {
            if (facility.lat && facility.lon) {
              try {
                const facilityLat = facility.lat;
                const facilityLon = facility.lon;
                const facilityName = facility.facilityName || facility.FacilityName || facility.facility_name || 'Unknown Health Care Facility';
                const facilityType = facility.fac_type || facility.FAC_TYPE || facility.Fac_Type || 'Unknown Type';
                
                // Create a custom icon for health care facilities
                const icon = createPOIIcon('🏥', '#10b981'); // Green icon for health care facilities
                
                const marker = L.marker([facilityLat, facilityLon], { icon });
                
                // Build popup content with all health care facility attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏥 ${facilityName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> ${facilityType}</div>
                      ${facility.territory ? `<div><strong>Territory:</strong> ${facility.territory}</div>` : ''}
                      ${facility.county ? `<div><strong>County:</strong> ${facility.county}</div>` : ''}
                      ${facility.address ? `<div><strong>Address:</strong> ${facility.address}</div>` : ''}
                      ${facility.usng ? `<div><strong>USNG:</strong> ${facility.usng}</div>` : ''}
                      ${facility.gen_capaci ? `<div><strong>Generator Capacity:</strong> ${facility.gen_capaci}</div>` : ''}
                      ${facility.diesel_gal ? `<div><strong>Diesel (Gallons):</strong> ${facility.diesel_gal}</div>` : ''}
                      ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;
                
                // Add all health care facility attributes (excluding internal fields)
                const excludeFields = ['facilityName', 'fac_type', 'territory', 'county', 'address', 'usng', 'gen_capaci', 'diesel_gal', 'latitude', 'longitude', 'lat', 'lon', 'distance_miles', 'attributes'];
                Object.entries(facility).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                // Also include any nested attributes object
                if (facility.attributes && typeof facility.attributes === 'object') {
                  Object.entries(facility.attributes).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                }
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                
                // Extend bounds to include this health care facility
                bounds.extend([facilityLat, facilityLon]);
                healthCareCount++;
              } catch (err) {
                console.error('Error drawing USVI Health Care Facility marker:', err);
              }
            }
          });
          
          // Add to legend
          if (healthCareCount > 0) {
            if (!legendAccumulator['usvi_health_care_facilities']) {
              legendAccumulator['usvi_health_care_facilities'] = {
                icon: '🏥',
                color: '#10b981',
                title: 'USVI Health Care Facilities',
                count: 0,
              };
            }
            legendAccumulator['usvi_health_care_facilities'].count += healthCareCount;
          }
        }
      } catch (error) {
        console.error('Error processing USVI Health Care Facilities:', error);
      }

      // Draw NH Nursing Homes as markers on the map
      if (enrichments.nh_nursing_homes_all && Array.isArray(enrichments.nh_nursing_homes_all)) {
        enrichments.nh_nursing_homes_all.forEach((home: any) => {
          if (home.lat && home.lon) {
            try {
              const homeLat = home.lat;
              const homeLon = home.lon;
              const homeName = home.name || home.NAME || home.Name || 'Unknown Nursing Home';
              const facType = home.fac_type || home.FAC_TYPE || home.FacType || 'Unknown Type';
              
              // Create a custom icon for nursing homes
              const icon = createPOIIcon('🏥', '#dc2626'); // Red icon for healthcare facilities
              
              const marker = L.marker([homeLat, homeLon], { icon });
              
              // Build popup content with all nursing home attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🏥 ${homeName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${facType}</div>
                    ${home.address ? `<div><strong>Address:</strong> ${home.address}</div>` : ''}
                    ${home.city ? `<div><strong>City:</strong> ${home.city}</div>` : ''}
                    ${home.telephone ? `<div><strong>Phone:</strong> ${home.telephone}</div>` : ''}
                    ${home.beds !== null && home.beds !== undefined ? `<div><strong>Beds:</strong> ${home.beds}</div>` : ''}
                    ${home.distance_miles !== null && home.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${home.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all nursing home attributes (excluding internal fields)
              const excludeFields = ['name', 'fac_type', 'address', 'city', 'state', 'zip', 'telephone', 'beds', 'lat', 'lon', 'distance_miles'];
              Object.entries(home).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this nursing home
              bounds.extend([homeLat, homeLon]);
            } catch (error) {
              console.error('Error drawing NH Nursing Home marker:', error);
            }
          }
        });
      }

      // Draw NH Key Destinations as markers on the map
      if (enrichments.nh_key_destinations_all && Array.isArray(enrichments.nh_key_destinations_all)) {
        enrichments.nh_key_destinations_all.forEach((dest: any) => {
          if (dest.lat && dest.lon) {
            try {
              const destLat = dest.lat;
              const destLon = dest.lon;
              const destName = dest.name || dest.NAME || dest.Name || 'Unknown Destination';
              const destType = dest.type || dest.TYPE || dest.Type || 'Unknown Type';
              
              // Create a custom icon for key destinations
              const icon = createPOIIcon('📍', '#8b5cf6'); // Purple icon for destinations
              
              const marker = L.marker([destLat, destLon], { icon });
              
              // Build popup content with all destination attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    📍 ${destName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    <div><strong>Type:</strong> ${destType}</div>
                    ${dest.distance_miles !== null && dest.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${dest.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all destination attributes (excluding internal fields)
              const excludeFields = ['name', 'type', 'lat', 'lon', 'distance_miles'];
              Object.entries(dest).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              
              // Extend bounds to include this destination
              bounds.extend([destLat, destLon]);
            } catch (error) {
              console.error('Error drawing NH Key Destination marker:', error);
            }
          }
        });
      }

      // Draw NH Parcels as polygons on the map
      if (enrichments.nh_parcels_all && Array.isArray(enrichments.nh_parcels_all)) {
        enrichments.nh_parcels_all.forEach((parcel: any) => {
          if (parcel.geometry && parcel.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = parcel.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = parcel.isContaining;
                const color = isContaining ? '#dc2626' : '#3b82f6'; // Red for containing, blue for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all parcel attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '📍 Containing Parcel' : '🏠 Nearby Parcel'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; max-height: 400px; overflow-y: auto;">
                `;
                
                // Add all parcel attributes (excluding internal fields)
                const excludeFields = ['parcelId', 'isContaining', 'distance_miles', 'geometry'];
                Object.entries(parcel).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
              }
            } catch (error) {
              console.error('Error drawing NH parcel polygon:', error);
            }
          }
        });
      }

      // Draw MA Parcels as polygons on the map
      if (enrichments.ma_parcels_all && Array.isArray(enrichments.ma_parcels_all)) {
        enrichments.ma_parcels_all.forEach((parcel: any) => {
          if (parcel.geometry && parcel.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = parcel.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                const isContaining = parcel.isContaining;
                const color = isContaining ? '#dc2626' : '#3b82f6'; // Red for containing, blue for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all parcel attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '📍 Containing Parcel' : '🏠 Nearby Parcel'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; max-height: 400px; overflow-y: auto;">
                `;
                
                // Add all parcel attributes (excluding internal fields)
                const excludeFields = ['parcelId', 'isContaining', 'distance_miles', 'geometry'];
                Object.entries(parcel).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
              }
            } catch (error) {
              console.error('Error drawing MA parcel polygon:', error);
            }
          }
        });
      }

      // Draw CT Parcels as polygons on the map
      if (enrichments.ct_parcels_all && Array.isArray(enrichments.ct_parcels_all)) {
        let parcelCount = 0;
        enrichments.ct_parcels_all.forEach((parcel: any) => {
          if (parcel.geometry && parcel.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = parcel.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                // Validate coordinates
                if (latlngs.length < 3) {
                  console.warn('CT Parcel polygon has less than 3 coordinates, skipping');
                  return;
                }

                const isContaining = parcel.isContaining;
                const color = isContaining ? '#059669' : '#10b981'; // Darker green for containing, lighter for nearby
                const weight = isContaining ? 3 : 2;

                const parcelId = parcel.parcelId || parcel.Link || parcel.link || parcel.OBJECTID || 'Unknown';
                const townName = parcel.Town_Name || parcel.TownName || parcel.town_name || '';
                const owner = parcel.Owner || parcel.owner || '';
                const location = parcel.Location || parcel.location || '';
                const assessedTotal = parcel.Assessed_Total || parcel.AssessedTotal || parcel.assessed_total || null;

                // Create polygon
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: 0.7,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏠 CT Parcel ${parcelId}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                      ${parcel.distance_miles !== null && parcel.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${parcel.distance_miles.toFixed(2)} miles</div>` : ''}
                      ${townName ? `<div><strong>Town:</strong> ${townName}</div>` : ''}
                      ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                      ${location ? `<div><strong>Location:</strong> ${location}</div>` : ''}
                      ${assessedTotal !== null ? `<div><strong>Assessed Total:</strong> $${assessedTotal.toLocaleString()}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all parcel attributes (excluding internal fields)
                const excludeFields = ['parcelId', 'Link', 'link', 'OBJECTID', 'objectid', 'isContaining', 'geometry', 'distance_miles', 'Town_Name', 'TownName', 'town_name', 'Owner', 'owner', 'Location', 'location', 'Assessed_Total', 'AssessedTotal', 'assessed_total'];
                Object.entries(parcel).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary); // Add to primary layer group
                
                try {
                  bounds.extend(polygon.getBounds());
                  parcelCount++;
                } catch (boundsError) {
                  console.warn('Error extending bounds for CT Parcel polygon:', boundsError);
                }
              }
            } catch (error) {
              console.error('Error drawing CT Parcel polygon:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (parcelCount > 0) {
          if (!legendAccumulator['ct_parcels']) {
            legendAccumulator['ct_parcels'] = {
              icon: '🏠',
              color: '#059669',
              title: 'CT Parcels',
              count: 0,
            };
          }
          legendAccumulator['ct_parcels'].count += parcelCount;
        }
      }

      // Draw NJ Parcels as polygons on the map
      if (enrichments.nj_parcels_all && Array.isArray(enrichments.nj_parcels_all)) {
        let parcelCount = 0;
        enrichments.nj_parcels_all.forEach((parcel: any) => {
          if (parcel.geometry && parcel.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              const rings = parcel.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                // Validate coordinates
                if (latlngs.length < 3) {
                  console.warn('NJ Parcel polygon has less than 3 coordinates, skipping');
                  return;
                }

                const isContaining = parcel.isContaining;
                const color = isContaining ? '#059669' : '#10b981'; // Darker green for containing, lighter for nearby
                const weight = isContaining ? 3 : 2;

                const parcelId = parcel.parcelId || parcel.PAMS_PIN || parcel.pams_pin || parcel.GIS_PIN || parcel.gis_pin || parcel.PIN_NODUP || parcel.pin_nodup || 'Unknown';
                const pin = parcel.pin || parcel.PAMS_PIN || parcel.pams_pin || parcel.GIS_PIN || parcel.gis_pin || parcel.PIN_NODUP || parcel.pin_nodup || '';
                const municipality = parcel.municipality || parcel.MUN_NAME || parcel.mun_name || '';
                const county = parcel.county || parcel.COUNTY || parcel.county || '';
                const block = parcel.block || parcel.PCLBLOCK || parcel.pclblock || '';
                const lot = parcel.lot || parcel.PCLLOT || parcel.pcllot || '';
                const ownerName = parcel.ownerName || parcel.OWNER_NAME || parcel.owner_name || '';
                const streetAddress = parcel.streetAddress || parcel.ST_ADDRESS || parcel.st_address || '';
                const cityState = parcel.cityState || parcel.CITY_STATE || parcel.city_state || '';
                const zipCode = parcel.zipCode || parcel.ZIP_CODE || parcel.zip_code || parcel.ZIP5 || parcel.zip5 || '';
                const landValue = parcel.landValue || parcel.LAND_VAL || parcel.land_val || null;
                const improvementValue = parcel.improvementValue || parcel.IMPRVT_VAL || parcel.imprvt_val || null;
                const netValue = parcel.netValue || parcel.NET_VALUE || parcel.net_value || null;
                const acres = parcel.acres || parcel.CALC_ACRE || parcel.calc_acre || null;

                // Create polygon
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: 0.7,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏠 NJ Parcel ${parcelId}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                      ${parcel.distance_miles !== null && parcel.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${parcel.distance_miles.toFixed(2)} miles</div>` : ''}
                      ${pin ? `<div><strong>PIN:</strong> ${pin}</div>` : ''}
                      ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${block ? `<div><strong>Block:</strong> ${block}</div>` : ''}
                      ${lot ? `<div><strong>Lot:</strong> ${lot}</div>` : ''}
                      ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                      ${streetAddress ? `<div><strong>Address:</strong> ${streetAddress}</div>` : ''}
                      ${cityState ? `<div><strong>City/State:</strong> ${cityState}</div>` : ''}
                      ${zipCode ? `<div><strong>ZIP:</strong> ${zipCode}</div>` : ''}
                      ${landValue !== null ? `<div><strong>Land Value:</strong> $${landValue.toLocaleString()}</div>` : ''}
                      ${improvementValue !== null ? `<div><strong>Improvement Value:</strong> $${improvementValue.toLocaleString()}</div>` : ''}
                      ${netValue !== null ? `<div><strong>Net Value:</strong> $${netValue.toLocaleString()}</div>` : ''}
                      ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toFixed(2)}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all parcel attributes (excluding internal fields)
                const excludeFields = ['parcelId', 'pin', 'municipality', 'county', 'block', 'lot', 'ownerName', 'streetAddress', 'cityState', 'zipCode', 'landValue', 'improvementValue', 'netValue', 'acres', 'isContaining', 'geometry', 'distance_miles', 'PAMS_PIN', 'pams_pin', 'GIS_PIN', 'gis_pin', 'PIN_NODUP', 'pin_nodup', 'MUN_NAME', 'mun_name', 'COUNTY', 'county', 'PCLBLOCK', 'pclblock', 'PCLLOT', 'pcllot', 'OWNER_NAME', 'owner_name', 'ST_ADDRESS', 'st_address', 'CITY_STATE', 'city_state', 'ZIP_CODE', 'zip_code', 'ZIP5', 'zip5', 'LAND_VAL', 'land_val', 'IMPRVT_VAL', 'imprvt_val', 'NET_VALUE', 'net_value', 'CALC_ACRE', 'calc_acre'];
                Object.entries(parcel).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary); // Add to primary layer group
                
                try {
                  bounds.extend(polygon.getBounds());
                  parcelCount++;
                } catch (boundsError) {
                  console.warn('Error extending bounds for NJ Parcel polygon:', boundsError);
                }
              }
            } catch (error) {
              console.error('Error drawing NJ Parcel polygon:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (parcelCount > 0) {
          if (!legendAccumulator['nj_parcels']) {
            legendAccumulator['nj_parcels'] = {
              icon: '🏠',
              color: '#059669',
              title: 'NJ Tax Parcels',
              count: 0,
            };
          }
          legendAccumulator['nj_parcels'].count += parcelCount;
        }
      }

      // Draw NJ Address Points as markers on the map
      if (enrichments.nj_address_points_all && Array.isArray(enrichments.nj_address_points_all)) {
        let addressPointCount = 0;
        enrichments.nj_address_points_all.forEach((point: any) => {
          if (point.lat && point.lon) {
            try {
              const pointLat = point.lat;
              const pointLon = point.lon;
              const fullAddress = point.fullAddress || point.FULL_ADDRESS || point.full_address || 'Unknown Address';
              const streetName = point.streetName || point.ST_NAME || point.st_name || point.LST_NAME || point.lst_name || '';
              const streetNumber = point.streetNumber || point.ST_NUMBER || point.st_number || point.LST_NUMBER || point.lst_number || '';
              const municipality = point.municipality || point.INC_MUNI || point.inc_muni || '';
              const county = point.county || point.COUNTY || point.county || '';
              const zipCode = point.zipCode || point.POST_CODE || point.post_code || point.ZIP_CODE || point.zip_code || '';
              const subtype = point.subtype || point.SUBTYPE || point.subtype || '';
              const placement = point.placement || point.PLACEMENT || point.placement || '';
              
              // Create a custom icon for address points
              const icon = createPOIIcon('📍', '#3b82f6'); // Blue icon for address points
              
              const marker = L.marker([pointLat, pointLon], { icon });
              
              // Build popup content with all address point attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    📍 ${fullAddress}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${streetNumber ? `<div><strong>Street Number:</strong> ${streetNumber}</div>` : ''}
                    ${streetName ? `<div><strong>Street Name:</strong> ${streetName}</div>` : ''}
                    ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${zipCode ? `<div><strong>ZIP Code:</strong> ${zipCode}</div>` : ''}
                    ${subtype ? `<div><strong>Subtype:</strong> ${subtype}</div>` : ''}
                    ${placement ? `<div><strong>Placement:</strong> ${placement}</div>` : ''}
                    ${point.distance_miles !== null && point.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${point.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all address point attributes (excluding internal fields)
              const excludeFields = ['fullAddress', 'streetName', 'streetNumber', 'municipality', 'county', 'zipCode', 'subtype', 'placement', 'lat', 'lon', 'distance_miles', 'FULL_ADDRESS', 'full_address', 'ST_NAME', 'st_name', 'LST_NAME', 'lst_name', 'ST_NUMBER', 'st_number', 'LST_NUMBER', 'lst_number', 'INC_MUNI', 'inc_muni', 'COUNTY', 'county', 'POST_CODE', 'post_code', 'ZIP_CODE', 'zip_code', 'ZIP5', 'zip5', 'SUBTYPE', 'subtype', 'PLACEMENT', 'placement'];
              Object.entries(point).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                    </div>
                  </div>
                `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([pointLat, pointLon]);
                addressPointCount++;
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Address Point:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Address Point:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (addressPointCount > 0) {
          if (!legendAccumulator['nj_address_points']) {
            legendAccumulator['nj_address_points'] = {
              icon: '📍',
              color: '#3b82f6',
              title: 'NJ Address Points',
              count: 0,
            };
          }
          legendAccumulator['nj_address_points'].count += addressPointCount;
        }
      }

      // Draw NJ Bus Stops as markers on the map
      if (enrichments.nj_bus_stops_all && Array.isArray(enrichments.nj_bus_stops_all)) {
        let busStopCount = 0;
        enrichments.nj_bus_stops_all.forEach((stop: any) => {
          if (stop.lat && stop.lon) {
            try {
              const stopLat = stop.lat;
              const stopLon = stop.lon;
              const description = stop.description || stop.DESCRIPTION_BSL || stop.description_bsl || 'Unknown Bus Stop';
              const stopNumber = stop.stopNumber || stop.STOP_NUM || stop.stop_num || '';
              const county = stop.county || stop.COUNTY || stop.county || '';
              const municipality = stop.municipality || stop.MUNICIPALITY || stop.municipality || '';
              const stopType = stop.stopType || stop.STOP_TYPE || stop.stop_type || '';
              const direction = stop.direction || stop.DIRECTION_OP || stop.direction_op || '';
              const streetDirection = stop.streetDirection || stop.STREET_DIR || stop.street_dir || '';
              const allLines = stop.allLines || stop.ALL_LINES || stop.all_lines || '';
              
              // Create a custom icon for bus stops
              const icon = createPOIIcon('🚌', '#f59e0b'); // Orange icon for bus stops
              
              const marker = L.marker([stopLat, stopLon], { icon });
              
              // Build popup content with all bus stop attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🚌 ${description}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${stopNumber ? `<div><strong>Stop Number:</strong> ${stopNumber}</div>` : ''}
                    ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${stopType ? `<div><strong>Stop Type:</strong> ${stopType}</div>` : ''}
                    ${direction ? `<div><strong>Direction:</strong> ${direction}</div>` : ''}
                    ${streetDirection ? `<div><strong>Street Direction:</strong> ${streetDirection}</div>` : ''}
                    ${allLines ? `<div><strong>Bus Lines:</strong> ${allLines}</div>` : ''}
                    ${stop.distance_miles !== null && stop.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${stop.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all bus stop attributes (excluding internal fields)
              const excludeFields = ['description', 'stopNumber', 'county', 'municipality', 'stopType', 'direction', 'streetDirection', 'allLines', 'lat', 'lon', 'distance_miles', 'DESCRIPTION_BSL', 'description_bsl', 'DESCRIPTION', 'description', 'STOP_NUM', 'stop_num', 'STOP_NUMBER', 'stop_number', 'COUNTY', 'county', 'MUNICIPALITY', 'municipality', 'STOP_TYPE', 'stop_type', 'DIRECTION_OP', 'direction_op', 'DIRECTION', 'direction', 'STREET_DIR', 'street_dir', 'ALL_LINES', 'all_lines', 'LINES', 'lines'];
              Object.entries(stop).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                    </div>
                  </div>
                `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([stopLat, stopLon]);
                busStopCount++;
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Bus Stop:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Bus Stop:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (busStopCount > 0) {
          if (!legendAccumulator['nj_bus_stops']) {
            legendAccumulator['nj_bus_stops'] = {
              icon: '🚌',
              color: '#f59e0b',
              title: 'NJ Bus Stops',
              count: 0,
            };
          }
          legendAccumulator['nj_bus_stops'].count += busStopCount;
        }
      }

      // Draw NJ Safety Service Patrol routes as polylines on the map
      if (enrichments.nj_safety_service_patrol_all && Array.isArray(enrichments.nj_safety_service_patrol_all)) {
        let patrolRouteCount = 0;
        enrichments.nj_safety_service_patrol_all.forEach((route: any) => {
          if (route.geometry && route.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = route.geometry.paths;
              if (paths && paths.length > 0) {
                patrolRouteCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const routeName = route.routeName || route.SRI_ || route.sri_ || route.ROUTE || route.route || 'Unknown Route';
                  const sri = route.sri || route.SRI || route.sri || '';
                  const beginMile = route.beginMile !== null && route.beginMile !== undefined ? route.beginMile : null;
                  const endMile = route.endMile !== null && route.endMile !== undefined ? route.endMile : null;
                  const totalMiles = route.totalMiles !== null && route.totalMiles !== undefined ? route.totalMiles : null;
                  const category = route.category || route.CAT || route.cat || '';
                  const categoryType = route.categoryType || route.CAT_1 || route.cat_1 || '';

                  // Create polyline with red color for safety service patrol
                  const polyline = L.polyline(latlngs, {
                    color: '#dc2626', // Red color for safety service patrol
                    weight: 4,
                    opacity: 0.8,
                    smoothFactor: 1
                  });

                  // Build popup content with all route attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🚨 ${routeName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${sri ? `<div><strong>SRI:</strong> ${sri}</div>` : ''}
                        ${beginMile !== null ? `<div><strong>Begin Mile:</strong> ${beginMile.toFixed(2)}</div>` : ''}
                        ${endMile !== null ? `<div><strong>End Mile:</strong> ${endMile.toFixed(2)}</div>` : ''}
                        ${totalMiles !== null ? `<div><strong>Total Miles:</strong> ${totalMiles.toFixed(2)}</div>` : ''}
                        ${category ? `<div><strong>Category:</strong> ${category}</div>` : ''}
                        ${categoryType ? `<div><strong>Category Type:</strong> ${categoryType}</div>` : ''}
                        ${route.distance_miles !== null && route.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${route.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all route attributes (excluding internal fields)
                  const excludeFields = ['routeName', 'sri', 'beginMile', 'endMile', 'totalMiles', 'category', 'categoryType', 'locationError', 'geometry', 'distance_miles', 'SRI_', 'sri_', 'ROUTE', 'route', 'SRI', 'sri', 'BEGIN_MILE', 'begin_mile', 'END_MILEPO', 'end_milepo', 'TOTAL_MILE', 'total_mile', 'CAT', 'cat', 'CAT_1', 'cat_1', 'LOC_ERROR', 'loc_error'];
                  Object.entries(route).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi); // Add to POI layer group
                  
                  try {
                    bounds.extend(polyline.getBounds());
                  } catch (boundsError) {
                    console.warn('Error extending bounds for NJ Safety Service Patrol route:', boundsError);
                  }
                });
              }
            } catch (error) {
              console.error('Error drawing NJ Safety Service Patrol route:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (patrolRouteCount > 0) {
          if (!legendAccumulator['nj_safety_service_patrol']) {
            legendAccumulator['nj_safety_service_patrol'] = {
              icon: '🚨',
              color: '#dc2626',
              title: 'NJ Safety Service Patrol',
              count: 0,
            };
          }
          legendAccumulator['nj_safety_service_patrol'].count += patrolRouteCount;
        }
      }

      // Draw NJ Service Areas as markers on the map
      if (enrichments.nj_service_areas_all && Array.isArray(enrichments.nj_service_areas_all)) {
        let serviceAreaCount = 0;
        enrichments.nj_service_areas_all.forEach((area: any) => {
          if (area.lat && area.lon) {
            try {
              const areaLat = area.lat;
              const areaLon = area.lon;
              const name = area.name || area.NAME || area.name || 'Unknown Service Area';
              const route = area.route || area.ROUTE || area.route || '';
              const milepost = area.milepost !== null && area.milepost !== undefined ? area.milepost : null;
              const lineType = area.lineType || area.LINETYPE || area.linetype || '';
              const rotation = area.rotation !== null && area.rotation !== undefined ? area.rotation : null;
              
              // Create a custom icon for service areas
              const icon = createPOIIcon('🛣️', '#8b5cf6'); // Purple icon for service areas
              
              const marker = L.marker([areaLat, areaLon], { icon });
              
              // Build popup content with all service area attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🛣️ ${name}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${route ? `<div><strong>Route:</strong> ${route}</div>` : ''}
                    ${milepost !== null ? `<div><strong>Milepost:</strong> ${milepost.toFixed(2)}</div>` : ''}
                    ${lineType ? `<div><strong>Line Type:</strong> ${lineType}</div>` : ''}
                    ${rotation !== null ? `<div><strong>Rotation:</strong> ${rotation}°</div>` : ''}
                    ${area.distance_miles !== null && area.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${area.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all service area attributes (excluding internal fields)
              const excludeFields = ['name', 'route', 'milepost', 'lineType', 'rotation', 'lat', 'lon', 'distance_miles', 'NAME', 'name', 'ROUTE', 'route', 'MILEPOST', 'milepost', 'LINETYPE', 'linetype', 'ROTATION', 'rotation'];
              Object.entries(area).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                    </div>
                  </div>
                `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([areaLat, areaLon]);
                serviceAreaCount++;
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Service Area:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Service Area:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (serviceAreaCount > 0) {
          if (!legendAccumulator['nj_service_areas']) {
            legendAccumulator['nj_service_areas'] = {
              icon: '🛣️',
              color: '#8b5cf6',
              title: 'NJ Service Areas',
              count: 0,
            };
          }
          legendAccumulator['nj_service_areas'].count += serviceAreaCount;
        }
      }

      // Draw NJ Roadway Network as polylines on the map
      if (enrichments.nj_roadway_network_all && Array.isArray(enrichments.nj_roadway_network_all)) {
        let roadwayCount = 0;
        enrichments.nj_roadway_network_all.forEach((roadway: any) => {
          if (roadway.geometry && roadway.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              const paths = roadway.geometry.paths;
              if (paths && paths.length > 0) {
                roadwayCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const sldName = roadway.sldName || roadway.SLD_NAME || roadway.sld_name || roadway.NAME || roadway.name || 'Unknown Roadway';
                  const sri = roadway.sri || roadway.SRI || roadway.sri || '';
                  const parentSRI = roadway.parentSRI || roadway.PARENT_SRI || roadway.parent_sri || '';
                  const mpStart = roadway.mpStart !== null && roadway.mpStart !== undefined ? roadway.mpStart : null;
                  const mpEnd = roadway.mpEnd !== null && roadway.mpEnd !== undefined ? roadway.mpEnd : null;
                  const parentMpStart = roadway.parentMpStart !== null && roadway.parentMpStart !== undefined ? roadway.parentMpStart : null;
                  const parentMpEnd = roadway.parentMpEnd !== null && roadway.parentMpEnd !== undefined ? roadway.parentMpEnd : null;
                  const measuredLength = roadway.measuredLength !== null && roadway.measuredLength !== undefined ? roadway.measuredLength : null;
                  const direction = roadway.direction || roadway.DIRECTION || roadway.direction || '';
                  const active = roadway.active || roadway.ACTIVE || roadway.active || '';
                  const routeSubtype = roadway.routeSubtype !== null && roadway.routeSubtype !== undefined ? roadway.routeSubtype : null;
                  const roadNum = roadway.roadNum || roadway.ROAD_NUM || roadway.road_num || '';

                  // Create polyline with yellow color for roadways
                  const polyline = L.polyline(latlngs, {
                    color: '#fbbf24', // Yellow color for roadways (better visibility on imagery basemap)
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1
                  });

                  // Build popup content with all roadway attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🛣️ ${sldName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${sri ? `<div><strong>SRI:</strong> ${sri}</div>` : ''}
                        ${parentSRI ? `<div><strong>Parent SRI:</strong> ${parentSRI}</div>` : ''}
                        ${mpStart !== null ? `<div><strong>MP Start:</strong> ${mpStart.toFixed(3)}</div>` : ''}
                        ${mpEnd !== null ? `<div><strong>MP End:</strong> ${mpEnd.toFixed(3)}</div>` : ''}
                        ${parentMpStart !== null ? `<div><strong>Parent MP Start:</strong> ${parentMpStart.toFixed(3)}</div>` : ''}
                        ${parentMpEnd !== null ? `<div><strong>Parent MP End:</strong> ${parentMpEnd.toFixed(3)}</div>` : ''}
                        ${measuredLength !== null ? `<div><strong>Measured Length:</strong> ${measuredLength.toFixed(3)} mi</div>` : ''}
                        ${direction ? `<div><strong>Direction:</strong> ${direction}</div>` : ''}
                        ${active ? `<div><strong>Active:</strong> ${active}</div>` : ''}
                        ${routeSubtype !== null ? `<div><strong>Route Subtype:</strong> ${routeSubtype}</div>` : ''}
                        ${roadNum ? `<div><strong>Road Number:</strong> ${roadNum}</div>` : ''}
                        ${roadway.distance_miles !== null && roadway.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${roadway.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all roadway attributes (excluding internal fields)
                  const excludeFields = ['sldName', 'sri', 'parentSRI', 'mpStart', 'mpEnd', 'parentMpStart', 'parentMpEnd', 'measuredLength', 'direction', 'active', 'routeSubtype', 'roadNum', 'geometry', 'distance_miles', 'SLD_NAME', 'sld_name', 'NAME', 'name', 'SRI', 'sri', 'PARENT_SRI', 'parent_sri', 'MP_START', 'mp_start', 'MP_END', 'mp_end', 'PARENT_MP_START', 'parent_mp_start', 'PARENT_MP_END', 'parent_mp_end', 'MEASURED_LENGTH', 'measured_length', 'DIRECTION', 'direction', 'ACTIVE', 'active', 'ROUTE_SUBTYPE', 'route_subtype', 'ROAD_NUM', 'road_num'];
                  Object.entries(roadway).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi); // Add to POI layer group
                  
                  try {
                    bounds.extend(polyline.getBounds());
                  } catch (boundsError) {
                    console.warn('Error extending bounds for NJ Roadway Network segment:', boundsError);
                  }
                });
              }
            } catch (error) {
              console.error('Error drawing NJ Roadway Network segment:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (roadwayCount > 0) {
          if (!legendAccumulator['nj_roadway_network']) {
            legendAccumulator['nj_roadway_network'] = {
              icon: '🛣️',
              color: '#fbbf24',
              title: 'NJ Roadway Network',
              count: 0,
            };
          }
          legendAccumulator['nj_roadway_network'].count += roadwayCount;
        }
      }

      // Draw NJ Known Contaminated Sites as markers on the map
      if (enrichments.nj_known_contaminated_sites_all && Array.isArray(enrichments.nj_known_contaminated_sites_all)) {
        let contaminatedSiteCount = 0;
        enrichments.nj_known_contaminated_sites_all.forEach((site: any) => {
          if (site.lat !== null && site.lat !== undefined && site.lon !== null && site.lon !== undefined) {
            try {
              contaminatedSiteCount++;
              
              const siteName = site.siteName || site.SITE_NAME || site.site_name || site.NAME || site.name || site.SITE || site.site || 'Unknown Site';
              const address = site.address || site.ADDRESS || site.address || '';
              const municipality = site.municipality || site.MUNICIPALITY || site.municipality || '';
              const county = site.county || site.COUNTY || site.county || '';
              const zipCode = site.zipCode || site.ZIP_CODE || site.zip_code || site.ZIP || site.zip || '';
              const siteType = site.siteType || site.SITE_TYPE || site.site_type || site.TYPE || site.type || '';
              const status = site.status || site.STATUS || site.status || site.SITE_STATUS || site.site_status || '';

              // Create marker with warning icon color
              const marker = L.marker([site.lat, site.lon], {
                icon: L.divIcon({
                  className: 'custom-marker-icon',
                  html: `<div style="background-color: #dc2626; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <span style="color: white; font-size: 14px;">⚠️</span>
                  </div>`,
                  iconSize: [24, 24],
                  iconAnchor: [12, 12]
                })
              });

              // Build popup content with all site attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    ⚠️ ${siteName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${zipCode ? `<div><strong>ZIP Code:</strong> ${zipCode}</div>` : ''}
                    ${siteType ? `<div><strong>Site Type:</strong> ${siteType}</div>` : ''}
                    ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                    ${site.distance_miles !== null && site.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${site.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all site attributes (excluding internal fields)
              const excludeFields = ['siteId', 'siteName', 'address', 'municipality', 'county', 'zipCode', 'siteType', 'status', 'lat', 'lon', 'distance_miles', 'SITE_NAME', 'site_name', 'NAME', 'name', 'SITE', 'site', 'ADDRESS', 'address', 'ADDR', 'addr', 'MUNICIPALITY', 'municipality', 'MUNI', 'muni', 'CITY', 'city', 'COUNTY', 'county', 'ZIP_CODE', 'zip_code', 'ZIP', 'zip', 'POSTAL_CODE', 'postal_code', 'SITE_TYPE', 'site_type', 'TYPE', 'type', 'STATUS', 'status', 'SITE_STATUS', 'site_status'];
              Object.entries(site).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;

              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([site.lat, site.lon]);
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Known Contaminated Site:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Known Contaminated Site:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (contaminatedSiteCount > 0) {
          if (!legendAccumulator['nj_known_contaminated_sites']) {
            legendAccumulator['nj_known_contaminated_sites'] = {
              icon: '⚠️',
              color: '#dc2626',
              title: 'NJ Known Contaminated Sites',
              count: 0,
            };
          }
          legendAccumulator['nj_known_contaminated_sites'].count += contaminatedSiteCount;
        }
      }

      // Draw NJ Alternative Fueled Vehicle Fueling Stations as markers on the map
      if (enrichments.nj_alternative_fuel_stations_all && Array.isArray(enrichments.nj_alternative_fuel_stations_all)) {
        let fuelStationCount = 0;
        enrichments.nj_alternative_fuel_stations_all.forEach((station: any) => {
          if (station.lat !== null && station.lat !== undefined && station.lon !== null && station.lon !== undefined) {
            try {
              fuelStationCount++;
              
              const stationName = station.stationName || station.STATION_NAME || station.station_name || station.NAME || station.name || station.FACILITY_NAME || station.facility_name || 'Unknown Station';
              const address = station.address || station.ADDRESS || station.address || '';
              const municipality = station.municipality || station.MUNICIPALITY || station.municipality || '';
              const county = station.county || station.COUNTY || station.county || '';
              const zipCode = station.zipCode || station.ZIP_CODE || station.zip_code || station.ZIP || station.zip || '';
              const fuelType = station.fuelType || station.FUEL_TYPE || station.fuel_type || station.TYPE || station.type || station.ALTERNATIVE_FUEL || station.alternative_fuel || '';
              const stationType = station.stationType || station.STATION_TYPE || station.station_type || station.FACILITY_TYPE || station.facility_type || '';

              // Create marker with green color for fuel stations
              const marker = L.marker([station.lat, station.lon], {
                icon: L.divIcon({
                  className: 'custom-marker-icon',
                  html: `<div style="background-color: #10b981; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <span style="color: white; font-size: 14px;">⛽</span>
                  </div>`,
                  iconSize: [24, 24],
                  iconAnchor: [12, 12]
                })
              });

              // Build popup content with all station attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    ⛽ ${stationName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                    ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${zipCode ? `<div><strong>ZIP Code:</strong> ${zipCode}</div>` : ''}
                    ${fuelType ? `<div><strong>Fuel Type:</strong> ${fuelType}</div>` : ''}
                    ${stationType ? `<div><strong>Station Type:</strong> ${stationType}</div>` : ''}
                    ${station.distance_miles !== null && station.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${station.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all station attributes (excluding internal fields)
              const excludeFields = ['stationId', 'stationName', 'address', 'municipality', 'county', 'zipCode', 'fuelType', 'stationType', 'lat', 'lon', 'distance_miles', 'STATION_NAME', 'station_name', 'NAME', 'name', 'FACILITY_NAME', 'facility_name', 'ADDRESS', 'address', 'ADDR', 'addr', 'STREET_ADDRESS', 'street_address', 'MUNICIPALITY', 'municipality', 'MUNI', 'muni', 'CITY', 'city', 'COUNTY', 'county', 'ZIP_CODE', 'zip_code', 'ZIP', 'zip', 'POSTAL_CODE', 'postal_code', 'FUEL_TYPE', 'fuel_type', 'TYPE', 'type', 'ALTERNATIVE_FUEL', 'alternative_fuel', 'STATION_TYPE', 'station_type', 'FACILITY_TYPE', 'facility_type'];
              Object.entries(station).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;

              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([station.lat, station.lon]);
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Alternative Fuel Station:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Alternative Fuel Station:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (fuelStationCount > 0) {
          if (!legendAccumulator['nj_alternative_fuel_stations']) {
            legendAccumulator['nj_alternative_fuel_stations'] = {
              icon: '⛽',
              color: '#10b981',
              title: 'NJ Alternative Fuel Stations',
              count: 0,
            };
          }
          legendAccumulator['nj_alternative_fuel_stations'].count += fuelStationCount;
        }
      }

      // Draw NJ Power Plants as markers on the map
      if (enrichments.nj_power_plants_all && Array.isArray(enrichments.nj_power_plants_all)) {
        let powerPlantCount = 0;
        enrichments.nj_power_plants_all.forEach((plant: any) => {
          if (plant.lat !== null && plant.lat !== undefined && plant.lon !== null && plant.lon !== undefined) {
            try {
              powerPlantCount++;
              
              const plantName = plant.plantName || plant.PLANT_NAME || plant.plant_name || plant.NAME || plant.name || 'Unknown Power Plant';
              const utilityName = plant.utilityName || plant.UTILITY_NAME || plant.utility_name || '';
              const city = plant.city || plant.CITY || plant.city || '';
              const county = plant.county || plant.COUNTY || plant.county || '';
              const streetAddress = plant.streetAddress || plant.STREET_ADD || plant.street_add || plant.ADDRESS || plant.address || '';
              const primarySource = plant.primarySource || plant.PRIMSOURCE || plant.primsource || plant.PRIMARY_SOURCE || plant.primary_source || '';
              const installMW = plant.installMW !== null && plant.installMW !== undefined ? plant.installMW : null;
              const totalMW = plant.totalMW !== null && plant.totalMW !== undefined ? plant.totalMW : null;
              const sourceDescription = plant.sourceDescription || plant.SOURCE_DES || plant.source_des || '';
              const technical = plant.technical || plant.TECHNICAL || plant.technical || '';
              const edc = plant.edc || plant.EDC || plant.edc || '';
              const gridSupply = plant.gridSupply || plant.GRIDSUPPLY || plant.gridsupply || '';
              const dmrLink = plant.dmrLink || plant.DMR_LINK || plant.dmr_link || '';

              // Create marker with orange/yellow color for power plants
              const marker = L.marker([plant.lat, plant.lon], {
                icon: L.divIcon({
                  className: 'custom-marker-icon',
                  html: `<div style="background-color: #f59e0b; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <span style="color: white; font-size: 14px;">⚡</span>
                  </div>`,
                  iconSize: [24, 24],
                  iconAnchor: [12, 12]
                })
              });

              // Build popup content with all plant attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    ⚡ ${plantName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${utilityName ? `<div><strong>Utility:</strong> ${utilityName}</div>` : ''}
                    ${streetAddress ? `<div><strong>Address:</strong> ${streetAddress}</div>` : ''}
                    ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                    ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                    ${primarySource ? `<div><strong>Primary Source:</strong> ${primarySource}</div>` : ''}
                    ${installMW !== null ? `<div><strong>Installed Capacity:</strong> ${installMW.toFixed(1)} MW</div>` : ''}
                    ${totalMW !== null ? `<div><strong>Total Capacity:</strong> ${totalMW.toFixed(1)} MW</div>` : ''}
                    ${sourceDescription ? `<div><strong>Source Description:</strong> ${sourceDescription}</div>` : ''}
                    ${technical ? `<div><strong>Technical:</strong> ${technical}</div>` : ''}
                    ${edc ? `<div><strong>EDC:</strong> ${edc}</div>` : ''}
                    ${gridSupply ? `<div><strong>Grid Supply:</strong> ${gridSupply}</div>` : ''}
                    ${plant.distance_miles !== null && plant.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${plant.distance_miles.toFixed(2)} miles</div>` : ''}
                    ${dmrLink ? `<div><strong><a href="${dmrLink}" target="_blank" rel="noopener noreferrer">DMR Link</a></strong></div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all plant attributes (excluding internal fields)
              const excludeFields = ['plantId', 'plantCode', 'plantName', 'utilityName', 'siteId', 'airPi', 'city', 'county', 'streetAddress', 'primarySource', 'installMW', 'totalMW', 'sourceDescription', 'technical', 'edc', 'gridSupply', 'dmrLink', 'lat', 'lon', 'distance_miles', 'PLANT_NAME', 'plant_name', 'NAME', 'name', 'UTILITY_NAME', 'utility_name', 'CITY', 'city', 'COUNTY', 'county', 'STREET_ADD', 'street_add', 'ADDRESS', 'address', 'PRIMSOURCE', 'primsource', 'PRIMARY_SOURCE', 'primary_source', 'INSTALL_MW', 'install_mw', 'TOTAL_MW', 'total_mw', 'SOURCE_DES', 'source_des', 'SOURCE_DESC', 'source_desc', 'TECHNICAL', 'technical', 'EDC', 'edc', 'GRIDSUPPLY', 'gridsupply', 'GRID_SUPPLY', 'grid_supply', 'DMR_LINK', 'dmr_link', 'DMR', 'dmr', 'LATITUDE', 'LONGITUDE'];
              Object.entries(plant).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;

              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([plant.lat, plant.lon]);
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Power Plant:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Power Plant:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (powerPlantCount > 0) {
          if (!legendAccumulator['nj_power_plants']) {
            legendAccumulator['nj_power_plants'] = {
              icon: '⚡',
              color: '#f59e0b',
              title: 'NJ Power Plants',
              count: 0,
            };
          }
          legendAccumulator['nj_power_plants'].count += powerPlantCount;
        }
      }

      // Draw NJ Public Solar Facilities as markers on the map
      if (enrichments.nj_public_solar_facilities_all && Array.isArray(enrichments.nj_public_solar_facilities_all)) {
        let solarFacilityCount = 0;
        enrichments.nj_public_solar_facilities_all.forEach((facility: any) => {
          if (facility.lat !== null && facility.lat !== undefined && facility.lon !== null && facility.lon !== undefined) {
            try {
              solarFacilityCount++;
              
              const companyName = facility.companyName || facility.COMPNAME || facility.compname || facility.COMPANY_NAME || facility.company_name || facility.NAME || facility.name || 'Unknown Facility';
              const systemSize = facility.systemSize !== null && facility.systemSize !== undefined ? facility.systemSize : null;
              const customerType = facility.customerType || facility.CUSTOMERTYPE || facility.customertype || facility.CUSTOMER_TYPE || facility.customer_type || '';
              const installAddress = facility.installAddress || facility.INSTALLADD || facility.installadd || facility.INSTALL_ADDRESS || facility.install_address || facility.ADDRESS || facility.address || '';
              const installCity = facility.installCity || facility.INSTALLCITY || facility.installcity || facility.INSTALL_CITY || facility.install_city || facility.CITY || facility.city || '';
              const installZip = facility.installZip || facility.INSTALLZIP || facility.installzip || facility.INSTALL_ZIP || facility.install_zip || facility.ZIP || facility.zip || '';
              const installer = facility.installer || facility.INSTALLER || facility.installer || '';
              const accountNumber = facility.accountNumber || facility.ACCOUNT_NUMBER || facility.account_number || '';
              const statusDate = facility.statusDate !== null && facility.statusDate !== undefined ? facility.statusDate : null;
              
              // Format status date if available (it's a timestamp in milliseconds)
              let statusDateFormatted = '';
              if (statusDate !== null) {
                try {
                  const date = new Date(statusDate);
                  statusDateFormatted = date.toLocaleDateString();
                } catch (e) {
                  statusDateFormatted = statusDate.toString();
                }
              }

              // Create marker with yellow/gold color for solar facilities
              const marker = L.marker([facility.lat, facility.lon], {
                icon: L.divIcon({
                  className: 'custom-marker-icon',
                  html: `<div style="background-color: #fbbf24; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                    <span style="color: white; font-size: 14px;">☀️</span>
                  </div>`,
                  iconSize: [24, 24],
                  iconAnchor: [12, 12]
                })
              });

              // Build popup content with all facility attributes
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    ☀️ ${companyName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${systemSize !== null ? `<div><strong>System Size:</strong> ${systemSize.toFixed(2)} kW</div>` : ''}
                    ${customerType ? `<div><strong>Customer Type:</strong> ${customerType}</div>` : ''}
                    ${installAddress ? `<div><strong>Address:</strong> ${installAddress}</div>` : ''}
                    ${installCity ? `<div><strong>City:</strong> ${installCity}</div>` : ''}
                    ${installZip ? `<div><strong>ZIP Code:</strong> ${installZip}</div>` : ''}
                    ${installer ? `<div><strong>Installer:</strong> ${installer}</div>` : ''}
                    ${accountNumber ? `<div><strong>Account Number:</strong> ${accountNumber}</div>` : ''}
                    ${statusDateFormatted ? `<div><strong>Status Date:</strong> ${statusDateFormatted}</div>` : ''}
                    ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all facility attributes (excluding internal fields)
              const excludeFields = ['facilityId', 'accountNumber', 'companyName', 'systemSize', 'customerType', 'installAddress', 'installCity', 'installZip', 'installer', 'statusDate', 'lat', 'lon', 'distance_miles', 'COMPNAME', 'compname', 'COMPANY_NAME', 'company_name', 'NAME', 'name', 'SYSTEMSIZE', 'systemsize', 'CUSTOMERTYPE', 'customertype', 'CUSTOMER_TYPE', 'customer_type', 'INSTALLADD', 'installadd', 'INSTALL_ADDRESS', 'install_address', 'ADDRESS', 'address', 'INSTALLCITY', 'installcity', 'INSTALL_CITY', 'install_city', 'CITY', 'city', 'INSTALLZIP', 'installzip', 'INSTALL_ZIP', 'install_zip', 'ZIP', 'zip', 'INSTALLER', 'installer', 'ACCOUNT_NUMBER', 'account_number', 'ACCOUNT', 'account', 'STATUSDATE', 'statusdate', 'LATITUDE', 'LONGITUDE'];
              Object.entries(facility).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;

              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([facility.lat, facility.lon]);
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Public Solar Facility:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Public Solar Facility:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (solarFacilityCount > 0) {
          if (!legendAccumulator['nj_public_solar_facilities']) {
            legendAccumulator['nj_public_solar_facilities'] = {
              icon: '☀️',
              color: '#fbbf24',
              title: 'NJ Public Solar Facilities',
              count: 0,
            };
          }
          legendAccumulator['nj_public_solar_facilities'].count += solarFacilityCount;
        }
      }

      // Draw NJ Public Places to Keep Cool as markers on the map
      if (enrichments.nj_public_places_to_keep_cool_all && Array.isArray(enrichments.nj_public_places_to_keep_cool_all)) {
        let placeCount = 0;
        enrichments.nj_public_places_to_keep_cool_all.forEach((place: any) => {
          if (place.lat !== null && place.lat !== undefined && place.lon !== null && place.lon !== undefined) {
            try {
              placeCount++;
              
              const featureName = place.featureName || place.FEATURE_NAME || place.feature_name || place.NAME || place.name || 'Unknown Place';
              const featureType = place.featureType || place.FEATURE_TYPE || place.feature_type || place.FeatureType || '';
              const address = place.address || place.ADDRESS || place.address || '';
              const city = place.city || place.CITY || place.city || '';
              const zip = place.zip || place.ZIP || place.zip || '';
              const municipality = place.municipality || place.MUNICIPALITY || place.municipality || '';
              const county = place.county || place.COUNTY || place.county || '';
              const website = place.website || place.WEBSITE || place.website || '';
              const phoneNumber = place.phoneNumber || place.PHONE_NUMBER || place.phone_number || place.PHONE || place.phone || '';
              const admission = place.admission || place.ADMISSION || place.admission || '';
              const in211 = place.in211 || place.IN_211 || place.in_211 || place.IN211 || place.in211 || '';
              const notes = place.notes || place.NOTES || place.notes || '';
              const distanceMiles = place.distance_miles !== null && place.distance_miles !== undefined ? place.distance_miles : null;

              // Create marker with blue color for cooling places
              const marker = L.marker([place.lat, place.lon], {
                icon: L.divIcon({
                  className: 'custom-marker',
                  html: `<div style="background-color: #3b82f6; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">❄️</div>`,
                  iconSize: [24, 24],
                  iconAnchor: [12, 12],
                }),
              });

              // Build popup content
              let popupContent = `
                <div style="max-width: 300px;">
                  <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #1e40af;">
                    ${featureName}
                  </div>
                  <div style="font-size: 12px; color: #4b5563;">
              `;

              if (featureType) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${featureType}</div>`;
              }
              if (address) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Address:</strong> ${address}</div>`;
              }
              if (city) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>City:</strong> ${city}</div>`;
              }
              if (zip) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>ZIP:</strong> ${zip}</div>`;
              }
              if (municipality) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Municipality:</strong> ${municipality}</div>`;
              }
              if (county) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>County:</strong> ${county}</div>`;
              }
              if (phoneNumber) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Phone:</strong> ${phoneNumber}</div>`;
              }
              if (website) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Website:</strong> <a href="${website}" target="_blank" rel="noopener noreferrer">${website}</a></div>`;
              }
              if (admission) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Admission:</strong> ${admission}</div>`;
              }
              if (in211) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>In 211:</strong> ${in211}</div>`;
              }
              if (notes) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Notes:</strong> ${notes}</div>`;
              }
              if (distanceMiles !== null) {
                popupContent += `<div style="margin-bottom: 4px;"><strong>Distance:</strong> ${distanceMiles.toFixed(2)} miles</div>`;
              }

              // Add all other attributes
              Object.keys(place).forEach(key => {
                if (!['lat', 'lon', 'distance_miles', 'featureName', 'FEATURE_NAME', 'feature_name', 'NAME', 'name', 'featureType', 'FEATURE_TYPE', 'feature_type', 'FeatureType', 'address', 'ADDRESS', 'address', 'city', 'CITY', 'city', 'zip', 'ZIP', 'zip', 'municipality', 'MUNICIPALITY', 'municipality', 'county', 'COUNTY', 'county', 'website', 'WEBSITE', 'website', 'phoneNumber', 'PHONE_NUMBER', 'phone_number', 'PHONE', 'phone', 'admission', 'ADMISSION', 'admission', 'in211', 'IN_211', 'in_211', 'IN211', 'in211', 'notes', 'NOTES', 'notes'].includes(key)) {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = place[key];
                  
                  if (typeof displayValue === 'object') {
                    displayValue = JSON.stringify(displayValue);
                  } else if (typeof displayValue === 'number') {
                    displayValue = displayValue.toLocaleString();
                  } else {
                    displayValue = String(displayValue);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;

              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi); // Add to POI layer group
              
              try {
                bounds.extend([place.lat, place.lon]);
              } catch (boundsError) {
                console.warn('Error extending bounds for NJ Public Place to Keep Cool:', boundsError);
              }
            } catch (error) {
              console.error('Error drawing NJ Public Place to Keep Cool:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (placeCount > 0) {
          if (!legendAccumulator['nj_public_places_to_keep_cool']) {
            legendAccumulator['nj_public_places_to_keep_cool'] = {
              icon: '❄️',
              color: '#3b82f6',
              title: 'NJ Public Places to Keep Cool',
              count: 0,
            };
          }
          legendAccumulator['nj_public_places_to_keep_cool'].count += placeCount;
        }
      }

      // Draw DE Parcels as polygons on the map
      if (enrichments.de_parcels_all && Array.isArray(enrichments.de_parcels_all)) {
        let parcelCount = 0;
        enrichments.de_parcels_all.forEach((parcel: any) => {
          if (parcel.geometry && parcel.geometry.rings) {
            try {
              const rings = parcel.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0];
                const latlngs = outerRing.map((coord: number[]) => {
                  return [coord[1], coord[0]] as [number, number];
                });

                if (latlngs.length < 3) {
                  console.warn('DE Parcel polygon has less than 3 coordinates, skipping');
                  return;
                }

                const isContaining = parcel.isContaining;
                const color = isContaining ? '#dc2626' : '#3b82f6';
                const weight = isContaining ? 3 : 2;

                const parcelId = parcel.parcelId || parcel.PIN || parcel.pin || parcel.OBJECTID || 'Unknown';
                const pin = parcel.PIN || parcel.pin || '';
                const acres = parcel.ACRES || parcel.acres || null;
                const county = parcel.COUNTY || parcel.county || '';

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: 0.7,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏠 DE Parcel ${parcelId}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                      ${parcel.distance_miles !== null && parcel.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${parcel.distance_miles.toFixed(2)} miles</div>` : ''}
                      ${pin ? `<div><strong>PIN:</strong> ${pin}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                const excludeFields = ['parcelId', 'PIN', 'pin', 'OBJECTID', 'objectid', 'isContaining', 'geometry', 'distance_miles', 'ACRES', 'acres', 'COUNTY', 'county'];
                Object.entries(parcel).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;

                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                  parcelCount++;
                } catch (boundsError) {
                  console.warn('Error extending bounds for DE Parcel polygon:', boundsError);
                }
              }
            } catch (error) {
              console.error('Error drawing DE Parcel polygon:', error);
            }
          }
        });
        
        if (parcelCount > 0) {
          if (!legendAccumulator['de_parcels']) {
            legendAccumulator['de_parcels'] = {
              icon: '🏠',
              color: '#dc2626',
              title: 'DE Parcels',
              count: 0,
            };
          }
          legendAccumulator['de_parcels'].count += parcelCount;
        }
      }

      // Draw DE LULC layers as polygons on the map
      const lulcLayers = [
        { key: 'de_lulc_2007_all', year: '2007', color: '#8b5cf6' },
        { key: 'de_lulc_2007_revised_all', year: '2007 Revised', color: '#7c3aed' },
        { key: 'de_lulc_2012_all', year: '2012', color: '#6366f1' },
        { key: 'de_lulc_2017_all', year: '2017', color: '#4f46e5' },
        { key: 'de_lulc_2022_all', year: '2022', color: '#4338ca' }
      ];

      lulcLayers.forEach(({ key, year, color }) => {
        if (enrichments[key] && Array.isArray(enrichments[key])) {
          let lulcCount = 0;
          enrichments[key].forEach((lulc: any) => {
            if (lulc.geometry && lulc.geometry.rings) {
              try {
                const rings = lulc.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn(`DE LULC ${year} polygon has less than 3 coordinates, skipping`);
                    return;
                  }

                  const lulcCode = lulc.lulcCode || lulc.LULC_CODE2007 || lulc.LULC_CODE2012 || lulc.LULC_CODE2017 || lulc.LULC_CODE2022 || null;
                  const lulcCategory = lulc.lulcCategory || lulc.LULC_CATEGORY2007 || lulc.LULC_CATEGORY2012 || lulc.LULC_CATEGORY2017 || lulc.LULC_CATEGORY2022 || 'Unknown';

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: 2,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.3
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🗺️ DE LULC ${year}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${lulcCode !== null ? `<div><strong>LULC Code:</strong> ${lulcCode}</div>` : ''}
                        ${lulcCategory ? `<div><strong>Category:</strong> ${lulcCategory}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['lulcCode', 'lulcCategory', 'geometry', 'LULC_CODE2007', 'LULC_CATEGORY2007', 'LULC_CODE2012', 'LULC_CATEGORY2012', 'LULC_CODE2017', 'LULC_CATEGORY2017', 'LULC_CODE2022', 'LULC_CATEGORY2022'];
                  Object.entries(lulc).forEach(([fieldKey, value]) => {
                    if (!excludeFields.includes(fieldKey) && value !== null && value !== undefined && value !== '') {
                      const displayKey = fieldKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  try {
                    bounds.extend(polygon.getBounds());
                    lulcCount++;
                  } catch (boundsError) {
                    console.warn(`Error extending bounds for DE LULC ${year} polygon:`, boundsError);
                  }
                }
              } catch (error) {
                console.error(`Error drawing DE LULC ${year} polygon:`, error);
              }
            }
          });
          
          if (lulcCount > 0) {
            if (!legendAccumulator[key.replace('_all', '')]) {
              legendAccumulator[key.replace('_all', '')] = {
                icon: '🗺️',
                color: color,
                title: `DE LULC ${year}`,
                count: 0,
              };
            }
            legendAccumulator[key.replace('_all', '')].count += lulcCount;
          }
        }
      });

      // Draw CT Building Footprints as polygons on the map
      if (enrichments.ct_building_footprints_all && Array.isArray(enrichments.ct_building_footprints_all)) {
        let buildingCount = 0;
        enrichments.ct_building_footprints_all.forEach((building: any) => {
          if (building.geometry && building.geometry.rings) {
            try {
              // Convert ESRI polygon rings to Leaflet LatLng array
              // ESRI polygons have rings (outer ring + holes), we'll use the first ring (outer boundary)
              const rings = building.geometry.rings;
              if (rings && rings.length > 0) {
                const outerRing = rings[0]; // First ring is the outer boundary
                const latlngs = outerRing.map((coord: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  // Since we requested outSR=4326, coordinates should already be in WGS84
                  // Convert [lon, lat] to [lat, lon] for Leaflet
                  return [coord[1], coord[0]] as [number, number];
                });

                // Validate coordinates
                if (latlngs.length < 3) {
                  console.warn('CT Building Footprint polygon has less than 3 coordinates, skipping');
                  return;
                }

                const isContaining = building.isContaining;
                const color = isContaining ? '#dc2626' : '#3b82f6'; // Red for containing, blue for nearby
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;

                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });

                // Build popup content with all building attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '📍 Containing Building' : '🏢 Nearby Building'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; max-height: 400px; overflow-y: auto;">
                `;
                
                // Add all building attributes (excluding internal fields)
                const excludeFields = ['buildingId', 'isContaining', 'distance_miles', 'geometry'];
                Object.entries(building).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(primary);
                
                try {
                  bounds.extend(polygon.getBounds());
                  buildingCount++;
                } catch (boundsError) {
                  console.warn('Error extending bounds for CT Building Footprint polygon:', boundsError);
                }
              }
            } catch (error) {
              console.error('Error drawing CT building footprint polygon:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (buildingCount > 0) {
          if (!legendAccumulator['ct_building_footprints']) {
            legendAccumulator['ct_building_footprints'] = {
              icon: '🏢',
              color: '#3b82f6',
              title: 'CT 2D Building Footprints',
              count: 0,
            };
          }
          legendAccumulator['ct_building_footprints'].count += buildingCount;
        }
      }

      // Draw CT Roads and Trails as polylines on the map
      if (enrichments.ct_roads_all && Array.isArray(enrichments.ct_roads_all)) {
        let roadCount = 0;
        enrichments.ct_roads_all.forEach((road: any) => {
          if (road.geometry && road.geometry.paths) {
            try {
              // Convert ESRI polyline paths to Leaflet LatLng arrays
              // ESRI polylines have paths (array of coordinate arrays)
              const paths = road.geometry.paths;
              if (paths && paths.length > 0) {
                roadCount++;
                // For each path in the polyline, create a separate polyline
                paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  const roadClass = road.roadClass || road.ROAD_CLASS || road.RoadClass || 'Unknown Road';
                  const avLegend = road.avLegend || road.AV_LEGEND || road.AvLegend || null;
                  const imsLegend = road.imsLegend || road.IMS_LEGEND || road.ImsLegend || null;
                  const lengthMiles = road.lengthMiles !== null && road.lengthMiles !== undefined ? road.lengthMiles : null;

                  // Create polyline with yellow color for CT roads
                  const polyline = L.polyline(latlngs, {
                    color: '#fbbf24', // Yellow color for CT roads (better visibility on imagery basemap)
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1
                  });

                  // Build popup content with all road attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🛣️ ${roadClass}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${avLegend ? `<div><strong>AV Legend:</strong> ${avLegend}</div>` : ''}
                        ${imsLegend ? `<div><strong>IMS Legend:</strong> ${imsLegend}</div>` : ''}
                        ${lengthMiles !== null ? `<div><strong>Length:</strong> ${lengthMiles.toFixed(2)} miles</div>` : ''}
                        ${road.distance_miles !== null && road.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${road.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all road attributes (excluding internal fields)
                  const excludeFields = ['roadClass', 'ROAD_CLASS', 'RoadClass', 'avLegend', 'AV_LEGEND', 'AvLegend', 'imsLegend', 'IMS_LEGEND', 'ImsLegend', 'lengthMiles', 'LENGTH_MI', 'length_mi', 'geometry', 'distance_miles'];
                  Object.entries(road).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  bounds.extend(polyline.getBounds());
                });
              }
            } catch (error) {
              console.error('Error drawing CT Road polyline:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (roadCount > 0) {
          if (!legendAccumulator['ct_roads']) {
            legendAccumulator['ct_roads'] = {
              icon: '🛣️',
              color: '#fbbf24',
              title: 'CT Roads and Trails',
              count: 0,
            };
          }
          legendAccumulator['ct_roads'].count += roadCount;
        }
      }

      // Draw CT Urgent Care facilities as points on the map
      if (enrichments.ct_urgent_care_all && Array.isArray(enrichments.ct_urgent_care_all)) {
        let facilityCount = 0;
        enrichments.ct_urgent_care_all.forEach((facility: any) => {
          if (facility.lat && facility.lon) {
            try {
              facilityCount++;
              
              // Create marker icon for urgent care facilities
              const urgentCareIcon = L.divIcon({
                className: 'custom-marker-icon',
                html: `<div style="background-color: #f97316; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"><span style="color: white; font-size: 14px;">🏥</span></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
              });
              
              const marker = L.marker([facility.lat, facility.lon], { icon: urgentCareIcon });
              
              // Build popup content
              const name = facility.name || facility.NAME || 'Unnamed Urgent Care';
              const address = facility.address || facility.ADDRESS || '';
              const city = facility.city || facility.CITY || '';
              const state = facility.state || facility.STATE || 'CT';
              const zip = facility.zip || facility.ZIP || '';
              const phone = facility.phone || facility.PHONE || '';
              const fullAddress = [address, city, state, zip].filter(Boolean).join(', ');
              
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🏥 ${name}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${fullAddress ? `<div><strong>Address:</strong> ${fullAddress}</div>` : ''}
                    ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                    ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all facility attributes (excluding internal fields)
              const excludeFields = ['id', 'ID', 'name', 'NAME', 'address', 'ADDRESS', 'city', 'CITY', 'state', 'STATE', 'zip', 'ZIP', 'phone', 'PHONE', 'lat', 'lon', 'LATITUDE', 'LONGITUDE', 'distance_miles', 'attributes'];
              const attrs = facility.attributes || facility;
              Object.entries(attrs).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                  let displayValue = '';
                  
                  if (typeof value === 'object') {
                    displayValue = JSON.stringify(value);
                  } else if (typeof value === 'number') {
                    displayValue = value.toLocaleString();
                  } else {
                    displayValue = String(value);
                  }
                  
                  popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent, { maxWidth: 400 });
              marker.addTo(poi);
              bounds.extend([facility.lat, facility.lon]);
            } catch (error) {
              console.error('Error drawing CT Urgent Care marker:', error);
            }
          }
        });
        
        // Add to legend accumulator
        if (facilityCount > 0) {
          if (!legendAccumulator['ct_urgent_care']) {
            legendAccumulator['ct_urgent_care'] = {
              icon: '🏥',
              color: '#f97316',
              title: 'CT Urgent Care',
              count: 0,
            };
          }
          legendAccumulator['ct_urgent_care'].count += facilityCount;
        }
      }

      // Draw CT DEEP Properties as polygons on the map
      try {
        if (enrichments.ct_deep_properties_all && Array.isArray(enrichments.ct_deep_properties_all)) {
          let propertyCount = 0;
          enrichments.ct_deep_properties_all.forEach((property: any) => {
            if (property.geometry && property.geometry.rings) {
              try {
                // Convert ESRI polygon rings to Leaflet LatLng array
                const rings = property.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0]; // First ring is the outer boundary
                  const latlngs = outerRing.map((coord: number[]) => {
                    // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                    // Since we requested outSR=4326, coordinates should already be in WGS84
                    // Convert [lon, lat] to [lat, lon] for Leaflet
                    return [coord[1], coord[0]] as [number, number];
                  });

                  // Validate coordinates
                  if (latlngs.length < 3) {
                    console.warn('CT DEEP Property polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const isContaining = property.isContaining;
                  const color = isContaining ? '#059669' : '#10b981'; // Darker green for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;

                  const propertyName = property.propertyName || property.PROPERTY || property.property || 'CT DEEP Property';
                  const avLegend = property.avLegend || property.AV_LEGEND || null;
                  const imsLegend = property.imsLegend || property.IMS_LEGEND || null;
                  const depId = property.depId || property.DEP_ID || null;
                  const agencyFunctionCode = property.agencyFunctionCode || property.AGNCYFN_CD || null;
                  const acreage = property.acreage !== null && property.acreage !== undefined ? property.acreage : null;

                  // Create polygon
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  // Build popup content with all property attributes
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏞️ ${propertyName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                        ${property.distance_miles !== null && property.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${property.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${avLegend ? `<div><strong>AV Legend:</strong> ${avLegend}</div>` : ''}
                        ${imsLegend ? `<div><strong>IMS Legend:</strong> ${imsLegend}</div>` : ''}
                        ${depId ? `<div><strong>DEP ID:</strong> ${depId}</div>` : ''}
                        ${agencyFunctionCode ? `<div><strong>Agency Function Code:</strong> ${agencyFunctionCode}</div>` : ''}
                        ${acreage !== null ? `<div><strong>Acreage:</strong> ${acreage.toFixed(2)} acres</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all property attributes (excluding internal fields)
                  const excludeFields = ['propertyId', 'propertyName', 'PROPERTY', 'property', 'avLegend', 'AV_LEGEND', 'AvLegend', 'imsLegend', 'IMS_LEGEND', 'ImsLegend', 'depId', 'DEP_ID', 'agencyFunctionCode', 'AGNCYFN_CD', 'acreage', 'ACRE_GIS', 'acre_gis', 'geometry', 'distance_miles', 'isContaining'];
                  Object.entries(property).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary); // Add to primary layer group
                  
                  try {
                    bounds.extend(polygon.getBounds());
                  } catch (boundsError) {
                    console.warn('Error extending bounds for CT DEEP Property polygon:', boundsError);
                  }
                  
                  propertyCount++;
                }
              } catch (error) {
                console.error('Error drawing CT DEEP Property polygon:', error);
              }
            }
          });
          
          // Add to legend accumulator
          if (propertyCount > 0) {
            if (!legendAccumulator['ct_deep_properties']) {
              legendAccumulator['ct_deep_properties'] = {
                icon: '🏞️',
                color: '#059669',
                title: 'CT DEEP Properties',
                count: 0,
              };
            }
            legendAccumulator['ct_deep_properties'].count += propertyCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT DEEP Properties:', error);
      }

      // Draw CT Tribal Lands as polygons on the map
      try {
        if (enrichments.ct_tribal_lands_all && Array.isArray(enrichments.ct_tribal_lands_all)) {
          let tribalLandCount = 0;
          enrichments.ct_tribal_lands_all.forEach((tribalLand: any) => {
            if (tribalLand.geometry && tribalLand.geometry.rings) {
              try {
                const rings = tribalLand.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT Tribal Land polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const isContaining = tribalLand.isContaining;
                  // Use different colors based on recognition type
                  let color = '#8b5cf6'; // Default purple
                  if (tribalLand.recognitionType === 'Federally Recognized') {
                    color = isContaining ? '#059669' : '#10b981'; // Green shades
                  } else if (tribalLand.recognitionType === 'State Recognized') {
                    color = isContaining ? '#dc2626' : '#ef4444'; // Red shades
                  }
                  const weight = isContaining ? 3 : 2;

                  const name = tribalLand.name || tribalLand.NAME || 'CT Tribal Land';
                  const nameLsad = tribalLand.nameLsad || tribalLand.NAMELSAD || null;
                  const recognitionType = tribalLand.recognitionType || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ ${name}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                        ${tribalLand.distance_miles !== null && tribalLand.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${tribalLand.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${recognitionType ? `<div><strong>Recognition:</strong> ${recognitionType}</div>` : ''}
                        ${nameLsad ? `<div><strong>Full Name:</strong> ${nameLsad}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['tribalLandId', 'name', 'NAME', 'nameLsad', 'NAMELSAD', 'recognitionType', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(tribalLand).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  try {
                    bounds.extend(polygon.getBounds());
                    tribalLandCount++;
                  } catch (boundsError) {
                    console.warn('Error extending bounds for CT Tribal Land polygon:', boundsError);
                  }
                }
              } catch (error) {
                console.error('Error drawing CT Tribal Land polygon:', error);
              }
            }
          });
          
          if (tribalLandCount > 0) {
            if (!legendAccumulator['ct_tribal_lands']) {
              legendAccumulator['ct_tribal_lands'] = {
                icon: '🏛️',
                color: '#8b5cf6',
                title: 'CT Tribal Lands',
                count: 0,
              };
            }
            legendAccumulator['ct_tribal_lands'].count += tribalLandCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Tribal Lands:', error);
      }

      // Draw CT Drinking Water Watersheds as polygons on the map
      try {
        if (enrichments.ct_drinking_water_watersheds_all && Array.isArray(enrichments.ct_drinking_water_watersheds_all)) {
          let watershedCount = 0;
          enrichments.ct_drinking_water_watersheds_all.forEach((watershed: any) => {
            if (watershed.geometry && watershed.geometry.rings) {
              try {
                const rings = watershed.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT Drinking Water Watershed polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const isContaining = watershed.isContaining;
                  const color = isContaining ? '#0891b2' : '#06b6d4'; // Darker blue for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;

                  const pwsName = watershed.pwsName || watershed.pws_name || watershed.PWS_NAME || 'CT Drinking Water Watershed';
                  const pwsId = watershed.pwsId || watershed.pws_id || watershed.PWS_ID || null;
                  const shed = watershed.shed || watershed.SHED || null;
                  const status = watershed.status || watershed.STATUS || null;
                  const acres = watershed.acres !== null && watershed.acres !== undefined ? watershed.acres : null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        💧 ${pwsName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                        ${watershed.distance_miles !== null && watershed.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${watershed.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${pwsId ? `<div><strong>PWS ID:</strong> ${pwsId}</div>` : ''}
                        ${shed ? `<div><strong>Watershed:</strong> ${shed}</div>` : ''}
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['watershedId', 'pwsName', 'pws_name', 'PWS_NAME', 'pwsId', 'pws_id', 'PWS_ID', 'shed', 'SHED', 'status', 'STATUS', 'acres', 'ACRES', 'st_area_sh', 'ST_AREA_SH', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(watershed).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  try {
                    bounds.extend(polygon.getBounds());
                    watershedCount++;
                  } catch (boundsError) {
                    console.warn('Error extending bounds for CT Drinking Water Watershed polygon:', boundsError);
                  }
                }
              } catch (error) {
                console.error('Error drawing CT Drinking Water Watershed polygon:', error);
              }
            }
          });
          
          if (watershedCount > 0) {
            if (!legendAccumulator['ct_drinking_water_watersheds']) {
              legendAccumulator['ct_drinking_water_watersheds'] = {
                icon: '💧',
                color: '#0891b2',
                title: 'CT Drinking Water Watersheds',
                count: 0,
              };
            }
            legendAccumulator['ct_drinking_water_watersheds'].count += watershedCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Drinking Water Watersheds:', error);
      }

      // Draw CT Broadband Availability blocks
      try {
        if (enrichments.ct_broadband_availability_all && Array.isArray(enrichments.ct_broadband_availability_all)) {
          let blockCount = 0;
          // Track counts for each served range
          const rangeCounts: Record<string, { label: string; color: string; count: number }> = {
            'no_data': { label: 'No Data', color: '#9ca3af', count: 0 },
            '0': { label: '0 served', color: '#dc2626', count: 0 },
            '1-10': { label: '1-10 served', color: '#f97316', count: 0 },
            '11-25': { label: '11-25 served', color: '#fb923c', count: 0 },
            '26-50': { label: '26-50 served', color: '#eab308', count: 0 },
            '51-100': { label: '51-100 served', color: '#22c55e', count: 0 },
            '101-250': { label: '101-250 served', color: '#16a34a', count: 0 },
            '251+': { label: '251+ served', color: '#15803d', count: 0 }
          };
          
          enrichments.ct_broadband_availability_all.forEach((block: any) => {
            if (block.geometry && block.geometry.rings) {
              try {
                const rings = block.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT Broadband Availability block polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const isContaining = block.isContaining;
                  
                  // Get served count for color coding
                  const served = block.served !== null && block.served !== undefined 
                    ? parseInt(block.served.toString()) 
                    : (block.served_locations !== null && block.served_locations !== undefined 
                      ? parseInt(block.served_locations.toString()) 
                      : null);
                  
                  // Color code based on served count ranges
                  let color: string;
                  let colorLabel: string;
                  let rangeKey: string;
                  if (served === null || served === undefined) {
                    // No data - gray
                    color = '#9ca3af';
                    colorLabel = 'No Data';
                    rangeKey = 'no_data';
                  } else if (served === 0) {
                    // 0 served - red
                    color = '#dc2626';
                    colorLabel = '0 served';
                    rangeKey = '0';
                  } else if (served <= 10) {
                    // 1-10 served - orange-red
                    color = '#f97316';
                    colorLabel = '1-10 served';
                    rangeKey = '1-10';
                  } else if (served <= 25) {
                    // 11-25 served - orange
                    color = '#fb923c';
                    colorLabel = '11-25 served';
                    rangeKey = '11-25';
                  } else if (served <= 50) {
                    // 26-50 served - yellow
                    color = '#eab308';
                    colorLabel = '26-50 served';
                    rangeKey = '26-50';
                  } else if (served <= 100) {
                    // 51-100 served - light green
                    color = '#22c55e';
                    colorLabel = '51-100 served';
                    rangeKey = '51-100';
                  } else if (served <= 250) {
                    // 101-250 served - green
                    color = '#16a34a';
                    colorLabel = '101-250 served';
                    rangeKey = '101-250';
                  } else {
                    // 251+ served - dark green
                    color = '#15803d';
                    colorLabel = '251+ served';
                    rangeKey = '251+';
                  }
                  
                  // Increment count for this range
                  if (rangeCounts[rangeKey]) {
                    rangeCounts[rangeKey].count++;
                  }
                  
                  const weight = isContaining ? 3 : 2;

                  const blockName = block.blockName || block.block_name || block.BLOCK_NAME || 'CT Broadband Block';
                  const blockGeoid = block.blockGeoid || block.block_geoid || block.BLOCK_GEOID || null;
                  const pctUnserved = block.pctUnserved !== null && block.pctUnserved !== undefined ? block.pctUnserved : null;
                  const maxDownload = block.maxDownload !== null && block.maxDownload !== undefined ? block.maxDownload : null;
                  const nProviders = block.nProviders !== null && block.nProviders !== undefined ? block.nProviders : null;
                  const townName = block.townName || block.town_name || block.TOWN_NAME || null;
                  const countyName = block.countyName || block.county_name || block.COUNTY_NAME || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.3
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        📡 ${blockName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                        ${block.distance_miles !== null && block.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${block.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${served !== null ? `<div><strong>Served Locations:</strong> ${served} <span style="color: ${color}; font-weight: 600;">(${colorLabel})</span></div>` : ''}
                        ${blockGeoid ? `<div><strong>Block GEOID:</strong> ${blockGeoid}</div>` : ''}
                        ${townName ? `<div><strong>Town:</strong> ${townName}</div>` : ''}
                        ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                        ${pctUnserved !== null ? `<div><strong>% Unserved:</strong> ${pctUnserved.toFixed(2)}%</div>` : ''}
                        ${maxDownload !== null ? `<div><strong>Max Download:</strong> ${maxDownload.toFixed(2)} Mbps</div>` : ''}
                        ${nProviders !== null ? `<div><strong>Number of Providers:</strong> ${nProviders}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['blockId', 'block_id', 'BLOCK_ID', 'blockGeoid', 'block_geoid', 'BLOCK_GEOID', 'blockName', 'block_name', 'BLOCK_NAME', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(block).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  blockCount++;
                }
              } catch (error) {
                console.error('Error drawing CT Broadband Availability block polygon:', error);
              }
            }
          });
          
          if (blockCount > 0) {
            // Create ranges array with only ranges that have counts > 0
            const ranges = Object.values(rangeCounts)
              .filter(range => range.count > 0)
              .sort((a, b) => {
                // Sort by served count (approximate order)
                const order: Record<string, number> = {
                  'No Data': 0,
                  '0 served': 1,
                  '1-10 served': 2,
                  '11-25 served': 3,
                  '26-50 served': 4,
                  '51-100 served': 5,
                  '101-250 served': 6,
                  '251+ served': 7
                };
                return (order[a.label] || 999) - (order[b.label] || 999);
              });
            
            if (!legendAccumulator['ct_broadband_availability']) {
              legendAccumulator['ct_broadband_availability'] = {
                icon: '📡',
                color: '#7c3aed',
                title: 'CT 2025 Broadband Availability by Block',
                count: blockCount,
                ranges: ranges
              };
            } else {
              legendAccumulator['ct_broadband_availability'].count += blockCount;
              // Merge ranges (in case blocks are processed in multiple batches)
              if (legendAccumulator['ct_broadband_availability'].ranges) {
                ranges.forEach(newRange => {
                  const existingRange = legendAccumulator['ct_broadband_availability'].ranges!.find(r => r.label === newRange.label);
                  if (existingRange) {
                    existingRange.count += newRange.count;
                  } else {
                    legendAccumulator['ct_broadband_availability'].ranges!.push(newRange);
                  }
                });
                // Re-sort after merging
                legendAccumulator['ct_broadband_availability'].ranges!.sort((a, b) => {
                  const order: Record<string, number> = {
                    'No Data': 0,
                    '0 served': 1,
                    '1-10 served': 2,
                    '11-25 served': 3,
                    '26-50 served': 4,
                    '51-100 served': 5,
                    '101-250 served': 6,
                    '251+ served': 7
                  };
                  return (order[a.label] || 999) - (order[b.label] || 999);
                });
              } else {
                legendAccumulator['ct_broadband_availability'].ranges = ranges;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error processing CT Broadband Availability:', error);
      }

      // Draw CT Water Pollution Control Facilities
      try {
        if (enrichments.ct_water_pollution_control_all && Array.isArray(enrichments.ct_water_pollution_control_all)) {
          let facilityCount = 0;
          enrichments.ct_water_pollution_control_all.forEach((facility: any) => {
            if (facility.lat !== null && facility.lon !== null) {
              try {
                const facilityName = facility.facilityName || facility.FACILITY_Name || facility.facility_name || 'CT Water Pollution Control Facility';
                const permittee = facility.permittee || facility.Permitte || null;
                const address = facility.address || facility.FACILITY_Address || facility.facility_address || null;
                const city = facility.city || facility.TOWN || facility.town || null;
                const permitId = facility.permitId || facility.Permit_ID || facility.permit_id || null;
                const receivingWaterbody = facility.receivingWaterbody || facility.Receiving_Waterbody || null;
                const facilityClass = facility.facilityClass || facility.CLASS || facility.class || null;

                const marker = L.marker([facility.lat, facility.lon], {
                  icon: createPOIIcon('💧', '#0ea5e9')
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      💧 ${facilityName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${facility.distance_miles !== null && facility.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${facility.distance_miles.toFixed(2)} miles</div>` : ''}
                      ${permittee ? `<div><strong>Permittee:</strong> ${permittee}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${permitId ? `<div><strong>Permit ID:</strong> ${permitId}</div>` : ''}
                      ${receivingWaterbody ? `<div><strong>Receiving Waterbody:</strong> ${receivingWaterbody}</div>` : ''}
                      ${facilityClass ? `<div><strong>Class:</strong> ${facilityClass}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                const excludeFields = ['facilityId', 'facility_id', 'FACILITY_ID', 'facilityName', 'facility_name', 'FACILITY_Name', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'lat', 'lon'];
                Object.entries(facility).forEach(([key, value]) => {
                  if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                    return;
                  }
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                });
                
                popupContent += `
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent);
                marker.addTo(poi);
                bounds.extend([facility.lat, facility.lon]);
                facilityCount++;
              } catch (error) {
                console.error('Error drawing CT Water Pollution Control Facility marker:', error);
              }
            }
          });
          
          if (facilityCount > 0) {
            if (!legendAccumulator['ct_water_pollution_control']) {
              legendAccumulator['ct_water_pollution_control'] = {
                icon: '💧',
                color: '#0ea5e9',
                title: 'CT Water Pollution Control Facilities',
                count: 0,
              };
            }
            legendAccumulator['ct_water_pollution_control'].count += facilityCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Water Pollution Control Facilities:', error);
      }

      // Draw CT Boat Launches
      try {
        if (enrichments.ct_boat_launches_all && Array.isArray(enrichments.ct_boat_launches_all)) {
          let launchCount = 0;
          enrichments.ct_boat_launches_all.forEach((launch: any) => {
            if (launch.lat !== null && launch.lon !== null) {
              try {
                const name = launch.name || launch.NAME || launch.Name || 'CT Boat Launch';
                const address = launch.address || launch.ADDRESS || launch.Address || null;
                const city = launch.city || launch.CITY || launch.City || null;
                const phone = launch.phone || launch.PHONE || launch.Phone || null;

                const marker = L.marker([launch.lat, launch.lon], {
                  icon: createPOIIcon('🚤', '#3b82f6')
                });

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚤 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${launch.distance_miles !== null && launch.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${launch.distance_miles.toFixed(2)} miles</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                const excludeFields = ['launchId', 'launch_id', 'LAUNCH_ID', 'name', 'NAME', 'Name', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'lat', 'lon'];
                Object.entries(launch).forEach(([key, value]) => {
                  if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                    return;
                  }
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                });
                
                popupContent += `
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent);
                marker.addTo(poi);
                bounds.extend([launch.lat, launch.lon]);
                launchCount++;
              } catch (error) {
                console.error('Error drawing CT Boat Launch marker:', error);
              }
            }
          });
          
          if (launchCount > 0) {
            if (!legendAccumulator['ct_boat_launches']) {
              legendAccumulator['ct_boat_launches'] = {
                icon: '🚤',
                color: '#3b82f6',
                title: 'CT Boat Launches',
                count: 0,
              };
            }
            legendAccumulator['ct_boat_launches'].count += launchCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Boat Launches:', error);
      }

      // Draw CT Federal Open Space
      try {
        if (enrichments.ct_federal_open_space_all && Array.isArray(enrichments.ct_federal_open_space_all)) {
          let openSpaceCount = 0;
          enrichments.ct_federal_open_space_all.forEach((openSpace: any) => {
            if (openSpace.geometry && openSpace.geometry.rings) {
              try {
                const rings = openSpace.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT Federal Open Space polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const isContaining = openSpace.isContaining;
                  const color = isContaining ? '#10b981' : '#34d399'; // Darker green for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;

                  const name = openSpace.name || openSpace.NAME || openSpace.Name || 'CT Federal Open Space';
                  const agency = openSpace.agency || openSpace.AGENCY || openSpace.Agency || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏞️ ${name}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div><strong>Status:</strong> Contains Location</div>' : ''}
                        ${openSpace.distance_miles !== null && openSpace.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${openSpace.distance_miles.toFixed(2)} miles</div>` : ''}
                        ${agency ? `<div><strong>Agency:</strong> ${agency}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['openSpaceId', 'open_space_id', 'OPEN_SPACE_ID', 'name', 'NAME', 'Name', 'agency', 'AGENCY', 'Agency', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(openSpace).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  openSpaceCount++;
                }
              } catch (error) {
                console.error('Error drawing CT Federal Open Space polygon:', error);
              }
            }
          });
          
          if (openSpaceCount > 0) {
            if (!legendAccumulator['ct_federal_open_space']) {
              legendAccumulator['ct_federal_open_space'] = {
                icon: '🏞️',
                color: '#10b981',
                title: 'CT Federal Open Space',
                count: 0,
              };
            }
            legendAccumulator['ct_federal_open_space'].count += openSpaceCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Federal Open Space:', error);
      }

      // Draw CT HUC Watershed Boundaries
      try {
        if (enrichments.ct_huc_watersheds_all && Array.isArray(enrichments.ct_huc_watersheds_all)) {
          let watershedCount = 0;
          enrichments.ct_huc_watersheds_all.forEach((watershed: any) => {
            if (watershed.geometry && watershed.geometry.rings) {
              try {
                const rings = watershed.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT HUC Watershed polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#06b6d4'; // Cyan for HUC watersheds
                  const weight = 3;

                  const huc12Name = watershed.huc12Name || watershed.HU_12_NAME || watershed.hu_12_name || null;
                  const huc10Name = watershed.huc10Name || watershed.HU_10_NAME || watershed.hu_10_name || null;
                  const huc12 = watershed.huc12 || watershed.HUC_12 || watershed.huc_12 || null;
                  const huc10 = watershed.huc10 || watershed.HUC_10 || watershed.huc_10 || null;
                  const huc8 = watershed.huc8 || watershed.HUC_8 || watershed.huc_8 || null;
                  const acres = watershed.acres !== null && watershed.acres !== undefined ? watershed.acres : (watershed.ACRES !== undefined ? watershed.ACRES : null);
                  const states = watershed.states || watershed.STATES || null;

                  const watershedName = huc12Name || huc10Name || `HUC ${huc12 || huc10 || huc8 || 'Unknown'}`;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 ${watershedName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Status:</strong> Contains Location</div>
                        ${huc12 ? `<div><strong>HUC-12:</strong> ${huc12}</div>` : ''}
                        ${huc12Name ? `<div><strong>HUC-12 Name:</strong> ${huc12Name}</div>` : ''}
                        ${huc10 ? `<div><strong>HUC-10:</strong> ${huc10}</div>` : ''}
                        ${huc10Name ? `<div><strong>HUC-10 Name:</strong> ${huc10Name}</div>` : ''}
                        ${huc8 ? `<div><strong>HUC-8:</strong> ${huc8}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toFixed(2)} acres</div>` : ''}
                        ${states ? `<div><strong>States:</strong> ${states}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['watershedId', 'watershed_id', 'WATERSHED_ID', 'huc8', 'HUC_8', 'huc_8', 'huc10', 'HUC_10', 'huc_10', 'huc12', 'HUC_12', 'huc_12', 'huc10Name', 'HU_10_NAME', 'hu_10_name', 'huc12Name', 'HU_12_NAME', 'hu_12_name', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(watershed).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  watershedCount++;
                }
              } catch (error) {
                console.error('Error drawing CT HUC Watershed polygon:', error);
              }
            }
          });
          
          if (watershedCount > 0) {
            if (!legendAccumulator['ct_huc_watersheds']) {
              legendAccumulator['ct_huc_watersheds'] = {
                icon: '🌊',
                color: '#06b6d4',
                title: 'CT HUC Watershed Boundaries',
                count: 0,
              };
            }
            legendAccumulator['ct_huc_watersheds'].count += watershedCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT HUC Watershed Boundaries:', error);
      }

      // Draw CT Soils Parent Material Name
      try {
        if (enrichments.ct_soils_parent_material_all && Array.isArray(enrichments.ct_soils_parent_material_all)) {
          let soilCount = 0;
          enrichments.ct_soils_parent_material_all.forEach((soil: any) => {
            if (soil.geometry && soil.geometry.rings) {
              try {
                const rings = soil.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CT Soils Parent Material polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#a16207'; // Brown/tan for soils
                  const weight = 3;

                  const parentMaterialName = soil.parentMaterialName || soil.ParMatNm || soil.parmatnm || 'Unknown Soil';
                  const mukey = soil.mukey || soil.MUKEY || soil.mukey || null;
                  const musym = soil.musym || soil.MUSYM || soil.musym || null;
                  const areaSymbol = soil.areaSymbol || soil.AREASYMBOL || soil.areasymbol || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌱 ${parentMaterialName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Status:</strong> Contains Location</div>
                        ${mukey ? `<div><strong>Map Unit Key (MUKEY):</strong> ${mukey}</div>` : ''}
                        ${musym ? `<div><strong>Map Unit Symbol (MUSYM):</strong> ${musym}</div>` : ''}
                        ${areaSymbol ? `<div><strong>Area Symbol:</strong> ${areaSymbol}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['soilId', 'soil_id', 'SOIL_ID', 'parentMaterialName', 'ParMatNm', 'parmatnm', 'mukey', 'MUKEY', 'musym', 'MUSYM', 'areaSymbol', 'AREASYMBOL', 'areasymbol', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(soil).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  soilCount++;
                }
              } catch (error) {
                console.error('Error drawing CT Soils Parent Material polygon:', error);
              }
            }
          });
          
          if (soilCount > 0) {
            if (!legendAccumulator['ct_soils_parent_material']) {
              legendAccumulator['ct_soils_parent_material'] = {
                icon: '🌱',
                color: '#a16207',
                title: 'CT Soils Parent Material Name',
                count: 0,
              };
            }
            legendAccumulator['ct_soils_parent_material'].count += soilCount;
          }
        }
      } catch (error) {
        console.error('Error processing CT Soils Parent Material Name:', error);
      }

      // Draw CA Power Outage Areas
      try {
        if (enrichments.ca_power_outage_areas_all && Array.isArray(enrichments.ca_power_outage_areas_all)) {
          let outageCount = 0;
          enrichments.ca_power_outage_areas_all.forEach((outage: any) => {
            if (outage.geometry && outage.geometry.rings) {
              try {
                const rings = outage.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Power Outage Area polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  // Color based on outage type: orange for "Not Planned", yellow for "Planned"
                  const isPlanned = outage.outageType === 'Planned' || outage.OutageType === 'Planned';
                  const color = isPlanned ? '#fbbf24' : '#f59e0b'; // Yellow for planned, orange for not planned
                  const weight = 3;

                  const utilityCompany = outage.utilityCompany || outage.UtilityCompany || 'Unknown Utility';
                  const outageStatus = outage.outageStatus || outage.OutageStatus || 'Unknown';
                  const outageType = outage.outageType || outage.OutageType || 'Unknown';
                  const incidentId = outage.incidentId || outage.IncidentId || outage.outageId || 'N/A';
                  const impactedCustomers = outage.impactedCustomers !== null && outage.impactedCustomers !== undefined 
                    ? outage.impactedCustomers 
                    : (outage.ImpactedCustomers !== null && outage.ImpactedCustomers !== undefined 
                      ? outage.ImpactedCustomers 
                      : null);
                  const county = outage.county || outage.County || null;
                  const cause = outage.cause || outage.Cause || null;
                  const startDate = outage.startDate || outage.StartDate ? new Date(outage.startDate || outage.StartDate).toLocaleString() : null;
                  const estimatedRestoreDate = outage.estimatedRestoreDate || outage.EstimatedRestoreDate ? new Date(outage.estimatedRestoreDate || outage.EstimatedRestoreDate).toLocaleString() : null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.3
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ⚡ Power Outage Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Incident ID:</strong> ${incidentId}</div>
                        <div><strong>Utility Company:</strong> ${utilityCompany}</div>
                        <div><strong>Status:</strong> ${outageStatus}</div>
                        <div><strong>Type:</strong> ${outageType}</div>
                        ${impactedCustomers !== null ? `<div><strong>Impacted Customers:</strong> ${impactedCustomers.toLocaleString()}</div>` : ''}
                        ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                        ${cause ? `<div><strong>Cause:</strong> ${cause}</div>` : ''}
                        ${startDate ? `<div><strong>Start Date:</strong> ${startDate}</div>` : ''}
                        ${estimatedRestoreDate ? `<div><strong>Estimated Restoration:</strong> ${estimatedRestoreDate}</div>` : ''}
                        ${outage.isContaining ? '<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${outage.distance_miles && outage.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${outage.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['outageId', 'OutageId', 'incidentId', 'IncidentId', 'utilityCompany', 'UtilityCompany', 'outageStatus', 'OutageStatus', 'outageType', 'OutageType', 'impactedCustomers', 'ImpactedCustomers', 'county', 'County', 'cause', 'Cause', 'startDate', 'StartDate', 'estimatedRestoreDate', 'EstimatedRestoreDate', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(outage).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  outageCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Power Outage Area polygon:', error);
              }
            }
          });
          
          if (outageCount > 0) {
            if (!legendAccumulator['ca_power_outage_areas']) {
              legendAccumulator['ca_power_outage_areas'] = {
                icon: '⚡',
                color: '#f59e0b',
                title: 'CA Power Outage Areas',
                count: 0,
              };
            }
            legendAccumulator['ca_power_outage_areas'].count += outageCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Power Outage Areas:', error);
      }

      // Draw CA Fire Perimeters (All)
      try {
        if (enrichments.ca_fire_perimeters_all_all && Array.isArray(enrichments.ca_fire_perimeters_all_all)) {
          let fireCount = 0;
          enrichments.ca_fire_perimeters_all_all.forEach((fire: any) => {
            if (fire.geometry && fire.geometry.rings) {
              try {
                const rings = fire.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Fire Perimeter polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#dc2626'; // Red for historical fire perimeters
                  const weight = 2;

                  const fireName = fire.fireName || fire.FIRE_NAME || fire.Name || fire.name || 'Unknown Fire';
                  const fireYear = fire.fireYear !== null && fire.fireYear !== undefined ? fire.fireYear : (fire.YEAR_ !== null && fire.YEAR_ !== undefined ? fire.YEAR_ : null);
                  const acres = fire.acres !== null && fire.acres !== undefined ? fire.acres : (fire.ACRES !== null && fire.ACRES !== undefined ? fire.ACRES : null);

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🔥 ${fireName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${fireYear ? `<div><strong>Year:</strong> ${fireYear}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString(undefined, { maximumFractionDigits: 0 })}</div>` : ''}
                        ${fire.isContaining ? '<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${fire.distance_miles && fire.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${fire.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  fireCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Fire Perimeter polygon:', error);
              }
            }
          });
          
          if (fireCount > 0) {
            if (!legendAccumulator['ca_fire_perimeters_all']) {
              legendAccumulator['ca_fire_perimeters_all'] = {
                icon: '🔥',
                color: '#dc2626',
                title: 'Historical CA Fire Perimeters (All)',
                count: 0,
              };
            }
            legendAccumulator['ca_fire_perimeters_all'].count += fireCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Fire Perimeters (All):', error);
      }

      // Draw CA Recent Large Fire Perimeters
      try {
        if (enrichments.ca_fire_perimeters_recent_large_all && Array.isArray(enrichments.ca_fire_perimeters_recent_large_all)) {
          let fireCount = 0;
          enrichments.ca_fire_perimeters_recent_large_all.forEach((fire: any) => {
            if (fire.geometry && fire.geometry.rings) {
              try {
                const rings = fire.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Recent Large Fire Perimeter polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#f97316'; // Orange for recent large fires
                  const weight = 2;

                  const fireName = fire.fireName || fire.FIRE_NAME || fire.Name || fire.name || 'Unknown Fire';
                  const fireYear = fire.fireYear !== null && fire.fireYear !== undefined ? fire.fireYear : (fire.YEAR_ !== null && fire.YEAR_ !== undefined ? fire.YEAR_ : null);
                  const acres = fire.acres !== null && fire.acres !== undefined ? fire.acres : (fire.ACRES !== null && fire.ACRES !== undefined ? fire.ACRES : null);

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🔥 ${fireName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${fireYear ? `<div><strong>Year:</strong> ${fireYear}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString(undefined, { maximumFractionDigits: 0 })}</div>` : ''}
                        ${fire.isContaining ? '<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${fire.distance_miles && fire.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${fire.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  fireCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Recent Large Fire Perimeter polygon:', error);
              }
            }
          });
          
          if (fireCount > 0) {
            if (!legendAccumulator['ca_fire_perimeters_recent_large']) {
              legendAccumulator['ca_fire_perimeters_recent_large'] = {
                icon: '🔥',
                color: '#ea580c',
                title: 'CA Recent Large Fire Perimeters',
                count: 0,
              };
            }
            legendAccumulator['ca_fire_perimeters_recent_large'].count += fireCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Recent Large Fire Perimeters:', error);
      }

      // Draw CA Fire Perimeters (1950+)
      try {
        if (enrichments.ca_fire_perimeters_1950_all && Array.isArray(enrichments.ca_fire_perimeters_1950_all)) {
          let fireCount = 0;
          enrichments.ca_fire_perimeters_1950_all.forEach((fire: any) => {
            if (fire.geometry && fire.geometry.rings) {
              try {
                const rings = fire.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Fire Perimeter (1950+) polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#f59e0b'; // Amber/orange for 1950+ fires
                  const weight = 2;

                  const fireName = fire.fireName || fire.FIRE_NAME || fire.Name || fire.name || 'Unknown Fire';
                  const fireYear = fire.fireYear !== null && fire.fireYear !== undefined ? fire.fireYear : (fire.YEAR_ !== null && fire.YEAR_ !== undefined ? fire.YEAR_ : null);
                  const acres = fire.acres !== null && fire.acres !== undefined ? fire.acres : (fire.ACRES !== null && fire.ACRES !== undefined ? fire.ACRES : null);

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🔥 ${fireName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${fireYear ? `<div><strong>Year:</strong> ${fireYear}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString(undefined, { maximumFractionDigits: 0 })}</div>` : ''}
                        ${fire.isContaining ? '<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${fire.distance_miles && fire.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${fire.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  fireCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Fire Perimeter (1950+) polygon:', error);
              }
            }
          });
          
          if (fireCount > 0) {
            if (!legendAccumulator['ca_fire_perimeters_1950']) {
              legendAccumulator['ca_fire_perimeters_1950'] = {
                icon: '🔥',
                color: '#f97316',
                title: 'CA Fire Perimeters (1950+)',
                count: 0,
              };
            }
            legendAccumulator['ca_fire_perimeters_1950'].count += fireCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Fire Perimeters (1950+):', error);
      }

      // Draw CA Land Ownership
      try {
        if (enrichments.ca_land_ownership_all && Array.isArray(enrichments.ca_land_ownership_all)) {
          let ownershipCount = 0;
          enrichments.ca_land_ownership_all.forEach((ownership: any) => {
            if (ownership.geometry && ownership.geometry.rings) {
              try {
                const rings = ownership.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Land Ownership polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#6366f1'; // Indigo for land ownership
                  const weight = 2;

                  const ownGroup = ownership.ownGroup || ownership.OWN_GROUP || ownership.own_group || 'Unknown';
                  const ownAgency = ownership.ownAgency || ownership.OWN_AGENCY || ownership.own_agency || null;
                  const ownLevel = ownership.ownLevel || ownership.OWN_LEVEL || ownership.own_level || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ ${ownGroup}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Status:</strong> Contains Location</div>
                        ${ownAgency ? `<div><strong>Agency:</strong> ${ownAgency}</div>` : ''}
                        ${ownLevel ? `<div><strong>Level:</strong> ${ownLevel}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['ownershipId', 'ownership_id', 'OWNERSHIP_ID', 'ownLevel', 'OWN_LEVEL', 'own_level', 'ownAgency', 'OWN_AGENCY', 'own_agency', 'ownGroup', 'OWN_GROUP', 'own_group', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(ownership).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  ownershipCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Land Ownership polygon:', error);
              }
            }
          });
          
          if (ownershipCount > 0) {
            if (!legendAccumulator['ca_land_ownership']) {
              legendAccumulator['ca_land_ownership'] = {
                icon: '🏛️',
                color: '#6366f1',
                title: 'CA Land Ownership',
                count: 0,
              };
            }
            legendAccumulator['ca_land_ownership'].count += ownershipCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Land Ownership:', error);
      }

      // Draw CA CGS Landslide Zones
      try {
        if (enrichments.ca_cgs_landslide_zones_all && Array.isArray(enrichments.ca_cgs_landslide_zones_all)) {
          let landslideCount = 0;
          enrichments.ca_cgs_landslide_zones_all.forEach((zone: any) => {
            if (zone.geometry && zone.geometry.rings) {
              try {
                const rings = zone.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA CGS Landslide Zone polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#f59e0b'; // Amber/orange for landslide zones
                  const weight = 2;

                  const zoneName = zone.zoneName || zone.NAME || zone.name || zone.Name || 'Unknown Landslide Zone';
                  const zoneType = zone.zoneType || zone.TYPE || zone.type || zone.Type || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏔️ ${zoneName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${zoneType ? `<div><strong>Type:</strong> ${zoneType}</div>` : ''}
                        ${zone.isContaining ? '<div style="color: #f59e0b; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${zone.distance_miles && zone.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${zone.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['landslideZoneId', 'landslide_zone_id', 'LANDSLIDE_ZONE_ID', 'zoneName', 'zone_name', 'ZONE_NAME', 'zoneType', 'zone_type', 'ZONE_TYPE', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  
                  // Check for link fields first and add them prominently
                  const geoPdfLink = zone.GEOPDFLINK || zone.geopdflink || zone.GeoPdfLink || null;
                  const reportLink = zone.REPORTLINK || zone.reportlink || zone.ReportLink || null;
                  
                  if (geoPdfLink || reportLink) {
                    popupContent += `<div style="margin-bottom: 8px; padding: 8px; background-color: #f3f4f6; border-radius: 4px;">`;
                    if (geoPdfLink) {
                      popupContent += `<div style="margin-bottom: 4px;"><strong>GeoPDF:</strong> <a href="${geoPdfLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline; word-break: break-all;">${geoPdfLink}</a></div>`;
                    }
                    if (reportLink) {
                      popupContent += `<div><strong>Report:</strong> <a href="${reportLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline; word-break: break-all;">${reportLink}</a></div>`;
                    }
                    popupContent += `</div>`;
                  }
                  
                  Object.entries(zone).forEach(([key, value]) => {
                    // Skip excluded fields and link fields (already handled above)
                    if (excludeFields.includes(key) || 
                        key.toUpperCase() === 'GEOPDFLINK' || 
                        key.toUpperCase() === 'REPORTLINK' ||
                        value === null || 
                        value === undefined || 
                        value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  landslideCount++;
                }
              } catch (error) {
                console.error('Error drawing CA CGS Landslide Zone polygon:', error);
              }
            }
          });
          
          if (landslideCount > 0) {
            if (!legendAccumulator['ca_cgs_landslide_zones']) {
              legendAccumulator['ca_cgs_landslide_zones'] = {
                icon: '🏔️',
                color: '#f59e0b',
                title: 'CA CGS Landslide Zones',
                count: 0,
              };
            }
            legendAccumulator['ca_cgs_landslide_zones'].count += landslideCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA CGS Landslide Zones:', error);
      }

      // Draw CA CGS Liquefaction Zones
      try {
        if (enrichments.ca_cgs_liquefaction_zones_all && Array.isArray(enrichments.ca_cgs_liquefaction_zones_all)) {
          let liquefactionCount = 0;
          enrichments.ca_cgs_liquefaction_zones_all.forEach((zone: any) => {
            if (zone.geometry && zone.geometry.rings) {
              try {
                const rings = zone.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA CGS Liquefaction Zone polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#10b981'; // Green for liquefaction zones (different from landslide amber)
                  const weight = 2;

                  const zoneName = zone.zoneName || zone.NAME || zone.name || zone.Name || 'Unknown Liquefaction Zone';
                  const zoneType = zone.zoneType || zone.TYPE || zone.type || zone.Type || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 ${zoneName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${zoneType ? `<div><strong>Type:</strong> ${zoneType}</div>` : ''}
                        ${zone.isContaining ? '<div style="color: #10b981; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${zone.distance_miles && zone.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${zone.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Check for link fields first and add them prominently
                  const geoPdfLink = zone.GEOPDFLINK || zone.geopdflink || zone.GeoPdfLink || null;
                  const reportLink = zone.REPORTLINK || zone.reportlink || zone.ReportLink || null;
                  
                  if (geoPdfLink || reportLink) {
                    popupContent += `<div style="margin-bottom: 8px; padding: 8px; background-color: #f3f4f6; border-radius: 4px;">`;
                    if (geoPdfLink) {
                      popupContent += `<div style="margin-bottom: 4px;"><strong>GeoPDF:</strong> <a href="${geoPdfLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline; word-break: break-all;">${geoPdfLink}</a></div>`;
                    }
                    if (reportLink) {
                      popupContent += `<div><strong>Report:</strong> <a href="${reportLink}" target="_blank" rel="noopener noreferrer" style="color: #2563eb; text-decoration: underline; word-break: break-all;">${reportLink}</a></div>`;
                    }
                    popupContent += `</div>`;
                  }
                  
                  const excludeFields = ['liquefactionZoneId', 'liquefaction_zone_id', 'LIQUEFACTION_ZONE_ID', 'zoneName', 'zone_name', 'ZONE_NAME', 'zoneType', 'zone_type', 'ZONE_TYPE', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GEOPDFLINK', 'geopdflink', 'GeoPdfLink', 'REPORTLINK', 'reportlink', 'ReportLink'];
                  Object.entries(zone).forEach(([key, value]) => {
                    // Skip excluded fields and link fields (already handled above)
                    if (excludeFields.includes(key) || 
                        value === null || 
                        value === undefined || 
                        value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  liquefactionCount++;
                }
              } catch (error) {
                console.error('Error drawing CA CGS Liquefaction Zone polygon:', error);
              }
            }
          });
          
          if (liquefactionCount > 0) {
            if (!legendAccumulator['ca_cgs_liquefaction_zones']) {
              legendAccumulator['ca_cgs_liquefaction_zones'] = {
                icon: '🌊',
                color: '#10b981',
                title: 'CA CGS Liquefaction Zones',
                count: 0,
              };
            }
            legendAccumulator['ca_cgs_liquefaction_zones'].count += liquefactionCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA CGS Liquefaction Zones:', error);
      }

      // Draw CA Wildland Fire Direct Protection Areas
      try {
        if (enrichments.ca_wildland_fire_direct_protection_all && Array.isArray(enrichments.ca_wildland_fire_direct_protection_all)) {
          let protectionCount = 0;
          enrichments.ca_wildland_fire_direct_protection_all.forEach((protection: any) => {
            if (protection.geometry && protection.geometry.rings) {
              try {
                const rings = protection.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA Wildland Fire Direct Protection Area polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#eab308'; // Yellow for fire protection areas
                  const weight = 2;

                  const dpaAgency = protection.dpaAgency || protection.DPA_AGENCY || protection.dpa_agency || 'Unknown';
                  const dpaGroup = protection.dpaGroup || protection.DPA_GROUP || protection.dpa_group || null;
                  const respondId = protection.respondId || protection.RESPOND_ID || protection.respond_id || null;
                  const nwcgUnitId = protection.nwcgUnitId || protection.NWCG_UNITID || protection.nwcg_unitid || null;
                  const agreements = protection.agreements || protection.AGREEMENTS || protection.agreements || null;
                  const costAppor = protection.costAppor || protection.COST_APPOR || protection.cost_appor || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🔥 ${dpaAgency}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Status:</strong> Contains Location</div>
                        ${dpaGroup ? `<div><strong>Group:</strong> ${dpaGroup}</div>` : ''}
                        ${respondId ? `<div><strong>Respond ID:</strong> ${respondId}</div>` : ''}
                        ${nwcgUnitId ? `<div><strong>NWCG Unit ID:</strong> ${nwcgUnitId}</div>` : ''}
                        ${agreements ? `<div><strong>Agreements:</strong> ${agreements}</div>` : ''}
                        ${costAppor ? `<div><strong>Cost Apportionment:</strong> ${costAppor}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['protectionAreaId', 'protection_area_id', 'PROTECTION_AREA_ID', 'dpaAgency', 'DPA_AGENCY', 'dpa_agency', 'dpaGroup', 'DPA_GROUP', 'dpa_group', 'respondId', 'RESPOND_ID', 'respond_id', 'nwcgUnitId', 'NWCG_UNITID', 'nwcg_unitid', 'agreements', 'AGREEMENTS', 'costAppor', 'COST_APPOR', 'cost_appor', 'comments', 'COMMENTS', 'isContaining', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid'];
                  Object.entries(protection).forEach(([key, value]) => {
                    if (excludeFields.includes(key) || value === null || value === undefined || value === '') {
                      return;
                    }
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  protectionCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Wildland Fire Direct Protection Area polygon:', error);
              }
            }
          });
          
          if (protectionCount > 0) {
            if (!legendAccumulator['ca_wildland_fire_direct_protection']) {
              legendAccumulator['ca_wildland_fire_direct_protection'] = {
                icon: '🔥',
                color: '#eab308',
                title: 'CA Wildland Fire Direct Protection Areas',
                count: 0,
              };
            }
            legendAccumulator['ca_wildland_fire_direct_protection'].count += protectionCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Wildland Fire Direct Protection Areas:', error);
      }

      // Draw CA CalVTP Treatment Areas as polygons on the map
      try {
        if (enrichments.ca_calvtp_treatment_areas_all && Array.isArray(enrichments.ca_calvtp_treatment_areas_all)) {
          let treatmentAreaCount = 0;
          enrichments.ca_calvtp_treatment_areas_all.forEach((area: any) => {
            if (area.geometry && area.geometry.rings) {
              try {
                const rings = area.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const projectId = area.projectId || area.Project_ID || area.project_id || 'Unknown Project';
                  const treatmentStage = area.treatmentStage || area.TreatmentStage || area.treatment_stage || null;
                  const treatmentAcres = area.treatmentAcres || area.Treatment_Acres || area.treatment_acres || null;
                  const county = area.county || area.County || null;
                  const fuelType = area.fuelType || area.Fuel_Type || area.fuel_type || null;
                  const dateCompleted = area.dateCompleted || area.Date_Completed || area.date_completed || null;
                  const distance = area.distance_miles !== null && area.distance_miles !== undefined ? area.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#fbbf24',
                    fillColor: '#fbbf24',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #991b1b;">🔥 ${projectId}</h3>
                  `;
                  
                  if (treatmentStage) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Treatment Stage:</strong> ${treatmentStage}</p>`;
                  }
                  
                  if (treatmentAcres) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Treatment Acres:</strong> ${treatmentAcres.toFixed(2)}</p>`;
                  }
                  
                  if (county) {
                    popupContent += `<p style="margin: 5px 0;"><strong>County:</strong> ${county}</p>`;
                  }
                  
                  if (fuelType) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Fuel Type:</strong> ${fuelType}</p>`;
                  }
                  
                  if (dateCompleted) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Date Completed:</strong> ${dateCompleted}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  // Add all other attributes
                  const allAttributes = { ...area };
                  delete allAttributes.geometry;
                  delete allAttributes.projectId;
                  delete allAttributes.treatmentStage;
                  delete allAttributes.treatmentAcres;
                  delete allAttributes.county;
                  delete allAttributes.fuelType;
                  delete allAttributes.dateCompleted;
                  delete allAttributes.distance_miles;
                  delete allAttributes.treatmentAreaId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  treatmentAreaCount++;
                }
              } catch (error) {
                console.error('Error drawing CA CalVTP Treatment Area polygon:', error);
              }
            }
          });
          
          if (treatmentAreaCount > 0) {
            if (!legendAccumulator['ca_calvtp_treatment_areas']) {
              legendAccumulator['ca_calvtp_treatment_areas'] = {
                icon: '🔥',
                color: '#fbbf24',
                title: 'CA CalVTP Treatment Areas',
                count: 0,
              };
            }
            legendAccumulator['ca_calvtp_treatment_areas'].count += treatmentAreaCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA CalVTP Treatment Areas:', error);
      }

      // Draw CA Post-Fire Damage Inspections (DINS) as point markers on the map
      try {
        if (enrichments.ca_postfire_damage_inspections_all && Array.isArray(enrichments.ca_postfire_damage_inspections_all)) {
          let inspectionCount = 0;
          enrichments.ca_postfire_damage_inspections_all.forEach((inspection: any) => {
            // Check for geometry with x/y (point geometry) or latitude/longitude fields
            const lat = inspection.geometry?.y || inspection.Latitude || inspection.latitude || null;
            const lon = inspection.geometry?.x || inspection.Longitude || inspection.longitude || null;
            
            if (lat !== null && lon !== null) {
              try {
                const damage = inspection.damage || inspection.DAMAGE || inspection.Damage || 'Unknown';
                const siteAddress = inspection.siteAddress || inspection.SITEADDRESS || inspection.SiteAddress || null;
                const streetNumber = inspection.streetNumber || inspection.STREETNUMBER || inspection.StreetNumber || null;
                const streetName = inspection.streetName || inspection.STREETNAME || inspection.StreetName || null;
                const streetType = inspection.streetType || inspection.STREETTYPE || inspection.StreetType || null;
                const city = inspection.city || inspection.CITY || inspection.City || null;
                const county = inspection.county || inspection.COUNTY || inspection.County || null;
                const incidentName = inspection.incidentName || inspection.INCIDENTNAME || inspection.IncidentName || null;
                const incidentNum = inspection.incidentNum || inspection.INCIDENTNUM || inspection.IncidentNum || null;
                const incidentStartDate = inspection.incidentStartDate || inspection.INCIDENTSTARTDATE || inspection.IncidentStartDate || null;
                const fireName = inspection.fireName || inspection.FIRENAME || inspection.FireName || null;
                const structureType = inspection.structureType || inspection.STRUCTURETYPE || inspection.StructureType || null;
                const structureCategory = inspection.structureCategory || inspection.STRUCTURECATEGORY || inspection.StructureCategory || null;
                const roofConstruction = inspection.roofConstruction || inspection.ROOFCONSTRUCTION || inspection.RoofConstruction || null;
                const yearBuilt = inspection.yearBuilt || inspection.YEARBUILT || inspection.YearBuilt || null;
                const apn = inspection.apn || inspection.APN || inspection.Apn || null;
                const assessedImprovedValue = inspection.assessedImprovedValue || inspection.ASSESSEDIMPROVEDVALUE || inspection.AssessedImprovedValue || null;
                const calFireUnit = inspection.calFireUnit || inspection.CALFIREUNIT || inspection.CalFireUnit || null;
                const distance = inspection.distance_miles !== null && inspection.distance_miles !== undefined ? inspection.distance_miles : 0;
                
                // Determine icon color based on damage level
                let iconColor = '#dc2626'; // Red for damaged/destroyed
                if (damage && (damage.toLowerCase().includes('no damage') || damage.toLowerCase().includes('affected'))) {
                  iconColor = '#f59e0b'; // Amber for affected/no damage
                }
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🔥', iconColor)
                });
                
                // Build address string
                let addressString = siteAddress || '';
                if (!addressString && (streetNumber || streetName || streetType)) {
                  const addressParts = [streetNumber, streetName, streetType].filter(part => part);
                  addressString = addressParts.join(' ');
                }
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🔥 ${damage}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${addressString ? `<div><strong>Address:</strong> ${addressString}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${fireName ? `<div><strong>Fire Name:</strong> ${fireName}</div>` : ''}
                      ${incidentName ? `<div><strong>Incident:</strong> ${incidentName}</div>` : ''}
                      ${incidentNum ? `<div><strong>Incident #:</strong> ${incidentNum}</div>` : ''}
                      ${incidentStartDate ? `<div><strong>Incident Date:</strong> ${incidentStartDate}</div>` : ''}
                      ${structureType ? `<div><strong>Structure Type:</strong> ${structureType}</div>` : ''}
                      ${structureCategory ? `<div><strong>Structure Category:</strong> ${structureCategory}</div>` : ''}
                      ${roofConstruction ? `<div><strong>Roof Construction:</strong> ${roofConstruction}</div>` : ''}
                      ${yearBuilt ? `<div><strong>Year Built:</strong> ${yearBuilt}</div>` : ''}
                      ${apn ? `<div><strong>APN:</strong> ${apn}</div>` : ''}
                      ${assessedImprovedValue !== null && assessedImprovedValue !== undefined ? `<div><strong>Assessed Value:</strong> $${assessedImprovedValue.toLocaleString()}</div>` : ''}
                      ${calFireUnit ? `<div><strong>CAL FIRE Unit:</strong> ${calFireUnit}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all inspection attributes (excluding internal fields)
                const excludeFields = ['damage', 'DAMAGE', 'Damage', 'siteAddress', 'SITEADDRESS', 'SiteAddress', 'streetNumber', 'STREETNUMBER', 'StreetNumber', 'streetName', 'STREETNAME', 'StreetName', 'streetType', 'STREETTYPE', 'StreetType', 'city', 'CITY', 'City', 'county', 'COUNTY', 'County', 'zipCode', 'ZIPCODE', 'ZipCode', 'incidentName', 'INCIDENTNAME', 'IncidentName', 'incidentNum', 'INCIDENTNUM', 'IncidentNum', 'incidentStartDate', 'INCIDENTSTARTDATE', 'IncidentStartDate', 'fireName', 'FIRENAME', 'FireName', 'structureType', 'STRUCTURETYPE', 'StructureType', 'structureCategory', 'STRUCTURECATEGORY', 'StructureCategory', 'roofConstruction', 'ROOFCONSTRUCTION', 'RoofConstruction', 'yearBuilt', 'YEARBUILT', 'YearBuilt', 'apn', 'APN', 'Apn', 'assessedImprovedValue', 'ASSESSEDIMPROVEDVALUE', 'AssessedImprovedValue', 'calFireUnit', 'CALFIREUNIT', 'CalFireUnit', 'battalion', 'BATTALION', 'Battalion', 'latitude', 'Latitude', 'LATITUDE', 'longitude', 'Longitude', 'LONGITUDE', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID'];
                Object.entries(inspection).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                inspectionCount++;
              } catch (error) {
                console.error('Error drawing CA Post-Fire Damage Inspection marker:', error);
              }
            }
          });
          
          if (inspectionCount > 0) {
            if (!legendAccumulator['ca_postfire_damage_inspections']) {
              legendAccumulator['ca_postfire_damage_inspections'] = {
                icon: '🔥',
                color: '#dc2626',
                title: 'CA Post-Fire Damage Inspections (DINS)',
                count: 0,
              };
            }
            legendAccumulator['ca_postfire_damage_inspections'].count += inspectionCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Post-Fire Damage Inspections:', error);
      }

      // Draw CA Medium and Heavy Duty Infrastructure as point markers on the map
      try {
        if (enrichments.ca_medium_heavy_duty_infrastructure_all && Array.isArray(enrichments.ca_medium_heavy_duty_infrastructure_all)) {
          let stationCount = 0;
          enrichments.ca_medium_heavy_duty_infrastructure_all.forEach((station: any) => {
            // Check for geometry with x/y (point geometry) or latitude/longitude fields
            const lat = station.geometry?.y || station.Latitude || station.latitude || null;
            const lon = station.geometry?.x || station.Longitude || station.longitude || null;
            
            if (lat !== null && lon !== null) {
              try {
                const chargingOrHydrogen = station.chargingOrHydrogen || station.Charging_or_Hydrogen || station.ChargingOrHydrogen || 'Unknown';
                const address = station.address || station.Address || station.ADDRESS || null;
                const chargerOrDispenserCount = station.chargerOrDispenserCount || station.Charger_or_Dispenser_Count || station.ChargerOrDispenserCount || null;
                const nozzleCount = station.nozzleCount || station.Nozzle_Count || station.NozzleCount || null;
                const fundingAgencies = station.fundingAgencies || station.Funding_Agencies || station.FundingAgencies || null;
                const operator = station.operator || station.Operator || station.OPERATOR || null;
                const eligible = station.eligible || station.Eligible || station.ELIGIBLE || null;
                const liquidGaseous = station.liquidGaseous || station.Liquid_Gaseous || station.LiquidGaseous || null;
                const chargingCapacity = station.chargingCapacity || station.Charging_Capacity || station.ChargingCapacity || null;
                const maximumCharging = station.maximumCharging || station.Maximum_Charging || station.MaximumCharging || null;
                const projectStatus = station.projectStatus || station.ProjectStatus || station.Project_Status || null;
                const distance = station.distance_miles !== null && station.distance_miles !== undefined ? station.distance_miles : 0;
                
                // Determine icon color based on type
                let iconColor = '#f97316'; // Orange default
                if (chargingOrHydrogen && chargingOrHydrogen.toLowerCase().includes('hydrogen')) {
                  iconColor = '#3b82f6'; // Blue for hydrogen
                } else if (chargingOrHydrogen && chargingOrHydrogen.toLowerCase().includes('both')) {
                  iconColor = '#8b5cf6'; // Purple for both
                }
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚛', iconColor)
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚛 ${chargingOrHydrogen} Station
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${projectStatus ? `<div><strong>Status:</strong> ${projectStatus}</div>` : ''}
                      ${operator ? `<div><strong>Operator:</strong> ${operator}</div>` : ''}
                      ${chargerOrDispenserCount ? `<div><strong>Charger/Dispenser Count:</strong> ${chargerOrDispenserCount}</div>` : ''}
                      ${nozzleCount ? `<div><strong>Nozzle Count:</strong> ${nozzleCount}</div>` : ''}
                      ${chargingCapacity ? `<div><strong>Charging Capacity:</strong> ${chargingCapacity}</div>` : ''}
                      ${maximumCharging ? `<div><strong>Maximum Charging:</strong> ${maximumCharging}</div>` : ''}
                      ${liquidGaseous ? `<div><strong>Liquid/Gaseous:</strong> ${liquidGaseous}</div>` : ''}
                      ${eligible ? `<div><strong>Eligible:</strong> ${eligible}</div>` : ''}
                      ${fundingAgencies ? `<div><strong>Funding Agencies:</strong> ${fundingAgencies}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all station attributes (excluding internal fields)
                const excludeFields = ['chargingOrHydrogen', 'Charging_or_Hydrogen', 'ChargingOrHydrogen', 'chargerOrDispenserCount', 'Charger_or_Dispenser_Count', 'ChargerOrDispenserCount', 'nozzleCount', 'Nozzle_Count', 'NozzleCount', 'address', 'Address', 'ADDRESS', 'latitude', 'Latitude', 'LATITUDE', 'longitude', 'Longitude', 'LONGITUDE', 'fundingAgencies', 'Funding_Agencies', 'FundingAgencies', 'operator', 'Operator', 'OPERATOR', 'eligible', 'Eligible', 'ELIGIBLE', 'liquidGaseous', 'Liquid_Gaseous', 'LiquidGaseous', 'chargingCapacity', 'Charging_Capacity', 'ChargingCapacity', 'maximumCharging', 'Maximum_Charging', 'MaximumCharging', 'projectStatus', 'ProjectStatus', 'Project_Status', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID'];
                Object.entries(station).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                stationCount++;
              } catch (error) {
                console.error('Error drawing CA Medium and Heavy Duty Infrastructure marker:', error);
              }
            }
          });
          
          if (stationCount > 0) {
            if (!legendAccumulator['ca_medium_heavy_duty_infrastructure']) {
              legendAccumulator['ca_medium_heavy_duty_infrastructure'] = {
                icon: '🚛',
                color: '#f97316',
                title: 'CA Medium & Heavy Duty Infrastructure',
                count: 0,
              };
            }
            legendAccumulator['ca_medium_heavy_duty_infrastructure'].count += stationCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Medium and Heavy Duty Infrastructure:', error);
      }

      // Draw CA FRAP Facilities as point markers on the map
      try {
        if (enrichments.ca_frap_facilities_all && Array.isArray(enrichments.ca_frap_facilities_all)) {
          let facilityCount = 0;
          enrichments.ca_frap_facilities_all.forEach((facility: any) => {
            // Check for geometry with x/y (point geometry) or latitude/longitude fields
            const lat = facility.geometry?.y || facility.LAT || facility.latitude || null;
            const lon = facility.geometry?.x || facility.LON || facility.longitude || null;
            
            if (lat !== null && lon !== null) {
              try {
                const name = facility.name || facility.NAME || facility.Name || 'Unknown Facility';
                const facilityStatus = facility.facilityStatus || facility.FACILITY_STATUS || facility.FacilityStatus || null;
                const cadName = facility.cadName || facility.CAD_NAME || facility.CadName || null;
                const aka = facility.aka || facility.AKA || facility.Aka || null;
                const type = facility.type || facility.TYPE || facility.Type || null;
                const unit = facility.unit || facility.UNIT || facility.Unit || null;
                const cdfUnit = facility.cdfUnit || facility.CDF_UNIT || facility.CdfUnit || null;
                const county = facility.county || facility.COUNTY || facility.County || null;
                const owner = facility.owner || facility.OWNER || facility.Owner || null;
                const funding = facility.funding || facility.FUNDING || facility.Funding || null;
                const staffing = facility.staffing || facility.STAFFING || facility.Staffing || null;
                const address = facility.address || facility.ADDRESS || facility.Address || null;
                const city = facility.city || facility.CITY || facility.City || null;
                const zip = facility.zip || facility.ZIP || facility.Zip || null;
                const phoneNum = facility.phoneNum || facility.PHONE_NUM || facility.PhoneNum || facility.PHONE || facility.phone || null;
                const distance = facility.distance_miles !== null && facility.distance_miles !== undefined ? facility.distance_miles : 0;
                
                // Use fire truck icon with red color for fire facilities
                const iconColor = '#dc2626'; // Red for fire facilities
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚒', iconColor)
                });
                
                // Build address string
                let addressString = address || '';
                if (city || zip) {
                  const addressParts = [address, city, zip].filter(part => part);
                  addressString = addressParts.join(', ');
                }
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚒 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${facilityStatus ? `<div><strong>Status:</strong> ${facilityStatus}</div>` : ''}
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${cadName ? `<div><strong>CAD Name:</strong> ${cadName}</div>` : ''}
                      ${aka ? `<div><strong>Also Known As:</strong> ${aka}</div>` : ''}
                      ${addressString ? `<div><strong>Address:</strong> ${addressString}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${unit ? `<div><strong>Unit:</strong> ${unit}</div>` : ''}
                      ${cdfUnit ? `<div><strong>CDF Unit:</strong> ${cdfUnit}</div>` : ''}
                      ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                      ${funding ? `<div><strong>Funding:</strong> ${funding}</div>` : ''}
                      ${staffing ? `<div><strong>Staffing:</strong> ${staffing}</div>` : ''}
                      ${phoneNum ? `<div><strong>Phone:</strong> ${phoneNum}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all facility attributes (excluding internal fields)
                const excludeFields = ['name', 'NAME', 'Name', 'facilityStatus', 'FACILITY_STATUS', 'FacilityStatus', 'cadName', 'CAD_NAME', 'CadName', 'aka', 'AKA', 'Aka', 'type', 'TYPE', 'Type', 'unit', 'UNIT', 'Unit', 'cdfUnit', 'CDF_UNIT', 'CdfUnit', 'county', 'COUNTY', 'County', 'owner', 'OWNER', 'Owner', 'funding', 'FUNDING', 'Funding', 'staffing', 'STAFFING', 'Staffing', 'address', 'ADDRESS', 'Address', 'city', 'CITY', 'City', 'zip', 'ZIP', 'Zip', 'ZIPCODE', 'zipCode', 'phoneNum', 'PHONE_NUM', 'PhoneNum', 'PHONE', 'phone', 'latitude', 'Latitude', 'LATITUDE', 'LAT', 'lat', 'longitude', 'Longitude', 'LONGITUDE', 'LON', 'lon', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID'];
                Object.entries(facility).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                facilityCount++;
              } catch (error) {
                console.error('Error drawing CA FRAP Facility marker:', error);
              }
            }
          });
          
          if (facilityCount > 0) {
            if (!legendAccumulator['ca_frap_facilities']) {
              legendAccumulator['ca_frap_facilities'] = {
                icon: '🚒',
                color: '#dc2626',
                title: 'CA Facilities for Wildland Fire Protection',
                count: 0,
              };
            }
            legendAccumulator['ca_frap_facilities'].count += facilityCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA FRAP Facilities:', error);
      }

      // Draw CA Solar Footprints as polygons on the map
      try {
        if (enrichments.ca_solar_footprints_all && Array.isArray(enrichments.ca_solar_footprints_all)) {
          let footprintCount = 0;
          enrichments.ca_solar_footprints_all.forEach((footprint: any) => {
            if (footprint.geometry && footprint.geometry.rings) {
              try {
                const rings = footprint.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('CA Solar Footprint polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = footprint.isContaining;
                  const color = isContaining ? '#fbbf24' : '#fcd34d'; // Yellow/amber for solar
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const countyName = footprint.countyName || footprint.COUNTYNAME || footprint.CountyName || '';
                  const acres = footprint.acres || footprint.Acres;
                  const type = footprint.type || footprint.Type || footprint.TYPE || 'Unknown';
                  const urbanRural = footprint.urbanRural || footprint.Urban_Rural || footprint.UrbanRural || null;
                  const combinedClass = footprint.combinedClass || footprint.Combined_Class || footprint.CombinedClass || null;
                  const distance = footprint.distance_miles !== null && footprint.distance_miles !== undefined ? footprint.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ☀️ Solar Footprint
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                        ${combinedClass ? `<div><strong>Class:</strong> ${combinedClass}</div>` : ''}
                        ${urbanRural ? `<div><strong>Urban/Rural:</strong> ${urbanRural}</div>` : ''}
                        ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                        ${acres !== null && acres !== undefined ? `<div><strong>Acres:</strong> ${acres.toFixed(2)}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this solar footprint</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all footprint attributes (excluding internal fields)
                  const excludeFields = ['countyName', 'COUNTYNAME', 'CountyName', 'COUNTY', 'county', 'acres', 'Acres', 'ACRES', 'type', 'Type', 'TYPE', 'urbanRural', 'Urban_Rural', 'UrbanRural', 'URBAN_RURAL', 'combinedClass', 'Combined_Class', 'CombinedClass', 'COMBINED_CLASS', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID'];
                  Object.entries(footprint).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds.getNorthEast());
                  bounds.extend(polygonBounds.getSouthWest());
                  
                  footprintCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Solar Footprint polygon:', error);
              }
            }
          });
          
          if (footprintCount > 0) {
            if (!legendAccumulator['ca_solar_footprints']) {
              legendAccumulator['ca_solar_footprints'] = {
                icon: '☀️',
                color: '#fbbf24',
                title: 'CA Solar Footprints',
                count: 0,
              };
            }
            legendAccumulator['ca_solar_footprints'].count += footprintCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Solar Footprints:', error);
      }

      // Draw CA Natural Gas Service Areas as polygons on the map
      try {
        if (enrichments.ca_natural_gas_service_areas_all && Array.isArray(enrichments.ca_natural_gas_service_areas_all)) {
          let serviceAreaCount = 0;
          enrichments.ca_natural_gas_service_areas_all.forEach((area: any) => {
            if (area.geometry && area.geometry.rings) {
              try {
                const rings = area.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('CA Natural Gas Service Area polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = area.isContaining;
                  const color = isContaining ? '#8b5cf6' : '#a78bfa'; // Purple for natural gas
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const serviceAreaId = area.serviceAreaId || area.OBJECTID || area.objectid || 'Unknown';
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ⛽ Natural Gas Service Area
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${serviceAreaId ? `<div><strong>Service Area ID:</strong> ${serviceAreaId}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this service area</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all service area attributes (excluding internal fields)
                  const excludeFields = ['serviceAreaId', 'OBJECTID', 'objectid', 'geometry', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds.getNorthEast());
                  bounds.extend(polygonBounds.getSouthWest());
                  
                  serviceAreaCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Natural Gas Service Area polygon:', error);
              }
            }
          });
          
          if (serviceAreaCount > 0) {
            if (!legendAccumulator['ca_natural_gas_service_areas']) {
              legendAccumulator['ca_natural_gas_service_areas'] = {
                icon: '⛽',
                color: '#8b5cf6',
                title: 'CA Natural Gas Service Areas',
                count: 0,
              };
            }
            legendAccumulator['ca_natural_gas_service_areas'].count += serviceAreaCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Natural Gas Service Areas:', error);
      }

      // Draw CA PLSS Sections as polygons on the map
      try {
        if (enrichments.ca_plss_sections_all && Array.isArray(enrichments.ca_plss_sections_all)) {
          let sectionCount = 0;
          enrichments.ca_plss_sections_all.forEach((section: any) => {
            if (section.geometry && section.geometry.rings) {
              try {
                const rings = section.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('CA PLSS Section polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = section.isContaining;
                  const color = isContaining ? '#6366f1' : '#818cf8'; // Indigo for PLSS
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const township = section.township || section.TOWNSHIP || section.Township || null;
                  const range = section.range || section.RANGE || section.Range || null;
                  const sectionNum = section.section || section.SECTION || section.Section || null;
                  const meridian = section.meridian || section.MERIDIAN || section.Meridian || null;
                  const sectionId = section.sectionId || section.OBJECTID || section.objectid || 'Unknown';
                  
                  // Format PLSS string
                  let plssString = '';
                  if (township && range) {
                    plssString = `T${township} R${range}`;
                    if (sectionNum) {
                      plssString += ` S${sectionNum}`;
                    }
                    if (meridian) {
                      plssString += ` ${meridian}`;
                    }
                  } else {
                    plssString = sectionId.toString();
                  }
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🗺️ PLSS Section
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${plssString ? `<div><strong>PLSS:</strong> ${plssString}</div>` : ''}
                        ${township ? `<div><strong>Township:</strong> ${township}</div>` : ''}
                        ${range ? `<div><strong>Range:</strong> ${range}</div>` : ''}
                        ${sectionNum ? `<div><strong>Section:</strong> ${sectionNum}</div>` : ''}
                        ${meridian ? `<div><strong>Meridian:</strong> ${meridian}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this section</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all section attributes (excluding internal fields)
                  const excludeFields = ['sectionId', 'township', 'TOWNSHIP', 'Township', 'TWP', 'Twp', 'twp', 'range', 'RANGE', 'Range', 'RNG', 'Rng', 'rng', 'section', 'SECTION', 'Section', 'SEC', 'Sec', 'sec', 'meridian', 'MERIDIAN', 'Meridian', 'MER', 'Mer', 'mer', 'geometry', 'isContaining', 'OBJECTID', 'objectid', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                  Object.entries(section).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds.getNorthEast());
                  bounds.extend(polygonBounds.getSouthWest());
                  
                  sectionCount++;
                }
              } catch (error) {
                console.error('Error drawing CA PLSS Section polygon:', error);
              }
            }
          });
          
          if (sectionCount > 0) {
            if (!legendAccumulator['ca_plss_sections']) {
              legendAccumulator['ca_plss_sections'] = {
                icon: '🗺️',
                color: '#6366f1',
                title: 'CA Public Land Survey Sections',
                count: 0,
              };
            }
            legendAccumulator['ca_plss_sections'].count += sectionCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA PLSS Sections:', error);
      }

      // Draw CA Geothermal Wells as point markers on the map
      try {
        if (enrichments.ca_geothermal_wells_all && Array.isArray(enrichments.ca_geothermal_wells_all)) {
          let wellCount = 0;
          enrichments.ca_geothermal_wells_all.forEach((well: any) => {
            // Check for geometry with x/y (point geometry) or latitude/longitude fields
            const lat = well.geometry?.y || well.LATITUDE || well.latitude || well.LAT || well.lat || null;
            const lon = well.geometry?.x || well.LONGITUDE || well.longitude || well.LON || well.lon || null;
            
            if (lat !== null && lon !== null) {
              try {
                const wellId = well.wellId || well.WELL_ID || well.Well_ID || well.well_id || well.API || well.api || well.OBJECTID || well.objectid || 'Unknown';
                const distance = well.distance_miles !== null && well.distance_miles !== undefined ? well.distance_miles : 0;
                
                // Use volcano/geothermal icon with orange color
                const iconColor = '#ea580c'; // Orange for geothermal
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🌋', iconColor)
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🌋 Geothermal Well
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${wellId ? `<div><strong>Well ID:</strong> ${wellId}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all well attributes (excluding internal fields)
                const excludeFields = ['wellId', 'WELL_ID', 'Well_ID', 'well_id', 'API', 'api', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID', 'LATITUDE', 'latitude', 'LAT', 'lat', 'LONGITUDE', 'longitude', 'LON', 'lon'];
                Object.entries(well).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                wellCount++;
              } catch (error) {
                console.error('Error drawing CA Geothermal Well marker:', error);
              }
            }
          });
          
          if (wellCount > 0) {
            if (!legendAccumulator['ca_geothermal_wells']) {
              legendAccumulator['ca_geothermal_wells'] = {
                icon: '🌋',
                color: '#ea580c',
                title: 'CA Geothermal Wells',
                count: 0,
              };
            }
            legendAccumulator['ca_geothermal_wells'].count += wellCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Geothermal Wells:', error);
      }

      // Draw CA Oil and Gas Wells as point markers on the map
      try {
        if (enrichments.ca_oil_gas_wells_all && Array.isArray(enrichments.ca_oil_gas_wells_all)) {
          let wellCount = 0;
          enrichments.ca_oil_gas_wells_all.forEach((well: any) => {
            // Check for geometry with x/y (point geometry) or latitude/longitude fields
            const lat = well.geometry?.y || well.LATITUDE || well.latitude || well.LAT || well.lat || null;
            const lon = well.geometry?.x || well.LONGITUDE || well.longitude || well.LON || well.lon || null;
            
            if (lat !== null && lon !== null) {
              try {
                const wellId = well.wellId || well.WELL_ID || well.Well_ID || well.well_id || well.API || well.api || well.OBJECTID || well.objectid || 'Unknown';
                const distance = well.distance_miles !== null && well.distance_miles !== undefined ? well.distance_miles : 0;
                
                // Use oil/gas icon with dark gray/black color
                const iconColor = '#1f2937'; // Dark gray/black for oil and gas
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🛢️', iconColor)
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🛢️ Oil and Gas Well
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${wellId ? `<div><strong>Well ID:</strong> ${wellId}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all well attributes (excluding internal fields)
                const excludeFields = ['wellId', 'WELL_ID', 'Well_ID', 'well_id', 'API', 'api', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'GLOBALID', 'LATITUDE', 'latitude', 'LAT', 'lat', 'LONGITUDE', 'longitude', 'LON', 'lon'];
                Object.entries(well).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                wellCount++;
              } catch (error) {
                console.error('Error drawing CA Oil and Gas Well marker:', error);
              }
            }
          });
          
          if (wellCount > 0) {
            if (!legendAccumulator['ca_oil_gas_wells']) {
              legendAccumulator['ca_oil_gas_wells'] = {
                icon: '🛢️',
                color: '#1f2937',
                title: 'CA Oil and Gas Wells',
                count: 0,
              };
            }
            legendAccumulator['ca_oil_gas_wells'].count += wellCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Oil and Gas Wells:', error);
      }

      // Draw CA Eco Regions as polygons on the map
      try {
        if (enrichments.ca_eco_regions_all && Array.isArray(enrichments.ca_eco_regions_all)) {
          let regionCount = 0;
          enrichments.ca_eco_regions_all.forEach((region: any) => {
            if (region.geometry && region.geometry.rings) {
              try {
                const rings = region.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('CA Eco Region polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = region.isContaining;
                  const color = isContaining ? '#16a34a' : '#22c55e'; // Green for eco regions
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const usL3Code = region.US_L3CODE || region.us_l3code || region.US_L3_CODE || null;
                  const usL3Name = region.US_L3NAME || region.us_l3name || region.US_L3_NAME || null;
                  const regionId = region.regionId || region.OBJECTID || region.objectid || 'Unknown';
                  const regionName = usL3Name || usL3Code || regionId.toString();
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌿 Eco Region
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${regionName ? `<div><strong>Region:</strong> ${regionName}</div>` : ''}
                        ${usL3Code ? `<div><strong>L3 Code:</strong> ${usL3Code}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this eco region</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all region attributes (excluding internal fields)
                  const excludeFields = ['regionId', 'US_L3CODE', 'us_l3code', 'US_L3_CODE', 'US_L3NAME', 'us_l3name', 'US_L3_NAME', 'geometry', 'isContaining', 'OBJECTID', 'objectid', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                  Object.entries(region).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds.getNorthEast());
                  bounds.extend(polygonBounds.getSouthWest());
                  
                  regionCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Eco Region polygon:', error);
              }
            }
          });
          
          if (regionCount > 0) {
            if (!legendAccumulator['ca_eco_regions']) {
              legendAccumulator['ca_eco_regions'] = {
                icon: '🌿',
                color: '#16a34a',
                title: 'CA Eco Regions',
                count: 0,
              };
            }
            legendAccumulator['ca_eco_regions'].count += regionCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Eco Regions:', error);
      }

      // Draw City of Los Angeles Zoning as polygons on the map
      try {
        if (enrichments.ca_la_zoning_all && Array.isArray(enrichments.ca_la_zoning_all)) {
          let zoningCount = 0;
          enrichments.ca_la_zoning_all.forEach((zone: any) => {
            if (zone.geometry && zone.geometry.rings) {
              try {
                const rings = zone.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('City of Los Angeles Zoning polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = zone.isContaining;
                  const color = isContaining ? '#7c3aed' : '#a78bfa'; // Purple for zoning
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const zoningId = zone.zoningId || zone.OBJECTID || zone.objectid || 'Unknown';
                  const distance = zone.distance_miles !== null && zone.distance_miles !== undefined ? zone.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏙️ Zoning Polygon
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${zoningId ? `<div><strong>Zoning ID:</strong> ${zoningId}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this zoning polygon</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all zoning attributes (excluding internal fields)
                  const excludeFields = ['zoningId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                  Object.entries(zone).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds.getNorthEast());
                  bounds.extend(polygonBounds.getSouthWest());
                  
                  zoningCount++;
                }
              } catch (error) {
                console.error('Error drawing City of Los Angeles Zoning polygon:', error);
              }
            }
          });
          
          if (zoningCount > 0) {
            if (!legendAccumulator['ca_la_zoning']) {
              legendAccumulator['ca_la_zoning'] = {
                icon: '🏙️',
                color: '#7c3aed',
                title: 'City of Los Angeles Zoning',
                count: 0,
              };
            }
            legendAccumulator['ca_la_zoning'].count += zoningCount;
          }
        }
      } catch (error) {
        console.error('Error processing City of Los Angeles Zoning:', error);
      }

      // Draw LA County Points of Interest as point markers on the map
      const laCountyPOILayers = [
        { key: 'la_county_arts_recreation_all', icon: '🎨', color: '#ec4899', title: 'LA County Arts and Recreation' },
        { key: 'la_county_education_all', icon: '🎓', color: '#3b82f6', title: 'LA County Education' },
        { key: 'la_county_hospitals_all', icon: '🏥', color: '#ef4444', title: 'LA County Hospitals' },
        { key: 'la_county_municipal_services_all', icon: '🏛️', color: '#6366f1', title: 'LA County Municipal Services' },
        { key: 'la_county_physical_features_all', icon: '🏔️', color: '#10b981', title: 'LA County Physical Features' },
        { key: 'la_county_public_safety_all', icon: '🚨', color: '#dc2626', title: 'LA County Public Safety' },
        { key: 'la_county_transportation_all', icon: '🚌', color: '#f59e0b', title: 'LA County Transportation' },
        { key: 'la_county_fire_hydrants_all', icon: '🚒', color: '#ef4444', title: 'LA County Fire Hydrants' }
      ];

      laCountyPOILayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let poiCount = 0;
            enrichments[key].forEach((poi: any) => {
              // Check for geometry with x/y (point geometry) or latitude/longitude fields
              const lat = poi.geometry?.y || poi.LATITUDE || poi.latitude || poi.LAT || poi.lat || null;
              const lon = poi.geometry?.x || poi.LONGITUDE || poi.longitude || poi.LON || poi.lon || null;
              
              if (lat !== null && lon !== null) {
                try {
                  // Special handling for fire hydrants - prioritize OBJECTID_1
                  const poiId = key === 'la_county_fire_hydrants_all' 
                    ? (poi.OBJECTID_1 || poi.OBJECTID || poi.objectid || 'Unknown')
                    : (poi.poiId || poi.OBJECTID || poi.objectid || 'Unknown');
                  const distance = poi.distance_miles !== null && poi.distance_miles !== undefined ? poi.distance_miles : 0;
                  
                  const marker = L.marker([lat, lon], {
                    icon: createPOIIcon(icon, color)
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${poiId ? `<div><strong>POI ID:</strong> ${poiId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all POI attributes (excluding internal fields)
                  const excludeFields = ['poiId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'LATITUDE', 'latitude', 'LAT', 'lat', 'LONGITUDE', 'longitude', 'LON', 'lon'];
                  Object.entries(poi).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  poiCount++;
                } catch (error) {
                  console.error(`Error drawing ${title} marker:`, error);
                }
              }
            });
            
            if (poiCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += poiCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw Chicago 311 Service Requests as point markers with color-coding by SR_TYPE
      try {
        if (enrichments.chicago_311_all && Array.isArray(enrichments.chicago_311_all)) {
          let chicago311Count = 0;
          
          // Color mapping function for SR_TYPE
          const getColorForSRType = (srType: string): string => {
            if (!srType) return '#6b7280'; // Default gray
            
            const type = srType.toLowerCase();
            // Common 311 request types with distinct colors
            if (type.includes('graffiti') || type.includes('vandalism')) return '#dc2626'; // Red
            if (type.includes('pothole') || type.includes('street')) return '#f59e0b'; // Orange
            if (type.includes('tree') || type.includes('parkway')) return '#10b981'; // Green
            if (type.includes('alley') || type.includes('light')) return '#3b82f6'; // Blue
            if (type.includes('garbage') || type.includes('trash') || type.includes('sanitation')) return '#8b5cf6'; // Purple
            if (type.includes('water') || type.includes('sewer')) return '#06b6d4'; // Cyan
            if (type.includes('building') || type.includes('housing')) return '#ef4444'; // Pink-red
            if (type.includes('rodent') || type.includes('animal')) return '#92400e'; // Brown
            if (type.includes('sidewalk') || type.includes('curb')) return '#6366f1'; // Indigo
            if (type.includes('traffic') || type.includes('sign')) return '#f97316'; // Orange-red
            
            // Default colors for other types (use hash of string for consistency)
            const colors = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4', '#ef4444', '#6366f1'];
            const hash = srType.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            return colors[hash % colors.length];
          };
          
          enrichments.chicago_311_all.forEach((request: any) => {
            try {
              const lat = request.latitude || request.geometry?.y || null;
              const lon = request.longitude || request.geometry?.x || null;
              
              if (lat !== null && lon !== null) {
                const srType = request.sr_type || request.SR_TYPE || 'Unknown';
                const srNumber = request.sr_number || request.SR_NUMBER || 'Unknown';
                const color = getColorForSRType(srType);
                const distance = request.distance_miles !== null && request.distance_miles !== undefined ? request.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('📞', color)
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      📞 Chicago 311 Service Request
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${srNumber ? `<div><strong>SR Number:</strong> ${srNumber}</div>` : ''}
                      ${srType ? `<div><strong>Type:</strong> ${srType}</div>` : ''}
                      ${request.status ? `<div><strong>Status:</strong> ${request.status}</div>` : ''}
                      ${request.street_address ? `<div><strong>Address:</strong> ${request.street_address}</div>` : ''}
                      ${request.community_area ? `<div><strong>Community Area:</strong> ${request.community_area}</div>` : ''}
                      ${request.ward ? `<div><strong>Ward:</strong> ${request.ward}</div>` : ''}
                      ${request.created_date ? `<div><strong>Created:</strong> ${new Date(request.created_date).toLocaleDateString()}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all request attributes (excluding internal fields)
                const excludeFields = ['geometry', 'distance_miles', 'latitude', 'longitude', 'location', 'sr_number', 'SR_NUMBER', 'sr_type', 'SR_TYPE', 'status', 'street_address', 'community_area', 'ward', 'created_date'];
                Object.entries(request).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                chicago311Count++;
              }
            } catch (error) {
              console.error('Error drawing Chicago 311 marker:', error);
            }
          });
          
          if (chicago311Count > 0) {
            if (!legendAccumulator['chicago_311']) {
              legendAccumulator['chicago_311'] = {
                icon: '📞',
                color: '#3b82f6',
                title: 'Chicago 311 Service Requests',
                count: 0,
              };
            }
            legendAccumulator['chicago_311'].count += chicago311Count;
          }
        }
      } catch (error) {
        console.error('Error processing Chicago 311:', error);
      }

      // Draw Chicago Traffic Crashes as point markers
      try {
        if (enrichments.chicago_traffic_crashes_all && Array.isArray(enrichments.chicago_traffic_crashes_all)) {
          let chicagoTrafficCrashesCount = 0;
          
          enrichments.chicago_traffic_crashes_all.forEach((crash: any) => {
            try {
              const lat = crash.latitude || crash.geometry?.y || null;
              const lon = crash.longitude || crash.geometry?.x || null;
              
              if (lat !== null && lon !== null) {
                // Create marker with crash icon
                const marker = L.marker([lat, lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: #dc2626; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">🚗</div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                  })
                });
                
                // Build popup content
                const crashId = crash.crash_record_id || crash.CRASH_RECORD_ID || 'Unknown';
                const crashDate = crash.crash_date || crash.CRASH_DATE || '';
                const crashType = crash.crash_type || crash.CRASH_TYPE || '';
                const firstCrashType = crash.first_crash_type || crash.FIRST_CRASH_TYPE || '';
                const primCause = crash.prim_contributory_cause || crash.PRIM_CONTRIBUTORY_CAUSE || '';
                const streetName = crash.street_name || crash.STREET_NAME || '';
                const streetNo = crash.street_no || crash.STREET_NO || '';
                const streetDir = crash.street_direction || crash.STREET_DIRECTION || '';
                const injuriesTotal = crash.injuries_total !== null && crash.injuries_total !== undefined ? crash.injuries_total : 0;
                const mostSevereInjury = crash.most_severe_injury || crash.MOST_SEVERE_INJURY || '';
                const distance = crash.distance_miles !== null && crash.distance_miles !== undefined ? crash.distance_miles.toFixed(2) : '';
                
                // Build address
                let address = '';
                if (streetNo) address += streetNo;
                if (streetDir) address += ` ${streetDir}`;
                if (streetName) address += ` ${streetName}`;
                
                let popupContent = `
                  <div style="max-width: 300px;">
                    <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #1f2937;">
                      🚗 Traffic Crash
                    </div>
                    <div style="font-size: 12px; color: #4b5563;">
                      ${crashId ? `<div><strong>Crash ID:</strong> ${crashId}</div>` : ''}
                      ${crashDate ? `<div><strong>Date:</strong> ${new Date(crashDate).toLocaleString()}</div>` : ''}
                      ${address ? `<div><strong>Location:</strong> ${address.trim()}</div>` : ''}
                      ${crashType ? `<div><strong>Crash Type:</strong> ${crashType}</div>` : ''}
                      ${firstCrashType ? `<div><strong>First Crash Type:</strong> ${firstCrashType}</div>` : ''}
                      ${primCause ? `<div><strong>Primary Cause:</strong> ${primCause}</div>` : ''}
                      ${injuriesTotal > 0 ? `<div><strong>Injuries:</strong> ${injuriesTotal}</div>` : ''}
                      ${mostSevereInjury ? `<div><strong>Most Severe Injury:</strong> ${mostSevereInjury}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                `;
                
                // Add all crash attributes (excluding internal fields)
                const excludeFields = ['geometry', 'distance_miles', 'latitude', 'longitude', 'location', 'crash_record_id', 'CRASH_RECORD_ID', 'crash_date', 'CRASH_DATE', 'crash_type', 'CRASH_TYPE', 'first_crash_type', 'FIRST_CRASH_TYPE', 'prim_contributory_cause', 'PRIM_CONTRIBUTORY_CAUSE', 'street_name', 'STREET_NAME', 'street_no', 'STREET_NO', 'street_direction', 'STREET_DIRECTION', 'injuries_total', 'INJURIES_TOTAL', 'most_severe_injury', 'MOST_SEVERE_INJURY'];
                Object.entries(crash).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                chicagoTrafficCrashesCount++;
              }
            } catch (error) {
              console.error('Error drawing Chicago Traffic Crash marker:', error);
            }
          });
          
          if (chicagoTrafficCrashesCount > 0) {
            if (!legendAccumulator['chicago_traffic_crashes']) {
              legendAccumulator['chicago_traffic_crashes'] = {
                icon: '🚗',
                color: '#dc2626',
                title: 'Chicago Traffic Crashes',
                count: 0,
              };
            }
            legendAccumulator['chicago_traffic_crashes'].count += chicagoTrafficCrashesCount;
          }
        }
      } catch (error) {
        console.error('Error processing Chicago Traffic Crashes:', error);
      }

      // Draw Chicago Building Centroids as point markers
      try {
        if (enrichments.chicago_building_footprints_all && Array.isArray(enrichments.chicago_building_footprints_all)) {
          let chicagoBuildingFootprintsCount = 0;
          
          enrichments.chicago_building_footprints_all.forEach((footprint: any) => {
            try {
              // Use centroid coordinates (latitude/longitude) from the adapter
              const lat = footprint.latitude;
              const lon = footprint.longitude;
              
              if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
                // Create marker with building icon
                const marker = L.marker([lat, lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: #8b5cf6; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">🏢</div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                  })
                });
                
                // Build popup content
                const bldgId = footprint.bldg_id || footprint.BLDG_ID || 'Unknown';
                const bldgName1 = footprint.bldg_name1 || footprint.BLDG_NAME1 || '';
                const bldgName2 = footprint.bldg_name2 || footprint.BLDG_NAME2 || '';
                const bldgName = bldgName1 || bldgName2 || '';
                const unitName = footprint.unit_name || footprint.UNIT_NAME || '';
                const fAdd1 = footprint.f_add1 || footprint.F_ADD1 || '';
                const tAdd1 = footprint.t_add1 || footprint.T_ADD1 || '';
                const preDir1 = footprint.pre_dir1 || footprint.PRE_DIR1 || '';
                const stName1 = footprint.st_name1 || footprint.ST_NAME1 || '';
                const stType1 = footprint.st_type1 || footprint.ST_TYPE1 || '';
                const sufDir1 = footprint.suf_dir1 || footprint.SUF_DIR1 || '';
                const yearBuilt = footprint.year_built || footprint.YEAR_BUILT || '';
                const stories = footprint.stories || footprint.STORIES || footprint.no_stories || footprint.NO_STORIES || '';
                const distance = footprint.distance_miles !== null && footprint.distance_miles !== undefined ? footprint.distance_miles.toFixed(2) : '';
                
                // Build address from components
                let address = '';
                if (fAdd1 || tAdd1) {
                  address = `${fAdd1}${tAdd1 ? `-${tAdd1}` : ''}`;
                }
                if (preDir1 || stName1 || stType1 || sufDir1) {
                  address += ` ${preDir1 || ''} ${stName1 || ''} ${stType1 || ''} ${sufDir1 || ''}`.trim();
                }
                if (unitName) {
                  address += ` ${unitName}`;
                }
                
                let popupContent = `
                  <div style="max-width: 300px;">
                    <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #1f2937;">
                      🏢 Building Centroid
                    </div>
                    <div style="font-size: 12px; color: #4b5563;">
                      ${bldgName ? `<div><strong>Name:</strong> ${bldgName}</div>` : ''}
                      ${bldgId ? `<div><strong>Building ID:</strong> ${bldgId}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address.trim()}</div>` : ''}
                      ${yearBuilt ? `<div><strong>Year Built:</strong> ${yearBuilt}</div>` : ''}
                      ${stories ? `<div><strong>Stories:</strong> ${stories}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                `;
                
                // Add all footprint attributes (excluding internal fields)
                const excludeFields = ['the_geom', 'geometry', 'distance_miles', 'latitude', 'longitude', 'location', 'bldg_id', 'BLDG_ID', 'bldg_name1', 'BLDG_NAME1', 'bldg_name2', 'BLDG_NAME2', 'unit_name', 'UNIT_NAME', 'f_add1', 'F_ADD1', 't_add1', 'T_ADD1', 'pre_dir1', 'PRE_DIR1', 'st_name1', 'ST_NAME1', 'st_type1', 'ST_TYPE1', 'suf_dir1', 'SUF_DIR1', 'year_built', 'YEAR_BUILT', 'stories', 'STORIES', 'no_stories', 'NO_STORIES'];
                Object.entries(footprint).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                chicagoBuildingFootprintsCount++;
              }
            } catch (error) {
              console.error('Error drawing Chicago Building Centroid:', error);
            }
          });
          
          if (chicagoBuildingFootprintsCount > 0) {
            if (!legendAccumulator['chicago_building_footprints']) {
              legendAccumulator['chicago_building_footprints'] = {
                icon: '🏢',
                color: '#8b5cf6',
                title: 'Chicago Building Centroids',
                count: 0,
              };
            }
            legendAccumulator['chicago_building_footprints'].count += chicagoBuildingFootprintsCount;
          }
        }
      } catch (error) {
        console.error('Error processing Chicago Building Centroids:', error);
      }

      // Draw Lake County Building Footprints as polygons
      try {
        if (enrichments.lake_county_building_footprints_all && Array.isArray(enrichments.lake_county_building_footprints_all)) {
          let lakeCountyBuildingFootprintsCount = 0;
          
          enrichments.lake_county_building_footprints_all.forEach((footprint: any) => {
            if (footprint.geometry && footprint.geometry.rings) {
              try {
                const rings = footprint.geometry.rings;
                if (rings && rings.length > 0 && rings[0] && rings[0].length > 0) {
                  // Convert ESRI rings to Leaflet latlngs
                  const latlngs = rings[0].map((ring: number[]) => {
                    if (Array.isArray(ring) && ring.length >= 2) {
                      return [ring[1], ring[0]] as [number, number]; // ESRI format is [lon, lat], Leaflet needs [lat, lon]
                    }
                    return null;
                  }).filter((coord: any): coord is [number, number] => coord !== null);
                  
                  if (latlngs.length > 0) {
                    const polygon = L.polygon(latlngs, {
                      color: '#10b981',
                      weight: 2,
                      opacity: 0.7,
                      fillColor: '#10b981',
                      fillOpacity: 0.3
                    }).addTo(primary);
                    
                    const featureCode = footprint.featureCode || 'Building General';
                    const buildingClass = footprint.buildingClass || 0;
                    const shapeArea = footprint.shapeArea || 0;
                    const shapeLength = footprint.shapeLength || 0;
                    const distance = footprint.distance || 0;
                    const containing = footprint.containing || false;
                    
                    const popupContent = `
                      <div style="max-width: 300px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: Lake County Building Footprint</h3>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                          <p style="margin: 4px 0;"><strong>Feature Code:</strong> ${featureCode}</p>
                          <p style="margin: 4px 0;"><strong>Building Class:</strong> ${buildingClass}</p>
                          <p style="margin: 4px 0;"><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</p>
                          <p style="margin: 4px 0;"><strong>Perimeter:</strong> ${shapeLength.toLocaleString()} units</p>
                          ${!containing && distance > 0 ? `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    
                    // Extend bounds to include polygon
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    
                    lakeCountyBuildingFootprintsCount++;
                  }
                }
              } catch (error) {
                console.error('Error drawing Lake County Building Footprint:', error);
              }
            }
          });
          
          if (lakeCountyBuildingFootprintsCount > 0) {
            if (!legendAccumulator['lake_county_building_footprints']) {
              legendAccumulator['lake_county_building_footprints'] = {
                icon: '🏢',
                color: '#10b981',
                title: 'Lake County Building Footprints',
                count: 0
              };
            }
            legendAccumulator['lake_county_building_footprints'].count += lakeCountyBuildingFootprintsCount;
          }
        }
      } catch (error) {
        console.error('Error processing Lake County Building Footprints:', error);
      }

      // Draw Lake County Pavement Boundaries as polygons
      try {
        if (enrichments.lake_county_pavement_boundaries_all && Array.isArray(enrichments.lake_county_pavement_boundaries_all)) {
          let lakeCountyPavementBoundariesCount = 0;
          
          enrichments.lake_county_pavement_boundaries_all.forEach((boundary: any) => {
            if (boundary.geometry && boundary.geometry.rings) {
              try {
                const rings = boundary.geometry.rings;
                // Only draw the outer ring (rings[0]) - same approach as building footprints
                // Additional rings are either inner rings (holes) or separate polygon parts
                // For now, we'll only draw the outer boundary to avoid filled-in appearance
                if (rings && rings.length > 0 && rings[0] && rings[0].length > 0) {
                  const outerRing = rings[0]; // First ring is the outer boundary
                  // Convert ESRI ring coordinates to Leaflet latlngs
                  const latlngs = outerRing.map((coord: number[]) => {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      return [coord[1], coord[0]] as [number, number]; // ESRI format is [lon, lat], Leaflet needs [lat, lon]
                    }
                    return null;
                  }).filter((coord: any): coord is [number, number] => coord !== null);
                  
                  if (latlngs.length >= 2) { // Need at least 2 points for a polyline
                    // Draw as polyline (outline only) instead of filled polygon
                    // This shows the road boundary without filling in the area
                    const polyline = L.polyline(latlngs, {
                      color: '#f59e0b',
                      weight: 3,
                      opacity: 0.8
                    }).addTo(primary);
                    
                    const type = boundary.type || 'Unknown';
                    const shapeArea = boundary.shapeArea || 0;
                    const shapeLength = boundary.shapeLength || 0;
                    const distance = boundary.distance || 0;
                    const containing = boundary.containing || false;
                    
                    const popupContent = `
                      <div style="max-width: 300px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: Lake County Pavement Boundary</h3>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                          <p style="margin: 4px 0;"><strong>Type:</strong> ${type}</p>
                          <p style="margin: 4px 0;"><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</p>
                          <p style="margin: 4px 0;"><strong>Perimeter:</strong> ${shapeLength.toLocaleString()} units</p>
                          ${!containing && distance > 0 ? `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                    
                    lakeCountyPavementBoundariesCount++;
                  }
                }
              } catch (error) {
                console.error('Error drawing Lake County Pavement Boundary:', error);
              }
            }
          });
          
          if (lakeCountyPavementBoundariesCount > 0) {
            if (!legendAccumulator['lake_county_pavement_boundaries']) {
              legendAccumulator['lake_county_pavement_boundaries'] = {
                icon: '🛣️',
                color: '#f59e0b',
                title: 'Lake County Pavement Boundaries',
                count: 0
              };
            }
            legendAccumulator['lake_county_pavement_boundaries'].count += lakeCountyPavementBoundariesCount;
          }
        }
      } catch (error) {
        console.error('Error processing Lake County Pavement Boundaries:', error);
      }

      // Draw Lake County Parcel Points as point markers
      try {
        if (enrichments.lake_county_parcel_points_all && Array.isArray(enrichments.lake_county_parcel_points_all)) {
          let lakeCountyParcelPointsCount = 0;
          
          enrichments.lake_county_parcel_points_all.forEach((point: any) => {
            if (point.lat && point.lon && !isNaN(point.lat) && !isNaN(point.lon)) {
              try {
                const marker = L.marker([point.lat, point.lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: #8b5cf6; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">🏘️</div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                  })
                });
                
                const distance = point.distance !== null && point.distance !== undefined ? point.distance.toFixed(3) : '';
                const objectId = point.objectId || '';
                
                const popupContent = `
                  <div style="max-width: 300px;">
                    <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">Lake County Parcel Point</h3>
                    <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                      ${objectId ? `<p style="margin: 4px 0;"><strong>Object ID:</strong> ${objectId}</p>` : ''}
                      ${distance ? `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance} miles</p>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([point.lat, point.lon]);
                lakeCountyParcelPointsCount++;
              } catch (error) {
                console.error('Error drawing Lake County Parcel Point:', error);
              }
            }
          });
          
          if (lakeCountyParcelPointsCount > 0) {
            if (!legendAccumulator['lake_county_parcel_points']) {
              legendAccumulator['lake_county_parcel_points'] = {
                icon: '🏘️',
                color: '#8b5cf6',
                title: 'Lake County Parcel Points',
                count: 0
              };
            }
            legendAccumulator['lake_county_parcel_points'].count += lakeCountyParcelPointsCount;
          }
        }
      } catch (error) {
        console.error('Error processing Lake County Parcel Points:', error);
      }

      // Draw Lake County Parcels as polygons
      try {
        if (enrichments.lake_county_parcels_all && Array.isArray(enrichments.lake_county_parcels_all)) {
          let lakeCountyParcelsCount = 0;
          
          enrichments.lake_county_parcels_all.forEach((parcel: any) => {
            if (parcel.geometry && parcel.geometry.rings) {
              try {
                const rings = parcel.geometry.rings;
                if (rings && rings.length > 0 && rings[0] && rings[0].length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      return [coord[1], coord[0]] as [number, number];
                    }
                    return null;
                  }).filter((coord: any): coord is [number, number] => coord !== null);
                  
                  if (latlngs.length >= 3) {
                    const polygon = L.polygon(latlngs, {
                      color: '#8b5cf6',
                      weight: 2,
                      opacity: 0.7,
                      fillColor: '#8b5cf6',
                      fillOpacity: 0.2
                    }).addTo(primary);
                    
                    const objectId = parcel.objectId || 0;
                    const distance = parcel.distance || 0;
                    const containing = parcel.containing || false;
                    
                    const popupContent = `
                      <div style="max-width: 300px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: Lake County Parcel</h3>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                          <p style="margin: 4px 0;"><strong>Object ID:</strong> ${objectId}</p>
                          ${!containing && distance > 0 ? `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    lakeCountyParcelsCount++;
                  }
                }
              } catch (error) {
                console.error('Error drawing Lake County Parcel:', error);
              }
            }
          });
          
          if (lakeCountyParcelsCount > 0) {
            if (!legendAccumulator['lake_county_parcels']) {
              legendAccumulator['lake_county_parcels'] = {
                icon: '🏘️',
                color: '#8b5cf6',
                title: 'Lake County Parcels',
                count: 0
              };
            }
            legendAccumulator['lake_county_parcels'].count += lakeCountyParcelsCount;
          }
        }
      } catch (error) {
        console.error('Error processing Lake County Parcels:', error);
      }

      // Draw Lake County High School Districts as polygons
      try {
        if (enrichments.lake_county_high_school_districts_all && Array.isArray(enrichments.lake_county_high_school_districts_all)) {
          let lakeCountyHighSchoolDistrictsCount = 0;
          
          enrichments.lake_county_high_school_districts_all.forEach((district: any) => {
            if (district.geometry && district.geometry.rings) {
              try {
                const rings = district.geometry.rings;
                if (rings && rings.length > 0 && rings[0] && rings[0].length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      return [coord[1], coord[0]] as [number, number];
                    }
                    return null;
                  }).filter((coord: any): coord is [number, number] => coord !== null);
                  
                  if (latlngs.length >= 3) {
                    const polygon = L.polygon(latlngs, {
                      color: '#6366f1',
                      weight: 2,
                      opacity: 0.7,
                      fillColor: '#6366f1',
                      fillOpacity: 0.2
                    }).addTo(primary);
                    
                    const highName = district.highName || district.name || 'Unknown';
                    const districtNum = district.district || district.highDist || '';
                    const addr = district.addr || '';
                    const city = district.city || '';
                    const zip = district.zip || '';
                    const phone = district.phone || '';
                    const url = district.url || '';
                    const shapeArea = district.shapeArea || 0;
                    const shapeLength = district.shapeLength || 0;
                    const distance = district.distance || 0;
                    const containing = district.containing || false;
                    
                    let address = '';
                    if (addr) {
                      address = addr;
                      if (city) address += `, ${city}`;
                      if (zip) address += ` ${zip}`;
                    }
                    
                    const popupContent = `
                      <div style="max-width: 300px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: ${highName}</h3>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                          ${districtNum ? `<p style="margin: 4px 0;"><strong>District:</strong> ${districtNum}</p>` : ''}
                          ${address ? `<p style="margin: 4px 0;"><strong>Address:</strong> ${address}</p>` : ''}
                          ${phone ? `<p style="margin: 4px 0;"><strong>Phone:</strong> ${phone}</p>` : ''}
                          ${url ? `<p style="margin: 4px 0;"><strong>Website:</strong> <a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a></p>` : ''}
                          <p style="margin: 4px 0;"><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</p>
                          <p style="margin: 4px 0;"><strong>Perimeter:</strong> ${shapeLength.toLocaleString()} units</p>
                          ${!containing && distance > 0 ? `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    lakeCountyHighSchoolDistrictsCount++;
                  }
                }
              } catch (error) {
                console.error('Error drawing Lake County High School District:', error);
              }
            }
          });
          
          if (lakeCountyHighSchoolDistrictsCount > 0) {
            if (!legendAccumulator['lake_county_high_school_districts']) {
              legendAccumulator['lake_county_high_school_districts'] = {
                icon: '🏫',
                color: '#6366f1',
                title: 'Lake County High School Districts',
                count: 0
              };
            }
            legendAccumulator['lake_county_high_school_districts'].count += lakeCountyHighSchoolDistrictsCount;
          }
        }
      } catch (error) {
        console.error('Error processing Lake County High School Districts:', error);
      }

      // Draw NWS Watches and Warnings layers
      const nwsLayers = [
        'nws_public_forecast_zones',
        'nws_fire_forecast_zones',
        'nws_us_counties',
        'nws_us_states_territories',
        'nws_coastal_marine_zones',
        'nws_events_ordered',
        'nws_extreme_events',
        'nws_severe_events',
        'nws_moderate_events',
        'nws_minor_events',
        'nws_other_events',
        // NWS NDFD Wind layers
        'nws_ndfd_wind_national',
        'nws_ndfd_wind_regional',
        'nws_ndfd_wind_state',
        'nws_ndfd_wind_county',
        'nws_ndfd_wind_district',
        'nws_ndfd_wind_block_group',
        'nws_ndfd_wind_city',
        // NWS NDFD Grid Forecast layers
        'nws_forecasted_snowfall',
        'nws_forecasted_precipitation',
        // NWS NDFD Ice layers
        'nws_ndfd_ice_amount_by_time',
        'nws_ndfd_ice_accumulation_by_time',
        'nws_ndfd_ice_cumulative_total',
        // Live Stream Gauges (points)
        'nws_stream_gauges_live'
      ];
      
      const nwsColors: Record<string, string> = {
        'nws_public_forecast_zones': '#3b82f6',
        'nws_fire_forecast_zones': '#ef4444',
        'nws_us_counties': '#8b5cf6',
        'nws_us_states_territories': '#6366f1',
        'nws_coastal_marine_zones': '#06b6d4',
        'nws_events_ordered': '#f59e0b',
        'nws_extreme_events': '#dc2626',
        'nws_severe_events': '#ea580c',
        'nws_moderate_events': '#f59e0b',
        'nws_minor_events': '#eab308',
        'nws_other_events': '#6b7280',
        'nws_forecasted_snowfall': '#0ea5e9',
        'nws_forecasted_precipitation': '#10b981',
        'nws_ndfd_ice_amount_by_time': '#60a5fa',
        'nws_ndfd_ice_accumulation_by_time': '#93c5fd',
        'nws_ndfd_ice_cumulative_total': '#1d4ed8',
        'nws_stream_gauges_live': '#2563eb'
      };
      
      nwsLayers.forEach(layerKey => {
        try {
          const allKey = `${layerKey}_all`;
          if (enrichments[allKey] && Array.isArray(enrichments[allKey])) {
            let nwsCount = 0;
            const color = nwsColors[layerKey] || '#3b82f6';
            
            enrichments[allKey].forEach((feature: any) => {
              if (feature.geometry) {
                try {
                  const geom = feature.geometry;
                  const attrs = feature.attributes || {};
                  const isWindLayer = layerKey.startsWith('nws_ndfd_wind');
                  const isIceLayer = layerKey.startsWith('nws_ndfd_ice_');

                  // For ice layers, skip any feature that is not a polygon (rings)
                  if (isIceLayer && !geom.rings) {
                    return;
                  }
                  
                  if (geom.rings) {
                    // Polygon geometry
                    const rings = geom.rings;
                    if (rings && rings.length > 0 && rings[0] && rings[0].length > 0) {
                      const outerRing = rings[0];
                      const latlngs = outerRing.map((coord: number[]) => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                          return [coord[1], coord[0]] as [number, number];
                        }
                        return null;
                      }).filter((coord: any): coord is [number, number] => coord !== null);
                      
                      if (latlngs.length >= 3) {
                        const polygon = L.polygon(latlngs, {
                          color: color,
                          weight: 2,
                          opacity: 0.7,
                          fillColor: color,
                          fillOpacity: 0.2
                        }).addTo(primary);
                        
                        const layerName = feature.layerName || 'NWS Feature';
                        const distance = feature.distance || 0;
                        const containing = feature.containing || false;
                        const windFieldConfigs = [
                          { key: 'IntervalStart', label: 'Interval Start' },
                          { key: 'WindDir', label: 'Wind Direction' },
                          { key: 'WindSpeed', label: 'Wind Speed' },
                          { key: 'WindGust', label: 'Wind Gust' },
                          { key: 'DeltaDir', label: 'Delta Direction' },
                          { key: 'DeltaSpeed', label: 'Delta Speed' },
                          { key: 'DeltaGust', label: 'Delta Gust' }
                        ];
                        const formatDateValue = (value: any) => {
                          if (typeof value === 'number') {
                            const date = new Date(value);
                            if (!isNaN(date.getTime())) return date.toLocaleString();
                          }
                          return value;
                        };
                        
                        let popupContent = `
                          <div style="max-width: 300px;">
                            <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: ${layerName}</h3>
                            <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                        `;
                        
                        if (isWindLayer) {
                          windFieldConfigs.forEach(({ key, label }) => {
                            const value = attrs[key];
                            if (value !== null && value !== undefined && value !== '') {
                              const displayValue = key === 'IntervalStart' ? formatDateValue(value) : value;
                              popupContent += `<p style="margin: 4px 0;"><strong>${label}:</strong> ${displayValue}</p>`;
                            }
                          });
                        } else if (isIceLayer) {
                          const iceLabel = attrs.label || attrs.Label || '';
                          if (iceLabel) {
                            popupContent += `<p style="margin: 4px 0;"><strong>Label:</strong> ${iceLabel}</p>`;
                          }
                          // Show a few key attributes if available
                          Object.keys(attrs).slice(0, 5).forEach(key => {
                            if (['label', 'Label'].includes(key)) return;
                            if (attrs[key] !== null && attrs[key] !== undefined && attrs[key] !== '') {
                              const value = typeof attrs[key] === 'object' ? JSON.stringify(attrs[key]) : attrs[key];
                              popupContent += `<p style="margin: 4px 0;"><strong>${key}:</strong> ${value}</p>`;
                            }
                          });
                        } else {
                          // Add key attributes to popup (limited)
                          Object.keys(attrs).slice(0, 10).forEach(key => {
                            if (attrs[key] !== null && attrs[key] !== undefined && attrs[key] !== '') {
                              const value = typeof attrs[key] === 'object' ? JSON.stringify(attrs[key]) : attrs[key];
                              popupContent += `<p style="margin: 4px 0;"><strong>${key}:</strong> ${value}</p>`;
                            }
                          });
                        }
                        
                        if (!containing && distance > 0) {
                          popupContent += `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>`;
                        }
                        
                        popupContent += `
                            </div>
                          </div>
                        `;
                        
                        polygon.bindPopup(popupContent);
                        const polygonBounds = L.latLngBounds(latlngs);
                        bounds.extend(polygonBounds);
                        nwsCount++;
                      }
                    }
                  } else if (geom.x !== undefined && geom.y !== undefined) {
                    if (isIceLayer) {
                      console.warn(`🥶 Ice layer ${layerKey} returned point geometry; skipping marker. Attributes:`, attrs);
                      return;
                    }
                    // Point geometry
                    const lat = geom.y;
                    const lon = geom.x;
                    
                    if (!isNaN(lat) && !isNaN(lon)) {
                      const marker = L.marker([lat, lon], {
                        icon: L.divIcon({
                          className: 'custom-marker-icon',
                          html: `<div style="background-color: ${color}; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">🌦️</div>`,
                          iconSize: [20, 20],
                          iconAnchor: [10, 10]
                        })
                      });
                      
                      const layerName = feature.layerName || 'NWS Feature';
                      const distance = feature.distance || 0;
                      const containing = feature.containing || false;
                      const attrs = feature.attributes || {};
                      const isWindLayer = layerKey.startsWith('nws_ndfd_wind');
                      const isIceLayer = layerKey.startsWith('nws_ndfd_ice_');
                      const windFieldConfigs = [
                        { key: 'IntervalStart', label: 'Interval Start' },
                        { key: 'WindDir', label: 'Wind Direction' },
                        { key: 'WindSpeed', label: 'Wind Speed' },
                        { key: 'WindGust', label: 'Wind Gust' },
                        { key: 'DeltaDir', label: 'Delta Direction' },
                        { key: 'DeltaSpeed', label: 'Delta Speed' },
                        { key: 'DeltaGust', label: 'Delta Gust' }
                      ];
                      const formatDateValue = (value: any) => {
                        if (typeof value === 'number') {
                          const date = new Date(value);
                          if (!isNaN(date.getTime())) return date.toLocaleString();
                        }
                        return value;
                      };
                      
                      let popupContent = `
                        <div style="max-width: 300px;">
                          <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">${containing ? 'Containing' : 'Nearby'}: ${layerName}</h3>
                          <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                      `;
                      
                      if (isWindLayer) {
                        windFieldConfigs.forEach(({ key, label }) => {
                          const value = attrs[key];
                          if (value !== null && value !== undefined && value !== '') {
                            const displayValue = key === 'IntervalStart' ? formatDateValue(value) : value;
                            popupContent += `<p style="margin: 4px 0;"><strong>${label}:</strong> ${displayValue}</p>`;
                          }
                        });
                      } else if (isIceLayer) {
                        const iceLabel = attrs.label || attrs.Label || '';
                        if (iceLabel) {
                          popupContent += `<p style="margin: 4px 0;"><strong>Label:</strong> ${iceLabel}</p>`;
                        }
                        Object.keys(attrs).slice(0, 5).forEach(key => {
                          if (['label', 'Label'].includes(key)) return;
                          if (attrs[key] !== null && attrs[key] !== undefined && attrs[key] !== '') {
                            const value = typeof attrs[key] === 'object' ? JSON.stringify(attrs[key]) : attrs[key];
                            popupContent += `<p style="margin: 4px 0;"><strong>${key}:</strong> ${value}</p>`;
                          }
                        });
                      } else {
                        // Add key attributes to popup (limited)
                        Object.keys(attrs).slice(0, 10).forEach(key => {
                          if (attrs[key] !== null && attrs[key] !== undefined && attrs[key] !== '') {
                            const value = typeof attrs[key] === 'object' ? JSON.stringify(attrs[key]) : attrs[key];
                            popupContent += `<p style="margin: 4px 0;"><strong>${key}:</strong> ${value}</p>`;
                          }
                        });
                      }
                      
                      if (!containing && distance > 0) {
                        popupContent += `<p style="margin: 4px 0;"><strong>Distance:</strong> ${distance.toFixed(3)} miles</p>`;
                      }
                      
                      popupContent += `
                          </div>
                        </div>
                      `;
                      
                      marker.bindPopup(popupContent);
                      marker.addTo(primary);
                      bounds.extend([lat, lon]);
                      nwsCount++;
                    }
                  }
                } catch (error) {
                  console.error(`Error drawing NWS ${layerKey} feature:`, error);
                }
              }
            });
            
            if (nwsCount > 0) {
              const firstFeature = enrichments[allKey] && enrichments[allKey].length > 0 ? enrichments[allKey][0] : null;
              const layerTitle = firstFeature?.layerName || layerKey.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
              
              if (!legendAccumulator[layerKey]) {
                legendAccumulator[layerKey] = {
                  icon: '🌦️',
                  color: color,
                  title: layerTitle,
                  count: 0
                };
              }
              legendAccumulator[layerKey].count += nwsCount;
            }
          }
        } catch (error) {
          console.error(`Error processing NWS ${layerKey}:`, error);
        }
      });

      // Draw NWS Current Drought Conditions as polygons
      try {
        if (enrichments.nws_drought_current_all && Array.isArray(enrichments.nws_drought_current_all)) {
          console.log(`🌵 Processing ${enrichments.nws_drought_current_all.length} NWS Current Drought Condition feature(s)`);
          let nwsDroughtCount = 0;
          
          enrichments.nws_drought_current_all.forEach((drought: any, index: number) => {
            console.log(`🌵 Processing drought feature ${index + 1}:`, {
              hasGeometry: !!drought.geometry,
              hasRings: !!(drought.geometry && drought.geometry.rings),
              ringsCount: drought.geometry?.rings?.length || 0,
              dm: drought.dm
            });
            
            if (drought.geometry && drought.geometry.rings) {
              try {
                const rings = drought.geometry.rings;
                if (rings && rings.length > 0) {
                  // Process all rings (for multipart polygons)
                  rings.forEach((ring: number[][], ringIndex: number) => {
                    if (ring && ring.length > 0) {
                      // Check if coordinates are in Web Mercator or WGS84
                      const firstCoord = ring[0];
                      if (!firstCoord || firstCoord.length < 2) {
                        console.warn(`🌵 Ring ${ringIndex} has invalid first coordinate`);
                        return;
                      }
                      
                      const isWebMercator = Math.abs(firstCoord[0]) > 180 || Math.abs(firstCoord[1]) > 90;
                      
                      const latlngs = ring.map((coord: number[]) => {
                        if (Array.isArray(coord) && coord.length >= 2) {
                          if (isWebMercator) {
                            // Convert from Web Mercator to WGS84
                            const lon = (coord[0] / 20037508.34) * 180;
                            let lat = (coord[1] / 20037508.34) * 180;
                            lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
                            return [lat, lon] as [number, number];
                          } else {
                            // Already in WGS84 - ESRI format is [lon, lat], Leaflet needs [lat, lon]
                            return [coord[1], coord[0]] as [number, number];
                          }
                        }
                        return null;
                      }).filter((coord: any): coord is [number, number] => coord !== null);
                      
                      if (latlngs.length >= 3) {
                        console.log(`🌵 Drawing polygon with ${latlngs.length} coordinates from ring ${ringIndex}`);
                        
                        // Color based on drought intensity (dm value)
                        const dm = drought.dm !== undefined && drought.dm !== null ? drought.dm : -1;
                        const colors: Record<number, string> = {
                          0: '#f0dfa6', // Abnormally Dry
                          1: '#edc97b', // Drought - Moderate
                          2: '#eb9550', // Drought - Severe
                          3: '#d94d23', // Drought - Extreme
                          4: '#990000'  // Drought - Exceptional
                        };
                        const color = colors[dm] || '#cccccc';
                        
                        const polygon = L.polygon(latlngs, {
                          color: color,
                          weight: 2,
                          opacity: 0.8,
                          fillColor: color,
                          fillOpacity: 0.4
                        }).addTo(primary);
                        
                        const droughtLabel = drought.dm !== undefined && drought.dm !== null 
                          ? (drought.dm === 0 ? 'Abnormally Dry' : 
                             drought.dm === 1 ? 'Drought - Moderate' :
                             drought.dm === 2 ? 'Drought - Severe' :
                             drought.dm === 3 ? 'Drought - Extreme' :
                             drought.dm === 4 ? 'Drought - Exceptional' : 'Unknown')
                          : 'Unknown';
                        const period = drought.period || '';
                        const ddate = drought.ddate || '';
                        const shapeArea = drought.shapeArea || 0;
                        const shapeLength = drought.shapeLength || 0;
                        
                        const popupContent = `
                          <div style="max-width: 300px;">
                            <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">Current Drought: ${droughtLabel}</h3>
                            <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                              ${period ? `<p style="margin: 4px 0;"><strong>Period:</strong> ${period}</p>` : ''}
                              ${ddate ? `<p style="margin: 4px 0;"><strong>Date:</strong> ${ddate}</p>` : ''}
                              ${drought.dm !== undefined && drought.dm !== null ? `<p style="margin: 4px 0;"><strong>Drought Monitor Class:</strong> D${drought.dm}</p>` : ''}
                              ${drought.d0 !== undefined ? `<p style="margin: 4px 0;"><strong>D0 (Abnormally Dry):</strong> ${drought.d0.toFixed(1)}%</p>` : ''}
                              ${drought.d1 !== undefined ? `<p style="margin: 4px 0;"><strong>D1 (Moderate):</strong> ${drought.d1.toFixed(1)}%</p>` : ''}
                              ${drought.d2 !== undefined ? `<p style="margin: 4px 0;"><strong>D2 (Severe):</strong> ${drought.d2.toFixed(1)}%</p>` : ''}
                              ${drought.d3 !== undefined ? `<p style="margin: 4px 0;"><strong>D3 (Extreme):</strong> ${drought.d3.toFixed(1)}%</p>` : ''}
                              ${drought.d4 !== undefined ? `<p style="margin: 4px 0;"><strong>D4 (Exceptional):</strong> ${drought.d4.toFixed(1)}%</p>` : ''}
                              <p style="margin: 4px 0;"><strong>Area:</strong> ${shapeArea.toLocaleString()} sq units</p>
                              <p style="margin: 4px 0;"><strong>Perimeter:</strong> ${shapeLength.toLocaleString()} units</p>
                            </div>
                          </div>
                        `;
                        
                        polygon.bindPopup(popupContent);
                        const polygonBounds = L.latLngBounds(latlngs);
                        bounds.extend(polygonBounds);
                        nwsDroughtCount++;
                      } else {
                        console.warn(`🌵 Ring ${ringIndex} has insufficient coordinates (${latlngs.length})`);
                      }
                    }
                  });
                } else {
                  console.warn(`🌵 Drought feature ${index + 1} has no rings`);
                }
              } catch (error) {
                console.error(`🌵 Error drawing NWS Current Drought Condition feature ${index + 1}:`, error);
              }
            } else {
              console.warn(`🌵 Drought feature ${index + 1} missing geometry or rings`);
            }
          });
          
          console.log(`🌵 Successfully drew ${nwsDroughtCount} NWS Current Drought Condition polygon(s)`);
          
          if (nwsDroughtCount > 0) {
            if (!legendAccumulator['nws_drought_current']) {
              legendAccumulator['nws_drought_current'] = {
                icon: '🌵',
                color: '#d94d23',
                title: 'NWS Current Drought Conditions',
                count: 0
              };
            }
            legendAccumulator['nws_drought_current'].count += nwsDroughtCount;
          }
        } else {
          console.log(`🌵 No NWS Current Drought Conditions data found in enrichments`);
        }
      } catch (error) {
        console.error('🌵 Error processing NWS Current Drought Conditions:', error);
      }

      // Draw 2023 National Seismic Hazard Model polygons
      try {
        if (enrichments.national_seismic_hazard_2023_all && Array.isArray(enrichments.national_seismic_hazard_2023_all)) {
          console.log(`🌍 Processing ${enrichments.national_seismic_hazard_2023_all.length} Seismic Hazard feature(s)`);
          let seismicCount = 0;
          const seismicColor = '#dc2626';
          
          enrichments.national_seismic_hazard_2023_all.forEach((feature: any, idx: number) => {
            console.log(`🌍 MapView Feature ${idx}:`, {
              hasGeometry: !!feature.geometry,
              geometryKeys: feature.geometry ? Object.keys(feature.geometry) : [],
              hasRings: !!(feature.geometry && feature.geometry.rings),
              ringsLength: feature.geometry?.rings?.length,
              spatialRef: feature.geometry?.spatialReference,
              firstRingSample: feature.geometry?.rings?.[0]?.[0]
            });
            
            if (feature.geometry) {
              try {
                const geom = feature.geometry;
                
                // Check if geometry has rings (polygon)
                if (geom.rings && Array.isArray(geom.rings) && geom.rings.length > 0) {
                  const rings = geom.rings;
                  console.log(`🌍 Feature ${idx} has ${rings.length} ring(s) - drawing all rings as multipolygon`);
                  
                  // Check spatial reference - Web Mercator is 3857, WGS84 is 4326
                  const spatialRef = geom.spatialReference;
                  const isWebMercator = spatialRef?.wkid === 3857 || spatialRef?.latestWkid === 3857;
                  
                  // Process all rings - each ring becomes a polygon part
                  const allPolygonParts: [number, number][][] = [];
                  
                  // Determine coordinate conversion once for all rings (they should all be in the same CRS)
                  let needsConversion = isWebMercator;
                  if (rings.length > 0 && rings[0] && rings[0].length > 0) {
                    const firstCoord = rings[0][0];
                    const coordIsWebMercator = firstCoord && Array.isArray(firstCoord) && 
                      (Math.abs(firstCoord[0]) > 180 || Math.abs(firstCoord[1]) > 90);
                    needsConversion = isWebMercator || coordIsWebMercator;
                    
                    console.log(`🌍 Feature ${idx} coordinate conversion:`, {
                      spatialRefWkid: spatialRef?.wkid,
                      spatialRefLatestWkid: spatialRef?.latestWkid,
                      isWebMercator,
                      coordIsWebMercator,
                      needsConversion
                    });
                  }
                  
                  rings.forEach((ring: any) => {
                    if (!ring || !Array.isArray(ring) || ring.length === 0) {
                      return;
                    }
                    
                    const ringLatlngs = ring.map((coord: any) => {
                      // Handle both [lon, lat] arrays and {x, y} objects
                      let lon: number, lat: number;
                      
                      if (Array.isArray(coord) && coord.length >= 2) {
                        lon = coord[0];
                        lat = coord[1];
                      } else if (coord && typeof coord === 'object' && 'x' in coord && 'y' in coord) {
                        lon = coord.x;
                        lat = coord.y;
                      } else {
                        return null;
                      }
                      
                      // Validate coordinates are numbers
                      if (typeof lon !== 'number' || typeof lat !== 'number' || 
                          isNaN(lon) || isNaN(lat) || !isFinite(lon) || !isFinite(lat)) {
                        return null;
                      }
                      
                      let finalLat: number, finalLon: number;
                      
                      if (needsConversion) {
                        // Convert from Web Mercator (3857) to WGS84 (4326)
                        const lonDeg = (lon / 20037508.34) * 180;
                        let latDeg = (lat / 20037508.34) * 180;
                        latDeg = 180 / Math.PI * (2 * Math.atan(Math.exp(latDeg * Math.PI / 180)) - Math.PI / 2);
                        finalLat = latDeg;
                        finalLon = lonDeg;
                      } else {
                        // Already in WGS84 - ESRI format is [lon, lat], Leaflet needs [lat, lon]
                        finalLat = lat;
                        finalLon = lon;
                      }
                      
                      // Final validation - ensure coordinates are in valid ranges
                      if (finalLat < -90 || finalLat > 90 || finalLon < -180 || finalLon > 180) {
                        return null;
                      }
                      
                      return [finalLat, finalLon] as [number, number];
                    }).filter((coord: any): coord is [number, number] => coord !== null);
                    
                    // Ensure ring is closed (first and last point should be the same)
                    if (ringLatlngs.length >= 3) {
                      const first = ringLatlngs[0];
                      const last = ringLatlngs[ringLatlngs.length - 1];
                      if (first[0] !== last[0] || first[1] !== last[1]) {
                        ringLatlngs.push([first[0], first[1]]);
                      }
                      allPolygonParts.push(ringLatlngs);
                    }
                  });
                  
                  console.log(`🌍 Feature ${idx} processed ${allPolygonParts.length} valid ring(s) out of ${rings.length}`);
                  
                  if (allPolygonParts.length > 0) {
                    // Draw as multipolygon (all rings together)
                    const polygon = L.polygon(allPolygonParts, {
                      color: seismicColor,
                      weight: 3,
                      opacity: 0.8,
                      fillColor: seismicColor,
                      fillOpacity: 0.3
                    }).addTo(primary);
                    
                    // Make sure polygon is visible
                    polygon.bringToFront();
                    
                    const attrs = feature.attributes || {};
                    const mmi = attrs.MMI || attrs.mmi || attrs.low_c || 'N/A';
                    const range = attrs.range_cont || attrs.range || '';
                    const low = attrs.low_cont || attrs.low || '';
                    const high = attrs.high_cont || attrs.high || '';
                    
                    const popupContent = `
                      <div style="max-width: 300px;">
                        <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">Seismic Hazard Zone</h3>
                        <div style="font-size: 12px; color: #4b5563; line-height: 1.6;">
                          ${mmi ? `<p style="margin: 4px 0;"><strong>MMI:</strong> ${mmi}</p>` : ''}
                          ${range ? `<p style="margin: 4px 0;"><strong>Range:</strong> ${range}</p>` : ''}
                          ${low ? `<p style="margin: 4px 0;"><strong>Low:</strong> ${low}</p>` : ''}
                          ${high ? `<p style="margin: 4px 0;"><strong>High:</strong> ${high}</p>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    
                    // Extend map bounds to include this polygon
                    try {
                      const polygonBounds = polygon.getBounds();
                      bounds.extend(polygonBounds);
                      console.log(`🌍 Extended bounds to include multipolygon ${idx} with ${allPolygonParts.length} parts`);
                    } catch (e) {
                      console.warn(`🌍 Could not get bounds for multipolygon ${idx}:`, e);
                    }
                    
                    seismicCount++;
                    console.log(`🌍 Successfully drew multipolygon ${idx} with ${allPolygonParts.length} parts, visible: ${(polygon.options.opacity || 0) > 0}`);
                  } else {
                    console.warn(`🌍 Feature ${idx} has no valid rings after processing`);
                  }
                }
              } catch (error) {
                console.error(`🌍 Error drawing Seismic Hazard feature ${idx}:`, error, feature);
              }
            } else {
              console.warn(`🌍 Feature ${idx} has no geometry:`, feature);
            }
          });
          
          if (seismicCount > 0) {
            if (!legendAccumulator['national_seismic_hazard_2023']) {
              legendAccumulator['national_seismic_hazard_2023'] = {
                icon: '🌍',
                color: seismicColor,
                title: '2023 National Seismic Hazard Model',
                count: 0
              };
            }
            legendAccumulator['national_seismic_hazard_2023'].count += seismicCount;
            console.log(`🌍 Successfully drew ${seismicCount} Seismic Hazard polygon(s)`);
          } else {
            console.warn(`🌍 No Seismic Hazard polygons drawn despite ${enrichments.national_seismic_hazard_2023_all.length} features`);
          }
        }
      } catch (error) {
        console.error('🌍 Error processing Seismic Hazard:', error);
      }

      // Draw Chicago Speed Camera Locations as point markers
      try {
        if (enrichments.chicago_speed_cameras_all && Array.isArray(enrichments.chicago_speed_cameras_all)) {
          let chicagoSpeedCamerasCount = 0;
          
          enrichments.chicago_speed_cameras_all.forEach((camera: any) => {
            try {
              const lat = camera.latitude || camera.geometry?.y || null;
              const lon = camera.longitude || camera.geometry?.x || null;
              
              if (lat !== null && lon !== null) {
                // Create marker with camera icon
                const marker = L.marker([lat, lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: #f59e0b; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">📷</div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                  })
                });
                
                // Build popup content
                const cameraId = camera.camera_id || camera.CAMERA_ID || 'Unknown';
                const address = camera.address || camera.ADDRESS || '';
                const distance = camera.distance_miles !== null && camera.distance_miles !== undefined ? camera.distance_miles.toFixed(2) : '';
                
                let popupContent = `
                  <div style="max-width: 300px;">
                    <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #1f2937;">
                      📷 Speed Camera
                    </div>
                    <div style="font-size: 12px; color: #4b5563;">
                      ${cameraId ? `<div><strong>Camera ID:</strong> ${cameraId}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                `;
                
                // Add all camera attributes (excluding internal fields)
                const excludeFields = ['geometry', 'distance_miles', 'latitude', 'longitude', 'location', 'camera_id', 'CAMERA_ID', 'address', 'ADDRESS'];
                Object.entries(camera).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend(marker.getLatLng());
                
                chicagoSpeedCamerasCount++;
              }
            } catch (error) {
              console.error('Error drawing Chicago Speed Camera marker:', error);
            }
          });
          
          if (chicagoSpeedCamerasCount > 0) {
            if (!legendAccumulator['chicago_speed_cameras']) {
              legendAccumulator['chicago_speed_cameras'] = {
                icon: '📷',
                color: '#f59e0b',
                title: 'Chicago Speed Camera Locations',
                count: 0,
              };
            }
            legendAccumulator['chicago_speed_cameras'].count += chicagoSpeedCamerasCount;
          }
        }
      } catch (error) {
        console.error('Error processing Chicago Speed Camera Locations:', error);
      }

      // Draw Chicago Red Light Camera Locations as point markers
      try {
        if (enrichments.chicago_red_light_cameras_all && Array.isArray(enrichments.chicago_red_light_cameras_all)) {
          let chicagoRedLightCamerasCount = 0;
          
          enrichments.chicago_red_light_cameras_all.forEach((camera: any) => {
            try {
              const lat = camera.latitude || camera.geometry?.y || null;
              const lon = camera.longitude || camera.geometry?.x || null;
              
              if (lat !== null && lon !== null) {
                // Create marker with red light camera icon
                const marker = L.marker([lat, lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: #dc2626; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">🚦</div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                  })
                });
                
                // Build popup content
                const cameraId = camera.camera_id || camera.CAMERA_ID || 'Unknown';
                const address = camera.address || camera.ADDRESS || '';
                const distance = camera.distance_miles !== null && camera.distance_miles !== undefined ? camera.distance_miles.toFixed(2) : '';
                
                let popupContent = `
                  <div style="max-width: 300px;">
                    <div style="font-weight: bold; font-size: 14px; margin-bottom: 8px; color: #1f2937;">
                      🚦 Red Light Camera
                    </div>
                    <div style="font-size: 12px; color: #4b5563;">
                      ${cameraId ? `<div><strong>Camera ID:</strong> ${cameraId}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                `;
                
                // Add all camera attributes (excluding internal fields)
                const excludeFields = ['geometry', 'distance_miles', 'latitude', 'longitude', 'location', 'camera_id', 'CAMERA_ID', 'address', 'ADDRESS'];
                Object.entries(camera).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend(marker.getLatLng());
                
                chicagoRedLightCamerasCount++;
              }
            } catch (error) {
              console.error('Error drawing Chicago Red Light Camera marker:', error);
            }
          });
          
          if (chicagoRedLightCamerasCount > 0) {
            if (!legendAccumulator['chicago_red_light_cameras']) {
              legendAccumulator['chicago_red_light_cameras'] = {
                icon: '🚦',
                color: '#dc2626',
                title: 'Chicago Red Light Camera Locations',
                count: 0,
              };
            }
            legendAccumulator['chicago_red_light_cameras'].count += chicagoRedLightCamerasCount;
          }
        }
      } catch (error) {
        console.error('Error processing Chicago Red Light Camera Locations:', error);
      }

      // Draw NYC MapPLUTO Tax Lots as polygons on the map
      try {
        if (enrichments.nyc_mappluto_all && Array.isArray(enrichments.nyc_mappluto_all)) {
          let taxLotCount = 0;
          enrichments.nyc_mappluto_all.forEach((taxLot: any) => {
            if (taxLot.geometry && taxLot.geometry.rings) {
              try {
                const rings = taxLot.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC MapPLUTO tax lot polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = taxLot.isContaining;
                  const color = isContaining ? '#3b82f6' : '#60a5fa'; // Blue for tax lots
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const bbl = taxLot.bbl || taxLot.BBL || taxLot.bbl || null;
                  const address = taxLot.address || taxLot.Address || taxLot.ADDRESS || null;
                  const borough = taxLot.borough || taxLot.Borough || taxLot.BOROUGH || null;
                  const block = taxLot.block || taxLot.Block || taxLot.BLOCK || null;
                  const lot = taxLot.lot || taxLot.Lot || taxLot.LOT || null;
                  const ownerName = taxLot.ownerName || taxLot.OwnerName || taxLot.OWNERNAME || null;
                  const landUse = taxLot.landUse || taxLot.LandUse || taxLot.LANDUSE || null;
                  const yearBuilt = taxLot.yearBuilt || taxLot.YearBuilt || taxLot.YEARBUILT || null;
                  const bldgClass = taxLot.bldgClass || taxLot.BldgClass || taxLot.BLDGCLASS || null;
                  const lotArea = taxLot.lotArea || taxLot.LotArea || taxLot.LOTAREA || null;
                  const bldgArea = taxLot.bldgArea || taxLot.BldgArea || taxLot.BLDGAREA || null;
                  const numBldgs = taxLot.numBldgs || taxLot.NumBldgs || taxLot.NUMBLDGS || null;
                  const numFloors = taxLot.numFloors || taxLot.NumFloors || taxLot.NUMFLOORS || null;
                  const unitsRes = taxLot.unitsRes || taxLot.UnitsRes || taxLot.UNITSRES || null;
                  const unitsTotal = taxLot.unitsTotal || taxLot.UnitsTotal || taxLot.UNITSTOTAL || null;
                  const assessLand = taxLot.assessLand || taxLot.AssessLand || taxLot.ASSESSLAND || null;
                  const assessTot = taxLot.assessTot || taxLot.AssessTot || taxLot.ASSESSTOT || null;
                  const zoneDist1 = taxLot.zoneDist1 || taxLot.ZoneDist1 || taxLot.ZONEDIST1 || null;
                  const zipCode = taxLot.zipCode || taxLot.ZipCode || taxLot.ZIPCODE || null;
                  const distance = taxLot.distance_miles !== null && taxLot.distance_miles !== undefined ? taxLot.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🏢 Containing Tax Lot' : '🏢 Nearby Tax Lot'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${bbl ? `<div><strong>BBL:</strong> ${bbl}</div>` : ''}
                        ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                        ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                        ${block ? `<div><strong>Block:</strong> ${block}</div>` : ''}
                        ${lot ? `<div><strong>Lot:</strong> ${lot}</div>` : ''}
                        ${zipCode ? `<div><strong>Zip Code:</strong> ${zipCode}</div>` : ''}
                        ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                        ${landUse ? `<div><strong>Land Use:</strong> ${landUse}</div>` : ''}
                        ${yearBuilt ? `<div><strong>Year Built:</strong> ${yearBuilt}</div>` : ''}
                        ${bldgClass ? `<div><strong>Building Class:</strong> ${bldgClass}</div>` : ''}
                        ${lotArea !== null && lotArea !== undefined ? `<div><strong>Lot Area:</strong> ${lotArea.toLocaleString()} sq ft</div>` : ''}
                        ${bldgArea !== null && bldgArea !== undefined ? `<div><strong>Building Area:</strong> ${bldgArea.toLocaleString()} sq ft</div>` : ''}
                        ${numBldgs !== null && numBldgs !== undefined ? `<div><strong>Number of Buildings:</strong> ${numBldgs}</div>` : ''}
                        ${numFloors ? `<div><strong>Number of Floors:</strong> ${numFloors}</div>` : ''}
                        ${unitsRes !== null && unitsRes !== undefined ? `<div><strong>Residential Units:</strong> ${unitsRes}</div>` : ''}
                        ${unitsTotal !== null && unitsTotal !== undefined ? `<div><strong>Total Units:</strong> ${unitsTotal}</div>` : ''}
                        ${assessLand !== null && assessLand !== undefined ? `<div><strong>Assessed Land Value:</strong> $${assessLand.toLocaleString()}</div>` : ''}
                        ${assessTot !== null && assessTot !== undefined ? `<div><strong>Total Assessed Value:</strong> $${assessTot.toLocaleString()}</div>` : ''}
                        ${zoneDist1 ? `<div><strong>Zoning District:</strong> ${zoneDist1}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this tax lot</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all tax lot attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'bbl', 'BBL', 'bbl', 'address', 'Address', 'ADDRESS', 'borough', 'Borough', 'BOROUGH', 'block', 'Block', 'BLOCK', 'lot', 'Lot', 'LOT', 'zipCode', 'ZipCode', 'ZIPCODE', 'ownerName', 'OwnerName', 'OWNERNAME', 'landUse', 'LandUse', 'LANDUSE', 'yearBuilt', 'YearBuilt', 'YEARBUILT', 'bldgClass', 'BldgClass', 'BLDGCLASS', 'lotArea', 'LotArea', 'LOTAREA', 'bldgArea', 'BldgArea', 'BLDGAREA', 'numBldgs', 'NumBldgs', 'NUMBLDGS', 'numFloors', 'NumFloors', 'NUMFLOORS', 'unitsRes', 'UnitsRes', 'UNITSRES', 'unitsTotal', 'UnitsTotal', 'UNITSTOTAL', 'assessLand', 'AssessLand', 'ASSESSLAND', 'assessTot', 'AssessTot', 'ASSESSTOT', 'zoneDist1', 'ZoneDist1', 'ZONEDIST1', 'isContaining'];
                  Object.entries(taxLot).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  taxLotCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC MapPLUTO tax lot polygon:', error);
              }
            }
          });
          
          if (taxLotCount > 0) {
            if (!legendAccumulator['nyc_mappluto']) {
              legendAccumulator['nyc_mappluto'] = {
                icon: '🏢',
                color: '#3b82f6',
                title: 'NYC MapPLUTO Tax Lots',
                count: 0,
              };
            }
            legendAccumulator['nyc_mappluto'].count += taxLotCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC MapPLUTO Tax Lots:', error);
      }

      // Draw NYC MapPLUTO Commercial + Mixed Use Tax Lots as polygons on the map
      try {
        if (enrichments.nyc_mappluto_commercial_mixed_use_all && Array.isArray(enrichments.nyc_mappluto_commercial_mixed_use_all)) {
          let taxLotCount = 0;
          enrichments.nyc_mappluto_commercial_mixed_use_all.forEach((taxLot: any) => {
            if (taxLot.geometry && taxLot.geometry.rings) {
              try {
                const rings = taxLot.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC MapPLUTO Commercial + Mixed Use tax lot polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = taxLot.isContaining;
                  const color = isContaining ? '#10b981' : '#34d399'; // Green for commercial/mixed use lots
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const bbl = taxLot.bbl || taxLot.BBL || taxLot.bbl || null;
                  const address = taxLot.address || taxLot.Address || taxLot.ADDRESS || null;
                  const borough = taxLot.borough || taxLot.Borough || taxLot.BOROUGH || null;
                  const block = taxLot.block || taxLot.Block || taxLot.BLOCK || null;
                  const lot = taxLot.lot || taxLot.Lot || taxLot.LOT || null;
                  const ownerName = taxLot.ownerName || taxLot.OwnerName || taxLot.OWNERNAME || null;
                  const landUse = taxLot.landUse || taxLot.LandUse || taxLot.LANDUSE || null;
                  const yearBuilt = taxLot.yearBuilt || taxLot.YearBuilt || taxLot.YEARBUILT || null;
                  const bldgClass = taxLot.bldgClass || taxLot.BldgClass || taxLot.BLDGCLASS || null;
                  const lotArea = taxLot.lotArea || taxLot.LotArea || taxLot.LOTAREA || null;
                  const bldgArea = taxLot.bldgArea || taxLot.BldgArea || taxLot.BLDGAREA || null;
                  const numBldgs = taxLot.numBldgs || taxLot.NumBldgs || taxLot.NUMBLDGS || null;
                  const numFloors = taxLot.numFloors || taxLot.NumFloors || taxLot.NUMFLOORS || null;
                  const unitsRes = taxLot.unitsRes || taxLot.UnitsRes || taxLot.UNITSRES || null;
                  const unitsTotal = taxLot.unitsTotal || taxLot.UnitsTotal || taxLot.UNITSTOTAL || null;
                  const assessLand = taxLot.assessLand || taxLot.AssessLand || taxLot.ASSESSLAND || null;
                  const assessTot = taxLot.assessTot || taxLot.AssessTot || taxLot.ASSESSTOT || null;
                  const zoneDist1 = taxLot.zoneDist1 || taxLot.ZoneDist1 || taxLot.ZONEDIST1 || null;
                  const zipCode = taxLot.zipCode || taxLot.ZipCode || taxLot.ZIPCODE || null;
                  const distance = taxLot.distance_miles !== null && taxLot.distance_miles !== undefined ? taxLot.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🏪 Containing Commercial/Mixed Use Lot' : '🏪 Nearby Commercial/Mixed Use Lot'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${bbl ? `<div><strong>BBL:</strong> ${bbl}</div>` : ''}
                        ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                        ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                        ${block ? `<div><strong>Block:</strong> ${block}</div>` : ''}
                        ${lot ? `<div><strong>Lot:</strong> ${lot}</div>` : ''}
                        ${zipCode ? `<div><strong>Zip Code:</strong> ${zipCode}</div>` : ''}
                        ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                        ${landUse ? `<div><strong>Land Use:</strong> ${landUse} (Commercial/Mixed Use)</div>` : ''}
                        ${yearBuilt ? `<div><strong>Year Built:</strong> ${yearBuilt}</div>` : ''}
                        ${bldgClass ? `<div><strong>Building Class:</strong> ${bldgClass}</div>` : ''}
                        ${lotArea !== null && lotArea !== undefined ? `<div><strong>Lot Area:</strong> ${lotArea.toLocaleString()} sq ft</div>` : ''}
                        ${bldgArea !== null && bldgArea !== undefined ? `<div><strong>Building Area:</strong> ${bldgArea.toLocaleString()} sq ft</div>` : ''}
                        ${numBldgs !== null && numBldgs !== undefined ? `<div><strong>Number of Buildings:</strong> ${numBldgs}</div>` : ''}
                        ${numFloors ? `<div><strong>Number of Floors:</strong> ${numFloors}</div>` : ''}
                        ${unitsRes !== null && unitsRes !== undefined ? `<div><strong>Residential Units:</strong> ${unitsRes}</div>` : ''}
                        ${unitsTotal !== null && unitsTotal !== undefined ? `<div><strong>Total Units:</strong> ${unitsTotal}</div>` : ''}
                        ${assessLand !== null && assessLand !== undefined ? `<div><strong>Assessed Land Value:</strong> $${assessLand.toLocaleString()}</div>` : ''}
                        ${assessTot !== null && assessTot !== undefined ? `<div><strong>Total Assessed Value:</strong> $${assessTot.toLocaleString()}</div>` : ''}
                        ${zoneDist1 ? `<div><strong>Zoning District:</strong> ${zoneDist1}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this commercial/mixed use lot</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all tax lot attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'bbl', 'BBL', 'bbl', 'address', 'Address', 'ADDRESS', 'borough', 'Borough', 'BOROUGH', 'block', 'Block', 'BLOCK', 'lot', 'Lot', 'LOT', 'zipCode', 'ZipCode', 'ZIPCODE', 'ownerName', 'OwnerName', 'OWNERNAME', 'landUse', 'LandUse', 'LANDUSE', 'yearBuilt', 'YearBuilt', 'YEARBUILT', 'bldgClass', 'BldgClass', 'BLDGCLASS', 'lotArea', 'LotArea', 'LOTAREA', 'bldgArea', 'BldgArea', 'BLDGAREA', 'numBldgs', 'NumBldgs', 'NUMBLDGS', 'numFloors', 'NumFloors', 'NUMFLOORS', 'unitsRes', 'UnitsRes', 'UNITSRES', 'unitsTotal', 'UnitsTotal', 'UNITSTOTAL', 'assessLand', 'AssessLand', 'ASSESSLAND', 'assessTot', 'AssessTot', 'ASSESSTOT', 'zoneDist1', 'ZoneDist1', 'ZONEDIST1', 'isContaining'];
                  Object.entries(taxLot).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  taxLotCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC MapPLUTO Commercial + Mixed Use tax lot polygon:', error);
              }
            }
          });
          
          if (taxLotCount > 0) {
            if (!legendAccumulator['nyc_mappluto_commercial_mixed_use']) {
              legendAccumulator['nyc_mappluto_commercial_mixed_use'] = {
                icon: '🏪',
                color: '#10b981',
                title: 'NYC MapPLUTO Commercial + Mixed Use Lots',
                count: 0
              };
            }
            legendAccumulator['nyc_mappluto_commercial_mixed_use'].count += taxLotCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC MapPLUTO Commercial + Mixed Use Tax Lots:', error);
      }

      // Helper function to draw NYC MapPLUTO filtered layers
      const drawNYCMapPLUTOLayer = (enrichmentKey: string, layerId: string, title: string, color: string, icon: string) => {
        try {
          if (enrichments[enrichmentKey] && Array.isArray(enrichments[enrichmentKey])) {
            let taxLotCount = 0;
            enrichments[enrichmentKey].forEach((taxLot: any) => {
              if (taxLot.geometry && taxLot.geometry.rings) {
                try {
                  const rings = taxLot.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = taxLot.isContaining;
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: color,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.2
                    });
                    
                    const bbl = taxLot.bbl || taxLot.BBL || taxLot.bbl || null;
                    const address = taxLot.address || taxLot.Address || taxLot.ADDRESS || null;
                    const borough = taxLot.borough || taxLot.Borough || taxLot.BOROUGH || null;
                    const block = taxLot.block || taxLot.Block || taxLot.BLOCK || null;
                    const lot = taxLot.lot || taxLot.Lot || taxLot.LOT || null;
                    const ownerName = taxLot.ownerName || taxLot.OwnerName || taxLot.OWNERNAME || null;
                    const landUse = taxLot.landUse || taxLot.LandUse || taxLot.LANDUSE || null;
                    const yearBuilt = taxLot.yearBuilt || taxLot.YearBuilt || taxLot.YEARBUILT || null;
                    const bldgClass = taxLot.bldgClass || taxLot.BldgClass || taxLot.BLDGCLASS || null;
                    const distance = taxLot.distance_miles !== null && taxLot.distance_miles !== undefined ? taxLot.distance_miles : 0;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${isContaining ? `${icon} Containing ${title}` : `${icon} Nearby ${title}`}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${bbl ? `<div><strong>BBL:</strong> ${bbl}</div>` : ''}
                          ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                          ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                          ${block ? `<div><strong>Block:</strong> ${block}</div>` : ''}
                          ${lot ? `<div><strong>Lot:</strong> ${lot}</div>` : ''}
                          ${ownerName ? `<div><strong>Owner:</strong> ${ownerName}</div>` : ''}
                          ${landUse ? `<div><strong>Land Use:</strong> ${landUse}</div>` : ''}
                          ${yearBuilt ? `<div><strong>Year Built:</strong> ${yearBuilt}</div>` : ''}
                          ${bldgClass ? `<div><strong>Building Class:</strong> ${bldgClass}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this lot</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    
                    taxLotCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (taxLotCount > 0) {
              if (!legendAccumulator[layerId]) {
                legendAccumulator[layerId] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0
                };
              }
              legendAccumulator[layerId].count += taxLotCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      };

      // Draw all NYC MapPLUTO filtered commercial layers
      drawNYCMapPLUTOLayer('nyc_mappluto_retail_all', 'nyc_mappluto_retail', 'NYC MapPLUTO Retail', '#ef4444', '🛍️');
      drawNYCMapPLUTOLayer('nyc_mappluto_office_all', 'nyc_mappluto_office', 'NYC MapPLUTO Office', '#3b82f6', '🏢');
      drawNYCMapPLUTOLayer('nyc_mappluto_industrial_all', 'nyc_mappluto_industrial', 'NYC MapPLUTO Industrial / Manufacturing', '#f59e0b', '🏭');
      drawNYCMapPLUTOLayer('nyc_mappluto_warehouses_all', 'nyc_mappluto_warehouses', 'NYC MapPLUTO Warehouses', '#8b5cf6', '📦');
      drawNYCMapPLUTOLayer('nyc_mappluto_hotels_all', 'nyc_mappluto_hotels', 'NYC MapPLUTO Hotels / Hospitality', '#ec4899', '🏨');
      drawNYCMapPLUTOLayer('nyc_mappluto_auto_commercial_all', 'nyc_mappluto_auto_commercial', 'NYC MapPLUTO Auto-Related Commercial', '#14b8a6', '🚗');
      drawNYCMapPLUTOLayer('nyc_mappluto_large_commercial_all', 'nyc_mappluto_large_commercial', 'NYC MapPLUTO Large Commercial Footprint', '#6366f1', '🏬');
      drawNYCMapPLUTOLayer('nyc_mappluto_residential_all', 'nyc_mappluto_residential', 'NYC MapPLUTO Residential', '#22c55e', '🏠');

      // Draw Scotland Gritter Vehicle Locations as points on the map
      try {
        if (enrichments.scotland_transport_gritter_locations_all && Array.isArray(enrichments.scotland_transport_gritter_locations_all)) {
          let locationCount = 0;
          enrichments.scotland_transport_gritter_locations_all.forEach((location: any) => {
            if (location.geometry && typeof location.geometry.x === 'number' && typeof location.geometry.y === 'number') {
              try {
                const lat = location.geometry.y;
                const lon = location.geometry.x;
                const distance = location.distance_miles !== null && location.distance_miles !== undefined ? location.distance_miles : 0;
                
                const vehicleId = location.vehicleId || location.VehicleID || location.vehicle_id || null;
                const vehicleName = location.vehicleName || location.VehicleName || location.vehicle_name || null;
                const status = location.status || location.Status || location.STATUS || null;
                const lastUpdate = location.lastUpdate || location.LastUpdate || location.last_update || null;
                
                // Create custom icon matching legend (🚛 emoji with orange color #f59e0b)
                const isMobile = window.innerWidth < 768;
                const gritterIcon = createPOIIcon('🚛', '#f59e0b', isMobile);
                
                // Create marker with custom icon (matches legend symbol 🚛)
                const marker = L.marker([lat, lon], {
                  icon: gritterIcon
                });
                
                // Build popup content with all available information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚛 Gritter Vehicle Location
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${vehicleId ? `<div style="margin-bottom: 4px;"><strong>Vehicle ID:</strong> ${vehicleId}</div>` : ''}
                      ${vehicleName ? `<div style="margin-bottom: 4px;"><strong>Vehicle Name:</strong> ${vehicleName}</div>` : ''}
                      ${status ? `<div style="margin-bottom: 4px;"><strong>Status:</strong> ${status}</div>` : ''}
                      ${lastUpdate ? `<div style="margin-bottom: 4px;"><strong>Last Update:</strong> ${lastUpdate}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                // Bind popup and ensure it opens on click
                marker.bindPopup(popupContent, {
                  maxWidth: 400,
                  className: 'gritter-location-popup'
                });
                
                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });
                
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                locationCount++;
              } catch (error) {
                console.error('Error drawing Scotland Gritter Location marker:', error);
              }
            }
          });
          
          if (locationCount > 0) {
            if (!legendAccumulator['scotland_transport_gritter_locations']) {
              legendAccumulator['scotland_transport_gritter_locations'] = {
                icon: '🚛',
                color: '#f59e0b',
                title: 'Scotland Gritter Vehicle Locations',
                count: 0
              };
            }
            legendAccumulator['scotland_transport_gritter_locations'].count += locationCount;
          }
        }
      } catch (error) {
        console.error('Error processing Scotland Gritter Locations:', error);
      }

      // Draw Scotland Trunk Road Network Height as polylines on the map
      try {
        if (enrichments.scotland_transport_trunk_road_height_all && Array.isArray(enrichments.scotland_transport_trunk_road_height_all)) {
          console.log(`🛣️ Drawing ${enrichments.scotland_transport_trunk_road_height_all.length} trunk road height segment(s)`);
          let segmentCount = 0;
          enrichments.scotland_transport_trunk_road_height_all.forEach((segment: any, segmentIndex: number) => {
            console.log(`🛣️ Road segment data [Segment ${segmentIndex}]:`, {
              hasGeometry: !!segment.geometry,
              geometryType: segment.geometry?.type,
              geometryKeys: segment.geometry ? Object.keys(segment.geometry) : [],
              hasPaths: !!segment.geometry?.paths,
              pathsLength: segment.geometry?.paths?.length,
              hasRings: !!segment.geometry?.rings,
              hasCoordinates: !!segment.geometry?.coordinates,
              maxHeight: segment.maxHeight,
              meanHeight: segment.meanHeight
            });
            
            // Check for geometry in various formats
            let paths = null;
            if (segment.geometry) {
              if (segment.geometry.paths) {
                // ESRI polyline format with paths array
                paths = segment.geometry.paths;
              } else if (segment.geometry.coordinates) {
                // GeoJSON format
                paths = [segment.geometry.coordinates];
              } else if (segment.geometry.rings) {
                // Polygon rings (shouldn't happen for roads, but handle it)
                paths = segment.geometry.rings;
              } else if (segment.geometry.x !== undefined && segment.geometry.y !== undefined) {
                // Point geometry - this shouldn't happen for roads, but if it does, skip it
                console.warn(`🛣️ Road segment ${segmentIndex} has point geometry instead of polyline - skipping.`);
                return; // Skip point geometry for roads
              }
            }
            
            if (paths && Array.isArray(paths) && paths.length > 0) {
              try {
                console.log(`🛣️ Processing ${paths.length} path(s) for road segment`);
                // Process each path in the polyline (roads can have multiple paths)
                paths.forEach((path: number[][], pathIndex: number) => {
                  try {
                    console.log(`🛣️ Path ${pathIndex}: ${path.length} coordinates, first coord:`, path[0]);
                    
                    if (!path || !Array.isArray(path) || path.length === 0) {
                      console.warn(`🛣️ Path ${pathIndex} is empty or invalid`);
                      return;
                    }
                    
                    const latlngs = path.map((coord: number[], coordIndex: number) => {
                      // ESRI coordinates: [x, y] where x is longitude, y is latitude (after outSR=4326)
                      // Leaflet expects [lat, lon]
                      if (!coord || !Array.isArray(coord)) {
                        console.warn(`🛣️ Coordinate ${coordIndex} in path ${pathIndex} is invalid:`, coord);
                        return null;
                      }
                      if (coord.length >= 2) {
                        const lat = coord[1];
                        const lon = coord[0];
                        if (typeof lat === 'number' && typeof lon === 'number' && !isNaN(lat) && !isNaN(lon)) {
                          return [lat, lon] as [number, number];
                        } else {
                          console.warn(`🛣️ Coordinate ${coordIndex} has invalid numbers:`, { lat, lon });
                        }
                      }
                      return null;
                    }).filter((coord): coord is [number, number] => coord !== null);
                    
                    console.log(`🛣️ Path ${pathIndex}: Converted ${latlngs.length} valid coordinates from ${path.length} total`);
                    
                    if (latlngs.length < 2) {
                      console.warn('🛣️ Road segment polyline has less than 2 coordinates, skipping');
                      return;
                    }
                    
                    const distance = segment.distance_miles !== null && segment.distance_miles !== undefined ? segment.distance_miles : 0;
                    const maxHeight = segment.maxHeight !== null && segment.maxHeight !== undefined ? segment.maxHeight : null;
                    const minHeight = segment.minHeight !== null && segment.minHeight !== undefined ? segment.minHeight : null;
                    const meanHeight = segment.meanHeight !== null && segment.meanHeight !== undefined ? segment.meanHeight : null;
                    const meanHeightGrouped = segment.meanHeightGrouped || segment.MEAN_H_G || null;
                    const maxHeightGrouped = segment.maxHeightGrouped || segment.MAX_H_G || null;
                    const shapeLength = segment.shapeLength || segment.Shape__Length || null;
                    
                    // Draw polyline (matches legend color #f59e0b for Scotland Transport)
                    const polyline = L.polyline(latlngs, {
                      color: '#f59e0b',
                      weight: 3,
                      opacity: 0.7
                    });
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ Trunk Road Network Height
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${maxHeight !== null ? `<div><strong>Max Height:</strong> ${maxHeight} m</div>` : ''}
                          ${minHeight !== null ? `<div><strong>Min Height:</strong> ${minHeight} m</div>` : ''}
                          ${meanHeight !== null ? `<div><strong>Mean Height:</strong> ${meanHeight} m</div>` : ''}
                          ${meanHeightGrouped ? `<div><strong>Mean Height Grouped:</strong> ${meanHeightGrouped}</div>` : ''}
                          ${maxHeightGrouped ? `<div><strong>Max Height Grouped:</strong> ${maxHeightGrouped}</div>` : ''}
                          ${shapeLength !== null ? `<div><strong>Segment Length:</strong> ${shapeLength.toLocaleString(undefined, { maximumFractionDigits: 2 })} m</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent, {
                      maxWidth: 400,
                      className: 'trunk-road-height-popup'
                    });
                    
                    // Enable popup to open on click
                    polyline.on('click', function(this: L.Polyline) {
                      this.openPopup();
                    });
                    
                    polyline.addTo(primary);
                    
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                    
                    segmentCount++;
                  } catch (error) {
                    console.error('Error drawing Scotland Trunk Road Height path:', error);
                  }
                });
              } catch (error) {
                console.error('Error processing Scotland Trunk Road Height paths:', error);
              }
            }
          });
          
          if (segmentCount > 0) {
            if (!legendAccumulator['scotland_transport_trunk_road_height']) {
              legendAccumulator['scotland_transport_trunk_road_height'] = {
                icon: '🛣️',
                color: '#f59e0b',
                title: 'Scotland Trunk Road Network Height',
                count: 0
              };
            }
            legendAccumulator['scotland_transport_trunk_road_height'].count += segmentCount;
          }
        }
      } catch (error) {
        console.error('Error processing Scotland Trunk Road Height:', error);
      }

      // Draw Miami Business Locations (FD Inspected) as points on the map
      try {
        if (enrichments.miami_business_fd_inspected_all && Array.isArray(enrichments.miami_business_fd_inspected_all)) {
          let businessCount = 0;
          enrichments.miami_business_fd_inspected_all.forEach((business: any) => {
            if (business.geometry && typeof business.geometry.x === 'number' && typeof business.geometry.y === 'number') {
              // Use objectId as primary key, fallback to coordinates - check across ALL results
              const businessId = business.objectId ? String(business.objectId) : `${business.geometry.x.toFixed(6)}_${business.geometry.y.toFixed(6)}`;
              if (drawnBusinessIds.has(businessId)) {
                return; // Skip - already drawn from a previous result
              }
              drawnBusinessIds.add(businessId);
              
              try {
                const lat = business.geometry.y;
                const lon = business.geometry.x;
                const distance = business.distance_miles !== null && business.distance_miles !== undefined ? business.distance_miles : 0;
                
                const businessName = business.businessName || business.BusinessNa || business.business_name || null;
                const businessAddress = business.businessAddress || business.BusinessAd || business.business_address || null;
                const city = business.city || business.City || null;
                const zipCode = business.zipCode || business.ZipCode || business.zip_code || null;
                const activity = business.activity || business.ACTIVITY || null;
                const fireZone90 = business.fireZone90 || business.FireZone90 || business.fire_zone_90 || null;
                const squareFoot = business.squareFoot !== null && business.squareFoot !== undefined ? business.squareFoot : null;
                
                // Create custom icon matching legend (🏢 emoji with blue color)
                const isMobile = window.innerWidth < 768;
                const businessIcon = createPOIIcon('🏢', '#3b82f6', isMobile);
                
                // Create marker with custom icon
                const marker = L.marker([lat, lon], {
                  icon: businessIcon
                });
                
                // Build popup content with all available information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏢 Business Location (FD Inspected)
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${businessName ? `<div style="margin-bottom: 4px;"><strong>Business Name:</strong> ${businessName}</div>` : ''}
                      ${businessAddress ? `<div style="margin-bottom: 4px;"><strong>Address:</strong> ${businessAddress}</div>` : ''}
                      ${city ? `<div style="margin-bottom: 4px;"><strong>City:</strong> ${city}</div>` : ''}
                      ${zipCode ? `<div style="margin-bottom: 4px;"><strong>Zip Code:</strong> ${zipCode}</div>` : ''}
                      ${activity ? `<div style="margin-bottom: 4px;"><strong>Activity:</strong> ${activity}</div>` : ''}
                      ${fireZone90 ? `<div style="margin-bottom: 4px;"><strong>Fire Zone:</strong> ${fireZone90}</div>` : ''}
                      ${squareFoot !== null && squareFoot !== 0 ? `<div style="margin-bottom: 4px;"><strong>Square Feet:</strong> ${squareFoot.toLocaleString()}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                
                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });
                
                marker.addTo(poi);
                businessCount++;
              } catch (error: any) {
                console.error('Error processing Miami Business FD Inspected point:', error);
              }
            }
          });
          
          // Accumulate total unique businesses drawn across all results
          totalBusinessCount += businessCount;
        }
      } catch (error) {
        console.error('Error processing Miami Business FD Inspected:', error);
      }

      // Draw Miami Public Schools as points on the map
      try {
        if (enrichments.miami_public_schools_all && Array.isArray(enrichments.miami_public_schools_all)) {
          let schoolCount = 0;
          enrichments.miami_public_schools_all.forEach((school: any) => {
            if (school.geometry && typeof school.geometry.x === 'number' && typeof school.geometry.y === 'number') {
              // Use objectId as primary key, fallback to coordinates - check across ALL results
              const schoolId = school.objectId ? String(school.objectId) : `${school.geometry.x.toFixed(6)}_${school.geometry.y.toFixed(6)}`;
              if (drawnPublicSchoolIds.has(schoolId)) {
                return; // Skip - already drawn from a previous result
              }
              drawnPublicSchoolIds.add(schoolId);
              
              try {
                const lat = school.geometry.y;
                const lon = school.geometry.x;
                const distance = school.distance_miles !== null && school.distance_miles !== undefined ? school.distance_miles : 0;
                
                const name = school.name || school.NAME || school.Name || null;
                const address = school.address || school.ADDRESS || school.Address || null;
                const city = school.city || school.CITY || school.City || null;
                const zipCode = school.zipCode || school.ZIPCODE || school.zip_code || null;
                const phone = school.phone || school.PHONE || school.Phone || null;
                const type = school.type || school.TYPE || school.Type || null;
                const grades = school.grades || school.GRADES || school.Grades || null;
                const capacity = school.capacity !== null && school.capacity !== undefined ? school.capacity : null;
                const enrollment = school.enrollment !== null && school.enrollment !== undefined ? school.enrollment : null;
                const region = school.region || school.REGION || school.Region || null;
                
                // Create custom icon matching legend (🎓 emoji with purple/blue color)
                const isMobile = window.innerWidth < 768;
                const schoolIcon = createPOIIcon('🎓', '#8b5cf6', isMobile);
                
                // Create marker with custom icon
                const marker = L.marker([lat, lon], {
                  icon: schoolIcon
                });
                
                // Build popup content with all available information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎓 ${name || 'Public School'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div style="margin-bottom: 4px;"><strong>Address:</strong> ${address}${city ? `, ${city}` : ''}${zipCode ? ` ${zipCode}` : ''}</div>` : ''}
                      ${phone ? `<div style="margin-bottom: 4px;"><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${type ? `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${type}</div>` : ''}
                      ${grades ? `<div style="margin-bottom: 4px;"><strong>Grades:</strong> ${grades}</div>` : ''}
                      ${capacity !== null && capacity !== 0 ? `<div style="margin-bottom: 4px;"><strong>Capacity:</strong> ${capacity.toLocaleString()}</div>` : ''}
                      ${enrollment !== null && enrollment !== 0 ? `<div style="margin-bottom: 4px;"><strong>Enrollment:</strong> ${enrollment.toLocaleString()}</div>` : ''}
                      ${region ? `<div style="margin-bottom: 4px;"><strong>Region:</strong> ${region}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                
                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });
                
                marker.addTo(poi);
                schoolCount++;
              } catch (error: any) {
                console.error('Error processing Miami Public School point:', error);
              }
            }
          });
          
          // Accumulate total unique schools drawn across all results
          totalPublicSchoolCount += schoolCount;
        }
      } catch (error) {
        console.error('Error processing Miami Public Schools:', error);
      }

      // Draw Miami Private Schools as points on the map
      try {
        if (enrichments.miami_private_schools_all && Array.isArray(enrichments.miami_private_schools_all)) {
          let schoolCount = 0;
          enrichments.miami_private_schools_all.forEach((school: any) => {
            if (school.geometry && typeof school.geometry.x === 'number' && typeof school.geometry.y === 'number') {
              // Use objectId as primary key, fallback to coordinates - check across ALL results
              const schoolId = school.objectId ? String(school.objectId) : `${school.geometry.x.toFixed(6)}_${school.geometry.y.toFixed(6)}`;
              if (drawnPrivateSchoolIds.has(schoolId)) {
                return; // Skip - already drawn from a previous result
              }
              drawnPrivateSchoolIds.add(schoolId);
              
              try {
                const lat = school.geometry.y;
                const lon = school.geometry.x;
                const distance = school.distance_miles !== null && school.distance_miles !== undefined ? school.distance_miles : 0;
                
                const name = school.name || school.NAME || school.Name || null;
                const address = school.address || school.ADDRESS || school.Address || null;
                const city = school.city || school.CITY || school.City || null;
                const zipCode = school.zipCode || school.ZIPCODE || school.zip_code || null;
                const phone = school.phone || school.PHONE || school.Phone || null;
                const type = school.type || school.TYPE || school.Type || null;
                const gradeLevel = school.gradeLevel || school.GRDLEVEL || school.Grades || null;
                const enrollment = school.enrollment !== null && school.enrollment !== undefined ? school.enrollment : null;
                const status = school.status || school.STATUS || school.Status || null;
                const website = school.website || school.WEBSITE || school.Website || null;
                const directorName = school.directorName || school.DIRCTNAME || school.DirectorName || null;
                const yearEstablished = school.yearEstablished || school.YEARESTB || school.YearEstablished || null;
                
                // Create custom icon matching legend (🏫 emoji with different color to distinguish from public schools)
                const isMobile = window.innerWidth < 768;
                const schoolIcon = createPOIIcon('🏫', '#a855f7', isMobile);
                
                // Create marker with custom icon
                const marker = L.marker([lat, lon], {
                  icon: schoolIcon
                });
                
                // Build popup content with all available information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏫 ${name || 'Private School'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div style="margin-bottom: 4px;"><strong>Address:</strong> ${address}${city ? `, ${city}` : ''}${zipCode ? ` ${zipCode}` : ''}</div>` : ''}
                      ${phone ? `<div style="margin-bottom: 4px;"><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${website ? `<div style="margin-bottom: 4px;"><strong>Website:</strong> <a href="${website}" target="_blank" rel="noopener noreferrer" style="color: #3b82f6; text-decoration: underline;">${website}</a></div>` : ''}
                      ${type ? `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${type}</div>` : ''}
                      ${gradeLevel ? `<div style="margin-bottom: 4px;"><strong>Grade Level:</strong> ${gradeLevel}</div>` : ''}
                      ${enrollment !== null && enrollment !== 0 ? `<div style="margin-bottom: 4px;"><strong>Enrollment:</strong> ${enrollment.toLocaleString()}</div>` : ''}
                      ${status ? `<div style="margin-bottom: 4px;"><strong>Status:</strong> ${status}</div>` : ''}
                      ${directorName ? `<div style="margin-bottom: 4px;"><strong>Director:</strong> ${directorName}</div>` : ''}
                      ${yearEstablished ? `<div style="margin-bottom: 4px;"><strong>Year Established:</strong> ${yearEstablished}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                
                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });
                
                marker.addTo(poi);
                schoolCount++;
              } catch (error: any) {
                console.error('Error processing Miami Private School point:', error);
              }
            }
          });
          
          // Accumulate total unique schools drawn across all results
          totalPrivateSchoolCount += schoolCount;
        }
      } catch (error) {
        console.error('Error processing Miami Private Schools:', error);
      }

      // Draw FLDOT Real-Time Traffic points on the map
      try {
        if (enrichments.fldot_real_time_traffic_all && Array.isArray(enrichments.fldot_real_time_traffic_all)) {
          enrichments.fldot_real_time_traffic_all.forEach((point: any) => {
            // Deduplicate: use cosite as unique identifier (already deduplicated in adapter, but check across all results)
            const trafficId = point.cosite ? String(point.cosite) :
              (point.latitude && point.longitude) ?
              `${point.latitude.toFixed(6)}_${point.longitude.toFixed(6)}` :
              point.objectId ? String(point.objectId) : null;
            
            if (trafficId && drawnTrafficIds.has(trafficId)) {
              return; // Skip - already drawn
            }
            if (trafficId) drawnTrafficIds.add(trafficId);
            
            const lat = point.latitude || point.lat || (point.geometry && point.geometry.y);
            const lon = point.longitude || point.lon || (point.geometry && point.geometry.x);
            
            if (lat && lon) {
              try {
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚦', '#ef4444', isMobile)
                });
                
                const localName = point.localName || point.LOCALNAM || '';
                const countyName = point.countyName || point.COUNTYNM || '';
                const direction = point.direction || point.DIRECTION || '';
                const currentVolume = point.currentVolume !== null && point.currentVolume !== undefined ? point.currentVolume : point.CURVOL;
                const averageVolume = point.averageVolume !== null && point.averageVolume !== undefined ? point.averageVolume : point.HAVGVOL;
                const percentDiffText = point.percentDiffText || point.PCTDIFTX || '';
                const currentAvgSpeed = point.currentAvgSpeed !== null && point.currentAvgSpeed !== undefined ? point.currentAvgSpeed : point.CURAVSPD;
                const maxSpeedRight = point.maxSpeedRight !== null && point.maxSpeedRight !== undefined ? point.maxSpeedRight : point.MAXSPEEDR;
                const speedPercentDiff = point.speedPercentDiff !== null && point.speedPercentDiff !== undefined ? point.speedPercentDiff : point.SPPCTDF;
                const labelValue = point.labelValue || point.LBLVAL || '';
                const dateTimeString = point.dateTimeString || point.DTSTR || '';
                const dateTimeStamp2 = point.dateTimeStamp2 || point.DTSTMP2 || '';
                const distance = point.distance_miles !== null && point.distance_miles !== undefined ? point.distance_miles : 0;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚦 Real-Time Traffic
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${localName ? `<div style="margin-bottom: 4px;"><strong>Road:</strong> ${localName}</div>` : ''}
                      ${countyName ? `<div style="margin-bottom: 4px;"><strong>County:</strong> ${countyName}</div>` : ''}
                      ${direction ? `<div style="margin-bottom: 4px;"><strong>Direction:</strong> ${direction}</div>` : ''}
                      ${currentVolume !== null && currentVolume !== undefined ? `<div style="margin-bottom: 4px;"><strong>Current Volume:</strong> ${currentVolume.toLocaleString()}</div>` : ''}
                      ${averageVolume !== null && averageVolume !== undefined ? `<div style="margin-bottom: 4px;"><strong>Average Volume:</strong> ${averageVolume.toLocaleString()}</div>` : ''}
                      ${percentDiffText ? `<div style="margin-bottom: 4px;"><strong>Volume Change:</strong> ${percentDiffText}</div>` : ''}
                      ${currentAvgSpeed !== null && currentAvgSpeed !== undefined ? `<div style="margin-bottom: 4px;"><strong>Current Avg Speed:</strong> ${currentAvgSpeed.toFixed(1)} mph</div>` : ''}
                      ${maxSpeedRight !== null && maxSpeedRight !== undefined ? `<div style="margin-bottom: 4px;"><strong>Speed Limit:</strong> ${maxSpeedRight} mph</div>` : ''}
                      ${speedPercentDiff !== null && speedPercentDiff !== undefined ? `<div style="margin-bottom: 4px;"><strong>Speed Change:</strong> ${speedPercentDiff > 0 ? '+' : ''}${speedPercentDiff}%</div>` : ''}
                      ${labelValue ? `<div style="margin-bottom: 4px;"><strong>Status:</strong> ${labelValue}</div>` : ''}
                      ${dateTimeStamp2 ? `<div style="margin-bottom: 4px;"><strong>Date/Time:</strong> ${dateTimeStamp2}</div>` : dateTimeString ? `<div style="margin-bottom: 4px;"><strong>Date/Time:</strong> ${dateTimeString}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                
                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });
                
                marker.addTo(poi);
                bounds.extend([lat, lon]);
                totalTrafficPointCount++;
              } catch (error: any) {
                console.error('Error processing FLDOT Real-Time Traffic point:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Real-Time Traffic:', error);
      }

      // Draw FLDOT Facilities points on the map
      try {
        if (enrichments.fldot_facilities_all && Array.isArray(enrichments.fldot_facilities_all)) {
          enrichments.fldot_facilities_all.forEach((facility: any) => {
            // Deduplicate: use FID as unique identifier
            const facilityId = facility.fid !== null && facility.fid !== undefined ? String(facility.fid) :
              (facility.lat && facility.lon) ?
              `${facility.lat.toFixed(6)}_${facility.lon.toFixed(6)}` : null;

            if (facilityId && drawnTrafficIds.has(facilityId)) {
              return; // Skip - already drawn
            }
            if (facilityId) drawnTrafficIds.add(facilityId);

            const lat = facility.lat || (facility.geometry && facility.geometry.y);
            const lon = facility.lon || (facility.geometry && facility.geometry.x);

            if (lat && lon) {
              try {
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🏢', '#10b981', isMobile)
                });

                const facName = facility.facName || facility.Fac_Name || facility.FAC_NAME || '';
                const facType = facility.facType || facility.Fac_Type || facility.FAC_TYPE || '';
                const city = facility.city || facility.City || facility.CITY || '';
                const county = facility.county || facility.County || facility.COUNTY || '';
                const district = facility.district || facility.District || facility.DISTRICT || '';
                const phone = facility.phone || facility.Phone || facility.PHONE || '';
                const longAddress = facility.longAddress || facility.Long_Addre || facility.LONG_ADDRE || '';
                const zipCode = facility.zipCode || facility.ZipCode || facility.ZIPCODE || '';
                const distance = facility.distance_miles !== null && facility.distance_miles !== undefined ? facility.distance_miles : 0;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏢 FDOT Facility
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${facName ? `<div style="margin-bottom: 4px;"><strong>Name:</strong> ${facName}</div>` : ''}
                      ${facType ? `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${facType}</div>` : ''}
                      ${district ? `<div style="margin-bottom: 4px;"><strong>District:</strong> ${district}</div>` : ''}
                      ${longAddress ? `<div style="margin-bottom: 4px;"><strong>Address:</strong> ${longAddress}</div>` : ''}
                      ${city ? `<div style="margin-bottom: 4px;"><strong>City:</strong> ${city}${county ? `, ${county} County` : ''}${zipCode ? ` ${zipCode}` : ''}</div>` : ''}
                      ${phone ? `<div style="margin-bottom: 4px;"><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 400 });

                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });

                marker.addTo(poi);
                bounds.extend([lat, lon]);
                totalFacilityPointCount++;
              } catch (error: any) {
                console.error('Error processing FLDOT Facility point:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Facilities:', error);
      }

      // Draw FLDOT Railroad Crossings points on the map
      try {
        if (enrichments.fldot_railroad_crossings_all && Array.isArray(enrichments.fldot_railroad_crossings_all)) {
          enrichments.fldot_railroad_crossings_all.forEach((crossing: any) => {
            // Deduplicate: use crossing number as unique identifier
            const crossingId = crossing.crossingNumber ? String(crossing.crossingNumber) :
              (crossing.fid !== null && crossing.fid !== undefined) ? String(crossing.fid) :
              (crossing.lat && crossing.lon) ?
              `${crossing.lat.toFixed(6)}_${crossing.lon.toFixed(6)}` : null;

            if (crossingId && drawnTrafficIds.has(crossingId)) {
              return; // Skip - already drawn
            }
            if (crossingId) drawnTrafficIds.add(crossingId);

            const lat = crossing.lat || (crossing.geometry && crossing.geometry.y);
            const lon = crossing.lon || (crossing.geometry && crossing.geometry.x);

            if (lat && lon) {
              try {
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚂', '#f59e0b', isMobile)
                });

                const roadway = crossing.roadway || crossing.ROADWAY || '';
                const crossingNumber = crossing.crossingNumber || crossing.CROSSING_N || '';
                const checkDigit = crossing.checkDigit || crossing.CHECK_DIGI || '';
                const county = crossing.county || crossing.COUNTY || '';
                const district = crossing.district !== null && crossing.district !== undefined ? crossing.district : null;
                const beginPost = crossing.beginPost !== null && crossing.beginPost !== undefined ? crossing.beginPost : null;
                const distance = crossing.distance_miles !== null && crossing.distance_miles !== undefined ? crossing.distance_miles : 0;

                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚂 FLDOT Railroad Crossing
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${crossingNumber ? `<div style="margin-bottom: 4px;"><strong>Crossing Number:</strong> ${crossingNumber}</div>` : ''}
                      ${checkDigit ? `<div style="margin-bottom: 4px;"><strong>Check Digit:</strong> ${checkDigit}</div>` : ''}
                      ${roadway ? `<div style="margin-bottom: 4px;"><strong>Roadway:</strong> ${roadway}</div>` : ''}
                      ${county ? `<div style="margin-bottom: 4px;"><strong>County:</strong> ${county}</div>` : ''}
                      ${district !== null ? `<div style="margin-bottom: 4px;"><strong>District:</strong> ${district}</div>` : ''}
                      ${beginPost !== null ? `<div style="margin-bottom: 4px;"><strong>Mile Post:</strong> ${beginPost.toFixed(3)}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 400 });

                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });

                marker.addTo(poi);
                bounds.extend([lat, lon]);
                totalRailroadCrossingCount++;
              } catch (error: any) {
                console.error('Error processing FLDOT Railroad Crossing point:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Railroad Crossings:', error);
      }

      // Draw FLDOT Bike Slots as polylines on the map
      try {
        if (enrichments.fldot_bike_slots_all && Array.isArray(enrichments.fldot_bike_slots_all)) {
          enrichments.fldot_bike_slots_all.forEach((slot: any) => {
            if (slot.geometry && slot.geometry.paths) {
              try {
                const paths = slot.geometry.paths;
                if (paths && Array.isArray(paths) && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && Array.isArray(path) && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });

                      if (latlngs.length < 2) {
                        return; // Skip paths with less than 2 points
                      }

                      const polyline = L.polyline(latlngs, {
                        color: '#8b5cf6',
                        weight: 3,
                        opacity: 0.7
                      });

                      const roadway = slot.roadway || slot.ROADWAY || '';
                      const roadSide = slot.roadSide || slot.ROAD_SIDE || '';
                      const county = slot.county || slot.COUNTY || '';
                      const district = slot.district !== null && slot.district !== undefined ? slot.district : null;
                      const description = slot.description || slot.DESCR || '';
                      const beginPost = slot.beginPost !== null && slot.beginPost !== undefined ? slot.beginPost : null;
                      const endPost = slot.endPost !== null && slot.endPost !== undefined ? slot.endPost : null;
                      const shapeLength = slot.shapeLength !== null && slot.shapeLength !== undefined ? slot.shapeLength : null;
                      const lncd = slot.lncd !== null && slot.lncd !== undefined ? slot.lncd : null;
                      const distance = slot.distance_miles !== null && slot.distance_miles !== undefined ? slot.distance_miles : 0;

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🚴 FLDOT Bike Slot
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${roadway ? `<div style="margin-bottom: 4px;"><strong>Roadway:</strong> ${roadway}</div>` : ''}
                            ${roadSide ? `<div style="margin-bottom: 4px;"><strong>Road Side:</strong> ${roadSide}</div>` : ''}
                            ${county ? `<div style="margin-bottom: 4px;"><strong>County:</strong> ${county}</div>` : ''}
                            ${district !== null ? `<div style="margin-bottom: 4px;"><strong>District:</strong> ${district}</div>` : ''}
                            ${description ? `<div style="margin-bottom: 4px;"><strong>Description:</strong> ${description}</div>` : ''}
                            ${lncd !== null ? `<div style="margin-bottom: 4px;"><strong>Lane Code:</strong> ${lncd}</div>` : ''}
                            ${beginPost !== null && endPost !== null ? `<div style="margin-bottom: 4px;"><strong>Mile Post:</strong> ${beginPost.toFixed(3)} - ${endPost.toFixed(3)}</div>` : ''}
                            ${shapeLength !== null ? `<div style="margin-bottom: 4px;"><strong>Length:</strong> ${shapeLength.toFixed(2)} meters</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                        </div>
                      `;

                      polyline.bindPopup(popupContent, { maxWidth: 400 });

                      polyline.on('click', function(this: L.Polyline) {
                        this.openPopup();
                      });

                      polyline.addTo(poi);
                      
                      // Extend bounds to include all points in the polyline
                      latlngs.forEach((latlng: [number, number]) => {
                        bounds.extend(latlng);
                      });
                      
                      totalBikeSlotCount++;
                    }
                  });
                }
              } catch (error: any) {
                console.error('Error processing FLDOT Bike Slot polyline:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Bike Slots:', error);
      }

      // Draw FLDOT Bike Lanes as polylines on the map
      try {
        if (enrichments.fldot_bike_lanes_all && Array.isArray(enrichments.fldot_bike_lanes_all)) {
          enrichments.fldot_bike_lanes_all.forEach((lane: any) => {
            if (lane.geometry && lane.geometry.paths) {
              try {
                const paths = lane.geometry.paths;
                if (paths && Array.isArray(paths) && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && Array.isArray(path) && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });

                      if (latlngs.length < 2) {
                        return; // Skip paths with less than 2 points
                      }

                      const polyline = L.polyline(latlngs, {
                        color: '#3b82f6',
                        weight: 3,
                        opacity: 0.7
                      });

                      const roadway = lane.roadway || lane.ROADWAY || '';
                      const roadSide = lane.roadSide || lane.ROAD_SIDE || '';
                      const county = lane.county || lane.COUNTY || '';
                      const district = lane.district !== null && lane.district !== undefined ? lane.district : null;
                      const description = lane.description || lane.DESCR || '';
                      const beginPost = lane.beginPost !== null && lane.beginPost !== undefined ? lane.beginPost : null;
                      const endPost = lane.endPost !== null && lane.endPost !== undefined ? lane.endPost : null;
                      const shapeLength = lane.shapeLength !== null && lane.shapeLength !== undefined ? lane.shapeLength : null;
                      const lncd = lane.lncd !== null && lane.lncd !== undefined ? lane.lncd : null;
                      const distance = lane.distance_miles !== null && lane.distance_miles !== undefined ? lane.distance_miles : 0;

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🚴 FLDOT Bike Lane
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${roadway ? `<div style="margin-bottom: 4px;"><strong>Roadway:</strong> ${roadway}</div>` : ''}
                            ${roadSide ? `<div style="margin-bottom: 4px;"><strong>Road Side:</strong> ${roadSide}</div>` : ''}
                            ${county ? `<div style="margin-bottom: 4px;"><strong>County:</strong> ${county}</div>` : ''}
                            ${district !== null ? `<div style="margin-bottom: 4px;"><strong>District:</strong> ${district}</div>` : ''}
                            ${description ? `<div style="margin-bottom: 4px;"><strong>Description:</strong> ${description}</div>` : ''}
                            ${lncd !== null ? `<div style="margin-bottom: 4px;"><strong>Lane Code:</strong> ${lncd}</div>` : ''}
                            ${beginPost !== null && endPost !== null ? `<div style="margin-bottom: 4px;"><strong>Mile Post:</strong> ${beginPost.toFixed(3)} - ${endPost.toFixed(3)}</div>` : ''}
                            ${shapeLength !== null ? `<div style="margin-bottom: 4px;"><strong>Length:</strong> ${shapeLength.toFixed(2)} meters</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                        </div>
                      `;

                      polyline.bindPopup(popupContent, { maxWidth: 400 });

                      polyline.on('click', function(this: L.Polyline) {
                        this.openPopup();
                      });

                      polyline.addTo(poi);
                      
                      // Extend bounds to include all points in the polyline
                      latlngs.forEach((latlng: [number, number]) => {
                        bounds.extend(latlng);
                      });
                      
                      totalBikeLaneCount++;
                    }
                  });
                }
              } catch (error: any) {
                console.error('Error processing FLDOT Bike Lane polyline:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Bike Lanes:', error);
      }

      // Draw FLDOT Number of Lanes as polylines on the map
      try {
        if (enrichments.fldot_number_of_lanes_all && Array.isArray(enrichments.fldot_number_of_lanes_all)) {
          enrichments.fldot_number_of_lanes_all.forEach((lane: any) => {
            // Check for polyline geometry (paths) - adapter already handles deduplication by FID
            if (lane.geometry && lane.geometry.paths) {
              try {
                const paths = lane.geometry.paths;
                if (paths && Array.isArray(paths) && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && Array.isArray(path) && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      if (latlngs.length < 2) {
                        return; // Skip paths with less than 2 points
                      }
                      
                      // Use different colors based on lane count
                      // Get lane count from attributes first, then fallback to parsed field
                      const laneCount = (lane.attributes && lane.attributes.LANE_CNT !== null && lane.attributes.LANE_CNT !== undefined) ? Number(lane.attributes.LANE_CNT) :
                                       (lane.laneCount !== null && lane.laneCount !== undefined) ? lane.laneCount : 0;
                      let lineColor = '#6366f1'; // Default: indigo for unknown/0
                      if (laneCount === 1) lineColor = '#ef4444'; // Red for 1 lane
                      else if (laneCount === 2) lineColor = '#f59e0b'; // Amber for 2 lanes
                      else if (laneCount === 3) lineColor = '#10b981'; // Green for 3 lanes
                      else if (laneCount === 4) lineColor = '#3b82f6'; // Blue for 4 lanes
                      else if (laneCount >= 5) lineColor = '#8b5cf6'; // Purple for 5+ lanes
                      
                      const polyline = L.polyline(latlngs, {
                        color: lineColor,
                        weight: 4,
                        opacity: 0.8
                      });
                      
                      // Get all attributes from the service - prioritize attributes object, fallback to lane object
                      const allAttributes = lane.attributes || lane;
                      const distance = lane.distance_miles !== null && lane.distance_miles !== undefined ? lane.distance_miles : 0;

                      // Build popup with ALL attributes from the service
                      let popupContent = `
                        <div style="min-width: 300px; max-width: 500px; max-height: 600px; overflow-y: auto;">
                          <h3 style="margin: 0 0 12px 0; color: #1f2937; font-weight: 600; font-size: 14px; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px;">
                            🛣️ FLDOT Number of Lanes
                          </h3>
                          <div style="font-size: 12px; color: #6b7280;">
                      `;

                      // Iterate through all attributes and display them
                      const excludeKeys = ['geometry', 'distance_miles', 'lat', 'lon', 'attributes'];
                      const attributeKeys = Object.keys(allAttributes).filter(key => 
                        !excludeKeys.includes(key) && 
                        allAttributes[key] !== null && 
                        allAttributes[key] !== undefined &&
                        allAttributes[key] !== ''
                      );

                      // Sort attributes - put important ones first
                      const importantKeys = ['LANE_CNT', 'laneCount', 'ROADWAY', 'roadway', 'ROAD_SIDE', 'roadSide', 'COUNTY', 'county', 'DISTRICT', 'district', 'BEGIN_POST', 'beginPost', 'END_POST', 'endPost', 'Shape_Leng', 'Shape__Length', 'shapeLength'];
                      const sortedKeys = [
                        ...importantKeys.filter(key => attributeKeys.includes(key)),
                        ...attributeKeys.filter(key => !importantKeys.includes(key))
                      ];

                      sortedKeys.forEach(key => {
                        const value = allAttributes[key];
                        let displayValue = value;
                        let displayKey = key;

                        // Format the key name for display
                        displayKey = key.replace(/_/g, ' ').replace(/([A-Z])/g, ' $1').trim();
                        displayKey = displayKey.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');

                        // Format the value
                        if (typeof value === 'number') {
                          if (key.includes('POST') || key.includes('Post')) {
                            displayValue = value.toFixed(3);
                          } else if (key.includes('Leng') || key.includes('Length') || key.includes('length')) {
                            displayValue = value.toFixed(2) + ' meters';
                          } else {
                            displayValue = value.toString();
                          }
                        } else if (typeof value === 'boolean') {
                          displayValue = value ? 'Yes' : 'No';
                        } else {
                          displayValue = String(value);
                        }

                        popupContent += `<div style="margin-bottom: 6px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      });

                      if (distance > 0) {
                        popupContent += `<div style="margin-top: 12px; padding-top: 12px; border-top: 2px solid #e5e7eb; color: #374151; font-weight: 600;"><strong>Distance from location:</strong> ${distance.toFixed(2)} miles</div>`;
                      }

                      popupContent += `
                          </div>
                        </div>
                      `;

                      polyline.bindPopup(popupContent, { maxWidth: 500, maxHeight: 600 });

                      polyline.on('click', function(this: L.Polyline) {
                        this.openPopup();
                      });

                      polyline.addTo(poi);
                      
                      // Extend bounds to include all points in the polyline
                      latlngs.forEach((latlng: [number, number]) => {
                        bounds.extend(latlng);
                      });
                      
                      // Track lane count for legend
                      if (laneCount !== null && laneCount !== undefined) {
                        laneCountStats[laneCount] = (laneCountStats[laneCount] || 0) + 1;
                      } else {
                        laneCountStats[0] = (laneCountStats[0] || 0) + 1; // Unknown
                      }
                      
                      totalNumberOfLanesCount++;
                    }
                  });
                } else {
                  console.warn('FLDOT Number of Lanes: geometry.paths is empty or invalid', lane);
                }
              } catch (error: any) {
                console.error('Error processing FLDOT Number of Lanes polyline:', error, lane);
              }
            } else {
              console.warn('FLDOT Number of Lanes: No geometry.paths found, skipping', lane);
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Number of Lanes:', error);
      }

      // Draw FLDOT Functional Classification as polylines on the map
      try {
        if (enrichments.fldot_functional_classification_all && Array.isArray(enrichments.fldot_functional_classification_all)) {
          enrichments.fldot_functional_classification_all.forEach((feature: any) => {
            // Check for polyline geometry (paths)
            if (feature.geometry && feature.geometry.paths) {
              try {
                const paths = feature.geometry.paths;
                if (paths && Array.isArray(paths) && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && Array.isArray(path) && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });

                      if (latlngs.length < 2) {
                        return; // Skip paths with less than 2 points
                      }

                      // Use different colors based on functional class
                      // FUNCLASS codes: 01-19 (Federal Functional Classification System)
                      const funclass = feature.funclass || feature.FUNCLASS || '';
                      let lineColor = '#6366f1'; // Default: indigo
                      
                      // Color code by FUNCLASS ranges
                      const funclassNum = parseInt(funclass);
                      if (funclassNum >= 1 && funclassNum <= 7) {
                        lineColor = '#ef4444'; // Red for Principal Arterial (01-07)
                      } else if (funclassNum >= 8 && funclassNum <= 12) {
                        lineColor = '#f59e0b'; // Amber for Minor Arterial (08-12)
                      } else if (funclassNum >= 13 && funclassNum <= 16) {
                        lineColor = '#10b981'; // Green for Collector (13-16)
                      } else if (funclassNum >= 17 && funclassNum <= 19) {
                        lineColor = '#3b82f6'; // Blue for Local (17-19)
                      }

                      const polyline = L.polyline(latlngs, {
                        color: lineColor,
                        weight: 3,
                        opacity: 0.7
                      });

                      const roadway = feature.roadway || feature.ROADWAY || 'Unknown';
                      const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;

                      // Get all attributes from the service
                      const allAttributes = feature.attributes || feature;
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🛣️ FLDOT Functional Classification
                          </h3>
                          <div style="font-size: 12px; color: #6b7280;">
                      `;

                      // Iterate through all attributes and display them
                      const excludeKeys = ['geometry', 'distance_miles', 'lat', 'lon', 'attributes'];
                      const attributeKeys = Object.keys(allAttributes).filter(key =>
                        !excludeKeys.includes(key) &&
                        allAttributes[key] !== null &&
                        allAttributes[key] !== undefined &&
                        allAttributes[key] !== ''
                      );

                      // Sort attributes - put important ones first
                      const importantKeys = ['FUNCLASS', 'funclass', 'ROADWAY', 'roadway', 'COUNTY', 'county', 'DISTRICT', 'district', 'COUNTYDOT', 'countydot', 'MNG_DIST', 'mngDist', 'BEGIN_POST', 'beginPost', 'END_POST', 'endPost', 'Shape_Leng', 'Shape__Length', 'shapeLength'];
                      const sortedKeys = [
                        ...importantKeys.filter(key => attributeKeys.includes(key)),
                        ...attributeKeys.filter(key => !importantKeys.includes(key))
                      ];

                      sortedKeys.forEach(key => {
                        const value = allAttributes[key];
                        let displayValue = value;
                        let displayKey = key;

                        // Format the key name for display
                        displayKey = key.replace(/_/g, ' ').replace(/([A-Z])/g, ' $1').trim();
                        displayKey = displayKey.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');

                        // Format the value
                        if (typeof value === 'number') {
                          if (key.toLowerCase().includes('length') || key.toLowerCase().includes('leng')) {
                            displayValue = `${value.toLocaleString()} m`;
                          } else {
                            displayValue = value.toLocaleString();
                          }
                        } else {
                          displayValue = String(value);
                        }

                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      });

                      if (distance > 0) {
                        popupContent += `<div style="margin-top: 8px; margin-bottom: 4px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>`;
                      }

                      popupContent += `
                          </div>
                        </div>
                      `;

                      popupContent = addMappingLinksToPopup(popupContent, feature.lat, feature.lon, roadway || 'Functional Classification Roadway');
                      polyline.bindPopup(popupContent, { maxWidth: 400 });

                      polyline.on('click', function(this: L.Polyline) {
                        this.openPopup();
                      });

                      polyline.addTo(poi);

                      // Extend bounds to include all points in the polyline
                      latlngs.forEach((latlng: [number, number]) => {
                        bounds.extend(latlng);
                      });

                      // Track functional class for legend
                      const funclassKey = funclass || 'Unknown';
                      funclassStats[funclassKey] = (funclassStats[funclassKey] || 0) + 1;

                      totalFunctionalClassificationCount++;
                    }
                  });
                } else {
                  console.warn('FLDOT Functional Classification: geometry.paths is empty or invalid', feature);
                }
              } catch (error: any) {
                console.error('Error processing FLDOT Functional Classification polyline:', error, feature);
              }
            } else {
              console.warn('FLDOT Functional Classification: No geometry.paths found, skipping', feature);
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Functional Classification:', error);
      }

      // Draw FLDOT Rest Areas & Welcome Centers points on the map
      try {
        if (enrichments.fldot_rest_areas_all && Array.isArray(enrichments.fldot_rest_areas_all)) {
          enrichments.fldot_rest_areas_all.forEach((restArea: any) => {
            // Deduplicate: use FID as unique identifier
            const restAreaId = (restArea.fid !== null && restArea.fid !== undefined) ? String(restArea.fid) :
              (restArea.lat && restArea.lon) ?
              `${restArea.lat.toFixed(6)}_${restArea.lon.toFixed(6)}` : null;

            if (restAreaId && drawnTrafficIds.has(restAreaId)) {
              return; // Skip - already drawn
            }
            if (restAreaId) drawnTrafficIds.add(restAreaId);

            const lat = restArea.lat || (restArea.geometry && restArea.geometry.y);
            const lon = restArea.lon || (restArea.geometry && restArea.geometry.x);

            if (lat && lon) {
              try {
                // Choose icon based on type
                let iconEmoji = '🚻'; // Default: restroom icon
                let iconColor = '#3b82f6'; // Default: blue
                const type = restArea.type || restArea.TYPE_ || '';
                if (type === 'RSTAREAS') {
                  iconEmoji = '🛑'; // Rest stop icon
                  iconColor = '#10b981'; // Green
                } else if (type === 'RSTARFAC') {
                  iconEmoji = '🏢'; // Building icon
                  iconColor = '#10b981'; // Green
                } else if (type === 'WAYSDPKS') {
                  iconEmoji = '🌳'; // Park icon
                  iconColor = '#16a34a'; // Darker green
                } else if (type === 'WEIGHSTA') {
                  iconEmoji = '⚖️'; // Scale/weigh station icon
                  iconColor = '#f59e0b'; // Amber
                } else if (type === 'WELCMSTA') {
                  iconEmoji = '🏛️'; // Welcome center icon
                  iconColor = '#6366f1'; // Indigo
                }
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon(iconEmoji, iconColor, isMobile)
                });

                const distance = restArea.distance_miles !== null && restArea.distance_miles !== undefined ? restArea.distance_miles : 0;

                // Get all attributes from the service - prioritize attributes object, fallback to restArea object
                const allAttributes = restArea.attributes || restArea;
                
                let typeLabel = type;
                if (type === 'RSTAREAS') typeLabel = 'Rest Areas';
                else if (type === 'RSTARFAC') typeLabel = 'Rest Area Facilities';
                else if (type === 'WAYSDPKS') typeLabel = 'Wayside Parks';
                else if (type === 'WEIGHSTA') typeLabel = 'Weigh Stations';
                else if (type === 'WELCMSTA') typeLabel = 'Welcome Stations';

                // Build popup with ALL attributes from the service
                let popupContent = `
                  <div style="min-width: 300px; max-width: 500px; max-height: 600px; overflow-y: auto;">
                    <h3 style="margin: 0 0 12px 0; color: #1f2937; font-weight: 600; font-size: 14px; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px;">
                      ${iconEmoji} FLDOT ${typeLabel || 'Rest Area/Welcome Center'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280;">
                `;

                // Iterate through all attributes and display them
                const excludeKeys = ['geometry', 'distance_miles', 'lat', 'lon', 'attributes'];
                const attributeKeys = Object.keys(allAttributes).filter(key => 
                  !excludeKeys.includes(key) && 
                  allAttributes[key] !== null && 
                  allAttributes[key] !== undefined &&
                  allAttributes[key] !== ''
                );

                // Sort attributes - put important ones first
                const importantKeys = ['TYPE_', 'type', 'ROADWAY', 'roadway', 'DIR', 'direction', 'COUNTY', 'county', 'DISTRICT', 'district', 'BEGIN_POST', 'beginPost', 'NUM_FAC', 'numFacilities', 'MNG_DIST', 'managementDistrict', 'COUNTYDOT', 'countyDot'];
                const sortedKeys = [
                  ...importantKeys.filter(key => attributeKeys.includes(key)),
                  ...attributeKeys.filter(key => !importantKeys.includes(key))
                ];

                sortedKeys.forEach(key => {
                  const value = allAttributes[key];
                  let displayValue = value;
                  let displayKey = key;

                  // Format the key name for display
                  displayKey = key.replace(/_/g, ' ').replace(/([A-Z])/g, ' $1').trim();
                  displayKey = displayKey.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');

                  // Format the value
                  if (typeof value === 'number') {
                    if (key.includes('POST') || key.includes('Post')) {
                      displayValue = value.toFixed(3);
                    } else {
                      displayValue = value.toString();
                    }
                  } else if (typeof value === 'boolean') {
                    displayValue = value ? 'Yes' : 'No';
                  } else {
                    displayValue = String(value);
                  }

                  popupContent += `<div style="margin-bottom: 6px; padding: 4px 0; border-bottom: 1px solid #f3f4f6;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                });

                if (distance > 0) {
                  popupContent += `<div style="margin-top: 12px; padding-top: 12px; border-top: 2px solid #e5e7eb; color: #374151; font-weight: 600;"><strong>Distance from location:</strong> ${distance.toFixed(2)} miles</div>`;
                }

                popupContent += `
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 500, maxHeight: 600 });

                // Enable popup to open on click
                marker.on('click', function(this: L.Marker) {
                  this.openPopup();
                });

                marker.addTo(poi);
                bounds.extend([lat, lon]);
                totalRestAreaCount++;
              } catch (error: any) {
                console.error('Error processing FLDOT Rest Area point:', error);
              }
            }
          });
        }
      } catch (error) {
        console.error('Error processing FLDOT Rest Areas:', error);
      }

      // Draw FLDOT Bike Routes as polylines on the map
      try {
        if (enrichments.fldot_bike_routes_all && Array.isArray(enrichments.fldot_bike_routes_all)) {
          let routeCount = 0;
          enrichments.fldot_bike_routes_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                const paths = route.geometry.paths;
                if (paths && Array.isArray(paths) && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    if (path && Array.isArray(path) && path.length > 0) {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      if (latlngs.length < 2) {
                        return; // Skip paths with less than 2 points
                      }
                      
                      const polyline = L.polyline(latlngs, {
                        color: '#10b981',
                        weight: 4,
                        opacity: 0.8
                      });
                      
                      const routeName = route.route || route.ROUTE || 'Unknown Route';
                      const routeNum = route.routeNum !== null && route.routeNum !== undefined ? route.routeNum : route.ROUTENUM || null;
                      const status = route.status || route.STATUS || null;
                      const ftype = route.ftype || route.FTYPE || null;
                      const fname = route.fname || route.FNAME || null;
                      const comments = route.comments || route.COMMENTS || null;
                      const cntyname = route.cntyname || route.CNTYNAME || null;
                      const fdotdist = route.fdotdist || route.FDOTDIST || null;
                      const shapeLength = route.shapeLength !== null && route.shapeLength !== undefined ? route.shapeLength : route.Shape_Leng || null;
                      const distance = route.distance_miles !== null && route.distance_miles !== undefined ? route.distance_miles : 0;
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🚴 FLDOT Bike Route
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${routeName ? `<div style="margin-bottom: 4px;"><strong>Route:</strong> ${routeName}</div>` : ''}
                            ${routeNum !== null ? `<div style="margin-bottom: 4px;"><strong>Route Number:</strong> ${routeNum}</div>` : ''}
                            ${status ? `<div style="margin-bottom: 4px;"><strong>Status:</strong> ${status}</div>` : ''}
                            ${ftype ? `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${ftype}</div>` : ''}
                            ${fname ? `<div style="margin-bottom: 4px;"><strong>Name:</strong> ${fname}</div>` : ''}
                            ${comments ? `<div style="margin-bottom: 4px;"><strong>Comments:</strong> ${comments}</div>` : ''}
                            ${cntyname ? `<div style="margin-bottom: 4px;"><strong>County:</strong> ${cntyname}</div>` : ''}
                            ${fdotdist ? `<div style="margin-bottom: 4px;"><strong>FDOT District:</strong> ${fdotdist}</div>` : ''}
                            ${shapeLength !== null ? `<div style="margin-bottom: 4px;"><strong>Length:</strong> ${shapeLength.toFixed(2)} miles</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent, { maxWidth: 400 });
                      
                      // Enable popup to open on click
                      polyline.on('click', function(this: L.Polyline) {
                        this.openPopup();
                      });
                      
                      polyline.addTo(primary);
                      
                      const polylineBounds = L.latLngBounds(latlngs);
                      bounds.extend(polylineBounds);
                    }
                  });
                  
                  routeCount++;
                }
              } catch (error: any) {
                console.error('Error processing FLDOT Bike Route polyline:', error);
              }
            }
          });
          
          // Accumulate total unique routes drawn across all results
          totalBikeRouteCount += routeCount;
        }
      } catch (error) {
        console.error('Error processing FLDOT Bike Routes:', error);
      }

      // Draw Miami Water Bodies as polygons on the map
      try {
        if (enrichments.miami_water_bodies_all && Array.isArray(enrichments.miami_water_bodies_all)) {
          let waterBodyCount = 0;
          enrichments.miami_water_bodies_all.forEach((waterBody: any) => {
            if (waterBody.geometry && waterBody.geometry.rings) {
              try {
                const rings = waterBody.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Miami Water Body polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = waterBody.isContaining;
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: '#0ea5e9',
                    weight: weight,
                    opacity: opacity,
                    fillColor: '#0ea5e9',
                    fillOpacity: 0.2
                  });
                  
                  const type = waterBody.type || waterBody.TYPE || waterBody.Type || null;
                  const shapeArea = waterBody.shapeArea !== null && waterBody.shapeArea !== undefined ? waterBody.shapeArea : null;
                  const shapeLength = waterBody.shapeLength !== null && waterBody.shapeLength !== undefined ? waterBody.shapeLength : null;
                  const lastUpdate = waterBody.lastUpdate || waterBody.LAST_UPDAT || waterBody.LastUpdate || null;
                  const distance = waterBody.distance_miles !== null && waterBody.distance_miles !== undefined ? waterBody.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        💧 ${isContaining ? 'Containing Water Body' : 'Nearby Water Body'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${type ? `<div style="margin-bottom: 4px;"><strong>Type:</strong> ${type}</div>` : ''}
                        ${shapeArea !== null ? `<div style="margin-bottom: 4px;"><strong>Area:</strong> ${shapeArea.toLocaleString(undefined, { maximumFractionDigits: 2 })} sq units</div>` : ''}
                        ${shapeLength !== null ? `<div style="margin-bottom: 4px;"><strong>Perimeter:</strong> ${shapeLength.toLocaleString(undefined, { maximumFractionDigits: 2 })} units</div>` : ''}
                        ${lastUpdate ? `<div style="margin-bottom: 4px;"><strong>Last Update:</strong> ${lastUpdate}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this water body</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  
                  // Enable popup to open on click
                  polygon.on('click', function(this: L.Polygon) {
                    this.openPopup();
                  });
                  
                  polygon.addTo(primary);
                  
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  waterBodyCount++;
                }
              } catch (error: any) {
                console.error('Error processing Miami Water Body polygon:', error);
              }
            }
          });
          
          if (waterBodyCount > 0) {
            if (!legendAccumulator['miami_water_bodies']) {
              legendAccumulator['miami_water_bodies'] = {
                icon: '💧',
                color: '#0ea5e9',
                title: 'Miami Water Bodies',
                count: 0
              };
            }
            legendAccumulator['miami_water_bodies'].count += waterBodyCount;
          }
        }
      } catch (error) {
        console.error('Error processing Miami Water Bodies:', error);
      }

      // Draw NYC Bike Routes as polylines on the map
      try {
        if (enrichments.nyc_bike_routes_all && Array.isArray(enrichments.nyc_bike_routes_all)) {
          let bikeRouteCount = 0;
          enrichments.nyc_bike_routes_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                const paths = route.geometry.paths;
                if (paths && paths.length > 0) {
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 2) {
                      return;
                    }
                    
                    const polyline = L.polyline(latlngs, {
                      color: '#10b981',
                      weight: 3,
                      opacity: 0.8
                    });
                    
                    const routeName = route.name || route.NAME || route.Name || 'Unknown Route';
                    const routeType = route.routeType || route.ROUTE_TYPE || route.route_type || route.TYPE || route.type || '';
                    const status = route.status || route.STATUS || route.Status || '';
                    const distance = route.distance_miles !== null && route.distance_miles !== undefined ? route.distance_miles.toFixed(2) : '';
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚴 Bike Route
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${routeName ? `<div><strong>Name:</strong> ${routeName}</div>` : ''}
                          ${routeType ? `<div><strong>Route Type:</strong> ${routeType}</div>` : ''}
                          ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                          ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all route attributes (excluding internal fields)
                    const excludeFields = ['geometry', 'distance_miles', 'routeId', 'ROUTE_ID', 'route_id', 'OBJECTID', 'objectid', 'name', 'NAME', 'Name', 'routeType', 'ROUTE_TYPE', 'route_type', 'TYPE', 'type', 'status', 'STATUS', 'Status'];
                    Object.entries(route).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                    
                    bikeRouteCount++;
                  });
                }
              } catch (error) {
                console.error('Error drawing NYC Bike Route polyline:', error);
              }
            }
          });
          
          if (bikeRouteCount > 0) {
            if (!legendAccumulator['nyc_bike_routes']) {
              legendAccumulator['nyc_bike_routes'] = {
                icon: '🚴',
                color: '#10b981',
                title: 'NYC Bike Routes',
                count: 0,
              };
            }
            legendAccumulator['nyc_bike_routes'].count += bikeRouteCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Bike Routes:', error);
      }

      // Draw NYC Neighborhoods as polygons on the map
      try {
        if (enrichments.nyc_neighborhoods_all && Array.isArray(enrichments.nyc_neighborhoods_all)) {
          let neighborhoodCount = 0;
          enrichments.nyc_neighborhoods_all.forEach((neighborhood: any) => {
            if (neighborhood.geometry && neighborhood.geometry.rings) {
              try {
                const rings = neighborhood.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC Neighborhood polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = neighborhood.isContaining;
                  const color = isContaining ? '#06b6d4' : '#67e8f9'; // Cyan for neighborhoods
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const ntaCode = neighborhood.ntaCode || neighborhood.NTACode || neighborhood.NTA_CODE || neighborhood.nta_code || null;
                  const ntaName = neighborhood.ntaName || neighborhood.NTAName || neighborhood.NTA_NAME || neighborhood.nta_name || neighborhood.Name || neighborhood.name || null;
                  const borough = neighborhood.borough || neighborhood.Borough || neighborhood.BOROUGH || null;
                  const distance = neighborhood.distance_miles !== null && neighborhood.distance_miles !== undefined ? neighborhood.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🏘️ Containing Neighborhood' : '🏘️ Nearby Neighborhood'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${ntaName ? `<div><strong>Neighborhood:</strong> ${ntaName}</div>` : ''}
                        ${ntaCode ? `<div><strong>NTA Code:</strong> ${ntaCode}</div>` : ''}
                        ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this neighborhood</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all neighborhood attributes (excluding internal fields)
                  const excludeFields = ['neighborhoodId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'ntaCode', 'NTACode', 'NTA_CODE', 'nta_code', 'ntaName', 'NTAName', 'NTA_NAME', 'nta_name', 'Name', 'name', 'borough', 'Borough', 'BOROUGH', 'isContaining'];
                  Object.entries(neighborhood).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  neighborhoodCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC Neighborhood polygon:', error);
              }
            }
          });
          
          if (neighborhoodCount > 0) {
            if (!legendAccumulator['nyc_neighborhoods']) {
              legendAccumulator['nyc_neighborhoods'] = {
                icon: '🏘️',
                color: '#06b6d4',
                title: 'NYC Neighborhoods',
                count: 0,
              };
            }
            legendAccumulator['nyc_neighborhoods'].count += neighborhoodCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Neighborhoods:', error);
      }

      // Draw NYC Zoning Districts as polygons on the map
      try {
        if (enrichments.nyc_zoning_districts_all && Array.isArray(enrichments.nyc_zoning_districts_all)) {
          let districtCount = 0;
          enrichments.nyc_zoning_districts_all.forEach((district: any) => {
            if (district.geometry && district.geometry.rings) {
              try {
                const rings = district.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC Zoning District polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = district.isContaining;
                  const color = isContaining ? '#8b5cf6' : '#a78bfa'; // Purple for zoning
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const zoneDistrict = district.zoneDistrict || district.ZONEDIST || district.zonedist || null;
                  const zoneSubdistrict = district.zoneSubdistrict || district.ZONESUBDIST || district.zonesubdist || null;
                  const distance = district.distance_miles !== null && district.distance_miles !== undefined ? district.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🏛️ Containing Zoning District' : '🏛️ Nearby Zoning District'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${zoneDistrict ? `<div><strong>Zone District:</strong> ${zoneDistrict}</div>` : ''}
                        ${zoneSubdistrict ? `<div><strong>Zone Subdistrict:</strong> ${zoneSubdistrict}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this zoning district</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all district attributes (excluding internal fields)
                  const excludeFields = ['districtId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'zoneDistrict', 'ZONEDIST', 'zonedist', 'ZoneDist', 'ZONE_DIST', 'zoneSubdistrict', 'ZONESUBDIST', 'zonesubdist', 'ZoneSubdist', 'ZONE_SUBDIST', 'isContaining'];
                  Object.entries(district).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  // Store metadata for tabbed popup
                  (polygon as any).__layerType = 'nyc_zoning_districts';
                  (polygon as any).__layerTitle = 'NYC Zoning Districts';
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  districtCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC Zoning District polygon:', error);
              }
            }
          });
          
          if (districtCount > 0) {
            if (!legendAccumulator['nyc_zoning_districts']) {
              legendAccumulator['nyc_zoning_districts'] = {
                icon: '🏛️',
                color: '#8b5cf6',
                title: 'NYC Zoning Districts',
                count: 0,
              };
            }
            legendAccumulator['nyc_zoning_districts'].count += districtCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Zoning Districts:', error);
      }

      // Draw NYC Waterfront Access - HPB Launch Site as points on the map
      try {
        if (enrichments.nyc_waterfront_hpb_launch_site_all && Array.isArray(enrichments.nyc_waterfront_hpb_launch_site_all)) {
          let launchSiteCount = 0;
          enrichments.nyc_waterfront_hpb_launch_site_all.forEach((site: any) => {
            if (site.geometry && site.geometry.x !== undefined && site.geometry.y !== undefined) {
              try {
                const lat = site.geometry.y;
                const lon = site.geometry.x;
                const name = site.name || site.NAME || site.Name || site.SITE_NAME || site.site_name || 'Unknown Launch Site';
                const type = site.type || site.TYPE || site.Type || null;
                const distance = site.distance_miles !== null && site.distance_miles !== undefined ? site.distance_miles.toFixed(2) : '';
                
                const icon = createPOIIcon('🚤', '#0891b2'); // Teal for waterfront
                const marker = L.marker([lat, lon], { icon });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚤 HPB Launch Site
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all site attributes (excluding internal fields)
                const excludeFields = ['featureId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME', 'Name', 'SITE_NAME', 'site_name', 'type', 'TYPE', 'Type', 'layerId', 'isContaining'];
                Object.entries(site).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (marker as any).__layerType = 'nyc_waterfront_hpb_launch_site';
                (marker as any).__layerTitle = 'NYC HPB Launch Site';
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                
                launchSiteCount++;
              } catch (error) {
                console.error('Error drawing NYC HPB Launch Site marker:', error);
              }
            }
          });
          
          if (launchSiteCount > 0) {
            if (!legendAccumulator['nyc_waterfront_hpb_launch_site']) {
              legendAccumulator['nyc_waterfront_hpb_launch_site'] = {
                icon: '🚤',
                color: '#0891b2',
                title: 'NYC HPB Launch Site',
                count: 0,
              };
            }
            legendAccumulator['nyc_waterfront_hpb_launch_site'].count += launchSiteCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC HPB Launch Site:', error);
      }

      // Draw NYC Waterfront Access - Waterfront Parks as polygons on the map
      try {
        if (enrichments.nyc_waterfront_parks_all && Array.isArray(enrichments.nyc_waterfront_parks_all)) {
          let parkCount = 0;
          enrichments.nyc_waterfront_parks_all.forEach((park: any) => {
            if (park.geometry && park.geometry.rings) {
              try {
                const rings = park.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC Waterfront Park polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = park.isContaining;
                  const color = isContaining ? '#10b981' : '#34d399'; // Green for parks
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const name = park.name || park.NAME || park.Name || park.PARK_NAME || park.park_name || 'Unknown Park';
                  const type = park.type || park.TYPE || park.Type || null;
                  const distance = park.distance_miles !== null && park.distance_miles !== undefined ? park.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🌳 Containing Waterfront Park' : '🌳 Nearby Waterfront Park'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                        ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this park</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all park attributes (excluding internal fields)
                  const excludeFields = ['featureId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME', 'Name', 'PARK_NAME', 'park_name', 'type', 'TYPE', 'Type', 'layerId', 'isContaining'];
                  Object.entries(park).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  // Store metadata for tabbed popup
                  (polygon as any).__layerType = 'nyc_waterfront_parks';
                  (polygon as any).__layerTitle = 'NYC Waterfront Parks';
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  parkCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC Waterfront Park polygon:', error);
              }
            }
          });
          
          if (parkCount > 0) {
            if (!legendAccumulator['nyc_waterfront_parks']) {
              legendAccumulator['nyc_waterfront_parks'] = {
                icon: '🌳',
                color: '#10b981',
                title: 'NYC Waterfront Parks',
                count: 0,
              };
            }
            legendAccumulator['nyc_waterfront_parks'].count += parkCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Waterfront Parks:', error);
      }

      // Draw NYC Waterfront Access - PAWS as polygons on the map
      try {
        if (enrichments.nyc_waterfront_paws_all && Array.isArray(enrichments.nyc_waterfront_paws_all)) {
          let pawsCount = 0;
          enrichments.nyc_waterfront_paws_all.forEach((paws: any) => {
            if (paws.geometry && paws.geometry.rings) {
              try {
                const rings = paws.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('NYC PAWS polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = paws.isContaining;
                  const color = isContaining ? '#06b6d4' : '#22d3ee'; // Cyan for PAWS
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const name = paws.name || paws.NAME || paws.Name || paws.SITE_NAME || paws.site_name || 'Unknown PAWS';
                  const type = paws.type || paws.TYPE || paws.Type || null;
                  const distance = paws.distance_miles !== null && paws.distance_miles !== undefined ? paws.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${isContaining ? '🌊 Containing PAWS' : '🌊 Nearby PAWS'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                        ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this PAWS</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all PAWS attributes (excluding internal fields)
                  const excludeFields = ['featureId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME', 'Name', 'SITE_NAME', 'site_name', 'type', 'TYPE', 'Type', 'layerId', 'isContaining'];
                  Object.entries(paws).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  // Store metadata for tabbed popup
                  (polygon as any).__layerType = 'nyc_waterfront_paws';
                  (polygon as any).__layerTitle = 'NYC PAWS Publicly Accessible Waterfront Spaces';
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  pawsCount++;
                }
              } catch (error) {
                console.error('Error drawing NYC PAWS polygon:', error);
              }
            }
          });
          
          if (pawsCount > 0) {
            if (!legendAccumulator['nyc_waterfront_paws']) {
              legendAccumulator['nyc_waterfront_paws'] = {
                icon: '🌊',
                color: '#06b6d4',
                title: 'NYC PAWS Publicly Accessible Waterfront Spaces',
                count: 0,
              };
            }
            legendAccumulator['nyc_waterfront_paws'].count += pawsCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC PAWS:', error);
      }

      // Draw NYC Business Improvement Districts as polygons on the map
      try {
        if (enrichments.nyc_business_improvement_districts_all && Array.isArray(enrichments.nyc_business_improvement_districts_all)) {
          let bidCount = 0;
          enrichments.nyc_business_improvement_districts_all.forEach((bid: any) => {
            // Check if geometry is available (could be GeoJSON polygon)
            if (bid.geometry && (bid.geometry.type === 'Polygon' || bid.geometry.type === 'MultiPolygon')) {
              try {
                let latlngs: [number, number][] = [];
                
                // Extract coordinates from GeoJSON geometry
                if (bid.geometry.type === 'Polygon' && bid.geometry.coordinates && bid.geometry.coordinates[0]) {
                  latlngs = bid.geometry.coordinates[0].map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number]; // GeoJSON is [lon, lat], Leaflet needs [lat, lon]
                  });
                } else if (bid.geometry.type === 'MultiPolygon' && bid.geometry.coordinates && bid.geometry.coordinates[0] && bid.geometry.coordinates[0][0]) {
                  latlngs = bid.geometry.coordinates[0][0].map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                }
                
                if (latlngs.length < 3) {
                  console.warn('NYC Business Improvement District polygon has less than 3 coordinates, skipping');
                  return;
                }
                
                const isContaining = bid.isContaining;
                const color = isContaining ? '#f59e0b' : '#fbbf24'; // Amber for BIDs
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const name = bid.name || bid.bid_name || bid.bidName || bid.BID_NAME || bid.NAME || bid.Name || 'Unknown BID';
                const borough = bid.borough || bid.Borough || bid.BOROUGH || null;
                const distance = bid.distance_miles !== null && bid.distance_miles !== undefined ? bid.distance_miles : 0;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏢 Containing Business Improvement District' : '🏢 Nearby Business Improvement District'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                      ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                      ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this BID</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all BID attributes (excluding internal fields)
                const excludeFields = ['districtId', 'bid_id', 'bidId', 'BID_ID', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'bid_name', 'bidName', 'BID_NAME', 'NAME', 'Name', 'borough', 'Borough', 'BOROUGH', 'isContaining', '__calculatedDistance'];
                Object.entries(bid).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value) && key !== 'the_geom') {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (polygon as any).__layerType = 'nyc_business_improvement_districts';
                (polygon as any).__layerTitle = 'NYC Business Improvement Districts';
                (polygon as any).__popupContent = popupContent;
                polygon.addTo(primary);
                
                // Extend bounds to include polygon
                const polygonBounds = L.latLngBounds(latlngs);
                bounds.extend(polygonBounds);
                
                bidCount++;
              } catch (error) {
                console.error('Error drawing NYC Business Improvement District polygon:', error);
              }
            } else if (bid.latitude && bid.longitude) {
              // Fallback: if no polygon geometry, render as point marker
              try {
                const lat = bid.latitude;
                const lon = bid.longitude;
                const name = bid.name || bid.bid_name || bid.bidName || bid.BID_NAME || bid.NAME || bid.Name || 'Unknown BID';
                const borough = bid.borough || bid.Borough || bid.BOROUGH || null;
                const distance = bid.distance_miles !== null && bid.distance_miles !== undefined ? bid.distance_miles.toFixed(2) : '';
                
                const icon = createPOIIcon('🏢', '#f59e0b'); // Amber for BIDs
                const marker = L.marker([lat, lon], { icon });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏢 Business Improvement District
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                      ${borough ? `<div><strong>Borough:</strong> ${borough}</div>` : ''}
                      ${distance ? `<div><strong>Distance:</strong> ${distance} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all BID attributes
                const excludeFields = ['districtId', 'bid_id', 'bidId', 'BID_ID', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'latitude', 'lat', 'LATITUDE', 'LAT', 'longitude', 'lon', 'LONGITUDE', 'LON', 'lng', 'LNG', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'bid_name', 'bidName', 'BID_NAME', 'NAME', 'Name', 'borough', 'Borough', 'BOROUGH', 'isContaining', '__calculatedDistance'];
                Object.entries(bid).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (marker as any).__layerType = 'nyc_business_improvement_districts';
                (marker as any).__layerTitle = 'NYC Business Improvement Districts';
                (marker as any).__popupContent = popupContent;
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                
                bidCount++;
              } catch (error) {
                console.error('Error drawing NYC Business Improvement District marker:', error);
              }
            }
          });
          
          if (bidCount > 0) {
            if (!legendAccumulator['nyc_business_improvement_districts']) {
              legendAccumulator['nyc_business_improvement_districts'] = {
                icon: '🏢',
                color: '#f59e0b',
                title: 'NYC Business Improvement Districts',
                count: 0,
              };
            }
            legendAccumulator['nyc_business_improvement_districts'].count += bidCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Business Improvement Districts:', error);
      }

      // Draw NYC Community Districts as polygons on the map
      try {
        if (enrichments.nyc_community_districts_all && Array.isArray(enrichments.nyc_community_districts_all)) {
          let districtCount = 0;
          enrichments.nyc_community_districts_all.forEach((district: any) => {
            // Check if geometry is available (ESRI polygon geometry)
            if (district.geometry && district.geometry.rings && Array.isArray(district.geometry.rings)) {
              try {
                // Convert ESRI rings to Leaflet latlngs
                const rings = district.geometry.rings;
                const latlngs: [number, number][] = [];
                
                // Use the first ring (outer boundary)
                if (rings[0] && Array.isArray(rings[0])) {
                  for (const coord of rings[0]) {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      // ESRI geometry might be in Web Mercator or WGS84
                      // Convert if needed
                      let lat: number;
                      let lon: number;
                      
                      if (Math.abs(coord[0]) > 180 || Math.abs(coord[1]) > 90) {
                        // Web Mercator to WGS84
                        lon = (coord[0] / 20037508.34) * 180;
                        let latRad = (coord[1] / 20037508.34) * 180;
                        lat = 180 / Math.PI * (2 * Math.atan(Math.exp(latRad * Math.PI / 180)) - Math.PI / 2);
                      } else {
                        // Already WGS84
                        lon = coord[0];
                        lat = coord[1];
                      }
                      
                      latlngs.push([lat, lon]);
                    }
                  }
                }
                
                if (latlngs.length < 3) {
                  console.warn('NYC Community District polygon has less than 3 coordinates, skipping');
                  return;
                }
                
                const isContaining = district.isContaining;
                const color = isContaining ? '#3b82f6' : '#60a5fa'; // Blue for Community Districts
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const boroCD = district.boroCD || district.BoroCD || district.BOROCD || district.districtId || 'Unknown';
                const distance = district.distance_miles !== null && district.distance_miles !== undefined ? district.distance_miles : 0;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏘️ Containing Community District' : '🏘️ Nearby Community District'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${boroCD ? `<div><strong>Community District:</strong> ${boroCD}</div>` : ''}
                      ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this district</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all district attributes (excluding internal fields)
                const excludeFields = ['districtId', 'boroCD', 'BoroCD', 'BOROCD', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining', '__calculatedDistance'];
                Object.entries(district).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value) && key !== 'the_geom') {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (polygon as any).__layerType = 'nyc_community_districts';
                (polygon as any).__layerTitle = 'NYC Community Districts';
                (polygon as any).__popupContent = popupContent;
                polygon.addTo(primary);
                
                // Extend bounds to include polygon
                const polygonBounds = L.latLngBounds(latlngs);
                bounds.extend(polygonBounds);
                
                districtCount++;
              } catch (error) {
                console.error('Error drawing NYC Community District polygon:', error);
              }
            }
          });
          
          if (districtCount > 0) {
            if (!legendAccumulator['nyc_community_districts']) {
              legendAccumulator['nyc_community_districts'] = {
                icon: '🏘️',
                color: '#3b82f6',
                title: 'NYC Community Districts',
                count: 0,
              };
            }
            legendAccumulator['nyc_community_districts'].count += districtCount;
          }
        }
      } catch (error) {
        console.error('Error processing NYC Community Districts:', error);
      }

      // Draw Houston Neighborhoods as polygons on the map
      try {
        if (enrichments.houston_neighborhoods_all && Array.isArray(enrichments.houston_neighborhoods_all)) {
          let neighborhoodCount = 0;
          enrichments.houston_neighborhoods_all.forEach((neighborhood: any) => {
            // Check if geometry is available (ESRI polygon geometry)
            if (neighborhood.geometry && neighborhood.geometry.rings && Array.isArray(neighborhood.geometry.rings)) {
              try {
                // Convert ESRI rings to Leaflet latlngs
                const rings = neighborhood.geometry.rings;
                const latlngs: [number, number][] = [];
                
                // Use the first ring (outer boundary)
                if (rings[0] && Array.isArray(rings[0])) {
                  for (const coord of rings[0]) {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      // ESRI geometry might be in Web Mercator or WGS84
                      // Convert if needed
                      let lat: number;
                      let lon: number;
                      
                      if (Math.abs(coord[0]) > 180 || Math.abs(coord[1]) > 90) {
                        // Web Mercator to WGS84
                        lon = (coord[0] / 20037508.34) * 180;
                        let latRad = (coord[1] / 20037508.34) * 180;
                        lat = 180 / Math.PI * (2 * Math.atan(Math.exp(latRad * Math.PI / 180)) - Math.PI / 2);
                      } else {
                        // Already WGS84
                        lon = coord[0];
                        lat = coord[1];
                      }
                      
                      latlngs.push([lat, lon]);
                    }
                  }
                }
                
                if (latlngs.length < 3) {
                  console.warn('Houston Neighborhood polygon has less than 3 coordinates, skipping');
                  return;
                }
                
                const isContaining = neighborhood.isContaining;
                const color = isContaining ? '#10b981' : '#34d399'; // Green for neighborhoods
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const nameLabel = neighborhood.nameLabel || neighborhood.NAME_LABEL || neighborhood.name_label || null;
                const nname = neighborhood.nname || neighborhood.NNAME || null;
                const name1 = neighborhood.name1 || neighborhood.NAME_1 || null;
                const name2 = neighborhood.name2 || neighborhood.NAME_2 || null;
                const codeNum = neighborhood.codeNum || neighborhood.CODE_NUM || neighborhood.code_num || null;
                const comment = neighborhood.comment || neighborhood.COMMENT || null;
                const distance = neighborhood.distance_miles !== null && neighborhood.distance_miles !== undefined ? neighborhood.distance_miles : 0;
                
                const displayName = nameLabel || nname || name1 || name2 || 'Unknown Neighborhood';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏘️ Containing Neighborhood' : '🏘️ Nearby Neighborhood'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${displayName ? `<div><strong>Neighborhood:</strong> ${displayName}</div>` : ''}
                      ${nname ? `<div><strong>NNAME:</strong> ${nname}</div>` : ''}
                      ${codeNum !== null ? `<div><strong>Code Number:</strong> ${codeNum}</div>` : ''}
                      ${comment ? `<div><strong>Comment:</strong> ${comment}</div>` : ''}
                      ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this neighborhood</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all neighborhood attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'nname', 'NNAME', 'nameLabel', 'NAME_LABEL', 'name_label', 'name1', 'NAME_1', 'name_1', 'name2', 'NAME_2', 'name_2', 'codeNum', 'CODE_NUM', 'code_num', 'comment', 'COMMENT', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining', '__calculatedDistance'];
                Object.entries(neighborhood).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value) && key !== 'the_geom') {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (polygon as any).__layerType = 'houston_neighborhoods';
                (polygon as any).__layerTitle = 'Houston Neighborhoods';
                (polygon as any).__popupContent = popupContent;
                polygon.addTo(primary);
                
                // Extend bounds to include polygon
                const polygonBounds = L.latLngBounds(latlngs);
                bounds.extend(polygonBounds);
                
                neighborhoodCount++;
              } catch (error) {
                console.error('Error drawing Houston Neighborhood polygon:', error);
              }
            }
          });
          
          if (neighborhoodCount > 0) {
            if (!legendAccumulator['houston_neighborhoods']) {
              legendAccumulator['houston_neighborhoods'] = {
                icon: '🏘️',
                color: '#10b981',
                title: 'Houston Neighborhoods',
                count: 0,
              };
            }
            legendAccumulator['houston_neighborhoods'].count += neighborhoodCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Neighborhoods:', error);
      }

      // Draw Houston Neighborhoods 2021 as polygons on the map
      try {
        if (enrichments.houston_neighborhoods_2021_all && Array.isArray(enrichments.houston_neighborhoods_2021_all)) {
          let neighborhoodCount = 0;
          enrichments.houston_neighborhoods_2021_all.forEach((neighborhood: any) => {
            // Check if geometry is available (ESRI polygon geometry)
            if (neighborhood.geometry && neighborhood.geometry.rings && Array.isArray(neighborhood.geometry.rings)) {
              try {
                // Convert ESRI rings to Leaflet latlngs
                const rings = neighborhood.geometry.rings;
                const latlngs: [number, number][] = [];
                
                // Use the first ring (outer boundary)
                if (rings[0] && Array.isArray(rings[0])) {
                  for (const coord of rings[0]) {
                    if (Array.isArray(coord) && coord.length >= 2) {
                      // ESRI geometry might be in Web Mercator or WGS84
                      // Convert if needed
                      let lat: number;
                      let lon: number;
                      
                      if (Math.abs(coord[0]) > 180 || Math.abs(coord[1]) > 90) {
                        // Web Mercator to WGS84
                        lon = (coord[0] / 20037508.34) * 180;
                        let latRad = (coord[1] / 20037508.34) * 180;
                        lat = 180 / Math.PI * (2 * Math.atan(Math.exp(latRad * Math.PI / 180)) - Math.PI / 2);
                      } else {
                        // Already WGS84
                        lon = coord[0];
                        lat = coord[1];
                      }
                      
                      latlngs.push([lat, lon]);
                    }
                  }
                }
                
                if (latlngs.length < 3) {
                  console.warn('Houston Neighborhood 2021 polygon has less than 3 coordinates, skipping');
                  return;
                }
                
                const isContaining = neighborhood.isContaining;
                const color = isContaining ? '#10b981' : '#34d399'; // Green for neighborhoods
                const weight = isContaining ? 3 : 2;
                const opacity = isContaining ? 0.8 : 0.5;
                
                const polygon = L.polygon(latlngs, {
                  color: color,
                  weight: weight,
                  opacity: opacity,
                  fillColor: color,
                  fillOpacity: 0.2
                });
                
                const objName = neighborhood.objName || neighborhood.OBJ_NAME || null;
                const objTyp = neighborhood.objTyp || neighborhood.OBJ_TYP || null;
                const objSubtcd = neighborhood.objSubtcd || neighborhood.OBJ_SUBTCD || null;
                const objSubtyp = neighborhood.objSubtyp || neighborhood.OBJ_SUBTYP || null;
                const metro = neighborhood.metro || neighborhood.METRO || null;
                const reldate = neighborhood.reldate || neighborhood.RELDATE || null;
                const objArea = neighborhood.objArea || neighborhood.OBJ_AREA || null;
                const distance = neighborhood.distance_miles !== null && neighborhood.distance_miles !== undefined ? neighborhood.distance_miles : 0;
                
                const displayName = objName || objTyp || 'Unknown Neighborhood';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ${isContaining ? '🏘️ Containing Neighborhood' : '🏘️ Nearby Neighborhood'}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${displayName ? `<div><strong>Neighborhood:</strong> ${displayName}</div>` : ''}
                      ${objTyp ? `<div><strong>Type:</strong> ${objTyp}</div>` : ''}
                      ${objSubtcd ? `<div><strong>Sub Type Code:</strong> ${objSubtcd}</div>` : ''}
                      ${objSubtyp ? `<div><strong>Sub Type:</strong> ${objSubtyp}</div>` : ''}
                      ${metro ? `<div><strong>Metro:</strong> ${metro}</div>` : ''}
                      ${reldate ? `<div><strong>Release Date:</strong> ${reldate}</div>` : ''}
                      ${objArea !== null ? `<div><strong>Area:</strong> ${objArea.toLocaleString()}</div>` : ''}
                      ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this neighborhood</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all neighborhood attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'FID', 'fid', 'objName', 'OBJ_NAME', 'objTyp', 'OBJ_TYP', 'objSubtcd', 'OBJ_SUBTCD', 'objSubtyp', 'OBJ_SUBTYP', 'country', 'COUNTRY', 'metro', 'METRO', 'lat', 'LAT', 'lon', 'LON', 'reldate', 'RELDATE', 'objArea', 'OBJ_AREA', 'geometry', 'distance_miles', 'GlobalID', 'GLOBALID', 'isContaining', '__calculatedDistance'];
                Object.entries(neighborhood).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value) && key !== 'the_geom') {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (polygon as any).__layerType = 'houston_neighborhoods_2021';
                (polygon as any).__layerTitle = 'Houston Neighborhoods';
                (polygon as any).__popupContent = popupContent;
                polygon.addTo(primary);
                
                // Extend bounds to include polygon
                const polygonBounds = L.latLngBounds(latlngs);
                bounds.extend(polygonBounds);
                
                neighborhoodCount++;
              } catch (error) {
                console.error('Error drawing Houston Neighborhood 2021 polygon:', error);
              }
            }
          });
          
          if (neighborhoodCount > 0) {
            if (!legendAccumulator['houston_neighborhoods_2021']) {
              legendAccumulator['houston_neighborhoods_2021'] = {
                icon: '🏘️',
                color: '#10b981',
                title: 'Houston Neighborhoods',
                count: 0,
              };
            }
            legendAccumulator['houston_neighborhoods_2021'].count += neighborhoodCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Neighborhoods 2021:', error);
      }

      // Draw Houston Site Addresses as points on the map
      try {
        if (enrichments.houston_site_addresses_all && Array.isArray(enrichments.houston_site_addresses_all)) {
          let addressCount = 0;
          enrichments.houston_site_addresses_all.forEach((address: any) => {
            // Check if geometry is available (ESRI point geometry)
            if (address.geometry && address.geometry.x !== undefined && address.geometry.y !== undefined) {
              try {
                const lat = address.geometry.y;
                const lon = address.geometry.x;
                
                const distance = address.distance_miles !== null && address.distance_miles !== undefined ? address.distance_miles : 0;
                const color = '#3b82f6'; // Blue for addresses
                
                const marker = L.marker([lat, lon], {
                  icon: L.divIcon({
                    className: 'custom-marker-icon',
                    html: `<div style="background-color: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                  })
                });
                
                const fulladdr = address.fulladdr || 'Unknown Address';
                const municipality = address.municipality || '';
                const zipcode = address.zipcode || '';
                const addrtype = address.addrtype || '';
                const status = address.status || '';
                const source = address.source || '';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      📍 Site Address
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${fulladdr ? `<div><strong>Address:</strong> ${fulladdr}</div>` : ''}
                      ${municipality ? `<div><strong>Municipality:</strong> ${municipality}</div>` : ''}
                      ${zipcode ? `<div><strong>Zip Code:</strong> ${zipcode}</div>` : ''}
                      ${addrtype ? `<div><strong>Address Type:</strong> ${addrtype}</div>` : ''}
                      ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                      ${source ? `<div><strong>Source:</strong> ${source}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all address attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'FID', 'fid', 'fulladdr', 'FULLADDR', 'addrnum', 'ADDRNUM', 'roadname', 'ROADNAME', 'roadtype', 'ROADTYPE', 'unitid', 'UNITID', 'unittype', 'UNITTYPE', 'municipality', 'MUNICIPALITY', 'zipcode', 'ZIPCODE', 'county', 'COUNTY', 'addrtype', 'ADDRTYPE', 'status', 'STATUS', 'source', 'SOURCE', 'geometry', 'distance_miles', 'GlobalID', 'GLOBALID', '__calculatedDistance'];
                Object.entries(address).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value) && key !== 'the_geom') {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                // Store metadata for tabbed popup
                (marker as any).__layerType = 'houston_site_addresses';
                (marker as any).__layerTitle = 'Houston Site Addresses';
                (marker as any).__popupContent = popupContent;
                marker.addTo(primary);
                
                // Extend bounds to include marker
                bounds.extend([lat, lon]);
                
                addressCount++;
              } catch (error) {
                console.error('Error drawing Houston Site Address marker:', error);
              }
            }
          });
          
          if (addressCount > 0) {
            if (!legendAccumulator['houston_site_addresses']) {
              legendAccumulator['houston_site_addresses'] = {
                icon: '📍',
                color: '#3b82f6',
                title: 'Houston Site Addresses',
                count: 0,
              };
            }
            legendAccumulator['houston_site_addresses'].count += addressCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Site Addresses:', error);
      }

      // Draw Houston Roads Centerline as polylines on the map
      try {
        if (enrichments.houston_roads_centerline_all && Array.isArray(enrichments.houston_roads_centerline_all)) {
          let roadCount = 0;
          enrichments.houston_roads_centerline_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = road.geometry.paths;
                if (paths && paths.length > 0) {
                  roadCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const fullname = road.fullname || road.FULLNAME || road.fullName || 'Unknown Road';
                    const roadclass = road.roadclass || road.ROADCLASS || road.roadClass || null;
                    const fromleft = road.fromleft !== null && road.fromleft !== undefined ? road.fromleft : null;
                    const fromright = road.fromright !== null && road.fromright !== undefined ? road.fromright : null;
                    const toleft = road.toleft !== null && road.toleft !== undefined ? road.toleft : null;
                    const toright = road.toright !== null && road.toright !== undefined ? road.toright : null;
                    const parityleft = road.parityleft || road.PARITYLEFT || road.parityLeft || null;
                    const parityright = road.parityright || road.PARITYRIGHT || road.parityRight || null;
                    const onewaydir = road.onewaydir || road.ONEWAYDIR || road.onewayDir || null;
                    const munileft = road.munileft || road.MUNILEFT || road.muniLeft || null;
                    const muniright = road.muniright || road.MUNIRIGHT || road.muniRight || null;
                    const countyleft = road.countyleft || road.COUNTYLEFT || road.countyLeft || null;
                    const countyright = road.countyright || road.COUNTYRIGHT || road.countyRight || null;
                    const zipleft = road.zipleft || road.ZIPLEFT || road.zipLeft || null;
                    const zipright = road.zipright || road.ZIPRIGHT || road.zipRight || null;
                    const speed = road.speed !== null && road.speed !== undefined ? road.speed : null;
                    const shapeLength = road.shapeLength || road.Shape__Length || road.shape_length || null;
                    const centerlineid = road.centerlineid || road.CENTERLINEID || road.centerlineId || null;
                    const source = road.source || road.SOURCE || null;
                    const distance = road.distance_miles !== null && road.distance_miles !== undefined ? road.distance_miles : 0;

                    // Create polyline with blue color for roads
                    const polyline = L.polyline(latlngs, {
                      color: '#3b82f6', // Blue color for Houston roads
                      weight: 3,
                      opacity: 0.7,
                      smoothFactor: 1
                    });

                    // Build popup content with all road attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${fullname}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${roadclass ? `<div><strong>Road Class:</strong> ${roadclass}</div>` : ''}
                          ${fromleft !== null && toleft !== null ? `<div><strong>Left Side:</strong> ${fromleft} - ${toleft}</div>` : ''}
                          ${fromright !== null && toright !== null ? `<div><strong>Right Side:</strong> ${fromright} - ${toright}</div>` : ''}
                          ${parityleft ? `<div><strong>Left Parity:</strong> ${parityleft}</div>` : ''}
                          ${parityright ? `<div><strong>Right Parity:</strong> ${parityright}</div>` : ''}
                          ${onewaydir ? `<div><strong>One Way Direction:</strong> ${onewaydir}</div>` : ''}
                          ${munileft || muniright ? `<div><strong>Municipality:</strong> ${munileft || muniright}</div>` : ''}
                          ${countyleft || countyright ? `<div><strong>County:</strong> ${countyleft || countyright}</div>` : ''}
                          ${zipleft || zipright ? `<div><strong>ZIP:</strong> ${zipleft || zipright}</div>` : ''}
                          ${speed !== null ? `<div><strong>Speed Limit:</strong> ${speed} mph</div>` : ''}
                          ${shapeLength !== null && shapeLength !== undefined ? `<div><strong>Length:</strong> ${shapeLength.toFixed(2)} meters</div>` : ''}
                          ${centerlineid ? `<div><strong>Centerline ID:</strong> ${centerlineid}</div>` : ''}
                          ${source ? `<div><strong>Source:</strong> ${source}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all road attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'centerlineid', 'CENTERLINEID', 'centerlineId', 'fullname', 'FULLNAME', 'fullName', 'roadname', 'ROADNAME', 'roadName', 'roadtype', 'ROADTYPE', 'roadType', 'prefix', 'PREFIX', 'suffix', 'SUFFIX', 'roadclass', 'ROADCLASS', 'roadClass', 'fromleft', 'FROMLEFT', 'fromLeft', 'fromright', 'FROMRIGHT', 'fromRight', 'toleft', 'TOLEFT', 'toLeft', 'toright', 'TORIGHT', 'toRight', 'parityleft', 'PARITYLEFT', 'parityLeft', 'parityright', 'PARITYRIGHT', 'parityRight', 'onewaydir', 'ONEWAYDIR', 'onewayDir', 'munileft', 'MUNILEFT', 'muniLeft', 'muniright', 'MUNIRIGHT', 'muniRight', 'countyleft', 'COUNTYLEFT', 'countyLeft', 'countyright', 'COUNTYRIGHT', 'countyRight', 'zipleft', 'ZIPLEFT', 'zipLeft', 'zipright', 'ZIPRIGHT', 'zipRight', 'speed', 'SPEED', 'shapeLength', 'Shape__Length', 'shape_length', 'source', 'SOURCE'];
                    Object.entries(road).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing Houston Roads Centerline polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['houston_roads_centerline']) {
              legendAccumulator['houston_roads_centerline'] = {
                icon: '🛣️',
                color: '#3b82f6',
                title: 'Houston Roads Centerline',
                count: 0,
              };
            }
            legendAccumulator['houston_roads_centerline'].count += roadCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Roads Centerline:', error);
      }

      // Draw Houston Metro Bus Routes as polylines on the map
      try {
        if (enrichments.houston_metro_bus_routes_all && Array.isArray(enrichments.houston_metro_bus_routes_all)) {
          let routeCount = 0;
          enrichments.houston_metro_bus_routes_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = route.geometry.paths;
                if (paths && paths.length > 0) {
                  routeCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = route.routeName || route.ROUTE_NAME || route.route_name || route.RouteName || route.NAME || route.name || route.Route || route.route || 'Unknown Route';
                    const routeNumber = route.routeNumber || route.ROUTE_NUMBER || route.route_number || route.RouteNumber || route.ROUTE || route.Route || route.NUMBER || route.number || '';
                    const routeType = route.routeType || route.ROUTE_TYPE || route.route_type || route.RouteType || route.TYPE || route.type || '';
                    const distance = route.distance_miles !== null && route.distance_miles !== undefined ? route.distance_miles : 0;

                    // Create polyline with blue color for bus routes
                    const polyline = L.polyline(latlngs, {
                      color: '#2563eb', // Blue color for Houston Metro Bus Routes (distinct from bikeways)
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with route information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚌 ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${routeNumber ? `<div><strong>Route Number:</strong> ${routeNumber}</div>` : ''}
                          ${routeType ? `<div><strong>Route Type:</strong> ${routeType}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all route attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'routeName', 'ROUTE_NAME', 'route_name', 'RouteName', 'NAME', 'name', 'Route', 'route', 'routeNumber', 'ROUTE_NUMBER', 'route_number', 'RouteNumber', 'ROUTE', 'NUMBER', 'number', 'routeType', 'ROUTE_TYPE', 'route_type', 'RouteType', 'TYPE', 'type'];
                    Object.entries(route).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing Houston Metro Bus Routes polyline:', error);
              }
            }
          });
          
          if (routeCount > 0) {
            if (!legendAccumulator['houston_metro_bus_routes']) {
              legendAccumulator['houston_metro_bus_routes'] = {
                icon: '🚌',
                color: '#2563eb',
                title: 'Houston Metro Bus Routes',
                count: 0,
              };
            }
            legendAccumulator['houston_metro_bus_routes'].count += routeCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Metro Bus Routes:', error);
      }

      // Draw Houston TIRZ as polygons on the map
      try {
        if (enrichments.houston_tirz_all && Array.isArray(enrichments.houston_tirz_all)) {
          let zoneCount = 0;
          enrichments.houston_tirz_all.forEach((zone: any) => {
            if (zone.geometry && zone.geometry.rings && Array.isArray(zone.geometry.rings)) {
              try {
                const rings = zone.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Houston TIRZ polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = zone.isContaining;
                  const color = isContaining ? '#f59e0b' : '#fbbf24'; // Orange/amber for TIRZ zones
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const name = zone.name || zone.NAME || 'Unknown Zone';
                  const siteNo = zone.siteNo !== null && zone.siteNo !== undefined ? zone.siteNo.toString() : (zone.SITENO !== null && zone.SITENO !== undefined ? zone.SITENO.toString() : '');
                  const zoneId = zone.objectId || zone.OBJECTID || zone.objectid || null;
                  const perimeter = zone.perimeter !== null && zone.perimeter !== undefined ? zone.perimeter.toFixed(2) : null;
                  const shapeArea = zone.shapeArea !== null && zone.shapeArea !== undefined ? zone.shapeArea : null;
                  const areaAcres = shapeArea ? (shapeArea * 0.000247105).toFixed(2) : null;
                  const shapeLength = zone.shapeLength !== null && zone.shapeLength !== undefined ? zone.shapeLength.toFixed(2) : null;
                  const distance = zone.distance_miles !== null && zone.distance_miles !== undefined ? zone.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ ${name}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${siteNo ? `<div><strong>Site Number:</strong> ${siteNo}</div>` : ''}
                        ${zoneId ? `<div><strong>Zone ID:</strong> ${zoneId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${perimeter ? `<div><strong>Perimeter:</strong> ${perimeter} meters</div>` : ''}
                        ${areaAcres ? `<div><strong>Area:</strong> ${areaAcres} acres</div>` : ''}
                        ${shapeLength ? `<div><strong>Length:</strong> ${shapeLength} meters</div>` : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all zone attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'globalId', 'name', 'NAME', 'siteNo', 'SITENO', 'perimeter', 'PERIMETER', 'shapeArea', 'Shape__Area', 'shape_area', 'shapeLength', 'Shape__Length', 'shape_length'];
                  Object.entries(zone).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  zoneCount++;
                }
              } catch (error) {
                console.error('Error drawing Houston TIRZ polygon:', error);
              }
            }
          });
          
          if (zoneCount > 0) {
            if (!legendAccumulator['houston_tirz']) {
              legendAccumulator['houston_tirz'] = {
                icon: '🏛️',
                color: '#f59e0b',
                title: 'Houston Tax Incentive Reinvestment Zones',
                count: 0,
              };
            }
            legendAccumulator['houston_tirz'].count += zoneCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston TIRZ:', error);
      }

      // Houston Affordability Tracts
      try {
        if (enrichments.houston_affordability_all && Array.isArray(enrichments.houston_affordability_all)) {
          let tractCount = 0;
          enrichments.houston_affordability_all.forEach((tract: any) => {
            if (tract.geometry && tract.geometry.rings && Array.isArray(tract.geometry.rings)) {
              try {
                const rings = tract.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Houston Affordability polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = tract.isContaining;
                  const layerType = tract.layerType || null;
                  
                  // Different colors for boundary layers vs tracts
                  let color: string;
                  let icon: string;
                  let title: string;
                  
                  if (layerType === 'CITY_LIMIT') {
                    color = isContaining ? '#3b82f6' : '#60a5fa'; // Blue for city limit
                    icon = '🏙️';
                    title = 'City of Houston City Limit';
                  } else if (layerType === 'ETJ') {
                    color = isContaining ? '#8b5cf6' : '#a78bfa'; // Purple for ETJ
                    icon = '🏘️';
                    title = 'City of Houston ETJ (Extra-Territorial Jurisdiction)';
                  } else {
                    color = isContaining ? '#10b981' : '#34d399'; // Green/emerald for affordability tracts
                    icon = '🏘️';
                    title = 'Census Tract';
                  }
                  
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const tractId = tract.tractId || tract.TRACT || tract.tract || tract.TRACTCE || tract.tractce || `Tract ${tract.objectId || 'Unknown'}`;
                  const htaIndex = tract.htaIndex !== null && tract.htaIndex !== undefined ? tract.htaIndex : (tract.HTA_INDEX !== null && tract.HTA_INDEX !== undefined ? tract.HTA_INDEX : null);
                  const tractObjectId = tract.objectId || tract.OBJECTID || tract.objectid || null;
                  const distance = tract.distance_miles !== null && tract.distance_miles !== undefined ? tract.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}${layerType ? '' : ` ${tractId}`}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${layerType ? `<div><strong>Type:</strong> ${layerType === 'CITY_LIMIT' ? 'City Limit' : 'ETJ'}</div>` : ''}
                        ${htaIndex !== null ? `<div><strong>HTA Index:</strong> ${htaIndex.toFixed(2)}</div>` : ''}
                        ${tractObjectId ? `<div><strong>${layerType ? 'Object ID' : 'Tract ID'}:</strong> ${tractObjectId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all tract attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'globalId', 'tractId', 'TRACT', 'tract', 'TRACTCE', 'tractce', 'htaIndex', 'HTA_INDEX', 'hta_index', 'layerType'];
                  Object.entries(tract).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  tractCount++;
                }
              } catch (error) {
                console.error('Error drawing Houston Affordability polygon:', error);
              }
            }
          });
          
          if (tractCount > 0) {
            if (!legendAccumulator['houston_affordability']) {
              legendAccumulator['houston_affordability'] = {
                icon: '🏘️',
                color: '#10b981',
                title: 'Houston Affordability (by Census Tract)',
                count: 0,
              };
            }
            legendAccumulator['houston_affordability'].count += tractCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Affordability:', error);
      }

      // Draw Houston Fire Hydrants as point markers on the map
      try {
        if (enrichments.houston_fire_hydrants_all && Array.isArray(enrichments.houston_fire_hydrants_all)) {
          let hydrantCount = 0;
          enrichments.houston_fire_hydrants_all.forEach((hydrant: any) => {
            if (hydrant.geometry && hydrant.geometry.x !== undefined && hydrant.geometry.y !== undefined) {
              try {
                // Extract coordinates from geometry (already in WGS84)
                const lat = hydrant.geometry.y;
                const lon = hydrant.geometry.x;
                
                const address = hydrant.address || hydrant.ADDRESS || 'Unknown Location';
                const hydrantNumber = hydrant.hydrantNumber || hydrant.HYDRANTNUMBER || null;
                const zone = hydrant.zone || hydrant.ZONE || null;
                const councilDistrict = hydrant.councilDistrict || hydrant.COUNCILDISTRICT || null;
                const owner = hydrant.owner || hydrant.OWNER || null;
                const barrelDiameter = hydrant.barrelDiameter !== null && hydrant.barrelDiameter !== undefined ? hydrant.barrelDiameter : (hydrant.BARRELDIAMETER !== null && hydrant.BARRELDIAMETER !== undefined ? Number(hydrant.BARRELDIAMETER) : null);
                const lineSize = hydrant.lineSize !== null && hydrant.lineSize !== undefined ? hydrant.lineSize : (hydrant.LINESIZE !== null && hydrant.LINESIZE !== undefined ? Number(hydrant.LINESIZE) : null);
                const mainDiameter = hydrant.mainDiameter !== null && hydrant.mainDiameter !== undefined ? hydrant.mainDiameter : (hydrant.MAINDIAMETER !== null && hydrant.MAINDIAMETER !== undefined ? Number(hydrant.MAINDIAMETER) : null);
                const distance = hydrant.distance_miles !== null && hydrant.distance_miles !== undefined ? hydrant.distance_miles : 0;
                
                // Create marker with fire hydrant icon
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚰', '#ef4444')
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚰 Fire Hydrant
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${hydrantNumber ? `<div><strong>Hydrant Number:</strong> ${hydrantNumber}</div>` : ''}
                      ${zone ? `<div><strong>Zone:</strong> ${zone}</div>` : ''}
                      ${councilDistrict ? `<div><strong>Council District:</strong> ${councilDistrict}</div>` : ''}
                      ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                      ${barrelDiameter !== null && barrelDiameter !== undefined ? `<div><strong>Barrel Diameter:</strong> ${barrelDiameter}"</div>` : ''}
                      ${lineSize !== null && lineSize !== undefined ? `<div><strong>Line Size:</strong> ${lineSize}"</div>` : ''}
                      ${mainDiameter !== null && mainDiameter !== undefined ? `<div><strong>Main Diameter:</strong> ${mainDiameter}"</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all hydrant attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'address', 'ADDRESS', 'hydrantNumber', 'HYDRANTNUMBER', 'zone', 'ZONE', 'councilDistrict', 'COUNCILDISTRICT', 'owner', 'OWNER', 'barrelDiameter', 'BARRELDIAMETER', 'lineSize', 'LINESIZE', 'mainDiameter', 'MAINDIAMETER'];
                Object.entries(hydrant).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                hydrantCount++;
              } catch (error) {
                console.error('Error drawing Houston Fire Hydrant marker:', error);
              }
            }
          });
          
          if (hydrantCount > 0) {
            if (!legendAccumulator['houston_fire_hydrants']) {
              legendAccumulator['houston_fire_hydrants'] = {
                icon: '🚰',
                color: '#ef4444',
                title: 'Houston Fire Hydrants',
                count: 0,
              };
            }
            legendAccumulator['houston_fire_hydrants'].count += hydrantCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Fire Hydrants:', error);
      }

      // Draw Houston Fire Stations as point markers on the map
      try {
        if (enrichments.houston_fire_stations_all && Array.isArray(enrichments.houston_fire_stations_all)) {
          let stationCount = 0;
          enrichments.houston_fire_stations_all.forEach((station: any) => {
            // Try multiple coordinate sources
            let lat: number | null = null;
            let lon: number | null = null;
            
            if (station.geometry && station.geometry.x !== undefined && station.geometry.y !== undefined) {
              lat = station.geometry.y;
              lon = station.geometry.x;
            } else if (station.lat !== null && station.lat !== undefined && station.long !== null && station.long !== undefined) {
              lat = station.lat;
              lon = station.long;
            } else if (station.yCoord !== null && station.yCoord !== undefined && station.xCoord !== null && station.xCoord !== undefined) {
              lat = station.yCoord;
              lon = station.xCoord;
            }
            
            if (lat !== null && lon !== null && !isNaN(lat) && !isNaN(lon)) {
              try {
                const name = station.name || station.NAME || station.text || station.TEXT_ || station.label || station.LABEL || `Fire Station ${station.distSta || station.DIST_STA || ''}` || 'Unknown Fire Station';
                const distSta = station.distSta || station.DIST_STA || null;
                const admin = station.admin || station.Admin || station.ADMIN || null;
                const ladders = station.ladders || station.LADDERS || null;
                const inDist = station.inDist !== null && station.inDist !== undefined ? station.inDist : null;
                const distance = station.distance_miles !== null && station.distance_miles !== undefined ? station.distance_miles : 0;
                
                // Create marker with fire station icon
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚒', '#dc2626')
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚒 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${distSta ? `<div><strong>District/Station:</strong> ${distSta}</div>` : ''}
                      ${admin ? `<div><strong>Admin:</strong> ${admin}</div>` : ''}
                      ${ladders ? `<div><strong>Ladders:</strong> ${ladders}</div>` : ''}
                      ${inDist !== null && inDist !== undefined ? `<div><strong>In District:</strong> ${inDist}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all station attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'globalId', 'name', 'NAME', 'label', 'LABEL', 'text', 'TEXT_', 'distSta', 'DIST_STA', 'admin', 'Admin', 'ADMIN', 'ladders', 'LADDERS', 'inDist', 'IN_DIST', 'lat', 'LAT', 'long', 'LONG', 'xCoord', 'X_COORD', 'yCoord', 'Y_COORD'];
                Object.entries(station).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                stationCount++;
              } catch (error) {
                console.error('Error drawing Houston Fire Station marker:', error);
              }
            }
          });
          
          if (stationCount > 0) {
            if (!legendAccumulator['houston_fire_stations']) {
              legendAccumulator['houston_fire_stations'] = {
                icon: '🚒',
                color: '#dc2626',
                title: 'Houston Fire Stations',
                count: 0,
              };
            }
            legendAccumulator['houston_fire_stations'].count += stationCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Fire Stations:', error);
      }

      // Draw Houston METRO Park and Ride Locations as point markers on the map
      try {
        if (enrichments.houston_metro_park_and_ride_all && Array.isArray(enrichments.houston_metro_park_and_ride_all)) {
          let locationCount = 0;
          enrichments.houston_metro_park_and_ride_all.forEach((location: any) => {
            if (location.geometry && location.geometry.x !== undefined && location.geometry.y !== undefined) {
              try {
                // Extract coordinates from geometry (already in WGS84)
                const lat = location.geometry.y;
                const lon = location.geometry.x;
                
                const name = location.name || location.NAME1 || 'Unknown Park and Ride';
                const address = location.address || location.ADDRESS || null;
                const parkingSpaces = location.parkingSpaces !== null && location.parkingSpaces !== undefined ? location.parkingSpaces : (location.PSPACES !== null && location.PSPACES !== undefined ? Number(location.PSPACES) : null);
                const routesServed = location.routesServed || location.ROUTES_SER || null;
                const fareZone = location.fareZone !== null && location.fareZone !== undefined ? location.fareZone : (location.FareZone !== null && location.FareZone !== undefined ? Number(location.FareZone) : null);
                const busStopId = location.busStopId !== null && location.busStopId !== undefined ? location.busStopId : (location.BusStopID !== null && location.BusStopID !== undefined ? Number(location.BusStopID) : null);
                const distance = location.distance_miles !== null && location.distance_miles !== undefined ? location.distance_miles : 0;
                
                // Create marker with car icon
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚗', '#3b82f6')
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚗 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${parkingSpaces !== null && parkingSpaces !== undefined ? `<div><strong>Parking Spaces:</strong> ${parkingSpaces}</div>` : ''}
                      ${routesServed ? `<div><strong>Routes Served:</strong> ${routesServed}</div>` : ''}
                      ${fareZone !== null && fareZone !== undefined ? `<div><strong>Fare Zone:</strong> ${fareZone}</div>` : ''}
                      ${busStopId !== null && busStopId !== undefined ? `<div><strong>Bus Stop ID:</strong> ${busStopId}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all location attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME1', 'address', 'ADDRESS', 'parkingSpaces', 'PSPACES', 'routesServed', 'ROUTES_SER', 'fareZone', 'FareZone', 'busStopId', 'BusStopID'];
                Object.entries(location).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                locationCount++;
              } catch (error) {
                console.error('Error drawing Houston METRO Park and Ride Location marker:', error);
              }
            }
          });
          
          if (locationCount > 0) {
            if (!legendAccumulator['houston_metro_park_and_ride']) {
              legendAccumulator['houston_metro_park_and_ride'] = {
                icon: '🚗',
                color: '#3b82f6',
                title: 'Houston METRO Park and Ride Locations',
                count: 0,
              };
            }
            legendAccumulator['houston_metro_park_and_ride'].count += locationCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston METRO Park and Ride Locations:', error);
      }

      // Draw Houston METRO Transit Centers as point markers on the map
      try {
        if (enrichments.houston_metro_transit_centers_all && Array.isArray(enrichments.houston_metro_transit_centers_all)) {
          let centerCount = 0;
          enrichments.houston_metro_transit_centers_all.forEach((center: any) => {
            if (center.geometry && center.geometry.x !== undefined && center.geometry.y !== undefined) {
              try {
                // Extract coordinates from geometry (already in WGS84)
                const lat = center.geometry.y;
                const lon = center.geometry.x;
                
                const name = center.name || center.NAME1 || 'Unknown Transit Center';
                const address = center.address || center.ADDRESS || null;
                const parkingSpaces = center.parkingSpaces !== null && center.parkingSpaces !== undefined ? center.parkingSpaces : (center.PSPACES !== null && center.PSPACES !== undefined ? Number(center.PSPACES) : null);
                const busBays = center.busBays !== null && center.busBays !== undefined ? center.busBays : (center.B_BAYS !== null && center.B_BAYS !== undefined ? Number(center.B_BAYS) : null);
                const routesServed = center.routesServed || center.ROUTES_SER || null;
                const transitCenterId = center.transitCenterId !== null && center.transitCenterId !== undefined ? center.transitCenterId : (center.TRANCTR_ID !== null && center.TRANCTR_ID !== undefined ? Number(center.TRANCTR_ID) : null);
                const busStopId = center.busStopId !== null && center.busStopId !== undefined ? center.busStopId : (center.BusStopID !== null && center.BusStopID !== undefined ? Number(center.BusStopID) : null);
                const distance = center.distance_miles !== null && center.distance_miles !== undefined ? center.distance_miles : 0;
                
                // Create marker with transit icon
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚇', '#8b5cf6')
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚇 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${transitCenterId !== null && transitCenterId !== undefined ? `<div><strong>Transit Center ID:</strong> ${transitCenterId}</div>` : ''}
                      ${busBays !== null && busBays !== undefined ? `<div><strong>Bus Bays:</strong> ${busBays}</div>` : ''}
                      ${parkingSpaces !== null && parkingSpaces !== undefined ? `<div><strong>Parking Spaces:</strong> ${parkingSpaces}</div>` : ''}
                      ${routesServed ? `<div><strong>Routes Served:</strong> ${routesServed}</div>` : ''}
                      ${busStopId !== null && busStopId !== undefined ? `<div><strong>Bus Stop ID:</strong> ${busStopId}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all center attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME1', 'name2', 'NAME2', 'address', 'ADDRESS', 'parkingSpaces', 'PSPACES', 'busBays', 'B_BAYS', 'routesServed', 'ROUTES_SER', 'transitCenterId', 'TRANCTR_ID', 'busStopId', 'BusStopID'];
                Object.entries(center).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                centerCount++;
              } catch (error) {
                console.error('Error drawing Houston METRO Transit Center marker:', error);
              }
            }
          });
          
          if (centerCount > 0) {
            if (!legendAccumulator['houston_metro_transit_centers']) {
              legendAccumulator['houston_metro_transit_centers'] = {
                icon: '🚇',
                color: '#8b5cf6',
                title: 'Houston METRO Transit Centers',
                count: 0,
              };
            }
            legendAccumulator['houston_metro_transit_centers'].count += centerCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston METRO Transit Centers:', error);
      }

      // Draw Houston Bikeways as polylines on the map
      try {
        if (enrichments.houston_bikeways_all && Array.isArray(enrichments.houston_bikeways_all)) {
          let bikewayCount = 0;
          enrichments.houston_bikeways_all.forEach((bikeway: any) => {
            if (bikeway.geometry && bikeway.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = bikeway.geometry.paths;
                if (paths && paths.length > 0) {
                  bikewayCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const bikewayName = bikeway.bikewayName || bikeway.NAME || bikeway.name || bikeway.NAME1 || bikeway.name1 || bikeway.BIKEWAY_NAME || bikeway.bikeway_name || bikeway.STREET_NAME || bikeway.street_name || 'Unknown Bikeway';
                    const bikewayType = bikeway.bikewayType || bikeway.TYPE || bikeway.type || bikeway.BIKEWAY_TYPE || bikeway.bikeway_type || bikeway.TYPE_DESC || bikeway.type_desc || '';
                    const distance = bikeway.distance_miles !== null && bikeway.distance_miles !== undefined ? bikeway.distance_miles : 0;

                    // Create polyline with teal/cyan color for bikeways
                    const polyline = L.polyline(latlngs, {
                      color: '#14b8a6', // Teal/cyan color for bikeways (distinct from bus routes)
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with bikeway information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚴 ${bikewayName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${bikewayType ? `<div><strong>Bikeway Type:</strong> ${bikewayType}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all bikeway attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'bikewayName', 'NAME', 'name', 'NAME1', 'name1', 'BIKEWAY_NAME', 'bikeway_name', 'STREET_NAME', 'street_name', 'bikewayType', 'TYPE', 'type', 'BIKEWAY_TYPE', 'bikeway_type', 'TYPE_DESC', 'type_desc'];
                    Object.entries(bikeway).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing Houston Bikeways polyline:', error);
              }
            }
          });
          
          if (bikewayCount > 0) {
            if (!legendAccumulator['houston_bikeways']) {
              legendAccumulator['houston_bikeways'] = {
                icon: '🚴',
                color: '#14b8a6',
                title: 'Houston Bikeways (Existing)',
                count: 0,
              };
            }
            legendAccumulator['houston_bikeways'].count += bikewayCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Bikeways:', error);
      }

      // Draw BLM National GTLF Public Managed Trails as polylines on the map
      try {
        if (enrichments.blm_national_trails_all && Array.isArray(enrichments.blm_national_trails_all)) {
          let trailCount = 0;
          enrichments.blm_national_trails_all.forEach((trail: any) => {
            if (trail.geometry && trail.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = trail.geometry.paths;
                if (paths && paths.length > 0) {
                  trailCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = trail.routeName || trail.ROUTE_PRMRY_NM || trail.Route_Prmry_Nm || 'Unknown Trail';
                    const adminState = trail.adminState || trail.ADMIN_ST || trail.Admin_St || '';
                    const assetClass = trail.assetClass || trail.PLAN_ASSET_CLASS || trail.Plan_Asset_Class || '';
                    const modeTransport = trail.modeTransport || trail.PLAN_MODE_TRNSPRT || trail.Plan_Mode_Trnsprt || '';
                    const routeUseClass = trail.routeUseClass || trail.OBSRVE_ROUTE_USE_CLASS || trail.Obsrve_Route_Use_Class || '';
                    const gisMiles = trail.gisMiles !== null && trail.gisMiles !== undefined ? trail.gisMiles : null;
                    const distance = trail.distance_miles !== null && trail.distance_miles !== undefined ? trail.distance_miles : 0;

                    // Create polyline with green color for BLM trails
                    const polyline = L.polyline(latlngs, {
                      color: '#059669', // Green color for BLM trails
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with trail information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🥾 ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                          ${assetClass ? `<div><strong>Asset Class:</strong> ${assetClass}</div>` : ''}
                          ${modeTransport ? `<div><strong>Mode:</strong> ${modeTransport}</div>` : ''}
                          ${routeUseClass ? `<div><strong>Use Class:</strong> ${routeUseClass}</div>` : ''}
                          ${gisMiles !== null && gisMiles !== undefined ? `<div><strong>Length:</strong> ${gisMiles.toFixed(2)} miles</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all trail attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'routeName', 'ROUTE_PRMRY_NM', 'Route_Prmry_Nm', 'adminState', 'ADMIN_ST', 'Admin_St', 'assetClass', 'PLAN_ASSET_CLASS', 'Plan_Asset_Class', 'modeTransport', 'PLAN_MODE_TRNSPRT', 'Plan_Mode_Trnsprt', 'routeUseClass', 'OBSRVE_ROUTE_USE_CLASS', 'Obsrve_Route_Use_Class', 'gisMiles', 'GIS_MILES', 'blmMiles', 'BLM_MILES'];
                    Object.entries(trail).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing BLM National Trail polyline:', error);
              }
            }
          });
          
          if (trailCount > 0) {
            if (!legendAccumulator['blm_national_trails']) {
              legendAccumulator['blm_national_trails'] = {
                icon: '🥾',
                color: '#059669',
                title: 'BLM National GTLF Public Managed Trails',
                count: 0,
              };
            }
            legendAccumulator['blm_national_trails'].count += trailCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Trails:', error);
      }

      // Draw BLM National GTLF Public Motorized Trails as polylines on the map
      try {
        if (enrichments.blm_national_motorized_trails_all && Array.isArray(enrichments.blm_national_motorized_trails_all)) {
          let trailCount = 0;
          enrichments.blm_national_motorized_trails_all.forEach((trail: any) => {
            if (trail.geometry && trail.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = trail.geometry.paths;
                if (paths && paths.length > 0) {
                  trailCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = trail.routeName || trail.ROUTE_PRMRY_NM || trail.Route_Prmry_Nm || 'Unknown Motorized Trail';
                    const adminState = trail.adminState || trail.ADMIN_ST || trail.Admin_St || '';
                    const assetClass = trail.assetClass || trail.PLAN_ASSET_CLASS || trail.Plan_Asset_Class || '';
                    const modeTransport = trail.modeTransport || trail.PLAN_MODE_TRNSPRT || trail.Plan_Mode_Trnsprt || '';
                    const routeUseClass = trail.routeUseClass || trail.OBSRVE_ROUTE_USE_CLASS || trail.Obsrve_Route_Use_Class || '';
                    const ohvRouteDesignation = trail.ohvRouteDesignation || trail.PLAN_OHV_ROUTE_DSGNTN || trail.Plan_Ohv_Route_Dsgntn || '';
                    const gisMiles = trail.gisMiles !== null && trail.gisMiles !== undefined ? trail.gisMiles : null;
                    const distance = trail.distance_miles !== null && trail.distance_miles !== undefined ? trail.distance_miles : 0;

                    // Create polyline with red color for motorized trails
                    const polyline = L.polyline(latlngs, {
                      color: '#dc2626', // Red color for motorized trails
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with trail information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🏍️ ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                          ${assetClass ? `<div><strong>Asset Class:</strong> ${assetClass}</div>` : ''}
                          ${modeTransport ? `<div><strong>Mode:</strong> ${modeTransport}</div>` : ''}
                          ${routeUseClass ? `<div><strong>Use Class:</strong> ${routeUseClass}</div>` : ''}
                          ${ohvRouteDesignation ? `<div><strong>OHV Route Designation:</strong> ${ohvRouteDesignation}</div>` : ''}
                          ${gisMiles !== null && gisMiles !== undefined ? `<div><strong>Length:</strong> ${gisMiles.toFixed(2)} miles</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all trail attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'routeName', 'ROUTE_PRMRY_NM', 'Route_Prmry_Nm', 'adminState', 'ADMIN_ST', 'Admin_St', 'assetClass', 'PLAN_ASSET_CLASS', 'Plan_Asset_Class', 'modeTransport', 'PLAN_MODE_TRNSPRT', 'Plan_Mode_Trnsprt', 'routeUseClass', 'OBSRVE_ROUTE_USE_CLASS', 'Obsrve_Route_Use_Class', 'ohvRouteDesignation', 'PLAN_OHV_ROUTE_DSGNTN', 'Plan_Ohv_Route_Dsgntn', 'gisMiles', 'GIS_MILES', 'blmMiles', 'BLM_MILES'];
                    Object.entries(trail).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing BLM National Motorized Trail polyline:', error);
              }
            }
          });
          
          if (trailCount > 0) {
            if (!legendAccumulator['blm_national_motorized_trails']) {
              legendAccumulator['blm_national_motorized_trails'] = {
                icon: '🏍️',
                color: '#dc2626',
                title: 'BLM National GTLF Public Motorized Trails',
                count: 0,
              };
            }
            legendAccumulator['blm_national_motorized_trails'].count += trailCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Motorized Trails:', error);
      }

      // Draw BLM National GTLF Public Nonmotorized Trails as polylines on the map
      try {
        if (enrichments.blm_national_nonmotorized_trails_all && Array.isArray(enrichments.blm_national_nonmotorized_trails_all)) {
          let trailCount = 0;
          enrichments.blm_national_nonmotorized_trails_all.forEach((trail: any) => {
            if (trail.geometry && trail.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = trail.geometry.paths;
                if (paths && paths.length > 0) {
                  trailCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = trail.routeName || trail.ROUTE_PRMRY_NM || trail.Route_Prmry_Nm || 'Unknown Nonmotorized Trail';
                    const adminState = trail.adminState || trail.ADMIN_ST || trail.Admin_St || '';
                    const assetClass = trail.assetClass || trail.PLAN_ASSET_CLASS || trail.Plan_Asset_Class || '';
                    const modeTransport = trail.modeTransport || trail.PLAN_MODE_TRNSPRT || trail.Plan_Mode_Trnsprt || '';
                    const routeUseClass = trail.routeUseClass || trail.OBSRVE_ROUTE_USE_CLASS || trail.Obsrve_Route_Use_Class || '';
                    const ohvRouteDesignation = trail.ohvRouteDesignation || trail.PLAN_OHV_ROUTE_DSGNTN || trail.Plan_Ohv_Route_Dsgntn || '';
                    const gisMiles = trail.gisMiles !== null && trail.gisMiles !== undefined ? trail.gisMiles : null;
                    const distance = trail.distance_miles !== null && trail.distance_miles !== undefined ? trail.distance_miles : 0;

                    // Create polyline with green color for nonmotorized trails
                    const polyline = L.polyline(latlngs, {
                      color: '#10b981', // Green color for nonmotorized trails
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with trail information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚶 ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                          ${assetClass ? `<div><strong>Asset Class:</strong> ${assetClass}</div>` : ''}
                          ${modeTransport ? `<div><strong>Mode:</strong> ${modeTransport}</div>` : ''}
                          ${routeUseClass ? `<div><strong>Use Class:</strong> ${routeUseClass}</div>` : ''}
                          ${ohvRouteDesignation ? `<div><strong>OHV Route Designation:</strong> ${ohvRouteDesignation}</div>` : ''}
                          ${gisMiles !== null && gisMiles !== undefined ? `<div><strong>Length:</strong> ${gisMiles.toFixed(2)} miles</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all trail attributes (excluding internal fields)
                    const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'routeName', 'ROUTE_PRMRY_NM', 'Route_Prmry_Nm', 'adminState', 'ADMIN_ST', 'Admin_St', 'assetClass', 'PLAN_ASSET_CLASS', 'Plan_Asset_Class', 'modeTransport', 'PLAN_MODE_TRNSPRT', 'Plan_Mode_Trnsprt', 'routeUseClass', 'OBSRVE_ROUTE_USE_CLASS', 'Obsrve_Route_Use_Class', 'ohvRouteDesignation', 'PLAN_OHV_ROUTE_DSGNTN', 'Plan_Ohv_Route_Dsgntn', 'gisMiles', 'GIS_MILES', 'blmMiles', 'BLM_MILES'];
                    Object.entries(trail).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing BLM National Nonmotorized Trail polyline:', error);
              }
            }
          });
          
          if (trailCount > 0) {
            if (!legendAccumulator['blm_national_nonmotorized_trails']) {
              legendAccumulator['blm_national_nonmotorized_trails'] = {
                icon: '🚶',
                color: '#10b981',
                title: 'BLM National GTLF Public Nonmotorized Trails',
                count: 0,
              };
            }
            legendAccumulator['blm_national_nonmotorized_trails'].count += trailCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Nonmotorized Trails:', error);
      }

      // Draw BLM National GTLF Limited Public Motorized Roads as polylines on the map
      try {
        if (enrichments.blm_national_limited_motorized_roads_all && Array.isArray(enrichments.blm_national_limited_motorized_roads_all)) {
          let roadCount = 0;
          enrichments.blm_national_limited_motorized_roads_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = road.geometry.paths;
                if (paths && paths.length > 0) {
                  roadCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = road.routePrimaryName || road.ROUTE_PRMRY_NM || road.Route_Prmry_Nm || 'Unknown Road';
                    const adminState = road.adminState || road.ADMIN_ST || road.Admin_St || '';
                    const planAssetClass = road.planAssetClass || road.PLAN_ASSET_CLASS || road.Plan_Asset_Class || '';
                    const planModeTransport = road.planModeTransport || road.PLAN_MODE_TRNSPRT || road.Plan_Mode_Trnsprt || '';
                    const observeRouteUseClass = road.observeRouteUseClass || road.OBSRVE_ROUTE_USE_CLASS || road.Obsrve_Route_Use_Class || '';
                    const planOhvRouteDsgntn = road.planOhvRouteDsgntn || road.PLAN_OHV_ROUTE_DSGNTN || road.Plan_Ohv_Route_Dsgntn || '';
                    const gisMiles = road.gisMiles !== null && road.gisMiles !== undefined ? road.gisMiles : null;
                    const distance = road.distance_miles !== null && road.distance_miles !== undefined ? road.distance_miles : 0;

                    // Create polyline with orange color for limited motorized roads
                    const polyline = L.polyline(latlngs, {
                      color: '#ea580c', // Orange color for limited motorized roads
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with road information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                          ${planAssetClass ? `<div><strong>Asset Class:</strong> ${planAssetClass}</div>` : ''}
                          ${planModeTransport ? `<div><strong>Mode:</strong> ${planModeTransport}</div>` : ''}
                          ${observeRouteUseClass ? `<div><strong>Use Class:</strong> ${observeRouteUseClass}</div>` : ''}
                          ${planOhvRouteDsgntn ? `<div><strong>OHV Route Designation:</strong> ${planOhvRouteDsgntn}</div>` : ''}
                          ${gisMiles !== null && gisMiles !== undefined ? `<div><strong>Length:</strong> ${gisMiles.toFixed(2)} miles</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                      </div>
                    `;

                    polyline.bindPopup(popupContent);
                    polyline.addTo(map);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing BLM Limited Motorized Road polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['blm_national_limited_motorized_roads']) {
              legendAccumulator['blm_national_limited_motorized_roads'] = {
                icon: '🛣️',
                color: '#ea580c',
                title: 'BLM National GTLF Limited Public Motorized Roads',
                count: 0,
              };
            }
            legendAccumulator['blm_national_limited_motorized_roads'].count += roadCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Limited Motorized Roads:', error);
      }

      // Draw BLM National GTLF Public Motorized Roads as polylines on the map
      try {
        if (enrichments.blm_national_public_motorized_roads_all && Array.isArray(enrichments.blm_national_public_motorized_roads_all)) {
          let roadCount = 0;
          enrichments.blm_national_public_motorized_roads_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = road.geometry.paths;
                if (paths && paths.length > 0) {
                  roadCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry paths are in [x, y] format (lon, lat) in WGS84
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = road.routePrimaryName || road.ROUTE_PRMRY_NM || road.Route_Prmry_Nm || 'Unknown Road';
                    const adminState = road.adminState || road.ADMIN_ST || road.Admin_St || '';
                    const planAssetClass = road.planAssetClass || road.PLAN_ASSET_CLASS || road.Plan_Asset_Class || '';
                    const planModeTransport = road.planModeTransport || road.PLAN_MODE_TRNSPRT || road.Plan_Mode_Trnsprt || '';
                    const observeRouteUseClass = road.observeRouteUseClass || road.OBSRVE_ROUTE_USE_CLASS || road.Obsrve_Route_Use_Class || '';
                    const planOhvRouteDsgntn = road.planOhvRouteDsgntn || road.PLAN_OHV_ROUTE_DSGNTN || road.Plan_Ohv_Route_Dsgntn || '';
                    const gisMiles = road.gisMiles !== null && road.gisMiles !== undefined ? road.gisMiles : null;
                    const distance = road.distance_miles !== null && road.distance_miles !== undefined ? road.distance_miles : 0;

                    // Create polyline with lighter orange color for public motorized roads
                    const polyline = L.polyline(latlngs, {
                      color: '#f97316', // Lighter orange color for public motorized roads
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with road information
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                          ${planAssetClass ? `<div><strong>Asset Class:</strong> ${planAssetClass}</div>` : ''}
                          ${planModeTransport ? `<div><strong>Mode:</strong> ${planModeTransport}</div>` : ''}
                          ${observeRouteUseClass ? `<div><strong>Use Class:</strong> ${observeRouteUseClass}</div>` : ''}
                          ${planOhvRouteDsgntn ? `<div><strong>OHV Route Designation:</strong> ${planOhvRouteDsgntn}</div>` : ''}
                          ${gisMiles !== null && gisMiles !== undefined ? `<div><strong>Length:</strong> ${gisMiles.toFixed(2)} miles</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                      </div>
                    `;

                    polyline.bindPopup(popupContent);
                    polyline.addTo(map);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing BLM Public Motorized Road polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['blm_national_public_motorized_roads']) {
              legendAccumulator['blm_national_public_motorized_roads'] = {
                icon: '🛣️',
                color: '#f97316',
                title: 'BLM National GTLF Public Motorized Roads',
                count: 0,
              };
            }
            legendAccumulator['blm_national_public_motorized_roads'].count += roadCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Public Motorized Roads:', error);
      }

      // Draw BLM National Grazing Pasture Polygons as polygons on the map
      try {
        if (enrichments.blm_national_grazing_pastures_all && Array.isArray(enrichments.blm_national_grazing_pastures_all)) {
          let pastureCount = 0;
          enrichments.blm_national_grazing_pastures_all.forEach((pasture: any) => {
            if (pasture.geometry && pasture.geometry.rings && Array.isArray(pasture.geometry.rings)) {
              try {
                const rings = pasture.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM Grazing Pasture polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = pasture.isContaining;
                  const color = isContaining ? '#a16207' : '#ca8a04'; // Brown/tan for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const pastureName = pasture.pastureName || pasture.PAST_NAME || pasture.Past_Name || 'Unknown Pasture';
                  const allotName = pasture.allotName || pasture.ALLOT_NAME || pasture.Allot_Name || null;
                  const allotNumber = pasture.allotNumber || pasture.ALLOT_NO || pasture.Allot_No || null;
                  const pastureNumber = pasture.pastureNumber || pasture.PAST_NO || pasture.Past_No || null;
                  const gisAcres = pasture.gisAcres !== null && pasture.gisAcres !== undefined ? pasture.gisAcres : null;
                  const adminState = pasture.adminState || pasture.ADMIN_ST || pasture.Admin_St || null;
                  const pastureId = pasture.objectId || pasture.OBJECTID || pasture.objectid || null;
                  const distance = pasture.distance_miles !== null && pasture.distance_miles !== undefined ? pasture.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐄 ${pastureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${allotName ? `<div><strong>Allotment:</strong> ${allotName}</div>` : ''}
                        ${allotNumber ? `<div><strong>Allotment Number:</strong> ${allotNumber}</div>` : ''}
                        ${pastureNumber ? `<div><strong>Pasture Number:</strong> ${pastureNumber}</div>` : ''}
                        ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>Acres:</strong> ${gisAcres.toFixed(2)}</div>` : ''}
                        ${pastureId ? `<div><strong>Pasture ID:</strong> ${pastureId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all pasture attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'pastureName', 'PAST_NAME', 'Past_Name', 'allotName', 'ALLOT_NAME', 'Allot_Name', 'allotNumber', 'ALLOT_NO', 'Allot_No', 'pastureNumber', 'PAST_NO', 'Past_No', 'gisAcres', 'GIS_ACRES', 'adminState', 'ADMIN_ST', 'Admin_St'];
                  Object.entries(pasture).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  pastureCount++;
                }
              } catch (error) {
                console.error('Error drawing BLM Grazing Pasture polygon:', error);
              }
            }
          });
          
          if (pastureCount > 0) {
            if (!legendAccumulator['blm_national_grazing_pastures']) {
              legendAccumulator['blm_national_grazing_pastures'] = {
                icon: '🐄',
                color: '#a16207',
                title: 'BLM National Grazing Pasture Polygons',
                count: 0,
              };
            }
            legendAccumulator['blm_national_grazing_pastures'].count += pastureCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Grazing Pasture Polygons:', error);
      }

      // Draw BLM National Areas of Critical Environmental Concern as polygons on the map
      try {
        if (enrichments.blm_national_acec_all && Array.isArray(enrichments.blm_national_acec_all)) {
          let acecCount = 0;
          enrichments.blm_national_acec_all.forEach((acec: any) => {
            if (acec.geometry && acec.geometry.rings && Array.isArray(acec.geometry.rings)) {
              try {
                const rings = acec.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM ACEC polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = acec.isContaining;
                  const color = isContaining ? '#16a34a' : '#22c55e'; // Green for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const acecName = acec.acecName || acec.ACEC_NAME || acec.Acec_Name || 'Unknown ACEC';
                  const lupName = acec.lupName || acec.LUP_NAME || acec.Lup_Name || null;
                  const nepaNum = acec.nepaNum || acec.NEPA_NUM || acec.Nepa_Num || null;
                  const rodDate = acec.rodDate || acec.ROD_DATE || null;
                  const gisAcres = acec.gisAcres !== null && acec.gisAcres !== undefined ? acec.gisAcres : null;
                  const adminState = acec.adminState || acec.ADMIN_ST || acec.Admin_St || null;
                  const acecId = acec.objectId || acec.OBJECTID || acec.objectid || null;
                  const distance = acec.distance_miles !== null && acec.distance_miles !== undefined ? acec.distance_miles : 0;
                  
                  // Build relevance flags
                  const relevanceFlags: string[] = [];
                  if (acec.relevanceCultural === 'YES') relevanceFlags.push('Cultural');
                  if (acec.relevanceForestry === 'YES') relevanceFlags.push('Forestry');
                  if (acec.relevanceHistoric === 'YES') relevanceFlags.push('Historic');
                  if (acec.relevanceNaturalHazards === 'YES') relevanceFlags.push('Natural Hazards');
                  if (acec.relevanceNaturalProcesses === 'YES') relevanceFlags.push('Natural Processes');
                  if (acec.relevanceNaturalSystems === 'YES') relevanceFlags.push('Natural Systems');
                  if (acec.relevanceScenic === 'YES') relevanceFlags.push('Scenic');
                  if (acec.relevanceWildlife === 'YES') relevanceFlags.push('Wildlife');
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌿 ${acecName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${lupName ? `<div><strong>Land Use Plan:</strong> ${lupName}</div>` : ''}
                        ${nepaNum ? `<div><strong>NEPA Number:</strong> ${nepaNum}</div>` : ''}
                        ${rodDate ? `<div><strong>ROD Date:</strong> ${rodDate}</div>` : ''}
                        ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>Acres:</strong> ${gisAcres.toFixed(2)}</div>` : ''}
                        ${acecId ? `<div><strong>ACEC ID:</strong> ${acecId}</div>` : ''}
                        ${relevanceFlags.length > 0 ? `<div><strong>Relevance:</strong> ${relevanceFlags.join(', ')}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  acecCount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM ACEC polygon:', error);
              }
            }
          });
          
          if (acecCount > 0) {
            if (!legendAccumulator['blm_national_acec']) {
              legendAccumulator['blm_national_acec'] = {
                icon: '🌿',
                color: '#16a34a',
                title: 'BLM National Areas of Critical Environmental Concern',
                count: 0,
              };
            }
            legendAccumulator['blm_national_acec'].count += acecCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Areas of Critical Environmental Concern:', error);
      }

      // Draw BLM National Sheep and Goat Billed Grazing Allotments as polygons on the map
      try {
        if (enrichments.blm_national_sheep_goat_grazing_all && Array.isArray(enrichments.blm_national_sheep_goat_grazing_all)) {
          let allotmentCount = 0;
          enrichments.blm_national_sheep_goat_grazing_all.forEach((allotment: any) => {
            if (allotment.geometry && allotment.geometry.rings && Array.isArray(allotment.geometry.rings)) {
              try {
                const rings = allotment.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM Sheep/Goat Billed Grazing Allotment polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = allotment.isContaining;
                  const color = isContaining ? '#ca8a04' : '#eab308'; // Orange/tan for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const allotName = allotment.allotName || allotment.ALLOT_NAME || allotment.Allot_Name || 'Unknown Allotment';
                  const stateAllotNum = allotment.stateAllotNum || allotment.ST_ALLOT_NUM || allotment.St_Allot_Num || null;
                  const status = allotment.status || allotment.Status || null;
                  const sumAcres = allotment.sumAcres !== null && allotment.sumAcres !== undefined ? allotment.sumAcres : null;
                  const allotId = allotment.objectId || allotment.OBJECTID || allotment.objectid || null;
                  const distance = allotment.distance_miles !== null && allotment.distance_miles !== undefined ? allotment.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐑 ${allotName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${stateAllotNum ? `<div><strong>State Allotment Number:</strong> ${stateAllotNum}</div>` : ''}
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${sumAcres !== null && sumAcres !== undefined ? `<div><strong>Acres:</strong> ${sumAcres.toFixed(2)}</div>` : ''}
                        ${allotId ? `<div><strong>Allotment ID:</strong> ${allotId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  allotmentCount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM Sheep/Goat Billed Grazing Allotment polygon:', error);
              }
            }
          });
          
          if (allotmentCount > 0) {
            if (!legendAccumulator['blm_national_sheep_goat_grazing']) {
              legendAccumulator['blm_national_sheep_goat_grazing'] = {
                icon: '🐑',
                color: '#ca8a04',
                title: 'BLM National Sheep and Goat Billed Grazing Allotments',
                count: 0,
              };
            }
            legendAccumulator['blm_national_sheep_goat_grazing'].count += allotmentCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Sheep and Goat Billed Grazing Allotments:', error);
      }

      // Draw BLM National Sheep and Goat Authorized Grazing Allotments as polygons on the map
      try {
        if (enrichments.blm_national_sheep_goat_authorized_grazing_all && Array.isArray(enrichments.blm_national_sheep_goat_authorized_grazing_all)) {
          let allotmentCount = 0;
          enrichments.blm_national_sheep_goat_authorized_grazing_all.forEach((allotment: any) => {
            if (allotment.geometry && allotment.geometry.rings && Array.isArray(allotment.geometry.rings)) {
              try {
                const rings = allotment.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM Sheep/Goat Authorized Grazing Allotment polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = allotment.isContaining;
                  const color = isContaining ? '#d97706' : '#f59e0b'; // Orange for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const allotName = allotment.allotName || allotment.ALLOT_NAME || allotment.Allot_Name || 'Unknown Allotment';
                  const stateAllotNum = allotment.stateAllotNum || allotment.ST_ALLOT_NUM || allotment.St_Allot_Num || null;
                  const status = allotment.status || allotment.Status || null;
                  const sumAcres = allotment.sumAcres !== null && allotment.sumAcres !== undefined ? allotment.sumAcres : null;
                  const allotId = allotment.objectId || allotment.OBJECTID || allotment.objectid || null;
                  const distance = allotment.distance_miles !== null && allotment.distance_miles !== undefined ? allotment.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐐 ${allotName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${stateAllotNum ? `<div><strong>State Allotment Number:</strong> ${stateAllotNum}</div>` : ''}
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${sumAcres !== null && sumAcres !== undefined ? `<div><strong>Acres:</strong> ${sumAcres.toFixed(2)}</div>` : ''}
                        ${allotId ? `<div><strong>Allotment ID:</strong> ${allotId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  allotmentCount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM Sheep/Goat Authorized Grazing Allotment polygon:', error);
              }
            }
          });
          
          if (allotmentCount > 0) {
            if (!legendAccumulator['blm_national_sheep_goat_authorized_grazing']) {
              legendAccumulator['blm_national_sheep_goat_authorized_grazing'] = {
                icon: '🐐',
                color: '#d97706',
                title: 'BLM National Sheep and Goat Authorized Grazing Allotments',
                count: 0,
              };
            }
            legendAccumulator['blm_national_sheep_goat_authorized_grazing'].count += allotmentCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Sheep and Goat Authorized Grazing Allotments:', error);
      }

      // Draw BLM National NLCS National Monuments and National Conservation Areas as polygons on the map
      try {
        if (enrichments.blm_national_nlcs_monuments_ncas_all && Array.isArray(enrichments.blm_national_nlcs_monuments_ncas_all)) {
          let monumentNCACount = 0;
          enrichments.blm_national_nlcs_monuments_ncas_all.forEach((monumentNCA: any) => {
            if (monumentNCA.geometry && monumentNCA.geometry.rings && Array.isArray(monumentNCA.geometry.rings)) {
              try {
                const rings = monumentNCA.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM NLCS Monument/NCA polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = monumentNCA.isContaining;
                  const color = isContaining ? '#9333ea' : '#a855f7'; // Purple for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const ncaName = monumentNCA.ncaName || monumentNCA.NCA_NAME || monumentNCA.Nca_Name || null;
                  const label = monumentNCA.label || monumentNCA.Label || null;
                  const displayName = ncaName || label || 'Unknown Monument/NCA';
                  const smaCode = monumentNCA.smaCode || monumentNCA.sma_code || monumentNCA.SMA_CODE || null;
                  const stateAdmin = monumentNCA.stateAdmin || monumentNCA.STATE_ADMN || monumentNCA.State_Admn || null;
                  const nlcsId = monumentNCA.nlcsId || monumentNCA.NLCS_ID || monumentNCA.Nlcs_Id || null;
                  const monumentNCAId = monumentNCA.objectId || monumentNCA.OBJECTID || monumentNCA.objectid || null;
                  const distance = monumentNCA.distance_miles !== null && monumentNCA.distance_miles !== undefined ? monumentNCA.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ ${displayName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${smaCode ? `<div><strong>Type:</strong> ${smaCode === 'BLM_MON' ? 'National Monument' : smaCode === 'BLM_NCA' ? 'National Conservation Area' : smaCode}</div>` : ''}
                        ${nlcsId ? `<div><strong>NLCS ID:</strong> ${nlcsId}</div>` : ''}
                        ${stateAdmin ? `<div><strong>State:</strong> ${stateAdmin}</div>` : ''}
                        ${monumentNCAId ? `<div><strong>Monument/NCA ID:</strong> ${monumentNCAId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  monumentNCACount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM NLCS Monument/NCA polygon:', error);
              }
            }
          });
          
          if (monumentNCACount > 0) {
            if (!legendAccumulator['blm_national_nlcs_monuments_ncas']) {
              legendAccumulator['blm_national_nlcs_monuments_ncas'] = {
                icon: '🏛️',
                color: '#9333ea',
                title: 'BLM National NLCS National Monuments and National Conservation Areas',
                count: 0,
              };
            }
            legendAccumulator['blm_national_nlcs_monuments_ncas'].count += monumentNCACount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National NLCS National Monuments and National Conservation Areas:', error);
      }

      // Draw BLM National Wild Horse and Burro Herd Areas as polygons on the map
      try {
        if (enrichments.blm_national_wild_horse_burro_herd_areas_all && Array.isArray(enrichments.blm_national_wild_horse_burro_herd_areas_all)) {
          let herdAreaCount = 0;
          enrichments.blm_national_wild_horse_burro_herd_areas_all.forEach((herdArea: any) => {
            if (herdArea.geometry && herdArea.geometry.rings && Array.isArray(herdArea.geometry.rings)) {
              try {
                const rings = herdArea.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM Wild Horse/Burro Herd Area polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = herdArea.isContaining;
                  const color = isContaining ? '#7c2d12' : '#991b1b'; // Dark brown for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const herdAreaName = herdArea.herdAreaName || herdArea.HA_NAME || herdArea.Ha_Name || 'Unknown Herd Area';
                  const herdAreaNumber = herdArea.herdAreaNumber || herdArea.HA_NO || herdArea.Ha_No || null;
                  const herdType = herdArea.herdType || herdArea.HERD_TYPE || herdArea.Herd_Type || null;
                  const adminState = herdArea.adminState || herdArea.ADMIN_ST || herdArea.Admin_St || null;
                  const blmAcres = herdArea.blmAcres !== null && herdArea.blmAcres !== undefined ? herdArea.blmAcres : null;
                  const totalAcres = herdArea.totalAcres !== null && herdArea.totalAcres !== undefined ? herdArea.totalAcres : null;
                  const estHorsePop = herdArea.estHorsePop !== null && herdArea.estHorsePop !== undefined ? herdArea.estHorsePop : null;
                  const estBurroPop = herdArea.estBurroPop !== null && herdArea.estBurroPop !== undefined ? herdArea.estBurroPop : null;
                  const herdAreaId = herdArea.objectId || herdArea.OBJECTID || herdArea.objectid || null;
                  const distance = herdArea.distance_miles !== null && herdArea.distance_miles !== undefined ? herdArea.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐴 ${herdAreaName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${herdAreaNumber ? `<div><strong>Herd Area Number:</strong> ${herdAreaNumber}</div>` : ''}
                        ${herdType ? `<div><strong>Herd Type:</strong> ${herdType}</div>` : ''}
                        ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                        ${blmAcres !== null && blmAcres !== undefined ? `<div><strong>BLM Acres:</strong> ${blmAcres.toLocaleString()}</div>` : ''}
                        ${totalAcres !== null && totalAcres !== undefined ? `<div><strong>Total Acres:</strong> ${totalAcres.toLocaleString()}</div>` : ''}
                        ${estHorsePop !== null && estHorsePop !== undefined ? `<div><strong>Est. Horse Population:</strong> ${estHorsePop}</div>` : ''}
                        ${estBurroPop !== null && estBurroPop !== undefined ? `<div><strong>Est. Burro Population:</strong> ${estBurroPop}</div>` : ''}
                        ${herdAreaId ? `<div><strong>Herd Area ID:</strong> ${herdAreaId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  herdAreaCount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM Wild Horse/Burro Herd Area polygon:', error);
              }
            }
          });
          
          if (herdAreaCount > 0) {
            if (!legendAccumulator['blm_national_wild_horse_burro_herd_areas']) {
              legendAccumulator['blm_national_wild_horse_burro_herd_areas'] = {
                icon: '🐴',
                color: '#7c2d12',
                title: 'BLM National Wild Horse and Burro Herd Areas',
                count: 0,
              };
            }
            legendAccumulator['blm_national_wild_horse_burro_herd_areas'].count += herdAreaCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Wild Horse and Burro Herd Areas:', error);
      }

      // Draw BLM National Recreation Sites as polygons on the map
      try {
        if (enrichments.blm_national_recreation_sites_all && Array.isArray(enrichments.blm_national_recreation_sites_all)) {
          let recreationSiteCount = 0;
          enrichments.blm_national_recreation_sites_all.forEach((site: any) => {
            if (site.geometry && site.geometry.rings && Array.isArray(site.geometry.rings)) {
              try {
                const rings = site.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('BLM Recreation Site polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = site.isContaining;
                  const color = isContaining ? '#059669' : '#10b981'; // Green for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const siteName = site.fetName || site.FET_NAME || site.Fet_Name || 'Unknown Recreation Site';
                  const fetSubtype = site.fetSubtype || site.FET_SUBTYPE || site.Fet_Subtype || null;
                  const fetType = site.fetType !== null && site.fetType !== undefined ? site.fetType : null;
                  const unitName = site.unitName || site.UNIT_NAME || site.Unit_Name || null;
                  const adminState = site.adminState || site.ADMIN_ST || site.Admin_St || null;
                  const gisAcres = site.gisAcres !== null && site.gisAcres !== undefined ? site.gisAcres : null;
                  const description = site.description || site.DESCRIPTION || site.Description || null;
                  const webLink = site.webLink || site.WEB_LINK || site.Web_Link || null;
                  const siteId = site.objectId || site.OBJECTID || site.objectid || null;
                  const distance = site.distance_miles !== null && site.distance_miles !== undefined ? site.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏕️ ${siteName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${fetSubtype ? `<div><strong>Type:</strong> ${fetSubtype}</div>` : ''}
                        ${fetType !== null && fetType !== undefined ? `<div><strong>Feature Type:</strong> ${fetType}</div>` : ''}
                        ${unitName ? `<div><strong>Unit Name:</strong> ${unitName}</div>` : ''}
                        ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>Acres:</strong> ${gisAcres.toFixed(2)}</div>` : ''}
                        ${description ? `<div><strong>Description:</strong> ${description}</div>` : ''}
                        ${webLink ? `<div><strong>Web Link:</strong> <a href="${webLink}" target="_blank" rel="noopener noreferrer">${webLink}</a></div>` : ''}
                        ${siteId ? `<div><strong>Site ID:</strong> ${siteId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  recreationSiteCount++;
                  
                  // Extend map bounds
                  const polygonBounds = polygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM Recreation Site polygon:', error);
              }
            }
          });
          
          if (recreationSiteCount > 0) {
            if (!legendAccumulator['blm_national_recreation_sites']) {
              legendAccumulator['blm_national_recreation_sites'] = {
                icon: '🏕️',
                color: '#059669',
                title: 'BLM National Recreation Site Polygons',
                count: 0,
              };
            }
            legendAccumulator['blm_national_recreation_sites'].count += recreationSiteCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Recreation Sites:', error);
      }

      // Draw BLM National Fire Perimeters as polygons on the map
      try {
        if (enrichments.blm_national_fire_perimeters_all && Array.isArray(enrichments.blm_national_fire_perimeters_all)) {
          let firePerimeterCount = 0;
          enrichments.blm_national_fire_perimeters_all.forEach((perimeter: any) => {
            if (perimeter.geometry && perimeter.geometry.rings && Array.isArray(perimeter.geometry.rings)) {
              try {
                const rings = perimeter.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  // rings[0] is the outer ring, rings[1+] are holes
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('BLM Fire Perimeter outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = perimeter.isContaining;
                  const color = isContaining ? '#dc2626' : '#ef4444'; // Red for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  // L.polygon can handle multiple rings (outer + holes) when passed as array of arrays
                  // First array is outer ring, subsequent arrays are holes
                  const firePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const incidentName = perimeter.incidentName || perimeter.INCDNT_NM || perimeter.Incdnt_Nm || 'Unknown Fire';
                  const fireDiscoveryYear = perimeter.fireDiscoveryYear !== null && perimeter.fireDiscoveryYear !== undefined ? perimeter.fireDiscoveryYear.toString() : null;
                  const fireDiscoveryDate = perimeter.fireDiscoveryDate || perimeter.FIRE_DSCVR_DT || null;
                  const fireControlDate = perimeter.fireControlDate || perimeter.FIRE_CNTRL_DT || null;
                  const fireCauseName = perimeter.fireCauseName || perimeter.FIRE_CAUSE_NM || perimeter.Fire_Cause_Nm || null;
                  const gisAcres = perimeter.gisAcres !== null && perimeter.gisAcres !== undefined ? perimeter.gisAcres : null;
                  const totalReportedAcres = perimeter.totalReportedAcres !== null && perimeter.totalReportedAcres !== undefined ? perimeter.totalReportedAcres : null;
                  const adminState = perimeter.adminState || perimeter.ADMIN_ST || perimeter.Admin_St || null;
                  const complexName = perimeter.complexName || perimeter.CMPLX_NM || perimeter.Cmplx_Nm || null;
                  const uniqueFireId = perimeter.uniqueFireId || perimeter.UNQE_FIRE_ID || perimeter.Unqe_Fire_Id || null;
                  const perimeterId = perimeter.objectId || perimeter.OBJECTID || perimeter.objectid || null;
                  const distance = perimeter.distance_miles !== null && perimeter.distance_miles !== undefined ? perimeter.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🔥 ${incidentName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${fireDiscoveryYear ? `<div><strong>Discovery Year:</strong> ${fireDiscoveryYear}</div>` : ''}
                        ${fireDiscoveryDate ? `<div><strong>Discovery Date:</strong> ${fireDiscoveryDate}</div>` : ''}
                        ${fireControlDate ? `<div><strong>Control Date:</strong> ${fireControlDate}</div>` : ''}
                        ${fireCauseName ? `<div><strong>Cause:</strong> ${fireCauseName}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>GIS Acres:</strong> ${gisAcres.toLocaleString()}</div>` : ''}
                        ${totalReportedAcres !== null && totalReportedAcres !== undefined ? `<div><strong>Total Reported Acres:</strong> ${totalReportedAcres.toLocaleString()}</div>` : ''}
                        ${adminState ? `<div><strong>State:</strong> ${adminState}</div>` : ''}
                        ${complexName ? `<div><strong>Complex Name:</strong> ${complexName}</div>` : ''}
                        ${uniqueFireId ? `<div><strong>Unique Fire ID:</strong> ${uniqueFireId}</div>` : ''}
                        ${perimeterId ? `<div><strong>Perimeter ID:</strong> ${perimeterId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  firePolygon.bindPopup(popupContent);
                  firePolygon.addTo(map);
                  firePerimeterCount++;
                  
                  // Extend map bounds
                  const polygonBounds = firePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM Fire Perimeter polygon:', error);
              }
            }
          });
          
          if (firePerimeterCount > 0) {
            if (!legendAccumulator['blm_national_fire_perimeters']) {
              legendAccumulator['blm_national_fire_perimeters'] = {
                icon: '🔥',
                color: '#dc2626',
                title: 'BLM National Fire Perimeters',
                count: 0,
              };
            }
            legendAccumulator['blm_national_fire_perimeters'].count += firePerimeterCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Fire Perimeters:', error);
      }

      // Draw BLM National Land and Water Conservation Fund (LWCF) Polygons as polygons on the map
      try {
        if (enrichments.blm_national_lwcf_all && Array.isArray(enrichments.blm_national_lwcf_all)) {
          let lwcfCount = 0;
          enrichments.blm_national_lwcf_all.forEach((polygon: any) => {
            if (polygon.geometry && polygon.geometry.rings && Array.isArray(polygon.geometry.rings)) {
              try {
                const rings = polygon.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  // rings[0] is the outer ring, rings[1+] are holes
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('BLM LWCF polygon outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = polygon.isContaining;
                  const color = isContaining ? '#0284c7' : '#38bdf8'; // Blue for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  // L.polygon can handle multiple rings (outer + holes) when passed as array of arrays
                  // First array is outer ring, subsequent arrays are holes
                  const lwcfPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const projectName = polygon.projectName || polygon.Prjt_Name || polygon.Prjt_Name || 'Unknown LWCF Project';
                  const snFull = polygon.snFull || polygon.SN_Full || polygon.Sn_Full || null;
                  const geoState = polygon.geoState || polygon.Geo_State || polygon.Geo_State || null;
                  const refNum = polygon.refNum || polygon.Ref_Num || polygon.Ref_Num || null;
                  const acqFund = polygon.acqFund || polygon.Acq_Fund || polygon.Acq_Fund || null;
                  const fundYear = polygon.fundYear || polygon.Fund_Year || polygon.Fund_Year || null;
                  const purpose = polygon.purpose || polygon.Purpose || polygon.Purpose || null;
                  const areaAcq = polygon.areaAcq !== null && polygon.areaAcq !== undefined ? polygon.areaAcq : null;
                  const paymentMade = polygon.paymentMade || polygon.Pmnt_Made || polygon.Pmnt_Made || null;
                  const acqValue = polygon.acqValue || polygon.Acq_Value || polygon.Acq_Value || null;
                  const deedSignDate = polygon.deedSignDate || polygon.Deed_Sign || null;
                  const countyRec = polygon.countyRec || polygon.County_Rec || polygon.County_Rec || null;
                  const administratingAgency = polygon.administratingAgency || polygon.Administrating_Agency || polygon.Administrating_Agency || null;
                  const caseId = polygon.caseId !== null && polygon.caseId !== undefined ? polygon.caseId.toString() : null;
                  const distance = polygon.distance_miles !== null && polygon.distance_miles !== undefined ? polygon.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        💧 ${projectName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${snFull ? `<div><strong>Serial Number:</strong> ${snFull}</div>` : ''}
                        ${caseId ? `<div><strong>Case ID:</strong> ${caseId}</div>` : ''}
                        ${geoState ? `<div><strong>State:</strong> ${geoState}</div>` : ''}
                        ${refNum ? `<div><strong>Reference Number:</strong> ${refNum}</div>` : ''}
                        ${acqFund ? `<div><strong>Acquisition Fund:</strong> ${acqFund}</div>` : ''}
                        ${fundYear ? `<div><strong>Fund Year:</strong> ${fundYear}</div>` : ''}
                        ${purpose ? `<div><strong>Purpose:</strong> ${purpose}</div>` : ''}
                        ${areaAcq !== null && areaAcq !== undefined ? `<div><strong>Area Acquired:</strong> ${areaAcq.toFixed(2)} acres</div>` : ''}
                        ${paymentMade ? `<div><strong>Payment Made:</strong> ${paymentMade}</div>` : ''}
                        ${acqValue ? `<div><strong>Acquisition Value:</strong> ${acqValue}</div>` : ''}
                        ${deedSignDate ? `<div><strong>Deed Signed:</strong> ${deedSignDate}</div>` : ''}
                        ${countyRec ? `<div><strong>County:</strong> ${countyRec}</div>` : ''}
                        ${administratingAgency ? `<div><strong>Administering Agency:</strong> ${administratingAgency}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  lwcfPolygon.bindPopup(popupContent);
                  lwcfPolygon.addTo(map);
                  lwcfCount++;
                  
                  // Extend map bounds
                  const polygonBounds = lwcfPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing BLM LWCF polygon:', error);
              }
            }
          });
          
          if (lwcfCount > 0) {
            if (!legendAccumulator['blm_national_lwcf']) {
              legendAccumulator['blm_national_lwcf'] = {
                icon: '💧',
                color: '#0284c7',
                title: 'BLM National Land and Water Conservation Fund (LWCF) Polygons',
                count: 0,
              };
            }
            legendAccumulator['blm_national_lwcf'].count += lwcfCount;
          }
        }
      } catch (error) {
        console.error('Error processing BLM National Land and Water Conservation Fund (LWCF) Polygons:', error);
      }

      // Draw USFS Forest Boundaries as polygons on the map
      try {
        if (enrichments.usfs_forest_boundaries_all && Array.isArray(enrichments.usfs_forest_boundaries_all)) {
          let forestCount = 0;
          enrichments.usfs_forest_boundaries_all.forEach((forest: any) => {
            if (forest.geometry && forest.geometry.rings && Array.isArray(forest.geometry.rings)) {
              try {
                const rings = forest.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  // rings[0] is the outer ring, rings[1+] are holes
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Forest Boundary outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = forest.isContaining;
                  const color = isContaining ? '#166534' : '#22c55e'; // Dark green for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  // L.polygon can handle multiple rings (outer + holes) when passed as array of arrays
                  // First array is outer ring, subsequent arrays are holes
                  const forestPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const forestName = forest.forestName || forest.FORESTNAME || forest.ForestName || forest.FOREST_NM || forest.Forest_Nm || 'Unknown Forest';
                  const forestCode = forest.forestCode || forest.FORESTCODE || forest.ForestCode || forest.FOREST_CD || forest.Forest_Cd || null;
                  const regionCode = forest.regionCode || forest.REGIONCODE || forest.RegionCode || forest.REGION_CD || forest.Region_Cd || null;
                  const regionName = forest.regionName || forest.REGIONNAME || forest.RegionName || forest.REGION_NM || forest.Region_Nm || null;
                  const forestId = forest.objectId || forest.OBJECTID || forest.objectid || null;
                  const distance = forest.distance_miles !== null && forest.distance_miles !== undefined ? forest.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌲 ${forestName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${forestCode ? `<div><strong>Forest Code:</strong> ${forestCode}</div>` : ''}
                        ${regionName ? `<div><strong>Region:</strong> ${regionName}</div>` : ''}
                        ${regionCode ? `<div><strong>Region Code:</strong> ${regionCode}</div>` : ''}
                        ${forestId ? `<div><strong>Forest ID:</strong> ${forestId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  forestPolygon.bindPopup(popupContent);
                  forestPolygon.addTo(map);
                  forestCount++;
                  
                  // Extend map bounds
                  const polygonBounds = forestPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Forest Boundary polygon:', error);
              }
            }
          });
          
          if (forestCount > 0) {
            if (!legendAccumulator['usfs_forest_boundaries']) {
              legendAccumulator['usfs_forest_boundaries'] = {
                icon: '🌲',
                color: '#166534',
                title: 'USFS Forest Boundaries',
                count: 0,
              };
            }
            legendAccumulator['usfs_forest_boundaries'].count += forestCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Forest Boundaries:', error);
      }

      // Draw Chinook Salmon Ranges as polygons on the map
      try {
        if (enrichments.chinook_salmon_ranges_all && Array.isArray(enrichments.chinook_salmon_ranges_all)) {
          let salmonCount = 0;
          enrichments.chinook_salmon_ranges_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings && Array.isArray(range.geometry.rings)) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('Chinook Salmon Range outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const color = '#0ea5e9'; // Blue color for salmon ranges
                  const weight = 3;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const salmonPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const esuDps = range.esu_dps || range.ESU_DPS || null;
                  const status = range.status || range.Status || null;
                  const classValue = range.class || range.Class || null;
                  const isContaining = range.isContaining || false;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐟 Chinook Salmon Range
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${esuDps ? `<div><strong>ESU/DPS:</strong> ${esuDps}</div>` : ''}
                        ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                        ${classValue ? `<div><strong>Class:</strong> ${classValue}</div>` : ''}
                        ${isContaining ? '<div><strong>Location Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  salmonPolygon.bindPopup(popupContent, { maxWidth: 400 });
                  salmonPolygon.addTo(primary);
                  
                  // Extend map bounds
                  const polygonBounds = salmonPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  salmonCount++;
                }
              } catch (error) {
                console.error('Error drawing Chinook Salmon Range polygon:', error);
              }
            }
          });
          
          if (salmonCount > 0) {
            if (!legendAccumulator['chinook_salmon_ranges']) {
              legendAccumulator['chinook_salmon_ranges'] = {
                icon: '🐟',
                color: '#0ea5e9',
                title: 'Chinook Salmon Ranges',
                count: 0,
              };
            }
            legendAccumulator['chinook_salmon_ranges'].count += salmonCount;
          }
        }
      } catch (error) {
        console.error('Error processing Chinook Salmon Ranges:', error);
      }

      // Draw TX School Districts 2024 as polygons on the map
      try {
        if (enrichments.tx_school_districts_2024_all && Array.isArray(enrichments.tx_school_districts_2024_all)) {
          let districtCount = 0;
          enrichments.tx_school_districts_2024_all.forEach((district: any) => {
            if (district.geometry && district.geometry.rings && Array.isArray(district.geometry.rings)) {
              try {
                const rings = district.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('TX School District outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const color = '#8b5cf6'; // Purple color for school districts
                  const weight = 2;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const districtPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const districtName = district.name20 || district.name || district.name2 || `District ${district.district || district.fid}`;
                  const isContaining = district.isContaining || false;
                  const distance = district.distance_miles !== null && district.distance_miles !== undefined ? district.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏫 ${districtName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${district.district ? `<div><strong>District:</strong> ${district.district}</div>` : ''}
                        ${district.nces_distr ? `<div><strong>NCES ID:</strong> ${district.nces_distr}</div>` : ''}
                        ${isContaining ? '<div style="color: #8b5cf6; font-weight: 600;">✓ Location is within this district</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  districtPolygon.bindPopup(popupContent, { maxWidth: 400 });
                  districtPolygon.addTo(primary);
                  
                  // Extend map bounds
                  const polygonBounds = districtPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  districtCount++;
                }
              } catch (error) {
                console.error('Error drawing TX School District polygon:', error);
              }
            }
          });
          
          if (districtCount > 0) {
            if (!legendAccumulator['tx_school_districts_2024']) {
              legendAccumulator['tx_school_districts_2024'] = {
                icon: '🏫',
                color: '#8b5cf6',
                title: 'TX School Districts 2024',
                count: 0,
              };
            }
            legendAccumulator['tx_school_districts_2024'].count += districtCount;
          }
        }
      } catch (error) {
        console.error('Error processing TX School Districts 2024:', error);
      }

      // Draw WRI Aqueduct Water Risk - Future Annual as polygons on the map
      try {
        if (enrichments.wri_aqueduct_water_risk_future_annual_all && Array.isArray(enrichments.wri_aqueduct_water_risk_future_annual_all)) {
          let featureCount = 0;
          enrichments.wri_aqueduct_water_risk_future_annual_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('WRI Aqueduct Water Risk Future Annual outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const color = '#06b6d4'; // Cyan color for water risk
                  const weight = 2;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  
                  // Get first 25 attributes for popup (exclude metadata fields)
                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 25);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');
                  
                  const totalAttributeCount = Object.keys(allAttributes).length;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 WRI Aqueduct Water Risk - Future Annual
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div style="color: #06b6d4; font-weight: 600;">✓ Location is within this feature</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 25 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 25} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);
                  
                  // Extend map bounds
                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing WRI Aqueduct Water Risk Future Annual polygon:', error);
              }
            }
          });
          
          if (featureCount > 0) {
            if (!legendAccumulator['wri_aqueduct_water_risk_future_annual']) {
              legendAccumulator['wri_aqueduct_water_risk_future_annual'] = {
                icon: '🌊',
                color: '#06b6d4',
                title: 'WRI Aqueduct Water Risk - Future Annual',
                count: 0,
              };
            }
            legendAccumulator['wri_aqueduct_water_risk_future_annual'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing WRI Aqueduct Water Risk Future Annual:', error);
      }

      // Draw WRI Aqueduct Water Risk - Baseline Annual as polygons on the map
      try {
        if (enrichments.wri_aqueduct_water_risk_baseline_annual_all && Array.isArray(enrichments.wri_aqueduct_water_risk_baseline_annual_all)) {
          let featureCount = 0;
          // Track bws_label values for legend ranges
          const bwsLabelCounts: Record<string, { count: number; color: string }> = {};
          
          enrichments.wri_aqueduct_water_risk_baseline_annual_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('WRI Aqueduct Water Risk Baseline Annual outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  // Color code by bws_label (Baseline Water Stress Label) - light to dark based on risk level
                  const bwsLabel = feature.bws_label || feature.BWS_LABEL || feature.bwsLabel || '';
                  const bwsLabelLower = String(bwsLabel).toLowerCase().trim();
                  
                  // Default color (if bws_label is not available)
                  let color = '#0891b2'; // Default darker cyan
                  let fillColor = '#0891b2';
                  let bwsLabelDisplay = 'Unknown';
                  
                  // Color mapping: light (low risk) to dark (high risk)
                  if (bwsLabelLower.includes('extremely high') || bwsLabelLower.includes('extreme')) {
                    color = '#164e63'; // Darkest teal/cyan for extremely high
                    fillColor = '#164e63';
                    bwsLabelDisplay = 'Extremely High';
                  } else if (bwsLabelLower.includes('high') && !bwsLabelLower.includes('medium')) {
                    color = '#0e7490'; // Dark teal for high
                    fillColor = '#0e7490';
                    bwsLabelDisplay = 'High';
                  } else if (bwsLabelLower.includes('medium-high') || bwsLabelLower.includes('medium high')) {
                    color = '#0891b2'; // Medium-dark teal for medium-high
                    fillColor = '#0891b2';
                    bwsLabelDisplay = 'Medium-High';
                  } else if (bwsLabelLower.includes('medium') && !bwsLabelLower.includes('low') && !bwsLabelLower.includes('high')) {
                    color = '#06b6d4'; // Medium cyan for medium
                    fillColor = '#06b6d4';
                    bwsLabelDisplay = 'Medium';
                  } else if (bwsLabelLower.includes('low-medium') || bwsLabelLower.includes('low medium')) {
                    color = '#22d3ee'; // Light cyan for low-medium
                    fillColor = '#22d3ee';
                    bwsLabelDisplay = 'Low-Medium';
                  } else if (bwsLabelLower.includes('low') && !bwsLabelLower.includes('medium') && !bwsLabelLower.includes('lowest') && !bwsLabelLower.includes('very low')) {
                    color = '#67e8f9'; // Light cyan for low
                    fillColor = '#67e8f9';
                    bwsLabelDisplay = 'Low';
                  } else if (bwsLabelLower.includes('lowest') || bwsLabelLower.includes('very low')) {
                    color = '#cffafe'; // Very light cyan for lowest
                    fillColor = '#cffafe';
                    bwsLabelDisplay = bwsLabelLower.includes('very low') ? 'Very Low' : 'Lowest';
                  } else if (bwsLabel) {
                    // Use original label if it doesn't match any pattern
                    bwsLabelDisplay = bwsLabel;
                  }
                  
                  // Track bws_label for legend
                  if (!bwsLabelCounts[bwsLabelDisplay]) {
                    bwsLabelCounts[bwsLabelDisplay] = { count: 0, color: fillColor };
                  }
                  bwsLabelCounts[bwsLabelDisplay].count++;
                  
                  const weight = 2;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: fillColor,
                    fillOpacity: 0.3
                  });
                  
                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  
                  // Get first 25 attributes for popup (exclude metadata fields)
                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 25);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');
                  
                  const totalAttributeCount = Object.keys(allAttributes).length;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 WRI Aqueduct Water Risk - Baseline Annual
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${bwsLabelDisplay !== 'Unknown' ? `<div style="margin-bottom: 4px;"><strong>Water Stress Level:</strong> <span style="color: ${fillColor}; font-weight: 600;">${bwsLabelDisplay}</span></div>` : ''}
                        ${isContaining ? '<div style="color: #0891b2; font-weight: 600;">✓ Location is within this feature</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 25 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 25} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);
                  
                  // Extend map bounds
                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing WRI Aqueduct Water Risk Baseline Annual polygon:', error);
              }
            }
          });
          
          if (featureCount > 0) {
            // Create ranges array from bws_label counts, ordered from low to high risk
            const riskOrder = ['Lowest', 'Very Low', 'Low', 'Low-Medium', 'Low Medium', 'Medium', 'Medium-High', 'Medium High', 'High', 'Extremely High', 'Extreme', 'Unknown'];
            const ranges = riskOrder
              .filter(label => bwsLabelCounts[label])
              .map(label => ({
                label: label,
                color: bwsLabelCounts[label].color,
                count: bwsLabelCounts[label].count
              }));
            
            // If no ranges found, add all unique labels
            if (ranges.length === 0) {
              Object.keys(bwsLabelCounts).forEach(label => {
                ranges.push({
                  label: label,
                  color: bwsLabelCounts[label].color,
                  count: bwsLabelCounts[label].count
                });
              });
            }
            
            if (!legendAccumulator['wri_aqueduct_water_risk_baseline_annual']) {
              legendAccumulator['wri_aqueduct_water_risk_baseline_annual'] = {
                icon: '🌊',
                color: '#0891b2',
                title: 'WRI Aqueduct Water Risk - Baseline Annual',
                count: 0,
                ranges: ranges.length > 0 ? ranges : undefined
              };
            } else {
              // Update ranges if they exist
              if (ranges.length > 0) {
                legendAccumulator['wri_aqueduct_water_risk_baseline_annual'].ranges = ranges;
              }
            }
            legendAccumulator['wri_aqueduct_water_risk_baseline_annual'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing WRI Aqueduct Water Risk Baseline Annual:', error);
      }

      // Draw WRI Aqueduct Water Risk - Baseline Monthly as polygons on the map
      try {
        if (enrichments.wri_aqueduct_water_risk_baseline_monthly_all && Array.isArray(enrichments.wri_aqueduct_water_risk_baseline_monthly_all)) {
          let featureCount = 0;
          const bws01LabelCounts: Record<string, { color: string; count: number }> = {};
          
          enrichments.wri_aqueduct_water_risk_baseline_monthly_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('WRI Aqueduct Water Risk Baseline Monthly outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  // Color code by bws_01_label (Baseline Water Stress Label for January) - light to dark based on risk level
                  const bws01Label = feature.bws_01_label || feature.BWS_01_LABEL || feature.bws01Label || '';
                  const bws01LabelLower = String(bws01Label).toLowerCase().trim();
                  
                  // Default color (if bws_01_label is not available)
                  let color = '#0e7490'; // Default darkest cyan
                  let fillColor = '#0e7490';
                  let bws01LabelDisplay = 'Unknown';
                  
                  // Color mapping: light (low risk) to dark (high risk) - same as Annual
                  if (bws01LabelLower.includes('extremely high') || bws01LabelLower.includes('extreme')) {
                    color = '#164e63'; // Darkest teal/cyan for extremely high
                    fillColor = '#164e63';
                    bws01LabelDisplay = 'Extremely High';
                  } else if (bws01LabelLower.includes('high') && !bws01LabelLower.includes('medium')) {
                    color = '#0e7490'; // Dark teal for high
                    fillColor = '#0e7490';
                    bws01LabelDisplay = 'High';
                  } else if (bws01LabelLower.includes('medium-high') || bws01LabelLower.includes('medium high')) {
                    color = '#0891b2'; // Medium-dark teal for medium-high
                    fillColor = '#0891b2';
                    bws01LabelDisplay = 'Medium-High';
                  } else if (bws01LabelLower.includes('medium') && !bws01LabelLower.includes('low') && !bws01LabelLower.includes('high')) {
                    color = '#06b6d4'; // Medium cyan for medium
                    fillColor = '#06b6d4';
                    bws01LabelDisplay = 'Medium';
                  } else if (bws01LabelLower.includes('low-medium') || bws01LabelLower.includes('low medium')) {
                    color = '#22d3ee'; // Light cyan for low-medium
                    fillColor = '#22d3ee';
                    bws01LabelDisplay = 'Low-Medium';
                  } else if (bws01LabelLower.includes('low') && !bws01LabelLower.includes('medium') && !bws01LabelLower.includes('lowest') && !bws01LabelLower.includes('very low')) {
                    color = '#67e8f9'; // Light cyan for low
                    fillColor = '#67e8f9';
                    bws01LabelDisplay = 'Low';
                  } else if (bws01LabelLower.includes('lowest') || bws01LabelLower.includes('very low')) {
                    color = '#cffafe'; // Very light cyan for lowest
                    fillColor = '#cffafe';
                    bws01LabelDisplay = bws01LabelLower.includes('very low') ? 'Very Low' : 'Lowest';
                  } else if (bws01Label) {
                    // Use original label if it doesn't match any pattern
                    bws01LabelDisplay = bws01Label;
                  }
                  
                  // Track bws_01_label for legend
                  if (!bws01LabelCounts[bws01LabelDisplay]) {
                    bws01LabelCounts[bws01LabelDisplay] = { count: 0, color: fillColor };
                  }
                  bws01LabelCounts[bws01LabelDisplay].count++;
                  
                  const weight = 2;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: fillColor,
                    fillOpacity: 0.3
                  });
                  
                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  
                  // Get first 25 attributes for popup (exclude metadata fields)
                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 25);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');
                  
                  const totalAttributeCount = Object.keys(allAttributes).length;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 WRI Aqueduct Water Risk - Baseline Monthly
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${bws01LabelDisplay !== 'Unknown' ? `<div style="margin-bottom: 4px;"><strong>Water Stress Level (January):</strong> <span style="color: ${fillColor}; font-weight: 600;">${bws01LabelDisplay}</span></div>` : ''}
                        ${isContaining ? '<div style="color: #0e7490; font-weight: 600;">✓ Location is within this feature</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 25 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 25} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);
                  
                  // Extend map bounds
                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing WRI Aqueduct Water Risk Baseline Monthly polygon:', error);
              }
            }
          });
          
          if (featureCount > 0) {
            // Create ranges array from bws_01_label counts, ordered from low to high risk
            const riskOrder = ['Lowest', 'Very Low', 'Low', 'Low-Medium', 'Low Medium', 'Medium', 'Medium-High', 'Medium High', 'High', 'Extremely High', 'Extreme', 'Unknown'];
            const ranges = riskOrder
              .filter(label => bws01LabelCounts[label])
              .map(label => ({
                label: label,
                color: bws01LabelCounts[label].color,
                count: bws01LabelCounts[label].count
              }));
            
            // If no ranges found in standard order, add all unique labels
            if (ranges.length === 0) {
              Object.keys(bws01LabelCounts).forEach(label => {
                ranges.push({
                  label: label,
                  color: bws01LabelCounts[label].color,
                  count: bws01LabelCounts[label].count
                });
              });
            }
            
            if (!legendAccumulator['wri_aqueduct_water_risk_baseline_monthly']) {
              legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'] = {
                icon: '🌊',
                color: '#0e7490',
                title: 'WRI Aqueduct Water Risk - Baseline Monthly',
                count: 0,
                ranges: ranges.length > 0 ? ranges : undefined
              };
            } else {
              // Merge ranges if they exist
              if (ranges.length > 0) {
                if (legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'].ranges) {
                  // Merge counts for existing ranges
                  ranges.forEach(newRange => {
                    const existingRange = legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'].ranges!.find(r => r.label === newRange.label);
                    if (existingRange) {
                      existingRange.count += newRange.count;
                    } else {
                      legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'].ranges!.push(newRange);
                    }
                  });
                } else {
                  legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'].ranges = ranges;
                }
              }
            }
            legendAccumulator['wri_aqueduct_water_risk_baseline_monthly'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing WRI Aqueduct Water Risk Baseline Monthly:', error);
      }

      // Draw all ACS boundary layers as polygons on the map (generic handler for all 78 layers)
      try {
        // List of all ACS layer keys
        const acsLayerKeys = [
          'acs_children_in_grandparent_households_state_all', 'acs_children_in_grandparent_households_county_all', 'acs_children_in_grandparent_households_tract_all',
          'acs_children_in_immigrant_families_state_all', 'acs_children_in_immigrant_families_county_all', 'acs_children_in_immigrant_families_tract_all',
          'acs_disability_by_age_and_sex_state_all', 'acs_disability_by_age_and_sex_county_all', 'acs_disability_by_age_and_sex_tract_all',
          'acs_disability_by_type_state_all', 'acs_disability_by_type_county_all', 'acs_disability_by_type_tract_all',
          'acs_education_by_veteran_status_state_all', 'acs_education_by_veteran_status_county_all', 'acs_education_by_veteran_status_tract_all',
          'acs_educational_attainment_state_all', 'acs_educational_attainment_county_all', 'acs_educational_attainment_tract_all',
          'acs_employment_status_state_all', 'acs_employment_status_county_all', 'acs_employment_status_tract_all',
          'acs_english_ability_and_linguistic_isolation_households_state_all', 'acs_english_ability_and_linguistic_isolation_households_county_all', 'acs_english_ability_and_linguistic_isolation_households_tract_all',
          'acs_fertility_by_age_state_all', 'acs_fertility_by_age_county_all', 'acs_fertility_by_age_tract_all',
          'acs_geographical_mobility_state_all', 'acs_geographical_mobility_county_all', 'acs_geographical_mobility_tract_all',
          'acs_health_insurance_state_all', 'acs_health_insurance_county_all', 'acs_health_insurance_tract_all',
          'acs_health_insurance_by_age_by_race_state_all', 'acs_health_insurance_by_age_by_race_county_all', 'acs_health_insurance_by_age_by_race_tract_all',
          'acs_highlights_child_well_being_state_all', 'acs_highlights_child_well_being_county_all', 'acs_highlights_child_well_being_tract_all',
          'acs_highlights_emergency_response_state_all', 'acs_highlights_emergency_response_county_all', 'acs_highlights_emergency_response_tract_all',
          'acs_highlights_population_housing_basics_state_all', 'acs_highlights_population_housing_basics_county_all', 'acs_highlights_population_housing_basics_tract_all',
          'acs_highlights_senior_well_being_state_all', 'acs_highlights_senior_well_being_county_all', 'acs_highlights_senior_well_being_tract_all',
          'acs_household_income_distribution_state_all', 'acs_household_income_distribution_county_all', 'acs_household_income_distribution_tract_all',
          'acs_household_size_state_all', 'acs_household_size_county_all', 'acs_household_size_tract_all',
          'acs_housing_costs_state_all', 'acs_housing_costs_county_all', 'acs_housing_costs_tract_all',
          'acs_housing_costs_by_age_state_all', 'acs_housing_costs_by_age_county_all', 'acs_housing_costs_by_age_tract_all',
          'acs_housing_occupancy_and_tenure_unit_value_state_all', 'acs_housing_occupancy_and_tenure_unit_value_county_all', 'acs_housing_occupancy_and_tenure_unit_value_tract_all',
          'acs_housing_tenure_by_education_level_state_all', 'acs_housing_tenure_by_education_level_county_all', 'acs_housing_tenure_by_education_level_tract_all',
          'acs_housing_tenure_by_heating_fuel_state_all', 'acs_housing_tenure_by_heating_fuel_county_all', 'acs_housing_tenure_by_heating_fuel_tract_all',
          'acs_housing_tenure_by_race_state_all', 'acs_housing_tenure_by_race_county_all', 'acs_housing_tenure_by_race_tract_all',
          'acs_housing_units_by_year_built_state_all', 'acs_housing_units_by_year_built_county_all', 'acs_housing_units_by_year_built_tract_all',
          'acs_housing_units_in_structure_state_all', 'acs_housing_units_in_structure_county_all', 'acs_housing_units_in_structure_tract_all',
          'acs_housing_units_vacancy_status_state_all', 'acs_housing_units_vacancy_status_county_all', 'acs_housing_units_vacancy_status_tract_all',
          'acs_labor_force_participation_by_age_state_all', 'acs_labor_force_participation_by_age_county_all', 'acs_labor_force_participation_by_age_tract_all',
          'acs_language_by_age_state_all', 'acs_language_by_age_county_all', 'acs_language_by_age_tract_all',
          'acs_marital_status_state_all', 'acs_marital_status_county_all', 'acs_marital_status_tract_all',
          'acs_means_of_transportation_to_work_state_all', 'acs_means_of_transportation_to_work_county_all', 'acs_means_of_transportation_to_work_tract_all',
          'acs_median_age_state_all', 'acs_median_age_county_all', 'acs_median_age_tract_all',
          'acs_median_earnings_by_occupation_state_all', 'acs_median_earnings_by_occupation_county_all', 'acs_median_earnings_by_occupation_tract_all',
          'acs_median_earnings_by_occupation_by_sex_state_all', 'acs_median_earnings_by_occupation_by_sex_county_all', 'acs_median_earnings_by_occupation_by_sex_tract_all',
          'acs_median_income_by_race_and_age_selp_emp_state_all', 'acs_median_income_by_race_and_age_selp_emp_county_all', 'acs_median_income_by_race_and_age_selp_emp_tract_all',
          'acs_nativity_citizenship_state_all', 'acs_nativity_citizenship_county_all', 'acs_nativity_citizenship_tract_all',
          'acs_parental_labor_force_participation_state_all', 'acs_parental_labor_force_participation_county_all', 'acs_parental_labor_force_participation_tract_all',
          'acs_population_by_race_and_hispanic_origin_state_all', 'acs_population_by_race_and_hispanic_origin_county_all', 'acs_population_by_race_and_hispanic_origin_tract_all',
          'acs_poverty_by_age_state_all', 'acs_poverty_by_age_county_all', 'acs_poverty_by_age_tract_all',
          'acs_school_enrollment_state_all', 'acs_school_enrollment_county_all', 'acs_school_enrollment_tract_all',
          'acs_specific_hispanic_or_latino_origin_state_all', 'acs_specific_hispanic_or_latino_origin_county_all', 'acs_specific_hispanic_or_latino_origin_tract_all',
          'acs_total_population_state_all', 'acs_total_population_county_all', 'acs_total_population_tract_all',
          'acs_travel_time_to_work_state_all', 'acs_travel_time_to_work_county_all', 'acs_travel_time_to_work_tract_all',
          'acs_vehicle_availability_state_all', 'acs_vehicle_availability_county_all', 'acs_vehicle_availability_tract_all',
          'acs_veteran_status_by_sex_and_age_state_all', 'acs_veteran_status_by_sex_and_age_county_all', 'acs_veteran_status_by_sex_and_age_tract_all',
          'acs_youth_activity_state_all', 'acs_youth_activity_county_all', 'acs_youth_activity_tract_all',
          'acs_educational_attainment_by_race_by_sex_state_all', 'acs_educational_attainment_by_race_by_sex_county_all', 'acs_educational_attainment_by_race_by_sex_tract_all',
          // New ACS V2 Services
          'acs_fertility_by_age_v2_state_all', 'acs_fertility_by_age_v2_county_all', 'acs_fertility_by_age_v2_tract_all',
          'acs_geographical_mobility_v2_state_all', 'acs_geographical_mobility_v2_county_all', 'acs_geographical_mobility_v2_tract_all',
          'acs_health_insurance_v2_state_all', 'acs_health_insurance_v2_county_all', 'acs_health_insurance_v2_tract_all',
          'acs_health_insurance_by_age_by_race_v2_state_all', 'acs_health_insurance_by_age_by_race_v2_county_all', 'acs_health_insurance_by_age_by_race_v2_tract_all',
          'acs_highlights_child_well_being_v2_state_all', 'acs_highlights_child_well_being_v2_county_all', 'acs_highlights_child_well_being_v2_tract_all',
          'acs_highlights_emergency_response_v2_state_all', 'acs_highlights_emergency_response_v2_county_all', 'acs_highlights_emergency_response_v2_tract_all',
          'acs_highlights_population_housing_basics_v2_state_all', 'acs_highlights_population_housing_basics_v2_county_all', 'acs_highlights_population_housing_basics_v2_tract_all',
          'acs_highlights_senior_well_being_v2_state_all', 'acs_highlights_senior_well_being_v2_county_all', 'acs_highlights_senior_well_being_v2_tract_all',
          'acs_household_income_distribution_v2_state_all', 'acs_household_income_distribution_v2_county_all', 'acs_household_income_distribution_v2_tract_all',
          'acs_household_size_v2_state_all', 'acs_household_size_v2_county_all', 'acs_household_size_v2_tract_all',
          'acs_housing_costs_v2_state_all', 'acs_housing_costs_v2_county_all', 'acs_housing_costs_v2_tract_all',
          'acs_housing_costs_by_age_v2_state_all', 'acs_housing_costs_by_age_v2_county_all', 'acs_housing_costs_by_age_v2_tract_all',
          'acs_housing_occupancy_and_tenure_unit_value_v2_state_all', 'acs_housing_occupancy_and_tenure_unit_value_v2_county_all', 'acs_housing_occupancy_and_tenure_unit_value_v2_tract_all',
          // New ACS V3 Services
          'acs_language_by_age_v2_state_all', 'acs_language_by_age_v2_county_all', 'acs_language_by_age_v2_tract_all',
          'acs_living_arrangements_state_all', 'acs_living_arrangements_county_all', 'acs_living_arrangements_tract_all',
          'acs_marital_status_v2_state_all', 'acs_marital_status_v2_county_all', 'acs_marital_status_v2_tract_all',
          'acs_means_of_transportation_to_work_v2_state_all', 'acs_means_of_transportation_to_work_v2_county_all', 'acs_means_of_transportation_to_work_v2_tract_all',
          'acs_median_age_v2_state_all', 'acs_median_age_v2_county_all', 'acs_median_age_v2_tract_all',
          'acs_median_earnings_by_occupation_v2_state_all', 'acs_median_earnings_by_occupation_v2_county_all', 'acs_median_earnings_by_occupation_v2_tract_all',
          'acs_median_earnings_by_occupation_by_sex_v2_state_all', 'acs_median_earnings_by_occupation_by_sex_v2_county_all', 'acs_median_earnings_by_occupation_by_sex_v2_tract_all',
          'acs_median_income_by_race_and_age_selp_emp_v2_state_all', 'acs_median_income_by_race_and_age_selp_emp_v2_county_all', 'acs_median_income_by_race_and_age_selp_emp_v2_tract_all',
          'acs_place_of_birth_state_all', 'acs_place_of_birth_county_all', 'acs_place_of_birth_tract_all',
          'acs_specific_asian_groups_state_all', 'acs_specific_asian_groups_county_all', 'acs_specific_asian_groups_tract_all',
          'acs_specific_language_spoken_by_english_ability_state_all', 'acs_specific_language_spoken_by_english_ability_county_all', 'acs_specific_language_spoken_by_english_ability_tract_all',
          'acs_travel_time_to_work_v2_state_all', 'acs_travel_time_to_work_v2_county_all', 'acs_travel_time_to_work_v2_tract_all',
          'acs_vehicle_availability_v2_state_all', 'acs_vehicle_availability_v2_county_all', 'acs_vehicle_availability_v2_tract_all',
          'acs_youth_activity_v2_state_all', 'acs_youth_activity_v2_county_all', 'acs_youth_activity_v2_tract_all',
          // Census 2020 DHC Age and Sex - Standard Boundaries
          'acs_census_2020_dhc_age_and_sex_nation_all', 'acs_census_2020_dhc_age_and_sex_state_all', 'acs_census_2020_dhc_age_and_sex_county_all', 'acs_census_2020_dhc_age_and_sex_census_tract_all', 'acs_census_2020_dhc_age_and_sex_block_group_all',
          // Census 2020 DHC Age and Sex - Legislative Boundaries
          'acs_census_2020_dhc_age_and_sex_legislative_nation_all', 'acs_census_2020_dhc_age_and_sex_legislative_congressional_district_all', 'acs_census_2020_dhc_age_and_sex_legislative_state_legislative_districts_upper_all', 'acs_census_2020_dhc_age_and_sex_legislative_state_legislative_districts_lower_all',
          // Census 2020 DHC Age and Sex - Metro Boundaries
          'acs_census_2020_dhc_age_and_sex_metro_nation_all', 'acs_census_2020_dhc_age_and_sex_metro_combined_statistical_area_all', 'acs_census_2020_dhc_age_and_sex_metro_core_based_statistical_area_all', 'acs_census_2020_dhc_age_and_sex_metro_metropolitan_division_all',
          // Census 2020 DHC Age and Sex - Place Boundaries
          'acs_census_2020_dhc_age_and_sex_place_nation_all', 'acs_census_2020_dhc_age_and_sex_place_consolidated_city_all', 'acs_census_2020_dhc_age_and_sex_place_census_designated_place_all', 'acs_census_2020_dhc_age_and_sex_place_incorporated_place_all',
          // Census 2020 DHC Age and Sex - School Boundaries
          'acs_census_2020_dhc_age_and_sex_school_nation_all', 'acs_census_2020_dhc_age_and_sex_school_district_unified_all', 'acs_census_2020_dhc_age_and_sex_school_district_elementary_all', 'acs_census_2020_dhc_age_and_sex_school_district_secondary_all',
          // Census 2020 DHC Age and Sex - Tribal Boundaries
          'acs_census_2020_dhc_age_and_sex_tribal_nation_all', 'acs_census_2020_dhc_age_and_sex_tribal_subdivision_all', 'acs_census_2020_dhc_age_and_sex_tribal_census_tract_all', 'acs_census_2020_dhc_age_and_sex_tribal_block_group_all', 'acs_census_2020_dhc_age_and_sex_tribal_alaska_native_regional_corporation_all', 'acs_census_2020_dhc_age_and_sex_tribal_american_indian_alaska_native_native_hawaiian_area_all',
          // Census 2020 DHC Blocks
          'acs_census_2020_dhc_blocks_nation_all', 'acs_census_2020_dhc_blocks_block_all',
          // Census 2020 DHC Group Quarters - Standard Boundaries
          'acs_census_2020_dhc_group_quarters_nation_all', 'acs_census_2020_dhc_group_quarters_state_all', 'acs_census_2020_dhc_group_quarters_county_all', 'acs_census_2020_dhc_group_quarters_census_tract_all', 'acs_census_2020_dhc_group_quarters_block_group_all',
          // Census 2020 DHC Group Quarters - Legislative Boundaries
          'acs_census_2020_dhc_group_quarters_legislative_nation_all', 'acs_census_2020_dhc_group_quarters_legislative_congressional_district_all', 'acs_census_2020_dhc_group_quarters_legislative_state_legislative_districts_upper_all', 'acs_census_2020_dhc_group_quarters_legislative_state_legislative_districts_lower_all',
          // Census 2020 DHC Group Quarters - Metro Boundaries
          'acs_census_2020_dhc_group_quarters_metro_nation_all', 'acs_census_2020_dhc_group_quarters_metro_combined_statistical_area_all', 'acs_census_2020_dhc_group_quarters_metro_core_based_statistical_area_all', 'acs_census_2020_dhc_group_quarters_metro_metropolitan_division_all',
          // Census 2020 DHC Group Quarters - Place Boundaries
          'acs_census_2020_dhc_group_quarters_place_nation_all', 'acs_census_2020_dhc_group_quarters_place_consolidated_city_all', 'acs_census_2020_dhc_group_quarters_place_census_designated_place_all', 'acs_census_2020_dhc_group_quarters_place_incorporated_place_all',
          // Census 2020 DHC Group Quarters - School Boundaries
          'acs_census_2020_dhc_group_quarters_school_nation_all', 'acs_census_2020_dhc_group_quarters_school_district_unified_all', 'acs_census_2020_dhc_group_quarters_school_district_elementary_all', 'acs_census_2020_dhc_group_quarters_school_district_secondary_all',
          // Census 2020 DHC Group Quarters - Tribal Boundaries
          'acs_census_2020_dhc_group_quarters_tribal_nation_all', 'acs_census_2020_dhc_group_quarters_tribal_subdivision_all', 'acs_census_2020_dhc_group_quarters_tribal_census_tract_all', 'acs_census_2020_dhc_group_quarters_tribal_block_group_all', 'acs_census_2020_dhc_group_quarters_tribal_alaska_native_regional_corporation_all', 'acs_census_2020_dhc_group_quarters_tribal_american_indian_alaska_native_native_hawaiian_area_all',
          // Census 2020 DHC Households - Standard Boundaries
          'acs_census_2020_dhc_households_nation_all', 'acs_census_2020_dhc_households_state_all', 'acs_census_2020_dhc_households_county_all', 'acs_census_2020_dhc_households_census_tract_all', 'acs_census_2020_dhc_households_block_group_all',
          // Census 2020 DHC Households - Legislative Boundaries
          'acs_census_2020_dhc_households_legislative_nation_all', 'acs_census_2020_dhc_households_legislative_congressional_district_all', 'acs_census_2020_dhc_households_legislative_state_legislative_districts_upper_all', 'acs_census_2020_dhc_households_legislative_state_legislative_districts_lower_all',
          // Census 2020 DHC Households - Metro Boundaries
          'acs_census_2020_dhc_households_metro_nation_all', 'acs_census_2020_dhc_households_metro_combined_statistical_area_all', 'acs_census_2020_dhc_households_metro_core_based_statistical_area_all', 'acs_census_2020_dhc_households_metro_metropolitan_division_all',
          // Census 2020 DHC Households - Place Boundaries
          'acs_census_2020_dhc_households_place_nation_all', 'acs_census_2020_dhc_households_place_consolidated_city_all', 'acs_census_2020_dhc_households_place_census_designated_place_all', 'acs_census_2020_dhc_households_place_incorporated_place_all',
          // Census 2020 DHC Households - School Boundaries
          'acs_census_2020_dhc_households_school_nation_all', 'acs_census_2020_dhc_households_school_district_unified_all', 'acs_census_2020_dhc_households_school_district_elementary_all', 'acs_census_2020_dhc_households_school_district_secondary_all',
          // Census 2020 DHC Households - Tribal Boundaries
          'acs_census_2020_dhc_households_tribal_nation_all', 'acs_census_2020_dhc_households_tribal_subdivision_all', 'acs_census_2020_dhc_households_tribal_census_tract_all', 'acs_census_2020_dhc_households_tribal_block_group_all', 'acs_census_2020_dhc_households_tribal_alaska_native_regional_corporation_all', 'acs_census_2020_dhc_households_tribal_american_indian_alaska_native_native_hawaiian_area_all',
          // Census 2020 DHC Housing Units - Standard Boundaries
          'acs_census_2020_dhc_housing_units_nation_all', 'acs_census_2020_dhc_housing_units_state_all', 'acs_census_2020_dhc_housing_units_county_all', 'acs_census_2020_dhc_housing_units_census_tract_all', 'acs_census_2020_dhc_housing_units_block_group_all'
        ];

        acsLayerKeys.forEach((layerKey) => {
          if (enrichments[layerKey] && Array.isArray(enrichments[layerKey])) {
            const layerName = layerKey.replace('_all', '').replace(/^acs_/, '').replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
            let featureCount = 0;

            enrichments[layerKey].forEach((feature: any) => {
              // Check if this is a Nation or State layer (no geometry or empty geometry is OK for these)
              const isNationOrStateLayer = layerKey.includes('_nation_all') || layerKey.includes('_state_all');
              
              // For Nation/State layers, if geometry is missing or empty, still count it but don't draw
              // For other layers, require geometry with rings
              if (isNationOrStateLayer && (!feature.geometry || !feature.geometry.rings || feature.geometry.rings.length === 0)) {
                // Nation/State layer without geometry - still count it for legend but don't draw
                featureCount++;
                return;
              }
              
              if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
                try {
                  const rings = feature.geometry.rings;
                  if (rings && rings.length > 0) {
                    const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                      return ring.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                    });

                    if (latlngsArray[0].length < 3) {
                      console.warn(`ACS ${layerName} outer ring has less than 3 coordinates, skipping`);
                      // Still count for Nation/State layers even if geometry is invalid
                      if (isNationOrStateLayer) {
                        featureCount++;
                      }
                      return;
                    }

                    const color = '#3b82f6'; // Blue color for ACS boundaries
                    const weight = 2;
                    const opacity = 0.8;

                    const featurePolygon = L.polygon(latlngsArray, {
                      color: color,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.2
                    });

                    const isContaining = feature.isContaining || false;
                    const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;

                    const allAttributes = { ...feature };
                    delete allAttributes.geometry;
                    delete allAttributes.distance_miles;
                    delete allAttributes.isContaining;

                    const attributeKeys = Object.keys(allAttributes).slice(0, 25);
                    const attributeRows = attributeKeys.map(key => {
                      const value = allAttributes[key];
                      const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                      return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                    }).join('');

                    const totalAttributeCount = Object.keys(allAttributes).length;

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          📊 ACS ${layerName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${isContaining ? '<div style="color: #3b82f6; font-weight: 600;">✓ Location is within this feature</div>' : ''}
                          ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                          ${totalAttributeCount > 25 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 25} more attributes (see CSV for all)</div>` : ''}
                        </div>
                      </div>
                    `;

                    featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                    featurePolygon.addTo(primary);

                    const polygonBounds = featurePolygon.getBounds();
                    if (polygonBounds.isValid()) {
                      bounds.extend(polygonBounds);
                    }

                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ACS ${layerName} polygon:`, error);
                  // Still count for Nation/State layers even if drawing fails
                  if (isNationOrStateLayer) {
                    featureCount++;
                  }
                }
              }
            });

            if (featureCount > 0) {
              const legendKey = layerKey.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: '📊',
                  color: '#3b82f6',
                  title: `ACS ${layerName}`,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        });
      } catch (error) {
        console.error('Error processing ACS boundary layers:', error);
      }

      // Draw Puerto Rico Hydrology as polylines on the map
      try {
        if (enrichments.pr_hydrology_all && Array.isArray(enrichments.pr_hydrology_all)) {
          let featureCount = 0;
          enrichments.pr_hydrology_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.paths && Array.isArray(feature.geometry.paths)) {
              try {
                const paths = feature.geometry.paths;
                if (paths && paths.length > 0) {
                  // Convert all paths to Leaflet format
                  paths.forEach((path: number[][]) => {
                    if (path && path.length > 0) {
                      // ESRI paths are [lon, lat] format, convert to [lat, lon] for Leaflet
                      const latlngs: L.LatLngExpression[] = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as L.LatLngExpression;
                      });
                      
                      // Determine color based on TIPO/Type
                      let color = '#0ea5e9'; // Default blue
                      let weight = 3;
                      const tipo = feature.tipo || feature.TIPO || feature.type || feature.Type || '';
                      
                      if (tipo === 'RIO' || tipo === 'Rio' || tipo === 'rio') {
                        color = '#0284c7'; // Darker blue for rivers
                        weight = 4;
                      } else if (tipo === 'QUEBRADA' || tipo === 'Quebrada' || tipo === 'quebrada') {
                        color = '#06b6d4'; // Cyan for streams
                        weight = 3;
                      } else if (tipo === 'CANAL' || tipo === 'Canal' || tipo === 'canal') {
                        color = '#0891b2'; // Teal for canals
                        weight = 2;
                      } else if (tipo === 'CANAL DE DRENAJE' || tipo === 'Canal de Drenaje') {
                        color = '#0e7490'; // Darker teal for drainage canals
                        weight = 2;
                      } else if (tipo === 'SIFON' || tipo === 'Sifon' || tipo === 'sifon') {
                        color = '#155e75'; // Dark teal for siphons
                        weight = 2;
                      } else if (tipo === 'TUNEL' || tipo === 'Tunel' || tipo === 'tunel') {
                        color = '#164e63'; // Darkest teal for tunnels
                        weight = 2;
                      }
                      
                      const polyline = L.polyline(latlngs, {
                        color: color,
                        weight: weight,
                        opacity: 0.8,
                        smoothFactor: 1
                      });
                      
                      const name = feature.name || feature.NAME || feature.Name || 'Unnamed';
                      const tipoDisplay = tipo || 'Unknown Type';
                      const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                      
                      let popupContent = `
                        <div style="min-width: 200px; max-width: 350px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🌊 ${name}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            <div><strong>Type:</strong> ${tipoDisplay}</div>
                            ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                            ${feature.shapeLength ? `<div><strong>Length:</strong> ${feature.shapeLength.toFixed(2)} m</div>` : ''}
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent, { maxWidth: 350 });
                      polyline.addTo(primary);
                      
                      (polyline as any).__layerType = 'pr_hydrology';
                      (polyline as any).__layerTitle = 'PR Hydrology';
                      
                      try {
                        bounds.extend(polyline.getBounds());
                      } catch (boundsError) {
                        console.warn('Error extending bounds for PR Hydrology:', boundsError);
                      }
                      
                      featureCount++;
                    }
                  });
                }
              } catch (error) {
                console.error('Error drawing Puerto Rico Hydrology polyline:', error);
              }
            }
          });
          
          if (featureCount > 0) {
            if (!legendAccumulator['pr_hydrology']) {
              legendAccumulator['pr_hydrology'] = {
                icon: '🌊',
                color: '#0ea5e9',
                title: 'PR Hydrology',
                count: 0,
              };
            }
            legendAccumulator['pr_hydrology'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing Puerto Rico Hydrology:', error);
      }

      // Draw SC Trout Streams as polylines on the map
      try {
        if (enrichments.sc_trout_streams_all && Array.isArray(enrichments.sc_trout_streams_all)) {
          let featureCount = 0;
          enrichments.sc_trout_streams_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.paths && Array.isArray(feature.geometry.paths)) {
              try {
                const paths = feature.geometry.paths;
                if (paths && paths.length > 0) {
                  // Convert all paths to Leaflet format
                  paths.forEach((path: number[][]) => {
                    if (path && path.length > 0) {
                      // ESRI paths are [lon, lat] format, convert to [lat, lon] for Leaflet
                      const latlngs: L.LatLngExpression[] = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as L.LatLngExpression;
                      });
                      
                      // Use a teal/green color for trout streams
                      const color = '#10b981'; // Green/teal for trout streams
                      const weight = 3;
                      
                      const polyline = L.polyline(latlngs, {
                        color: color,
                        weight: weight,
                        opacity: 0.8,
                        smoothFactor: 1
                      });
                      
                      const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                      
                      // Build popup with all attributes
                      const allAttributes = { ...feature };
                      delete allAttributes.geometry;
                      delete allAttributes.distance_miles;
                      delete allAttributes.fid;
                      delete allAttributes.objectid;
                      
                      const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                      const attributeRows = attributeKeys.map(key => {
                        const value = allAttributes[key];
                        const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                        return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                      }).join('');
                      
                      const totalAttributeCount = Object.keys(allAttributes).length;
                      
                      let popupContent = `
                        <div style="min-width: 200px; max-width: 350px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            🐟 SC Trout Stream
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                            ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                            ${totalAttributeCount > 20 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 20} more attributes (see CSV for all)</div>` : ''}
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent, { maxWidth: 350 });
                      polyline.addTo(primary);
                      
                      (polyline as any).__layerType = 'sc_trout_streams';
                      (polyline as any).__layerTitle = 'SC Trout Streams';
                      
                      try {
                        bounds.extend(polyline.getBounds());
                      } catch (boundsError) {
                        console.warn('Error extending bounds for SC Trout Streams:', boundsError);
                      }
                      
                      featureCount++;
                    }
                  });
                }
              } catch (error) {
                console.error('Error drawing SC Trout Streams polyline:', error);
              }
            }
          });
          
          if (featureCount > 0) {
            if (!legendAccumulator['sc_trout_streams']) {
              legendAccumulator['sc_trout_streams'] = {
                icon: '🐟',
                color: '#10b981',
                title: 'SC Trout Streams',
                count: 0,
              };
            }
            legendAccumulator['sc_trout_streams'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Trout Streams:', error);
      }

      // Draw SC Scenic Rivers as polylines on the map
      try {
        if (enrichments.sc_scenic_rivers_all && Array.isArray(enrichments.sc_scenic_rivers_all)) {
          let riverCount = 0;
          enrichments.sc_scenic_rivers_all.forEach((river: any) => {
            if (river.geometry && river.geometry.paths) {
              try {
                const paths = river.geometry.paths;
                const name = river.name || river.NAME || river.Name || 'Scenic River';
                const dnrMiles = river.dnrMiles !== null && river.dnrMiles !== undefined ? river.dnrMiles : (river.DNR_miles !== null && river.DNR_miles !== undefined ? river.DNR_miles : null);
                const dateEst = river.dateEst || river.date_est || river.Date_Est || '';
                const riverCons = river.riverCons || river.river_cons || river.River_Cons || '';
                const description = river.description || river.Description || river.DESCRIPTION || '';
                
                // Draw each path as a polyline
                paths.forEach((path: number[][]) => {
                  const latLngs = path.map((coord: number[]) => {
                    // ESRI paths are [lon, lat] format
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  const polyline = L.polyline(latLngs, {
                    color: '#06b6d4', // Cyan color for scenic rivers
                    weight: 3,
                    opacity: 0.8
                  });
                  
                  // Build popup content
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 ${name}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${dnrMiles !== null ? `<div><strong>Miles:</strong> ${dnrMiles}</div>` : ''}
                        ${dateEst ? `<div><strong>Date Established:</strong> ${dateEst}</div>` : ''}
                        ${riverCons ? `<div><strong>River Conservation:</strong> ${riverCons}</div>` : ''}
                        ${description ? `<div style="margin-top: 6px;"><strong>Description:</strong> ${description}</div>` : ''}
                        ${river.distance_miles !== null && river.distance_miles !== undefined ? `<div style="margin-top: 6px;"><strong>Distance:</strong> ${river.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                        <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                  `;
                  
                  // Add all river attributes (excluding internal fields)
                  const excludeFields = ['name', 'dnrMiles', 'dateEst', 'riverCons', 'description', 'geometry', 'distance_miles', 'attributes', 'objectid', 'NAME', 'DNR_miles', 'date_est', 'river_cons', 'Description'];
                  Object.entries(river).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                  
                  // Also include any nested attributes object
                  if (river.attributes && typeof river.attributes === 'object') {
                    Object.entries(river.attributes).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                  }
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent, { maxWidth: 400 });
                  polyline.addTo(poi);
                  
                  // Extend bounds to include this river
                  latLngs.forEach((latLng: [number, number]) => {
                    bounds.extend(latLng);
                  });
                });
                
                riverCount++;
              } catch (error) {
                console.error('Error drawing SC Scenic River polyline:', error);
              }
            }
          });
          
          // Add to legend
          if (riverCount > 0) {
            if (!legendAccumulator['sc_scenic_rivers']) {
              legendAccumulator['sc_scenic_rivers'] = {
                icon: '🌊',
                color: '#06b6d4',
                title: 'SC Scenic Rivers',
                count: 0,
              };
            }
            legendAccumulator['sc_scenic_rivers'].count += riverCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Scenic Rivers:', error);
      }

      // Draw SC Game Zones as polygons on the map
      try {
        if (enrichments.sc_game_zones_all && Array.isArray(enrichments.sc_game_zones_all)) {
          let featureCount = 0;
          enrichments.sc_game_zones_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('SC Game Zones outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#10b981'; // Green color for game zones
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const gameZone = feature.gameZone || feature.GameZone || feature.GAMEZONE || 'Unknown';

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🎯 SC Game Zone
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Game Zone:</strong> ${gameZone}</div>
                        ${isContaining ? '<div style="color: #10b981; font-weight: 600;">✓ Location is within this game zone</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 20 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 20} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);

                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }

                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing SC Game Zones polygon:', error);
              }
            }
          });

          if (featureCount > 0) {
            if (!legendAccumulator['sc_game_zones']) {
              legendAccumulator['sc_game_zones'] = {
                icon: '🎯',
                color: '#10b981',
                title: 'SC Game Zones',
                count: 0,
              };
            }
            legendAccumulator['sc_game_zones'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Game Zones:', error);
      }

      // Draw SC Coastal Ponds as polygons on the map
      try {
        if (enrichments.sc_coastal_ponds_all && Array.isArray(enrichments.sc_coastal_ponds_all)) {
          let featureCount = 0;
          enrichments.sc_coastal_ponds_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('SC Coastal Ponds outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#06b6d4'; // Cyan color for coastal ponds
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const pondId = feature.pondId || feature.Pond_ID || feature.POND_ID || 'Unknown';
                  const countyName = feature.countyName || feature.County_Nam || feature.County_Name || '';
                  const hucName = feature.hucName || feature.HUC_Name || feature.HUC_NAME || '';
                  const className = feature.className || feature.Class || '';

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌊 SC Coastal Pond
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${pondId ? `<div><strong>Pond ID:</strong> ${pondId}</div>` : ''}
                        ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                        ${hucName ? `<div><strong>HUC Name:</strong> ${hucName}</div>` : ''}
                        ${className ? `<div><strong>Class:</strong> ${className}</div>` : ''}
                        ${isContaining ? '<div style="color: #06b6d4; font-weight: 600;">✓ Location is within this pond</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 20 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 20} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);

                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }

                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing SC Coastal Ponds polygon:', error);
              }
            }
          });

          if (featureCount > 0) {
            if (!legendAccumulator['sc_coastal_ponds']) {
              legendAccumulator['sc_coastal_ponds'] = {
                icon: '🌊',
                color: '#06b6d4',
                title: 'SC Coastal Ponds',
                count: 0,
              };
            }
            legendAccumulator['sc_coastal_ponds'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Coastal Ponds:', error);
      }

      // Draw SC Lakes and Reservoirs as polygons on the map
      try {
        if (enrichments.sc_lakes_reservoirs_all && Array.isArray(enrichments.sc_lakes_reservoirs_all)) {
          let featureCount = 0;
          enrichments.sc_lakes_reservoirs_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('SC Lakes and Reservoirs outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#0ea5e9'; // Blue color for lakes and reservoirs
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const name = feature.name || feature.NAME || feature.Name || 'Unnamed';
                  const acres = feature.acres !== null && feature.acres !== undefined ? feature.acres : null;

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏞️ SC Lake/Reservoir
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        <div><strong>Name:</strong> ${name}</div>
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                        ${isContaining ? '<div style="color: #0ea5e9; font-weight: 600;">✓ Location is within this lake/reservoir</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${attributeRows ? `<div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">${attributeRows}</div>` : ''}
                        ${totalAttributeCount > 20 ? `<div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">... and ${totalAttributeCount - 20} more attributes (see CSV for all)</div>` : ''}
                      </div>
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent, { maxWidth: 400 });
                  featurePolygon.addTo(primary);

                  const polygonBounds = featurePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }

                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing SC Lakes and Reservoirs polygon:', error);
              }
            }
          });

          if (featureCount > 0) {
            if (!legendAccumulator['sc_lakes_reservoirs']) {
              legendAccumulator['sc_lakes_reservoirs'] = {
                icon: '🏞️',
                color: '#0ea5e9',
                title: 'SC Lakes and Reservoirs',
                count: 0,
              };
            }
            legendAccumulator['sc_lakes_reservoirs'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Lakes and Reservoirs:', error);
      }

      // Draw USFWS Final Critical Habitat polygons on the map
      try {
        if (enrichments.usfws_final_critical_habitat_all && Array.isArray(enrichments.usfws_final_critical_habitat_all)) {
          let featureCount = 0;
          enrichments.usfws_final_critical_habitat_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('USFWS Final Critical Habitat outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#dc2626'; // Red color for critical habitat
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const speciesName = feature.speciesName || feature.SCIENTIFIC_NAME || feature.scientific_name || 'Unknown Species';
                  const commonName = feature.commonName || feature.COMMON_NAME || feature.common_name || null;
                  const status = feature.status || 'Final';

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  delete allAttributes.speciesName;
                  delete allAttributes.commonName;
                  delete allAttributes.status;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🦅 USFWS Final Critical Habitat
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${commonName ? `<div><strong>Common Name:</strong> ${commonName}</div>` : ''}
                        <div><strong>Scientific Name:</strong> ${speciesName}</div>
                        <div><strong>Status:</strong> ${status}</div>
                        ${isContaining ? '<div style="color: #dc2626; font-weight: 600;">✓ Location is within this habitat</div>' : ''}
                        ${!isContaining && distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      ${attributeRows ? `<div style="border-top: 1px solid #e5e7eb; padding-top: 8px; margin-top: 8px; font-size: 11px; color: #4b5563;">${attributeRows}</div>` : ''}
                      ${totalAttributeCount > 20 ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 4px;">... and ${totalAttributeCount - 20} more attributes</div>` : ''}
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent);
                  featurePolygon.addTo(mapInstanceRef.current!);
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing USFWS Final Critical Habitat polygon:', error);
              }
            }
          });
          if (featureCount > 0) {
            if (!legendAccumulator['usfws_final_critical_habitat']) {
              legendAccumulator['usfws_final_critical_habitat'] = {
                icon: '🦅',
                color: '#dc2626',
                title: 'USFWS Final Critical Habitat',
                count: 0,
              };
            }
            legendAccumulator['usfws_final_critical_habitat'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFWS Final Critical Habitat:', error);
      }

      // Draw USFWS Proposed Critical Habitat polygons on the map
      try {
        if (enrichments.usfws_proposed_critical_habitat_all && Array.isArray(enrichments.usfws_proposed_critical_habitat_all)) {
          let featureCount = 0;
          enrichments.usfws_proposed_critical_habitat_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('USFWS Proposed Critical Habitat outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#f59e0b'; // Orange color for proposed critical habitat
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const speciesName = feature.speciesName || feature.SCIENTIFIC_NAME || feature.scientific_name || 'Unknown Species';
                  const commonName = feature.commonName || feature.COMMON_NAME || feature.common_name || null;
                  const status = feature.status || 'Proposed';

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  delete allAttributes.speciesName;
                  delete allAttributes.commonName;
                  delete allAttributes.status;
                  
                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🦅 USFWS Proposed Critical Habitat
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${commonName ? `<div><strong>Common Name:</strong> ${commonName}</div>` : ''}
                        <div><strong>Scientific Name:</strong> ${speciesName}</div>
                        <div><strong>Status:</strong> ${status}</div>
                        ${isContaining ? '<div style="color: #dc2626; font-weight: 600;">✓ Location is within this habitat</div>' : ''}
                        ${!isContaining && distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      ${attributeRows ? `<div style="border-top: 1px solid #e5e7eb; padding-top: 8px; margin-top: 8px; font-size: 11px; color: #4b5563;">${attributeRows}</div>` : ''}
                      ${totalAttributeCount > 20 ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 4px;">... and ${totalAttributeCount - 20} more attributes</div>` : ''}
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent);
                  featurePolygon.addTo(mapInstanceRef.current!);
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing USFWS Proposed Critical Habitat polygon:', error);
              }
            }
          });
          if (featureCount > 0) {
            if (!legendAccumulator['usfws_proposed_critical_habitat']) {
              legendAccumulator['usfws_proposed_critical_habitat'] = {
                icon: '🦅',
                color: '#f59e0b',
                title: 'USFWS Proposed Critical Habitat',
                count: 0,
              };
            }
            legendAccumulator['usfws_proposed_critical_habitat'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFWS Proposed Critical Habitat:', error);
      }

      // Draw American Eel Current Range as polygons on the map
      try {
        if (enrichments.american_eel_current_range_all && Array.isArray(enrichments.american_eel_current_range_all)) {
          let featureCount = 0;
          enrichments.american_eel_current_range_all.forEach((feature: any) => {
            if (feature.geometry && feature.geometry.rings && Array.isArray(feature.geometry.rings)) {
              try {
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });

                  if (latlngsArray[0].length < 3) {
                    console.warn('American Eel Current Range outer ring has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#16a34a'; // Green color for American Eel Current Range
                  const weight = 2;
                  const opacity = 0.8;

                  const featurePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  const isContaining = feature.isContaining || false;
                  const distance = feature.distance_miles !== null && feature.distance_miles !== undefined ? feature.distance_miles : 0;
                  const region = feature.region || feature.REGION || '';
                  const subregion = feature.subregion || feature.SUBREGION || '';
                  const basin = feature.basin || feature.BASIN || '';
                  const subbasin = feature.subbasin || feature.SUBBASIN || '';
                  const huc8 = feature.huc8 || feature.HUC_8 || feature.HUC8_dbl || '';
                  const acres = feature.acres !== null && feature.acres !== undefined ? feature.acres : null;
                  const sqMiles = feature.sqMiles !== null && feature.sqMiles !== undefined ? feature.sqMiles : null;

                  const allAttributes = { ...feature };
                  delete allAttributes.geometry;
                  delete allAttributes.distance_miles;
                  delete allAttributes.isContaining;
                  delete allAttributes.region;
                  delete allAttributes.subregion;
                  delete allAttributes.basin;
                  delete allAttributes.subbasin;
                  delete allAttributes.huc8;
                  delete allAttributes.acres;
                  delete allAttributes.sqMiles;

                  const attributeKeys = Object.keys(allAttributes).slice(0, 20);
                  const attributeRows = attributeKeys.map(key => {
                    const value = allAttributes[key];
                    const displayValue = value !== null && value !== undefined ? String(value) : 'N/A';
                    return `<div><strong>${key}:</strong> ${displayValue}</div>`;
                  }).join('');

                  const totalAttributeCount = Object.keys(allAttributes).length;

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🐟 American Eel Current Range
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${region ? `<div><strong>Region:</strong> ${region}</div>` : ''}
                        ${subregion ? `<div><strong>Subregion:</strong> ${subregion}</div>` : ''}
                        ${basin ? `<div><strong>Basin:</strong> ${basin}</div>` : ''}
                        ${subbasin ? `<div><strong>Subbasin:</strong> ${subbasin}</div>` : ''}
                        ${huc8 ? `<div><strong>HUC-8:</strong> ${huc8}</div>` : ''}
                        ${acres !== null ? `<div><strong>Acres:</strong> ${acres.toLocaleString()}</div>` : ''}
                        ${sqMiles !== null ? `<div><strong>Square Miles:</strong> ${sqMiles.toLocaleString()}</div>` : ''}
                        <div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>
                        <div><strong>Containing:</strong> ${isContaining ? 'Yes' : 'No'}</div>
                        ${attributeRows}
                        ${totalAttributeCount > 20 ? `<div>... ${totalAttributeCount - 20} more attributes</div>` : ''}
                      </div>
                    </div>
                  `;

                  featurePolygon.bindPopup(popupContent);
                  featurePolygon.addTo(map);
                  featureCount++;
                }
              } catch (error) {
                console.error('Error drawing American Eel Current Range polygon:', error);
              }
            }
          });
          if (featureCount > 0) {
            if (!legendAccumulator['american_eel_current_range']) {
              legendAccumulator['american_eel_current_range'] = {
                icon: '🐟',
                color: '#16a34a',
                title: 'American Eel Current Range',
                count: 0,
              };
            }
            legendAccumulator['american_eel_current_range'].count += featureCount;
          }
        }
      } catch (error) {
        console.error('Error processing American Eel Current Range:', error);
      }

      // Draw Bighorn Sheep Captures and Releases as point markers on the map
      try {
        if (enrichments.bighorn_sheep_captures_releases_all && Array.isArray(enrichments.bighorn_sheep_captures_releases_all)) {
          let sheepCount = 0;
          enrichments.bighorn_sheep_captures_releases_all.forEach((sheep: any) => {
            if (sheep.y && sheep.x) { // y is latitude, x is longitude
              try {
                const sheepLat = sheep.y;
                const sheepLon = sheep.x;
                const capRelType = sheep.capRelType || sheep.CapRelType || 'Unknown';
                const year = sheep.year || sheep.Year || 'N/A';
                const subspecies = sheep.subspecies || sheep.Subspecies || 'N/A';
                const captureSite = sheep.captureSite || sheep.CapturSite || 'N/A';
                const releaseSite = sheep.releaseSite || sheep.ReleseSite || 'N/A';
                const stateCapture = sheep.stateCapture || sheep.State_Capt || 'N/A';
                const stateRelease = sheep.stateRelease || sheep.State_Rele || 'N/A';
                const bighornNos = sheep.bighornNos !== null && sheep.bighornNos !== undefined ? sheep.bighornNos : 'N/A';

                // Create a custom icon for bighorn sheep
                const sheepIcon = createPOIIcon('🐑', '#8b5cf6'); // Purple icon for bighorn sheep

                const marker = L.marker([sheepLat, sheepLon], { icon: sheepIcon });

                // Build popup content with sheep attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🐑 Bighorn Sheep ${capRelType}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> ${capRelType}</div>
                      <div><strong>Year:</strong> ${year}</div>
                      <div><strong>Subspecies:</strong> ${subspecies}</div>
                      ${capRelType === 'Capture' ? `<div><strong>Capture Site:</strong> ${captureSite}</div>` : ''}
                      ${capRelType === 'Capture' ? `<div><strong>State:</strong> ${stateCapture}</div>` : ''}
                      ${capRelType === 'Release' ? `<div><strong>Release Site:</strong> ${releaseSite}</div>` : ''}
                      ${capRelType === 'Release' ? `<div><strong>State:</strong> ${stateRelease}</div>` : ''}
                      ${bighornNos !== 'N/A' ? `<div><strong>Number of Bighorn:</strong> ${bighornNos}</div>` : ''}
                      ${sheep.distance_miles !== null && sheep.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${sheep.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;

                // Add all sheep attributes (excluding internal fields)
                const excludeFields = ['capRelType', 'year', 'subspecies', 'releaseDate', 'releaseSite', 'stateRelease', 'bighornNos', 'captureSite', 'capMethod', 'captureDate', 'stateCapture', 'rams', 'ewes', 'm_lambs', 'f_lambs', 'x', 'y', 'distance_miles', 'attributes', 'objectid', 'OBJECTID', 'CapRelType', 'Year', 'Subspecies', 'ReleseDate', 'ReleseSite', 'State_Rele', 'BighornNos', 'CapturSite', 'CapMethod', 'CapturDate', 'State_Capt', 'Rams', 'Ewes', 'M_lambs', 'F_lambs'];
                Object.entries(sheep).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';

                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }

                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });

                popupContent += `
                    </div>
                  </div>
                `;

                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(map);
                sheepCount++;
              } catch (error) {
                console.error('Error drawing Bighorn Sheep marker:', error);
              }
            }
          });

          // Add to legend
          if (sheepCount > 0) {
            if (!legendAccumulator['bighorn_sheep_captures_releases']) {
              legendAccumulator['bighorn_sheep_captures_releases'] = {
                icon: '🐑',
                color: '#8b5cf6',
                title: 'Bighorn Sheep Captures and Releases',
                count: 0,
              };
            }
            legendAccumulator['bighorn_sheep_captures_releases'].count += sheepCount;
          }
        }
      } catch (error) {
        console.error('Error processing Bighorn Sheep Captures and Releases:', error);
      }

      // Draw National Aquatic Barrier Dam Inventory as point markers on the map
      try {
        if (enrichments.national_aquatic_barrier_dams_all && Array.isArray(enrichments.national_aquatic_barrier_dams_all)) {
          let damCount = 0;
          enrichments.national_aquatic_barrier_dams_all.forEach((dam: any) => {
            if (dam.lat && dam.lon) {
              try {
                const damLat = dam.lat;
                const damLon = dam.lon;
                const barrierName = dam.barrierName || dam.Barrier_Name || dam.barrier_name || 'Unnamed Dam';
                const otherBarrierName = dam.otherBarrierName || dam.Other_Barrier_Name || dam.other_barrier_name || null;
                const stateAbbreviation = dam.stateAbbreviation || dam.StateAbbreviation || dam.state_abbreviation || null;
                const county = dam.county || dam.COUNTY || dam.County || null;
                const river = dam.river || dam.RIVER || dam.River || null;
                const height = dam.height !== null && dam.height !== undefined ? dam.height : null;
                const width = dam.width !== null && dam.width !== undefined ? dam.width : null;
                const length = dam.length !== null && dam.length !== undefined ? dam.length : null;
                const yearCompleted = dam.yearCompleted !== null && dam.yearCompleted !== undefined ? dam.yearCompleted : null;
                const structureCategory = dam.structureCategory !== null && dam.structureCategory !== undefined ? dam.structureCategory : null;
                const structureClass = dam.structureClass !== null && dam.structureClass !== undefined ? dam.structureClass : null;
                const purposeCategory = dam.purposeCategory !== null && dam.purposeCategory !== undefined ? dam.purposeCategory : null;
                
                // Create a custom icon for dams
                const icon = createPOIIcon('🏗️', '#dc2626'); // Red icon for dams
                
                const marker = L.marker([damLat, damLon], { icon });
                
                // Build popup content with dam attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏗️ National Aquatic Barrier Dam
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Barrier Name:</strong> ${barrierName}</div>
                      ${otherBarrierName ? `<div><strong>Other Name:</strong> ${otherBarrierName}</div>` : ''}
                      ${stateAbbreviation ? `<div><strong>State:</strong> ${stateAbbreviation}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${river ? `<div><strong>River:</strong> ${river}</div>` : ''}
                      ${height !== null ? `<div><strong>Height (ft):</strong> ${height.toLocaleString()}</div>` : ''}
                      ${width !== null ? `<div><strong>Width (ft):</strong> ${width.toLocaleString()}</div>` : ''}
                      ${length !== null ? `<div><strong>Length (ft):</strong> ${length.toLocaleString()}</div>` : ''}
                      ${yearCompleted !== null ? `<div><strong>Year Completed:</strong> ${yearCompleted}</div>` : ''}
                      ${structureCategory !== null ? `<div><strong>Structure Category:</strong> ${structureCategory}</div>` : ''}
                      ${structureClass !== null ? `<div><strong>Structure Class:</strong> ${structureClass}</div>` : ''}
                      ${purposeCategory !== null ? `<div><strong>Purpose Category:</strong> ${purposeCategory}</div>` : ''}
                      ${dam.distance_miles !== null && dam.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${dam.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;
                
                // Add all dam attributes (excluding internal fields)
                const excludeFields = ['barrierName', 'otherBarrierName', 'stateAbbreviation', 'county', 'river', 'height', 'width', 'length', 'yearCompleted', 'structureCategory', 'structureClass', 'purposeCategory', 'lat', 'lon', 'distance_miles', 'attributes', 'objectid'];
                Object.entries(dam).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(mapInstanceRef.current!);
                damCount++;
              } catch (error) {
                console.error('Error drawing National Aquatic Barrier Dam marker:', error);
              }
            }
          });
          if (damCount > 0) {
            if (!legendAccumulator['national_aquatic_barrier_dams']) {
              legendAccumulator['national_aquatic_barrier_dams'] = {
                icon: '🏗️',
                color: '#dc2626',
                title: 'National Aquatic Barrier Dams',
                count: 0,
              };
            }
            legendAccumulator['national_aquatic_barrier_dams'].count += damCount;
          }
        }
      } catch (error) {
        console.error('Error processing National Aquatic Barrier Dam Inventory:', error);
      }

      // Draw SC Coastal Well Inventory as point markers on the map
      try {
        if (enrichments.sc_coastal_well_inventory_all && Array.isArray(enrichments.sc_coastal_well_inventory_all)) {
          let wellCount = 0;
          enrichments.sc_coastal_well_inventory_all.forEach((well: any) => {
            if (well.lat && well.lon) {
              try {
                const wellLat = well.lat;
                const wellLon = well.lon;
                const wellId = well.wellId || well.WELL_ID || well.Well_Id || 'Unknown';
                const owner = well.owner || well.OWNER || well.Owner || '';
                const wellUse = well.wellUse || well.WELL_USE || well.Well_Use || '';
                const county = well.county || well.COUNTY || well.County || '';
                const depthD = well.depthD !== null && well.depthD !== undefined ? well.depthD : null;
                const yieldVal = well.yield !== null && well.yield !== undefined ? well.yield : null;
                
                // Create a custom icon for wells
                const icon = createPOIIcon('💧', '#3b82f6'); // Blue icon for wells
                
                const marker = L.marker([wellLat, wellLon], { icon });
                
                // Build popup content with well attributes
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      💧 SC Coastal Well
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Well ID:</strong> ${wellId}</div>
                      ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                      ${wellUse ? `<div><strong>Well Use:</strong> ${wellUse}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${depthD !== null ? `<div><strong>Depth (ft):</strong> ${depthD.toLocaleString()}</div>` : ''}
                      ${yieldVal !== null ? `<div><strong>Yield (gpm):</strong> ${yieldVal.toLocaleString()}</div>` : ''}
                      ${well.drillYr ? `<div><strong>Drill Year:</strong> ${well.drillYr}</div>` : ''}
                      ${well.distance_miles !== null && well.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${well.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;
                
                // Add all well attributes (excluding internal fields)
                const excludeFields = ['wellId', 'owner', 'wellUse', 'county', 'depthD', 'yield', 'drillYr', 'lat', 'lon', 'distance_miles', 'attributes', 'objectid1', 'objectid', 'scGrid', 'latDDNAD83', 'lonDDNAD83', 'topo', 'elev', 'depthC', 'diam1', 'diam2', 'ohCas', 'screenT', 'screenB', 'drillMo', 'yieldYr', 'gLogs', 'dLogs', 'pTest', 'chem', 'scgsSamples', 'wlQ', 'wlFt', 'wlYr', 'driller', 'remarks', 'globalId', 'dLogsText', 'pTestText'];
                Object.entries(well).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                // Also include any nested attributes object
                if (well.attributes && typeof well.attributes === 'object') {
                  Object.entries(well.attributes).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                }
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                
                // Extend bounds to include this well
                bounds.extend([wellLat, wellLon]);
                wellCount++;
              } catch (error) {
                console.error('Error drawing SC Coastal Well marker:', error);
              }
            }
          });
          
          // Add to legend
          if (wellCount > 0) {
            if (!legendAccumulator['sc_coastal_well_inventory']) {
              legendAccumulator['sc_coastal_well_inventory'] = {
                icon: '💧',
                color: '#3b82f6',
                title: 'SC Coastal Well Inventory',
                count: 0,
              };
            }
            legendAccumulator['sc_coastal_well_inventory'].count += wellCount;
          }
        }
      } catch (error) {
        console.error('Error processing SC Coastal Well Inventory:', error);
      }

      // Draw Orlando Christmas Light Displays as point markers on the map
      try {
        if (enrichments.orlando_christmas_lights_all && Array.isArray(enrichments.orlando_christmas_lights_all)) {
          let displayCount = 0;
          enrichments.orlando_christmas_lights_all.forEach((display: any) => {
            if (display.lat && display.lon) {
              try {
                const displayLat = display.lat;
                const displayLon = display.lon;
                
                // Filter out personal names from name and description
                const nameRaw = display.name || display.Name || display.NAME || null;
                const descriptionRaw = display.description || display.Description || display.DESCRIPTION || null;
                const name = filterPersonalNames(nameRaw) || 'Christmas Light Display';
                const description = filterPersonalNames(descriptionRaw) || '';
                
                const address = display.address || display.Address || display.ADDRESS || '';
                const dates = display.dates || display.Dates || display.DATES || '';
                const times = display.times || display.Times || display.TIMES || '';
                const website = display.website || display.Website || display.WEBSITE || '';
                
                // Create a custom icon for Christmas lights
                const icon = createPOIIcon('✨', '#ef4444'); // Red color with sparkles emoji for Christmas lights
                
                const marker = L.marker([displayLat, displayLon], { icon });
                
                // Build popup content with display information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎄 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${description ? `<div style="margin-top: 6px;"><strong>Description:</strong> ${description}</div>` : ''}
                      ${dates ? `<div><strong>Dates:</strong> ${dates}</div>` : ''}
                      ${times ? `<div><strong>Times:</strong> ${times}</div>` : ''}
                      ${website ? `<div style="margin-top: 6px;"><a href="${website}" target="_blank" style="color: #3b82f6; text-decoration: underline;">Visit Website</a></div>` : ''}
                      ${display.distance_miles !== null && display.distance_miles !== undefined ? `<div style="margin-top: 6px;"><strong>Distance:</strong> ${display.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;
                
                // Add all display attributes (excluding internal fields)
                const excludeFields = ['name', 'address', 'description', 'dates', 'times', 'website', 'lat', 'lon', 'distance_miles', 'attributes', 'objectid'];
                Object.entries(display).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                // Also include any nested attributes object
                if (display.attributes && typeof display.attributes === 'object') {
                  Object.entries(display.attributes).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                }
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                
                // Extend bounds to include this display
                bounds.extend([displayLat, displayLon]);
                displayCount++;
              } catch (error) {
                console.error('Error drawing Orlando Christmas Light Display marker:', error);
              }
            }
          });
          
          // Add to legend
          if (displayCount > 0) {
            if (!legendAccumulator['orlando_christmas_lights']) {
              legendAccumulator['orlando_christmas_lights'] = {
                icon: '✨',
                color: '#ef4444',
                title: 'Orlando Christmas Light Displays',
                count: 0,
              };
            }
            legendAccumulator['orlando_christmas_lights'].count += displayCount;
          }
        }
      } catch (error) {
        console.error('Error processing Orlando Christmas Light Displays:', error);
      }

      // Draw US Drilling Platforms as point markers on the map
      try {
        if (enrichments.us_drilling_platforms_all && Array.isArray(enrichments.us_drilling_platforms_all)) {
          let platformCount = 0;
          enrichments.us_drilling_platforms_all.forEach((platform: any) => {
            if (platform.lat && platform.lon) {
              try {
                const platformLat = platform.lat;
                const platformLon = platform.lon;
                const structureName = platform.structureName || platform.STRUCTURE_NAME || platform.Structure_Name || 'Drilling Platform';
                const structureNumber = platform.structureNumber || platform.STRUCTURE_NUMBER || platform.Structure_Number || '';
                const complexIdNumber = platform.complexIdNumber !== null && platform.complexIdNumber !== undefined ? platform.complexIdNumber : (platform.COMPLEX_ID_NUMBER !== null && platform.COMPLEX_ID_NUMBER !== undefined ? platform.COMPLEX_ID_NUMBER : null);
                const areaCode = platform.areaCode || platform.AREA_CODE || platform.Area_Code || '';
                const blockNumber = platform.blockNumber || platform.BLOCK_NUMBER || platform.Block_Number || '';
                const districtCode = platform.districtCode !== null && platform.districtCode !== undefined ? platform.districtCode : (platform.DISTRICT_CODE !== null && platform.DISTRICT_CODE !== undefined ? platform.DISTRICT_CODE : null);
                const majorStructureFlag = platform.majorStructureFlag || platform.Major_Structure_Flag || platform.major_structure_flag || '';
                
                // Create a custom icon for drilling platforms
                const icon = createPOIIcon('🛢️', '#f59e0b'); // Amber/orange color for drilling platforms
                
                const marker = L.marker([platformLat, platformLon], { icon });
                
                // Build popup content with platform information
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🛢️ ${structureName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${structureNumber ? `<div><strong>Structure Number:</strong> ${structureNumber}</div>` : ''}
                      ${complexIdNumber !== null ? `<div><strong>Complex ID:</strong> ${complexIdNumber}</div>` : ''}
                      ${areaCode ? `<div><strong>Area Code:</strong> ${areaCode}</div>` : ''}
                      ${blockNumber ? `<div><strong>Block Number:</strong> ${blockNumber}</div>` : ''}
                      ${districtCode !== null ? `<div><strong>District Code:</strong> ${districtCode}</div>` : ''}
                      ${majorStructureFlag ? `<div><strong>Major Structure:</strong> ${majorStructureFlag}</div>` : ''}
                      ${platform.distance_miles !== null && platform.distance_miles !== undefined ? `<div style="margin-top: 6px;"><strong>Distance:</strong> ${platform.distance_miles.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      <div style="font-weight: 600; margin-bottom: 6px; color: #1f2937;">All Attributes:</div>
                `;
                
                // Add all platform attributes (excluding internal fields)
                const excludeFields = ['structureName', 'structureNumber', 'complexIdNumber', 'areaCode', 'blockNumber', 'districtCode', 'majorStructureFlag', 'lat', 'lon', 'distance_miles', 'attributes', 'objectid', 'STRUCTURE_NAME', 'STRUCTURE_NUMBER', 'COMPLEX_ID_NUMBER', 'AREA_CODE', 'BLOCK_NUMBER', 'DISTRICT_CODE', 'Major_Structure_Flag', 'LATITUDE', 'LONGITUDE'];
                Object.entries(platform).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                // Also include any nested attributes object
                if (platform.attributes && typeof platform.attributes === 'object') {
                  Object.entries(platform.attributes).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                      let displayValue = '';
                      
                      if (typeof value === 'object') {
                        displayValue = JSON.stringify(value);
                      } else if (typeof value === 'number') {
                        displayValue = value.toLocaleString();
                      } else {
                        displayValue = String(value);
                      }
                      
                      popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                    }
                  });
                }
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(poi);
                
                // Extend bounds to include this platform
                bounds.extend([platformLat, platformLon]);
                platformCount++;
              } catch (error) {
                console.error('Error drawing US Drilling Platform marker:', error);
              }
            }
          });
          
          // Add to legend
          if (platformCount > 0) {
            if (!legendAccumulator['us_drilling_platforms']) {
              legendAccumulator['us_drilling_platforms'] = {
                icon: '🛢️',
                color: '#f59e0b',
                title: 'US Drilling Platforms',
                count: 0,
              };
            }
            legendAccumulator['us_drilling_platforms'].count += platformCount;
          }
        }
      } catch (error) {
        console.error('Error processing US Drilling Platforms:', error);
      }

      // Draw Guam Villages as polygons on the map
      try {
        if (enrichments.guam_villages_all && Array.isArray(enrichments.guam_villages_all)) {
          let villageCount = 0;
          enrichments.guam_villages_all.forEach((village: any) => {
            if (village.geometry && village.geometry.rings && Array.isArray(village.geometry.rings)) {
              try {
                const rings = village.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngs: L.LatLngExpression[][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => [coord[1], coord[0]] as L.LatLngExpression);
                  });
                  
                  // Create polygon with first ring as outer boundary and rest as holes
                  const polygon = L.polygon(latlngs, {
                    color: '#10b981',
                    weight: 2,
                    opacity: 0.8,
                    fillColor: '#10b981',
                    fillOpacity: 0.2
                  });
                  
                  // Build popup content
                  const villageName = village.NAME || village.name || village.Name || 'Unknown Village';
                  const isContaining = village.isContaining || false;
                  const distance = village.distance_miles !== null && village.distance_miles !== undefined ? village.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏝️ ${villageName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div style="color: #10b981; font-weight: 600;">✓ Location is within this village</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Store metadata for tabbed popup
                  (polygon as any).__layerType = 'guam_villages';
                  (polygon as any).__layerTitle = 'Guam Villages';
                  
                  // Extend bounds
                  bounds.extend(polygon.getBounds());
                  villageCount++;
                }
              } catch (error) {
                console.error('Error drawing Guam Village polygon:', error);
              }
            }
          });
          
          // Add to legend
          if (villageCount > 0) {
            if (!legendAccumulator['guam_villages']) {
              legendAccumulator['guam_villages'] = {
                icon: '🏝️',
                color: '#10b981',
                title: 'Guam Villages',
                count: 0,
              };
            }
            legendAccumulator['guam_villages'].count += villageCount;
          }
        }
      } catch (error) {
        console.error('Error processing Guam Villages:', error);
      }

      // Draw Guam State Boundary as polygons on the map
      try {
        if (enrichments.guam_state_boundary_all && Array.isArray(enrichments.guam_state_boundary_all)) {
          let boundaryCount = 0;
          enrichments.guam_state_boundary_all.forEach((boundary: any) => {
            if (boundary.geometry && boundary.geometry.rings && Array.isArray(boundary.geometry.rings)) {
              try {
                const rings = boundary.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngs: L.LatLngExpression[][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => [coord[1], coord[0]] as L.LatLngExpression);
                  });
                  
                  // Create polygon with first ring as outer boundary and rest as holes
                  const polygon = L.polygon(latlngs, {
                    color: '#3b82f6',
                    weight: 3,
                    opacity: 0.9,
                    fillColor: '#3b82f6',
                    fillOpacity: 0.15
                  });
                  
                  // Build popup content
                  const isContaining = boundary.isContaining || false;
                  const distance = boundary.distance_miles !== null && boundary.distance_miles !== undefined ? boundary.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏝️ Guam State Boundary
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${isContaining ? '<div style="color: #3b82f6; font-weight: 600;">✓ Location is within Guam</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Store metadata for tabbed popup
                  (polygon as any).__layerType = 'guam_state_boundary';
                  (polygon as any).__layerTitle = 'Guam State Boundary';
                  
                  // Extend bounds
                  bounds.extend(polygon.getBounds());
                  boundaryCount++;
                }
              } catch (error) {
                console.error('Error drawing Guam State Boundary polygon:', error);
              }
            }
          });
          
          // Add to legend
          if (boundaryCount > 0) {
            if (!legendAccumulator['guam_state_boundary']) {
              legendAccumulator['guam_state_boundary'] = {
                icon: '🏝️',
                color: '#3b82f6',
                title: 'Guam State Boundary',
                count: 0,
              };
            }
            legendAccumulator['guam_state_boundary'].count += boundaryCount;
          }
        }
      } catch (error) {
        console.error('Error processing Guam State Boundary:', error);
      }

      // Draw NPS National Parks as polygons on the map
      try {
        if (enrichments.nps_national_parks_all && Array.isArray(enrichments.nps_national_parks_all)) {
          let parkCount = 0;
          enrichments.nps_national_parks_all.forEach((park: any) => {
            if (park.geometry && park.geometry.rings && Array.isArray(park.geometry.rings)) {
              try {
                const rings = park.geometry.rings;
                if (rings && rings.length > 0) {
                  // Convert all rings to Leaflet format (outer ring + holes)
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  // Validate outer ring
                  if (latlngsArray[0].length < 3) {
                    console.warn('NPS National Park outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const color = '#16a34a'; // Green color for national parks
                  const weight = 3;
                  const opacity = 0.8;
                  
                  // L.polygon can handle multiple rings (outer + holes)
                  const parkPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const fullName = park.fullName || park.name || 'Unknown National Park';
                  const parkCode = park.parkCode || null;
                  const designation = park.designation || null;
                  const states = park.states || null;
                  const description = park.description || null;
                  const url = park.url || null;
                  const distance = park.distance_miles !== null && park.distance_miles !== undefined ? park.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏞️ ${fullName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${designation ? `<div><strong>Designation:</strong> ${designation}</div>` : ''}
                        ${parkCode ? `<div><strong>Park Code:</strong> ${parkCode}</div>` : ''}
                        ${states ? `<div><strong>States:</strong> ${states}</div>` : ''}
                        ${description ? `<div style="margin-top: 8px;"><strong>Description:</strong> ${description.substring(0, 200)}${description.length > 200 ? '...' : ''}</div>` : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        ${url ? `<div style="margin-top: 8px;"><a href="${url}" target="_blank" style="color: #3b82f6;">Visit NPS Website →</a></div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  parkPolygon.bindPopup(popupContent, { maxWidth: 400 });
                  parkPolygon.addTo(primary);
                  
                  // Store metadata for tabbed popup
                  (parkPolygon as any).__layerType = 'nps_national_parks';
                  (parkPolygon as any).__layerTitle = 'NPS National Parks';
                  
                  // Extend map bounds
                  const polygonBounds = parkPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                  
                  parkCount++;
                }
              } catch (error) {
                console.error('Error drawing NPS National Park polygon:', error);
              }
            } else if (park.lat && park.lon) {
              // If no geometry but has coordinates, draw as marker
              try {
                const parkMarker = L.marker([park.lat, park.lon], {
                  icon: L.divIcon({
                    className: 'custom-park-marker',
                    html: '<div style="background-color: #16a34a; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                  })
                });
                
                const fullName = park.fullName || park.name || 'Unknown National Park';
                const parkCode = park.parkCode || null;
                const designation = park.designation || null;
                const states = park.states || null;
                const description = park.description || null;
                const url = park.url || null;
                const distance = park.distance_miles !== null && park.distance_miles !== undefined ? park.distance_miles : 0;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏞️ ${fullName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${designation ? `<div><strong>Designation:</strong> ${designation}</div>` : ''}
                      ${parkCode ? `<div><strong>Park Code:</strong> ${parkCode}</div>` : ''}
                      ${states ? `<div><strong>States:</strong> ${states}</div>` : ''}
                      ${description ? `<div style="margin-top: 8px;"><strong>Description:</strong> ${description.substring(0, 200)}${description.length > 200 ? '...' : ''}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${url ? `<div style="margin-top: 8px;"><a href="${url}" target="_blank" style="color: #3b82f6;">Visit NPS Website →</a></div>` : ''}
                    </div>
                  </div>
                `;
                
                parkMarker.bindPopup(popupContent, { maxWidth: 400 });
                parkMarker.addTo(primary);
                
                // Store metadata for tabbed popup
                (parkMarker as any).__layerType = 'nps_national_parks';
                (parkMarker as any).__layerTitle = 'NPS National Parks';
                
                parkCount++;
              } catch (error) {
                console.error('Error drawing NPS National Park marker:', error);
              }
            }
          });
          
          if (parkCount > 0) {
            if (!legendAccumulator['nps_national_parks']) {
              legendAccumulator['nps_national_parks'] = {
                icon: '🏞️',
                color: '#16a34a',
                title: 'NPS National Parks',
                count: 0,
              };
            }
            legendAccumulator['nps_national_parks'].count += parkCount;
          }
        }
      } catch (error) {
        console.error('Error processing NPS National Parks:', error);
      }

      // Draw NPS National Register of Historic Places Locations as markers on the map
      try {
        if (enrichments.nps_nrhp_locations_all && Array.isArray(enrichments.nps_nrhp_locations_all)) {
          let nrhpCount = 0;
          enrichments.nps_nrhp_locations_all.forEach((location: any) => {
            if (location.lat && location.lon) {
              try {
                const nrhpMarker = L.marker([location.lat, location.lon], {
                  icon: L.divIcon({
                    className: 'custom-nrhp-marker',
                    html: '<div style="background-color: #dc2626; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [10, 10],
                    iconAnchor: [5, 5]
                  })
                });
                
                const resourceName = location.resourceName || 'Unknown Historic Place';
                const nrhpNumber = location.nrhpNumber || null;
                const resourceId = location.resourceId || null;
                const state = location.state || null;
                const county = location.county || null;
                const city = location.city || null;
                const address = location.address || null;
                const propertyType = location.propertyType || null;
                const dateListed = location.dateListed || null;
                const dateAdded = location.dateAdded || null;
                const distance = location.distance_miles !== null && location.distance_miles !== undefined ? location.distance_miles : 0;
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏛️ ${resourceName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${nrhpNumber ? `<div><strong>NRHP Number:</strong> ${nrhpNumber}</div>` : ''}
                      ${resourceId ? `<div><strong>Resource ID:</strong> ${resourceId}</div>` : ''}
                      ${propertyType ? `<div><strong>Property Type:</strong> ${propertyType}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                      ${dateListed ? `<div><strong>Date Listed:</strong> ${dateListed}</div>` : ''}
                      ${dateAdded ? `<div><strong>Date Added:</strong> ${dateAdded}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                nrhpMarker.bindPopup(popupContent, { maxWidth: 400 });
                nrhpMarker.addTo(poi);
                
                // Store metadata for tabbed popup
                (nrhpMarker as any).__layerType = 'nps_nrhp_locations';
                (nrhpMarker as any).__layerTitle = 'NPS NRHP Locations';
                (nrhpMarker as any).__popupContent = popupContent;
                
                nrhpCount++;
              } catch (error) {
                console.error('Error drawing NPS NRHP Location marker:', error);
              }
            }
          });
          
          if (nrhpCount > 0) {
            if (!legendAccumulator['nps_nrhp_locations']) {
              legendAccumulator['nps_nrhp_locations'] = {
                icon: '🏛️',
                color: '#dc2626',
                title: 'NPS National Register of Historic Places',
                count: 0,
              };
            }
            legendAccumulator['nps_nrhp_locations'].count += nrhpCount;
          }
        }
      } catch (error) {
        console.error('Error processing NPS NRHP Locations:', error);
      }

      // Draw Ireland Centres of Population as markers on the map
      try {
        if (enrichments.ireland_centres_of_population_all && Array.isArray(enrichments.ireland_centres_of_population_all)) {
          let centreCount = 0;
          enrichments.ireland_centres_of_population_all.forEach((centre: any) => {
            if (centre.lat && centre.lon) {
              try {
                const centreMarker = L.marker([centre.lat, centre.lon], {
                  icon: createPOIIcon('🏘️', '#a855f7')
                });
                
                // Extract fields with multiple possible field name variations
                const irishName = centre.irishName || centre.Irish_Name || centre.IRISH_NAME || '';
                const county = centre.county || centre.County || centre.COUNTY || '';
                const englishName = centre.englishName || centre.English_Na || centre.ENGLISH_NA || '';
                const contae = centre.contae || centre.Contae || centre.CONTAE || '';
                const townClass = centre.townClass || centre.Town_Class || centre.TOWN_CLASS || '';
                const classification = centre.classification || centre.Classifica || centre.CLASSIFICA || '';
                const distance = centre.distance_miles !== null && centre.distance_miles !== undefined ? centre.distance_miles : 0;
                
                // Use Irish Name as primary title if available, otherwise English Name
                const displayName = irishName || englishName || 'Unknown Centre';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏘️ ${displayName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${irishName ? `<div><strong>Irish Name:</strong> ${irishName}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${englishName && englishName !== displayName ? `<div><strong>English Name:</strong> ${englishName}</div>` : ''}
                      ${contae ? `<div><strong>Contae:</strong> ${contae}</div>` : ''}
                      ${townClass ? `<div><strong>Town Class:</strong> ${townClass}</div>` : ''}
                      ${classification ? `<div><strong>Classification:</strong> ${classification}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other centre attributes
                const excludeFields = ['englishName', 'English_Na', 'irishName', 'Irish_Name', 'county', 'County', 'contae', 'Contae', 'townClass', 'Town_Class', 'classification', 'Classifica', 'lat', 'lon', 'distance_miles', 'objectId', 'OBJECTID_1'];
                Object.entries(centre).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                centreMarker.bindPopup(popupContent, { maxWidth: 400 });
                centreMarker.addTo(poi);
                
                // Store metadata for tabbed popup
                (centreMarker as any).__layerType = 'ireland_centres_of_population';
                (centreMarker as any).__layerTitle = 'Ireland Centres of Population';
                (centreMarker as any).__popupContent = popupContent;
                
                bounds.extend([centre.lat, centre.lon]);
                centreCount++;
              } catch (error) {
                console.error('Error drawing Ireland Centre of Population marker:', error);
              }
            }
          });
          
          if (centreCount > 0) {
            if (!legendAccumulator['ireland_centres_of_population']) {
              legendAccumulator['ireland_centres_of_population'] = {
                icon: '🏘️',
                color: '#a855f7',
                title: 'Ireland Centres of Population',
                count: 0,
              };
            }
            legendAccumulator['ireland_centres_of_population'].count += centreCount;
          }
        }
      } catch (error) {
        console.error('Error processing Ireland Centres of Population:', error);
      }

      // Draw Ireland Mountains as markers on the map
      try {
        if (enrichments.ireland_mountains_all && Array.isArray(enrichments.ireland_mountains_all)) {
          let mountainCount = 0;
          enrichments.ireland_mountains_all.forEach((mountain: any) => {
            if (mountain.lat && mountain.lon) {
              try {
                const mountainMarker = L.marker([mountain.lat, mountain.lon], {
                  icon: createPOIIcon('⛰️', '#6d28d9')
                });
                
                const name = mountain.name || mountain.NAMN1 || '';
                const fCode = mountain.fCode || mountain.F_CODE || '';
                const distance = mountain.distance_miles !== null && mountain.distance_miles !== undefined ? mountain.distance_miles : 0;
                
                const displayName = name || 'Unknown Mountain';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ⛰️ ${displayName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${fCode ? `<div><strong>F Code:</strong> ${fCode}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other mountain attributes
                const excludeFields = ['name', 'NAMN1', 'fCode', 'F_CODE', 'lat', 'lon', 'distance_miles', 'objectId', 'OBJECTID'];
                Object.entries(mountain).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                mountainMarker.bindPopup(popupContent, { maxWidth: 400 });
                mountainMarker.addTo(poi);
                
                // Store metadata for tabbed popup
                (mountainMarker as any).__layerType = 'ireland_mountains';
                (mountainMarker as any).__layerTitle = 'Ireland Mountain Peaks';
                (mountainMarker as any).__popupContent = popupContent;
                
                bounds.extend([mountain.lat, mountain.lon]);
                mountainCount++;
              } catch (error) {
                console.error('Error drawing Ireland Mountain marker:', error);
              }
            }
          });
          
          if (mountainCount > 0) {
            if (!legendAccumulator['ireland_mountains']) {
              legendAccumulator['ireland_mountains'] = {
                icon: '⛰️',
                color: '#6d28d9',
                title: 'Ireland Mountain Peaks',
                count: 0,
              };
            }
            legendAccumulator['ireland_mountains'].count += mountainCount;
          }
        }

        // Draw Ireland POIs as points on the map
        if (enrichments.ireland_pois_all && Array.isArray(enrichments.ireland_pois_all)) {
          let poiCount = 0;
          enrichments.ireland_pois_all.forEach((poiItem: any) => {
            if (poiItem.lat && poiItem.lon) {
              try {
                const poiMarker = L.marker([poiItem.lat, poiItem.lon], {
                  icon: createPOIIcon('📍', '#10b981')
                });
                
                const orgName = poiItem.orgName || poiItem.ORG_NAME || '';
                const category = poiItem.category || poiItem.Category || '';
                const name = poiItem.name || poiItem.Name || '';
                const address = poiItem.address || poiItem.Address || '';
                const eircode = poiItem.eircode || poiItem.EIRCODE || '';
                const town = poiItem.town || poiItem.Town || '';
                const county = poiItem.county || poiItem.County || '';
                const distance = poiItem.distance_miles !== null && poiItem.distance_miles !== undefined ? poiItem.distance_miles : 0;
                
                // Use ORG_NAME and Category for display as requested
                const displayName = orgName || name || 'Unknown POI';
                const displayCategory = category || 'Point of Interest';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      📍 ${displayName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${displayCategory ? `<div><strong>Category:</strong> ${displayCategory}</div>` : ''}
                      ${name && name !== displayName ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${eircode ? `<div><strong>Eircode:</strong> ${eircode}</div>` : ''}
                      ${town ? `<div><strong>Town:</strong> ${town}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all other POI attributes
                const excludeFields = ['orgName', 'ORG_NAME', 'category', 'Category', 'name', 'Name', 'address', 'Address', 'eircode', 'EIRCODE', 'town', 'Town', 'county', 'County', 'lat', 'lon', 'latitude', 'Latitude', 'longitude', 'Longitude', 'geometry', 'distance_miles', 'objectId', 'ObjectId', 'OBJECTID', 'ESRI_OID'];
                Object.entries(poiItem).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                (poiMarker as any).__layerType = 'ireland_pois';
                (poiMarker as any).__layerTitle = 'Ireland Points of Interest';
                (poiMarker as any).__popupContent = popupContent;
                
                poiMarker.bindPopup(popupContent, { maxWidth: 400 });
                poiMarker.addTo(poi);
                bounds.extend([poiItem.lat, poiItem.lon]);
                poiCount++;
      } catch (error) {
                console.error('Error drawing Ireland POI marker:', error);
              }
            }
          });
          
          if (poiCount > 0) {
            if (!legendAccumulator['ireland_pois']) {
              legendAccumulator['ireland_pois'] = {
                icon: '📍',
                color: '#10b981',
                title: 'Ireland Points of Interest',
                count: 0,
              };
            }
            legendAccumulator['ireland_pois'].count += poiCount;
          }
        }

        // Draw Ireland High Water Marks as polylines on the map
        if (enrichments.ireland_high_water_marks_all && Array.isArray(enrichments.ireland_high_water_marks_all)) {
          let waterMarkCount = 0;
          enrichments.ireland_high_water_marks_all.forEach((waterMark: any) => {
            if (waterMark.geometry && waterMark.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                // ESRI polylines have paths (array of coordinate arrays)
                const paths = waterMark.geometry.paths;
                if (paths && paths.length > 0) {
                  waterMarkCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const guid = waterMark.guid || waterMark.GUID || 'Unknown';
                    const bdyTypeValue = waterMark.bdyTypeValue || waterMark.BDY_TYPE_VALUE || null;
                    const shapeLength = waterMark.shapeLength || waterMark.Shape__Length || waterMark.SHAPE__LENGTH || null;

                    // Create polyline with blue color for water marks
                    const polyline = L.polyline(latlngs, {
                      color: '#0284c7', // Blue color for water marks
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all water mark attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🌊 High Water Mark
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${guid ? `<div><strong>GUID:</strong> ${guid}</div>` : ''}
                          ${bdyTypeValue ? `<div><strong>Boundary Type:</strong> ${bdyTypeValue}</div>` : ''}
                          ${shapeLength !== null && shapeLength !== undefined ? `<div><strong>Length:</strong> ${shapeLength.toFixed(2)} m</div>` : ''}
                          ${waterMark.distance_miles !== null && waterMark.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${waterMark.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all water mark attributes (excluding internal fields)
                    const excludeFields = ['guid', 'GUID', 'bdyTypeValue', 'BDY_TYPE_VALUE', 'shapeLength', 'Shape__Length', 'SHAPE__LENGTH', 'geometry', 'distance_miles', 'objectId', 'OBJECTID'];
                    Object.entries(waterMark).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    (polyline as any).__layerType = 'ireland_high_water_marks';
                    (polyline as any).__layerTitle = 'Ireland Coastal High Water Marks';
                    (polyline as any).__popupContent = popupContent;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Ireland High Water Mark polyline:', error);
              }
            }
          });
          
          if (waterMarkCount > 0) {
            if (!legendAccumulator['ireland_high_water_marks']) {
              legendAccumulator['ireland_high_water_marks'] = {
                icon: '🌊',
                color: '#0284c7',
                title: 'Ireland Coastal High Water Marks',
                count: 0,
              };
            }
            legendAccumulator['ireland_high_water_marks'].count += waterMarkCount;
          }
        }

        // Draw Australia Railways as polylines on the map
        if (enrichments.australia_railways_all && Array.isArray(enrichments.australia_railways_all)) {
          let railwayCount = 0;
          enrichments.australia_railways_all.forEach((railway: any) => {
            if (railway.geometry && railway.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = railway.geometry.paths;
                if (paths && paths.length > 0) {
                  railwayCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const name = railway.name || railway.Name || 'Unknown Railway';
                    const operationalStatus = railway.operationalStatus || railway.operational_status || railway.OPERATIONAL_STATUS || null;
                    const trackGauge = railway.trackGauge || railway.track_gauge || railway.TRACK_GAUGE || null;
                    const tracks = railway.tracks || railway.Tracks || null;
                    const lengthKm = railway.lengthKm || railway.length_km || railway.LENGTH_KM || null;
                    const alternativeName = railway.alternativeName || railway.alternative_name || railway.ALTERNATIVE_NAME || null;
                    const owner = railway.owner || railway.Owner || null;

                    // Create polyline with brown/rust color for railways
                    const polyline = L.polyline(latlngs, {
                      color: '#b45309', // Brown/rust color for railways
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all railway attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚂 ${name}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${operationalStatus ? `<div><strong>Status:</strong> ${operationalStatus}</div>` : ''}
                          ${trackGauge ? `<div><strong>Track Gauge:</strong> ${trackGauge}</div>` : ''}
                          ${tracks ? `<div><strong>Tracks:</strong> ${tracks}</div>` : ''}
                          ${lengthKm !== null && lengthKm !== undefined ? `<div><strong>Length:</strong> ${lengthKm.toFixed(2)} km</div>` : ''}
                          ${alternativeName ? `<div><strong>Alternative Name:</strong> ${alternativeName}</div>` : ''}
                          ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                          ${railway.distance_miles !== null && railway.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${railway.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all railway attributes (excluding internal fields)
                    const excludeFields = ['name', 'Name', 'operationalStatus', 'operational_status', 'OPERATIONAL_STATUS', 'trackGauge', 'track_gauge', 'TRACK_GAUGE', 'tracks', 'Tracks', 'lengthKm', 'length_km', 'LENGTH_KM', 'alternativeName', 'alternative_name', 'ALTERNATIVE_NAME', 'owner', 'Owner', 'geometry', 'distance_miles', 'objectId', 'OBJECTID', 'objectid', 'lat', 'lon'];
                    Object.entries(railway).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    (polyline as any).__layerType = 'australia_railways';
                    (polyline as any).__layerTitle = 'Australia Railways';
                    (polyline as any).__popupContent = popupContent;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Australia Railway polyline:', error);
              }
            }
          });
          
          if (railwayCount > 0) {
            if (!legendAccumulator['australia_railways']) {
              legendAccumulator['australia_railways'] = {
                icon: '🚂',
                color: '#b45309',
                title: 'Australia Railways',
                count: 0,
              };
            }
            legendAccumulator['australia_railways'].count += railwayCount;
          }
        }

        // Draw Australia Trams as polylines on the map
        if (enrichments.australia_trams_all && Array.isArray(enrichments.australia_trams_all)) {
          let tramCount = 0;
          enrichments.australia_trams_all.forEach((tram: any) => {
            if (tram.geometry && tram.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = tram.geometry.paths;
                if (paths && paths.length > 0) {
                  tramCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const name = tram.name || tram.Name || 'Unknown Tram';
                    const operationalStatus = tram.operationalStatus || tram.operational_status || tram.OPERATIONAL_STATUS || null;
                    const trackGauge = tram.trackGauge || tram.track_gauge || tram.TRACK_GAUGE || null;
                    const tracks = tram.tracks || tram.Tracks || null;
                    const lengthKm = tram.lengthKm || tram.length_km || tram.LENGTH_KM || null;
                    const alternativeName = tram.alternativeName || tram.alternative_name || tram.ALTERNATIVE_NAME || null;
                    const owner = tram.owner || tram.Owner || null;

                    // Create polyline with green color for trams
                    const polyline = L.polyline(latlngs, {
                      color: '#059669', // Green color for trams
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all tram attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🚋 ${name}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${operationalStatus ? `<div><strong>Status:</strong> ${operationalStatus}</div>` : ''}
                          ${trackGauge ? `<div><strong>Track Gauge:</strong> ${trackGauge}</div>` : ''}
                          ${tracks ? `<div><strong>Tracks:</strong> ${tracks}</div>` : ''}
                          ${lengthKm !== null && lengthKm !== undefined ? `<div><strong>Length:</strong> ${lengthKm.toFixed(2)} km</div>` : ''}
                          ${alternativeName ? `<div><strong>Alternative Name:</strong> ${alternativeName}</div>` : ''}
                          ${owner ? `<div><strong>Owner:</strong> ${owner}</div>` : ''}
                          ${tram.distance_miles !== null && tram.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${tram.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all tram attributes (excluding internal fields)
                    const excludeFields = ['name', 'Name', 'operationalStatus', 'operational_status', 'OPERATIONAL_STATUS', 'trackGauge', 'track_gauge', 'TRACK_GAUGE', 'tracks', 'Tracks', 'lengthKm', 'length_km', 'LENGTH_KM', 'alternativeName', 'alternative_name', 'ALTERNATIVE_NAME', 'owner', 'Owner', 'geometry', 'distance_miles', 'objectId', 'OBJECTID', 'objectid', 'lat', 'lon'];
                    Object.entries(tram).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    (polyline as any).__layerType = 'australia_trams';
                    (polyline as any).__layerTitle = 'Australia Trams';
                    (polyline as any).__popupContent = popupContent;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Australia Tram polyline:', error);
              }
            }
          });
          
          if (tramCount > 0) {
            if (!legendAccumulator['australia_trams']) {
              legendAccumulator['australia_trams'] = {
                icon: '🚋',
                color: '#059669',
                title: 'Australia Trams',
                count: 0,
              };
            }
            legendAccumulator['australia_trams'].count += tramCount;
          }
        }

        // Draw Australia National Roads as polylines on the map
        if (enrichments.australia_national_roads_all && Array.isArray(enrichments.australia_national_roads_all)) {
          let roadCount = 0;
          enrichments.australia_national_roads_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = road.geometry.paths;
                if (paths && paths.length > 0) {
                  roadCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const name = road.fullStreetName || `${road.streetName || 'Unnamed'} ${road.streetType || ''}`.trim() || 'Unnamed Road';
                    const hierarchy = road.hierarchy || null;
                    const status = road.status || null;
                    const surface = road.surface || null;
                    const state = road.state || null;
                    const oneWay = road.oneWay || null;
                    const laneDescription = road.laneDescription || null;

                    // Create polyline with blue color for national roads
                    const polyline = L.polyline(latlngs, {
                      color: '#2563eb', // Blue color for national roads
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all road attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${name}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${hierarchy ? `<div><strong>Hierarchy:</strong> ${hierarchy}</div>` : ''}
                          ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                          ${surface ? `<div><strong>Surface:</strong> ${surface}</div>` : ''}
                          ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                          ${oneWay ? `<div><strong>One Way:</strong> ${oneWay}</div>` : ''}
                          ${laneDescription ? `<div><strong>Lanes:</strong> ${laneDescription}</div>` : ''}
                          ${road.distance_miles !== null && road.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${road.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all road attributes (excluding internal fields)
                    const excludeFields = ['fullStreetName', 'FULL_STREET_NAME', 'streetName', 'STREET_NAME', 'street_name_label', 'STREET_NAME_LABEL', 'streetType', 'STREET_TYPE', 'street_type_label', 'STREET_TYPE_LABEL', 'hierarchy', 'HIERARCHY', 'status', 'STATUS', 'surface', 'SURFACE', 'state', 'STATE', 'oneWay', 'ONE_WAY', 'laneDescription', 'LANE_DESCRIPTION', 'geometry', 'distance_miles', 'objectId', 'OBJECTID', 'objectid', 'roadId', 'ROAD_ID', 'lat', 'lon'];
                    Object.entries(road).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    (polyline as any).__layerType = 'australia_national_roads';
                    (polyline as any).__layerTitle = 'Australia National Roads';
                    (polyline as any).__popupContent = popupContent;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Australia National Road polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['australia_national_roads']) {
              legendAccumulator['australia_national_roads'] = {
                icon: '🛣️',
                color: '#2563eb',
                title: 'Australia National Roads',
                count: 0,
              };
            }
            legendAccumulator['australia_national_roads'].count += roadCount;
          }
        }

        // Draw Australia Major Roads as polylines on the map
        if (enrichments.australia_major_roads_all && Array.isArray(enrichments.australia_major_roads_all)) {
          let roadCount = 0;
          enrichments.australia_major_roads_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = road.geometry.paths;
                if (paths && paths.length > 0) {
                  roadCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const name = road.fullStreetName || `${road.streetName || 'Unnamed'} ${road.streetType || ''}`.trim() || 'Unnamed Road';
                    const hierarchy = road.hierarchy || null;
                    const status = road.status || null;
                    const surface = road.surface || null;
                    const state = road.state || null;
                    const oneWay = road.oneWay || null;
                    const laneDescription = road.laneDescription || null;

                    // Create polyline with red color for major roads
                    const polyline = L.polyline(latlngs, {
                      color: '#dc2626', // Red color for major roads
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all road attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${name}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${hierarchy ? `<div><strong>Hierarchy:</strong> ${hierarchy}</div>` : ''}
                          ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                          ${surface ? `<div><strong>Surface:</strong> ${surface}</div>` : ''}
                          ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                          ${oneWay ? `<div><strong>One Way:</strong> ${oneWay}</div>` : ''}
                          ${laneDescription ? `<div><strong>Lanes:</strong> ${laneDescription}</div>` : ''}
                          ${road.distance_miles !== null && road.distance_miles !== undefined ? `<div><strong>Distance:</strong> ${road.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all road attributes (excluding internal fields)
                    const excludeFields = ['fullStreetName', 'FULL_STREET_NAME', 'streetName', 'STREET_NAME', 'street_name_label', 'STREET_NAME_LABEL', 'streetType', 'STREET_TYPE', 'street_type_label', 'STREET_TYPE_LABEL', 'hierarchy', 'HIERARCHY', 'status', 'STATUS', 'surface', 'SURFACE', 'state', 'STATE', 'oneWay', 'ONE_WAY', 'laneDescription', 'LANE_DESCRIPTION', 'geometry', 'distance_miles', 'objectId', 'OBJECTID', 'objectid', 'roadId', 'ROAD_ID', 'lat', 'lon'];
                    Object.entries(road).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    (polyline as any).__layerType = 'australia_major_roads';
                    (polyline as any).__layerTitle = 'Australia Major Roads';
                    (polyline as any).__popupContent = popupContent;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Australia Major Road polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['australia_major_roads']) {
              legendAccumulator['australia_major_roads'] = {
                icon: '🛣️',
                color: '#dc2626',
                title: 'Australia Major Roads',
                count: 0,
              };
            }
            legendAccumulator['australia_major_roads'].count += roadCount;
          }
        }

        // Draw Australia Bushfires as points and polygons on the map
        if (enrichments.australia_bushfires_all && Array.isArray(enrichments.australia_bushfires_all)) {
          let bushfireCount = 0;
          enrichments.australia_bushfires_all.forEach((bushfire: any) => {
            try {
              const isContaining = bushfire.isContaining || bushfire.distance_miles === 0;
              const distance = bushfire.distance_miles !== null && bushfire.distance_miles !== undefined ? bushfire.distance_miles : 0;
              
              // Check if it's a polygon (has rings) or a point
              if (bushfire.geometry && bushfire.geometry.rings) {
                // Draw as polygon
                const rings = bushfire.geometry.rings[0]; // Use first ring
                const latlngs = rings.map((ring: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [ring[1], ring[0]] as [number, number];
                });
                
                const polygon = L.polygon(latlngs, {
                  color: '#dc2626', // Red color for bushfires
                  weight: 2,
                  opacity: 0.8,
                  fillColor: '#ef4444',
                  fillOpacity: 0.3
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🔥 ${isContaining ? 'Containing' : 'Nearby'} Bushfire Extent
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : '<div><strong>Status:</strong> Containing</div>'}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all bushfire attributes
                const excludeFields = ['geometry', 'distance_miles', 'isContaining', 'objectId', 'OBJECTID', 'objectid', 'lat', 'lon'];
                Object.entries(bushfire).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                (polygon as any).__layerType = 'australia_bushfires';
                (polygon as any).__layerTitle = 'Recent Australia Bushfires';
                (polygon as any).__popupContent = popupContent;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(poi);
                bounds.extend(polygon.getBounds());
                bushfireCount++;
              } else if (bushfire.lat && bushfire.lon) {
                // Draw as point
                const bushfireMarker = L.marker([bushfire.lat, bushfire.lon], {
                  icon: L.divIcon({
                    className: 'custom-bushfire-marker',
                    html: '<div style="background-color: #dc2626; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                  })
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🔥 ${isContaining ? 'Containing' : 'Nearby'} Bushfire Location
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : '<div><strong>Status:</strong> Containing</div>'}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all bushfire attributes
                const excludeFields = ['geometry', 'distance_miles', 'isContaining', 'objectId', 'OBJECTID', 'objectid', 'lat', 'lon'];
                Object.entries(bushfire).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                (bushfireMarker as any).__layerType = 'australia_bushfires';
                (bushfireMarker as any).__layerTitle = 'Recent Australia Bushfires';
                (bushfireMarker as any).__popupContent = popupContent;
                
                bushfireMarker.bindPopup(popupContent, { maxWidth: 400 });
                bushfireMarker.addTo(poi);
                bounds.extend([bushfire.lat, bushfire.lon]);
                bushfireCount++;
              }
            } catch (error) {
              console.error('Error drawing Australia Bushfire:', error);
            }
          });
          
          if (bushfireCount > 0) {
            if (!legendAccumulator['australia_bushfires']) {
              legendAccumulator['australia_bushfires'] = {
                icon: '🔥',
                color: '#dc2626',
                title: 'Recent Australia Bushfires',
                count: 0,
              };
            }
            legendAccumulator['australia_bushfires'].count += bushfireCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia Bushfires:', error);
      }

      // Draw Australia Built-Up Areas as yellow polygons
      try {
        if (enrichments.australia_built_up_areas_all && Array.isArray(enrichments.australia_built_up_areas_all)) {
          let areaCount = 0;
          enrichments.australia_built_up_areas_all.forEach((area: any) => {
            try {
              const isContaining = area.isContaining || area.distance_miles === 0;
              const distance = area.distance_miles !== null && area.distance_miles !== undefined ? area.distance_miles : 0;
              
              // Check if it has polygon geometry
              if (area.geometry && area.geometry.rings) {
                // Draw as polygon
                const rings = area.geometry.rings[0]; // Use first ring
                const latlngs = rings.map((ring: number[]) => {
                  // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                  return [ring[1], ring[0]] as [number, number];
                });
                
                const polygon = L.polygon(latlngs, {
                  color: '#eab308', // Yellow border
                  weight: 2,
                  opacity: 0.8,
                  fillColor: '#fde047', // Yellow fill
                  fillOpacity: 0.3
                });
                
                // Build popup content
                const areaName = area.featureType || area.name || 'Built-Up Area';
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏙️ ${isContaining ? 'Containing' : 'Nearby'} Built-Up Area
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Type:</strong> ${areaName}</div>
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : '<div><strong>Status:</strong> Containing</div>'}
                      ${area.shapeArea ? `<div><strong>Area:</strong> ${(area.shapeArea / 1000000).toFixed(2)} km²</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all area attributes
                const excludeFields = ['geometry', 'distance_miles', 'isContaining', 'objectId', 'OBJECTID', 'objectid', 'lat', 'lon'];
                Object.entries(area).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let displayValue = '';
                    
                    if (typeof value === 'object') {
                      displayValue = JSON.stringify(value);
                    } else if (typeof value === 'number') {
                      displayValue = value.toLocaleString();
                    } else {
                      displayValue = String(value);
                    }
                    
                    popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                (polygon as any).__layerType = 'australia_built_up_areas';
                (polygon as any).__layerTitle = 'Australia Built-Up Areas';
                (polygon as any).__popupContent = popupContent;
                
                polygon.bindPopup(popupContent, { maxWidth: 400 });
                polygon.addTo(poi);
                bounds.extend(polygon.getBounds());
                areaCount++;
              }
            } catch (error) {
              console.error('Error drawing Australia Built-Up Area:', error);
            }
          });
          
          if (areaCount > 0) {
            if (!legendAccumulator['australia_built_up_areas']) {
              legendAccumulator['australia_built_up_areas'] = {
                icon: '🏙️',
                color: '#fde047',
                title: 'Australia Built-Up Areas',
                count: 0,
              };
            }
            legendAccumulator['australia_built_up_areas'].count += areaCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia Built-Up Areas:', error);
      }

      // Draw Australia Operating Mines
      try {
        if (enrichments.australia_operating_mines_all_pois && Array.isArray(enrichments.australia_operating_mines_all_pois)) {
          let mineCount = 0;
          enrichments.australia_operating_mines_all_pois.forEach((mine: any) => {
            if (mine.lat && mine.lon) {
              try {
                const mineMarker = L.marker([mine.lat, mine.lon], {
                  icon: createPOIIcon('⛏️', '#f59e0b')
                });
                
                const name = mine.mineName || mine.name || 'Unnamed Mine';
                const distance = mine.distance_miles !== null && mine.distance_miles !== undefined ? mine.distance_miles : 0;
                const commodity = mine.commodity || '';
                const state = mine.state || '';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ⛏️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Status:</strong> Operating Mine</div>
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${commodity ? `<div><strong>Commodity:</strong> ${commodity}</div>` : ''}
                      ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                    </div>
                  </div>
                `;
                
                mineMarker.bindPopup(popupContent, { maxWidth: 400 });
                mineMarker.addTo(poi);
                bounds.extend([mine.lat, mine.lon]);
                mineCount++;
              } catch (error) {
                console.error('Error drawing Australia Operating Mine:', error);
              }
            }
          });
          
          if (mineCount > 0) {
            if (!legendAccumulator['australia_operating_mines']) {
              legendAccumulator['australia_operating_mines'] = {
                icon: '⛏️',
                color: '#f59e0b',
                title: 'Australia Operating Mines',
                count: 0,
              };
            }
            legendAccumulator['australia_operating_mines'].count += mineCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia Operating Mines:', error);
      }

      // Draw Australia Developing Mines
      try {
        if (enrichments.australia_developing_mines_all_pois && Array.isArray(enrichments.australia_developing_mines_all_pois)) {
          let mineCount = 0;
          enrichments.australia_developing_mines_all_pois.forEach((mine: any) => {
            if (mine.lat && mine.lon) {
              try {
                const mineMarker = L.marker([mine.lat, mine.lon], {
                  icon: createPOIIcon('🏗️', '#3b82f6')
                });
                
                const name = mine.mineName || mine.name || 'Unnamed Mine';
                const distance = mine.distance_miles !== null && mine.distance_miles !== undefined ? mine.distance_miles : 0;
                const commodity = mine.commodity || '';
                const state = mine.state || '';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏗️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Status:</strong> Developing Mine</div>
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${commodity ? `<div><strong>Commodity:</strong> ${commodity}</div>` : ''}
                      ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                    </div>
                  </div>
                `;
                
                mineMarker.bindPopup(popupContent, { maxWidth: 400 });
                mineMarker.addTo(poi);
                bounds.extend([mine.lat, mine.lon]);
                mineCount++;
              } catch (error) {
                console.error('Error drawing Australia Developing Mine:', error);
              }
            }
          });
          
          if (mineCount > 0) {
            if (!legendAccumulator['australia_developing_mines']) {
              legendAccumulator['australia_developing_mines'] = {
                icon: '🏗️',
                color: '#3b82f6',
                title: 'Australia Developing Mines',
                count: 0,
              };
            }
            legendAccumulator['australia_developing_mines'].count += mineCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia Developing Mines:', error);
      }

      // Draw Australia Care/Maintenance Mines
      try {
        if (enrichments.australia_care_maintenance_mines_all_pois && Array.isArray(enrichments.australia_care_maintenance_mines_all_pois)) {
          let mineCount = 0;
          enrichments.australia_care_maintenance_mines_all_pois.forEach((mine: any) => {
            if (mine.lat && mine.lon) {
              try {
                const mineMarker = L.marker([mine.lat, mine.lon], {
                  icon: createPOIIcon('⚙️', '#6b7280')
                });
                
                const name = mine.mineName || mine.name || 'Unnamed Mine';
                const distance = mine.distance_miles !== null && mine.distance_miles !== undefined ? mine.distance_miles : 0;
                const commodity = mine.commodity || '';
                const state = mine.state || '';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ⚙️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      <div><strong>Status:</strong> Care/Maintenance Mine</div>
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${commodity ? `<div><strong>Commodity:</strong> ${commodity}</div>` : ''}
                      ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                    </div>
                  </div>
                `;
                
                mineMarker.bindPopup(popupContent, { maxWidth: 400 });
                mineMarker.addTo(poi);
                bounds.extend([mine.lat, mine.lon]);
                mineCount++;
              } catch (error) {
                console.error('Error drawing Australia Care/Maintenance Mine:', error);
              }
            }
          });
          
          if (mineCount > 0) {
            if (!legendAccumulator['australia_care_maintenance_mines']) {
              legendAccumulator['australia_care_maintenance_mines'] = {
                icon: '⚙️',
                color: '#6b7280',
                title: 'Australia Care/Maintenance Mines',
                count: 0,
              };
            }
            legendAccumulator['australia_care_maintenance_mines'].count += mineCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia Care/Maintenance Mines:', error);
      }

      // Draw Australia NPI Facilities
      try {
        if (enrichments.australia_npi_facilities_all_pois && Array.isArray(enrichments.australia_npi_facilities_all_pois)) {
          let facilityCount = 0;
          enrichments.australia_npi_facilities_all_pois.forEach((facility: any) => {
            const facilityLat = facility.latitude || facility.lat;
            const facilityLon = facility.longitude || facility.lon;
            if (facilityLat && facilityLon) {
              try {
                const facilityMarker = L.marker([facilityLat, facilityLon], {
                  icon: createPOIIcon('🏭', '#dc2626')
                });
                
                const name = facility.facilityName || facility.registeredBusinessName || 'Unnamed Facility';
                const distance = facility.distance_miles !== null && facility.distance_miles !== undefined ? facility.distance_miles : 0;
                const primaryAnzsicClassName = facility.primaryAnzsicClassName || '';
                const mainActivities = facility.mainActivities || '';
                const state = facility.state || '';
                const suburb = facility.suburb || '';
                const latestReportYear = facility.latestReportYear || '';
                const latestReportUrl = facility.latestReportUrl || '';
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏭 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${primaryAnzsicClassName ? `<div><strong>Industry:</strong> ${primaryAnzsicClassName}</div>` : ''}
                      ${mainActivities ? `<div><strong>Activities:</strong> ${mainActivities}</div>` : ''}
                      ${state ? `<div><strong>State:</strong> ${state}</div>` : ''}
                      ${suburb ? `<div><strong>Suburb:</strong> ${suburb}</div>` : ''}
                      ${latestReportYear ? `<div><strong>Latest Report:</strong> ${latestReportYear}</div>` : ''}
                      ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      ${latestReportUrl ? `<div style="margin-top: 8px;"><a href="${latestReportUrl}" target="_blank" style="color: #3b82f6; text-decoration: underline;">View NPI Report →</a></div>` : ''}
                    </div>
                  </div>
                `;
                
                facilityMarker.bindPopup(popupContent, { maxWidth: 400 });
                facilityMarker.addTo(poi);
                bounds.extend([facilityLat, facilityLon]);
                facilityCount++;
              } catch (error) {
                console.error('Error drawing Australia NPI Facility:', error);
              }
            }
          });
          
          if (facilityCount > 0) {
            if (!legendAccumulator['australia_npi_facilities']) {
              legendAccumulator['australia_npi_facilities'] = {
                icon: '🏭',
                color: '#dc2626',
                title: 'Australia NPI Facilities',
                count: 0,
              };
            }
            legendAccumulator['australia_npi_facilities'].count += facilityCount;
          }
        }
      } catch (error) {
        console.error('Error processing Australia NPI Facilities:', error);
      }

      // Draw USFS National Wilderness Areas as polygons on the map

      // Draw USFS National Wilderness Areas as polygons on the map
      try {
        if (enrichments.usfs_wilderness_areas_all && Array.isArray(enrichments.usfs_wilderness_areas_all)) {
          let wildernessCount = 0;
          enrichments.usfs_wilderness_areas_all.forEach((wilderness: any) => {
            if (wilderness.geometry && wilderness.geometry.rings && Array.isArray(wilderness.geometry.rings)) {
              try {
                const rings = wilderness.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Wilderness Area outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = wilderness.isContaining;
                  const color = isContaining ? '#1e40af' : '#3b82f6'; // Blue for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const wildernessPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const wildernessName = wilderness.wildernessName || wilderness.WILDERNESSNAME || wilderness.WildernessName || wilderness.WILDERNESS_NM || 'Unknown Wilderness Area';
                  const wildernessCode = wilderness.wildernessCode || wilderness.WILDERNESSCODE || wilderness.WildernessCode || wilderness.WILDERNESS_CD || null;
                  const wildernessId = wilderness.objectId || wilderness.OBJECTID || wilderness.objectid || null;
                  const distance = wilderness.distance_miles !== null && wilderness.distance_miles !== undefined ? wilderness.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏔️ ${wildernessName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${wildernessCode ? `<div><strong>Wilderness Code:</strong> ${wildernessCode}</div>` : ''}
                        ${wildernessId ? `<div><strong>Wilderness ID:</strong> ${wildernessId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  wildernessPolygon.bindPopup(popupContent);
                  wildernessPolygon.addTo(map);
                  wildernessCount++;
                  
                  const polygonBounds = wildernessPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Wilderness Area polygon:', error);
              }
            }
          });
          
          if (wildernessCount > 0) {
            if (!legendAccumulator['usfs_wilderness_areas']) {
              legendAccumulator['usfs_wilderness_areas'] = {
                icon: '🏔️',
                color: '#1e40af',
                title: 'USFS National Wilderness Areas',
                count: 0,
              };
            }
            legendAccumulator['usfs_wilderness_areas'].count += wildernessCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS National Wilderness Areas:', error);
      }

      // Draw USFS National Grassland Units as polygons on the map
      try {
        if (enrichments.usfs_national_grasslands_all && Array.isArray(enrichments.usfs_national_grasslands_all)) {
          let grasslandCount = 0;
          enrichments.usfs_national_grasslands_all.forEach((grassland: any) => {
            if (grassland.geometry && grassland.geometry.rings && Array.isArray(grassland.geometry.rings)) {
              try {
                const rings = grassland.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Grassland outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = grassland.isContaining;
                  const color = isContaining ? '#ca8a04' : '#eab308'; // Yellow/tan for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const grasslandPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const grasslandName = grassland.grasslandName || grassland.GRASSLANDNAME || grassland.GrasslandName || grassland.NATIONALGRASSLANDNAME || 'Unknown Grassland';
                  const grasslandId = grassland.grasslandId || grassland.NATIONALGRASSLANDID || null;
                  const gisAcres = grassland.gisAcres !== null && grassland.gisAcres !== undefined ? grassland.gisAcres : null;
                  const grasslandObjId = grassland.objectId || grassland.OBJECTID || grassland.objectid || null;
                  const distance = grassland.distance_miles !== null && grassland.distance_miles !== undefined ? grassland.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌾 ${grasslandName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${grasslandId ? `<div><strong>Grassland ID:</strong> ${grasslandId}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>Acres:</strong> ${gisAcres.toLocaleString()}</div>` : ''}
                        ${grasslandObjId ? `<div><strong>Object ID:</strong> ${grasslandObjId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  grasslandPolygon.bindPopup(popupContent);
                  grasslandPolygon.addTo(map);
                  grasslandCount++;
                  
                  const polygonBounds = grasslandPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Grassland polygon:', error);
              }
            }
          });
          
          if (grasslandCount > 0) {
            if (!legendAccumulator['usfs_national_grasslands']) {
              legendAccumulator['usfs_national_grasslands'] = {
                icon: '🌾',
                color: '#ca8a04',
                title: 'USFS National Grassland Units',
                count: 0,
              };
            }
            legendAccumulator['usfs_national_grasslands'].count += grasslandCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS National Grassland Units:', error);
      }

      // Draw USFS Hazardous Sites (CERCLA Sites) as polygons on the map
      try {
        if (enrichments.usfs_hazardous_sites_all && Array.isArray(enrichments.usfs_hazardous_sites_all)) {
          let siteCount = 0;
          enrichments.usfs_hazardous_sites_all.forEach((site: any) => {
            if (site.geometry && site.geometry.rings && Array.isArray(site.geometry.rings)) {
              try {
                const rings = site.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Hazardous Site outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = site.isContaining;
                  const color = isContaining ? '#dc2626' : '#ef4444'; // Red for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const sitePolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const areaName = site.areaName || site.AREANAME || site.AreaName || site.caseName || site.CASENAME || site.CaseName || 'Unknown Hazardous Site';
                  const caseName = site.caseName || site.CASENAME || site.CaseName || null;
                  const areaType = site.areaType || site.AREATYPE || site.AreaType || null;
                  const boundaryStatus = site.boundaryStatus || site.BOUNDARYSTATUS || site.BoundaryStatus || null;
                  const officialAcres = site.officialAcres !== null && site.officialAcres !== undefined ? site.officialAcres : null;
                  const gisAcres = site.gisAcres !== null && site.gisAcres !== undefined ? site.gisAcres : null;
                  const region = site.region || site.REGION || site.Region || null;
                  const comments = site.comments || site.COMMENTS || site.Comments || null;
                  const actionDate = site.actionDate || site.ACTIONDATE || null;
                  const siteId = site.objectId || site.OBJECTID || site.objectid || null;
                  const distance = site.distance_miles !== null && site.distance_miles !== undefined ? site.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ⚠️ ${areaName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${caseName ? `<div><strong>Case Name:</strong> ${caseName}</div>` : ''}
                        ${areaType ? `<div><strong>Area Type:</strong> ${areaType}</div>` : ''}
                        ${boundaryStatus ? `<div><strong>Boundary Status:</strong> ${boundaryStatus}</div>` : ''}
                        ${officialAcres !== null && officialAcres !== undefined ? `<div><strong>Official Acres:</strong> ${officialAcres.toLocaleString()}</div>` : ''}
                        ${gisAcres !== null && gisAcres !== undefined ? `<div><strong>GIS Acres:</strong> ${gisAcres.toLocaleString()}</div>` : ''}
                        ${region ? `<div><strong>Region:</strong> ${region}</div>` : ''}
                        ${actionDate ? `<div><strong>Action Date:</strong> ${actionDate}</div>` : ''}
                        ${comments ? `<div><strong>Comments:</strong> ${comments}</div>` : ''}
                        ${siteId ? `<div><strong>Site ID:</strong> ${siteId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  sitePolygon.bindPopup(popupContent);
                  sitePolygon.addTo(map);
                  siteCount++;
                  
                  const polygonBounds = sitePolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Hazardous Site polygon:', error);
              }
            }
          });
          
          if (siteCount > 0) {
            if (!legendAccumulator['usfs_hazardous_sites']) {
              legendAccumulator['usfs_hazardous_sites'] = {
                icon: '⚠️',
                color: '#dc2626',
                title: 'USFS Hazardous Sites (CERCLA Sites)',
                count: 0,
              };
            }
            legendAccumulator['usfs_hazardous_sites'].count += siteCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Hazardous Sites:', error);
      }

      // Draw USFS Office Locations as point markers on the map
      try {
        if (enrichments.usfs_office_locations_all && Array.isArray(enrichments.usfs_office_locations_all)) {
          let officeCount = 0;
          enrichments.usfs_office_locations_all.forEach((office: any) => {
            if (office.geometry && office.geometry.x !== undefined && office.geometry.y !== undefined) {
              try {
                const lat = office.geometry.y;
                const lon = office.geometry.x;
                
                const officeName = office.officeName || office.OFFICENAME || office.OfficeName || 'Unknown Office';
                const officeType = office.officeType || office.OFFICETYPE || office.OfficeType || null;
                const forestName = office.forestName || office.FORESTNAME || office.ForestName || null;
                const address = office.address || office.ADDRESS || office.Address || null;
                const phone = office.phone || office.PHONE || office.Phone || null;
                const distance = office.distance_miles !== null && office.distance_miles !== undefined ? office.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🏢', '#059669')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏢 ${officeName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${officeType ? `<div><strong>Type:</strong> ${officeType}</div>` : ''}
                      ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                      ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                officeCount++;
              } catch (error) {
                console.error('Error drawing USFS Office Location marker:', error);
              }
            }
          });
          
          if (officeCount > 0) {
            if (!legendAccumulator['usfs_office_locations']) {
              legendAccumulator['usfs_office_locations'] = {
                icon: '🏢',
                color: '#059669',
                title: 'USFS Office Locations',
                count: 0,
              };
            }
            legendAccumulator['usfs_office_locations'].count += officeCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Office Locations:', error);
      }

      // Draw USFS Special Uses Communications Sites as point markers on the map
      try {
        if (enrichments.usfs_special_uses_communications_sites_all && Array.isArray(enrichments.usfs_special_uses_communications_sites_all)) {
          let siteCount = 0;
          enrichments.usfs_special_uses_communications_sites_all.forEach((site: any) => {
            if (site.geometry && site.geometry.x !== undefined && site.geometry.y !== undefined) {
              try {
                const lat = site.geometry.y;
                const lon = site.geometry.x;
                
                const siteName = site.siteName || site.SITENAME || site.SiteName || 'Unknown Communications Site';
                const siteType = site.siteType || site.SITETYPE || site.SiteType || null;
                const forestName = site.forestName || site.FORESTNAME || site.ForestName || null;
                const distance = site.distance_miles !== null && site.distance_miles !== undefined ? site.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('📡', '#0891b2')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      📡 ${siteName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${siteType ? `<div><strong>Type:</strong> ${siteType}</div>` : ''}
                      ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                siteCount++;
              } catch (error) {
                console.error('Error drawing USFS Special Uses Communications Site marker:', error);
              }
            }
          });
          
          if (siteCount > 0) {
            if (!legendAccumulator['usfs_special_uses_communications_sites']) {
              legendAccumulator['usfs_special_uses_communications_sites'] = {
                icon: '📡',
                color: '#0891b2',
                title: 'USFS Special Uses Communications Sites',
                count: 0,
              };
            }
            legendAccumulator['usfs_special_uses_communications_sites'].count += siteCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Special Uses Communications Sites:', error);
      }

      // Draw USFS Administrative Boundaries as polygons on the map
      try {
        if (enrichments.usfs_administrative_boundaries_all && Array.isArray(enrichments.usfs_administrative_boundaries_all)) {
          let boundaryCount = 0;
          enrichments.usfs_administrative_boundaries_all.forEach((boundary: any) => {
            if (boundary.geometry && boundary.geometry.rings && Array.isArray(boundary.geometry.rings)) {
              try {
                const rings = boundary.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Administrative Boundary outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = boundary.isContaining;
                  const color = isContaining ? '#1e40af' : '#3b82f6';
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const boundaryPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const boundaryName = boundary.boundaryName || boundary.BOUNDARYNAME || boundary.BoundaryName || boundary.forestName || boundary.FORESTNAME || 'Unknown Boundary';
                  const boundaryType = boundary.boundaryType || boundary.BOUNDARYTYPE || boundary.BoundaryType || null;
                  const forestName = boundary.forestName || boundary.FORESTNAME || boundary.ForestName || null;
                  const distance = boundary.distance_miles !== null && boundary.distance_miles !== undefined ? boundary.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ ${boundaryName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${boundaryType ? `<div><strong>Type:</strong> ${boundaryType}</div>` : ''}
                        ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  boundaryPolygon.bindPopup(popupContent);
                  boundaryPolygon.addTo(map);
                  boundaryCount++;
                  
                  const polygonBounds = boundaryPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Administrative Boundary polygon:', error);
              }
            }
          });
          
          if (boundaryCount > 0) {
            if (!legendAccumulator['usfs_administrative_boundaries']) {
              legendAccumulator['usfs_administrative_boundaries'] = {
                icon: '🏛️',
                color: '#1e40af',
                title: 'USFS Administrative Boundaries',
                count: 0,
              };
            }
            legendAccumulator['usfs_administrative_boundaries'].count += boundaryCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Administrative Boundaries:', error);
      }

      // Draw USFS Recreation Opportunities as point markers on the map
      try {
        if (enrichments.usfs_recreation_opportunities_all && Array.isArray(enrichments.usfs_recreation_opportunities_all)) {
          let oppCount = 0;
          enrichments.usfs_recreation_opportunities_all.forEach((opp: any) => {
            if (opp.geometry && opp.geometry.x !== undefined && opp.geometry.y !== undefined) {
              try {
                const lat = opp.geometry.y;
                const lon = opp.geometry.x;
                
                const recAreaName = opp.recAreaName || opp.RECAREANAME || opp.RecAreaName || 'Unknown Recreation Area';
                const forestName = opp.forestName || opp.FORESTNAME || opp.ForestName || null;
                const markerActivity = opp.markerActivity || opp.MARKERACTIVITY || opp.MarkerActivity || null;
                const markerActivityGroup = opp.markerActivityGroup || opp.MARKERACTIVITYGROUP || opp.MarkerActivityGroup || null;
                const openSeasonStart = opp.openSeasonStart || opp.OPEN_SEASON_START || opp.Open_Season_Start || null;
                const openSeasonEnd = opp.openSeasonEnd || opp.OPEN_SEASON_END || opp.Open_Season_End || null;
                const recAreaUrl = opp.recAreaUrl || opp.RECAREAURL || opp.RecAreaUrl || null;
                const distance = opp.distance_miles !== null && opp.distance_miles !== undefined ? opp.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🏕️', '#059669')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏕️ ${recAreaName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                      ${markerActivity ? `<div><strong>Activity:</strong> ${markerActivity}</div>` : ''}
                      ${markerActivityGroup ? `<div><strong>Activity Group:</strong> ${markerActivityGroup}</div>` : ''}
                      ${openSeasonStart ? `<div><strong>Season Start:</strong> ${openSeasonStart}</div>` : ''}
                      ${openSeasonEnd ? `<div><strong>Season End:</strong> ${openSeasonEnd}</div>` : ''}
                      ${recAreaUrl ? `<div><strong>URL:</strong> <a href="${recAreaUrl}" target="_blank">${recAreaUrl}</a></div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                oppCount++;
              } catch (error) {
                console.error('Error drawing USFS Recreation Opportunity marker:', error);
              }
            }
          });
          
          if (oppCount > 0) {
            if (!legendAccumulator['usfs_recreation_opportunities']) {
              legendAccumulator['usfs_recreation_opportunities'] = {
                icon: '🏕️',
                color: '#059669',
                title: 'USFS Recreation Opportunities',
                count: 0,
              };
            }
            legendAccumulator['usfs_recreation_opportunities'].count += oppCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Recreation Opportunities:', error);
      }

      // Draw USFS Recreation Area Activities as point markers on the map
      try {
        if (enrichments.usfs_recreation_area_activities_all && Array.isArray(enrichments.usfs_recreation_area_activities_all)) {
          let activityCount = 0;
          enrichments.usfs_recreation_area_activities_all.forEach((activity: any) => {
            if (activity.geometry && activity.geometry.x !== undefined && activity.geometry.y !== undefined) {
              try {
                const lat = activity.geometry.y;
                const lon = activity.geometry.x;
                
                const recAreaName = activity.recAreaName || activity.RECAREANAME || activity.RecAreaName || 'Unknown Recreation Area';
                const forestName = activity.forestName || activity.FORESTNAME || activity.ForestName || null;
                const markerActivity = activity.markerActivity || activity.MARKERACTIVITY || activity.MarkerActivity || null;
                const markerActivityGroup = activity.markerActivityGroup || activity.MARKERACTIVITYGROUP || activity.MarkerActivityGroup || null;
                const activityName = activity.activityName || activity.ACTIVITYNAME || activity.ActivityName || null;
                const parentActivityName = activity.parentActivityName || activity.PARENTACTIVITYNAME || activity.ParentActivityName || null;
                const openSeasonStart = activity.openSeasonStart || activity.OPEN_SEASON_START || activity.Open_Season_Start || null;
                const openSeasonEnd = activity.openSeasonEnd || activity.OPEN_SEASON_END || activity.Open_Season_End || null;
                const recAreaUrl = activity.recAreaUrl || activity.RECAREAURL || activity.RecAreaUrl || null;
                const distance = activity.distance_miles !== null && activity.distance_miles !== undefined ? activity.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🎯', '#7c3aed')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🎯 ${recAreaName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                      ${activityName ? `<div><strong>Activity:</strong> ${activityName}</div>` : ''}
                      ${parentActivityName ? `<div><strong>Parent Activity:</strong> ${parentActivityName}</div>` : ''}
                      ${markerActivity ? `<div><strong>Marker Activity:</strong> ${markerActivity}</div>` : ''}
                      ${markerActivityGroup ? `<div><strong>Activity Group:</strong> ${markerActivityGroup}</div>` : ''}
                      ${openSeasonStart ? `<div><strong>Season Start:</strong> ${openSeasonStart}</div>` : ''}
                      ${openSeasonEnd ? `<div><strong>Season End:</strong> ${openSeasonEnd}</div>` : ''}
                      ${recAreaUrl ? `<div><strong>URL:</strong> <a href="${recAreaUrl}" target="_blank">${recAreaUrl}</a></div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                activityCount++;
              } catch (error) {
                console.error('Error drawing USFS Recreation Area Activity marker:', error);
              }
            }
          });
          
          if (activityCount > 0) {
            if (!legendAccumulator['usfs_recreation_area_activities']) {
              legendAccumulator['usfs_recreation_area_activities'] = {
                icon: '🎯',
                color: '#7c3aed',
                title: 'USFS Recreation Area Activities',
                count: 0,
              };
            }
            legendAccumulator['usfs_recreation_area_activities'].count += activityCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Recreation Area Activities:', error);
      }

      // Draw USFS Roads Closed to Motorized Uses as polylines on the map
      try {
        if (enrichments.usfs_roads_closed_to_motorized_all && Array.isArray(enrichments.usfs_roads_closed_to_motorized_all)) {
          let roadCount = 0;
          enrichments.usfs_roads_closed_to_motorized_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths && Array.isArray(road.geometry.paths)) {
              try {
                road.geometry.paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 2) {
                    return;
                  }
                  
                  const roadName = road.roadName || road.ROADNAME || road.RoadName || road.roadNumber || road.ROADNUMBER || 'Unknown Road';
                  const roadNumber = road.roadNumber || road.ROADNUMBER || road.RoadNumber || null;
                  const forestName = road.forestName || road.FORESTNAME || road.ForestName || null;
                  const distance = road.distance_miles !== null && road.distance_miles !== undefined ? road.distance_miles : 0;
                  
                  const polyline = L.polyline(latlngs, {
                    color: '#dc2626',
                    weight: 3,
                    opacity: 0.8
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🚫 ${roadName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${roadNumber ? `<div><strong>Road Number:</strong> ${roadNumber}</div>` : ''}
                        ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                        <div><strong>Status:</strong> Closed to Motorized Uses</div>
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent);
                  polyline.addTo(map);
                  roadCount++;
                  
                  const polylineBounds = polyline.getBounds();
                  if (polylineBounds.isValid()) {
                    bounds.extend(polylineBounds);
                  }
                });
              } catch (error) {
                console.error('Error drawing USFS Road Closed to Motorized Uses polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['usfs_roads_closed_to_motorized']) {
              legendAccumulator['usfs_roads_closed_to_motorized'] = {
                icon: '🚫',
                color: '#dc2626',
                title: 'USFS Roads Closed to Motorized Uses',
                count: 0,
              };
            }
            legendAccumulator['usfs_roads_closed_to_motorized'].count += roadCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Roads Closed to Motorized Uses:', error);
      }

      // Draw USFS System Roads as polylines on the map
      try {
        if (enrichments.usfs_system_roads_all && Array.isArray(enrichments.usfs_system_roads_all)) {
          let roadCount = 0;
          enrichments.usfs_system_roads_all.forEach((road: any) => {
            if (road.geometry && road.geometry.paths && Array.isArray(road.geometry.paths)) {
              try {
                road.geometry.paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 2) {
                    return;
                  }
                  
                  const roadName = road.roadName || road.ROADNAME || road.RoadName || road.roadNumber || road.ROADNUMBER || 'Unknown Road';
                  const roadNumber = road.roadNumber || road.ROADNUMBER || road.RoadNumber || null;
                  const forestName = road.forestName || road.FORESTNAME || road.ForestName || null;
                  const roadType = road.roadType || road.ROADTYPE || road.RoadType || null;
                  const distance = road.distance_miles !== null && road.distance_miles !== undefined ? road.distance_miles : 0;
                  
                  const polyline = L.polyline(latlngs, {
                    color: '#6b7280',
                    weight: 2,
                    opacity: 0.7
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🛣️ ${roadName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${roadNumber ? `<div><strong>Road Number:</strong> ${roadNumber}</div>` : ''}
                        ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                        ${roadType ? `<div><strong>Road Type:</strong> ${roadType}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent);
                  polyline.addTo(map);
                  roadCount++;
                  
                  const polylineBounds = polyline.getBounds();
                  if (polylineBounds.isValid()) {
                    bounds.extend(polylineBounds);
                  }
                });
              } catch (error) {
                console.error('Error drawing USFS System Road polyline:', error);
              }
            }
          });
          
          if (roadCount > 0) {
            if (!legendAccumulator['usfs_system_roads']) {
              legendAccumulator['usfs_system_roads'] = {
                icon: '🛣️',
                color: '#6b7280',
                title: 'USFS System Roads',
                count: 0,
              };
            }
            legendAccumulator['usfs_system_roads'].count += roadCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS System Roads:', error);
      }

      // Draw USFS MVUM as polylines on the map
      try {
        if (enrichments.usfs_mvum_all && Array.isArray(enrichments.usfs_mvum_all)) {
          let routeCount = 0;
          enrichments.usfs_mvum_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths && Array.isArray(route.geometry.paths)) {
              try {
                route.geometry.paths.forEach((path: number[][]) => {
                  const latlngs = path.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 2) {
                    return;
                  }
                  
                  const routeName = route.routeName || route.ROUTENAME || route.RouteName || route.routeNumber || route.ROUTENUMBER || 'Unknown Route';
                  const routeNumber = route.routeNumber || route.ROUTENUMBER || route.RouteNumber || null;
                  const forestName = route.forestName || route.FORESTNAME || route.ForestName || null;
                  const vehicleType = route.vehicleType || route.VEHICLETYPE || route.VehicleType || null;
                  const seasonOfUse = route.seasonOfUse || route.SEASONOFUSE || route.SeasonOfUse || null;
                  const distance = route.distance_miles !== null && route.distance_miles !== undefined ? route.distance_miles : 0;
                  
                  const polyline = L.polyline(latlngs, {
                    color: '#f59e0b',
                    weight: 2,
                    opacity: 0.7
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🚗 ${routeName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${routeNumber ? `<div><strong>Route Number:</strong> ${routeNumber}</div>` : ''}
                        ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                        ${vehicleType ? `<div><strong>Vehicle Type:</strong> ${vehicleType}</div>` : ''}
                        ${seasonOfUse ? `<div><strong>Season of Use:</strong> ${seasonOfUse}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  polyline.bindPopup(popupContent);
                  polyline.addTo(map);
                  routeCount++;
                  
                  const polylineBounds = polyline.getBounds();
                  if (polylineBounds.isValid()) {
                    bounds.extend(polylineBounds);
                  }
                });
              } catch (error) {
                console.error('Error drawing USFS MVUM polyline:', error);
              }
            }
          });
          
          if (routeCount > 0) {
            if (!legendAccumulator['usfs_mvum']) {
              legendAccumulator['usfs_mvum'] = {
                icon: '🚗',
                color: '#f59e0b',
                title: 'USFS Motor Vehicle Use Map (MVUM)',
                count: 0,
              };
            }
            legendAccumulator['usfs_mvum'].count += routeCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS MVUM:', error);
      }

      // Draw USFS Colorado Roadless Areas as polygons on the map
      try {
        if (enrichments.usfs_co_roadless_areas_all && Array.isArray(enrichments.usfs_co_roadless_areas_all)) {
          let areaCount = 0;
          enrichments.usfs_co_roadless_areas_all.forEach((area: any) => {
            if (area.geometry && area.geometry.rings && Array.isArray(area.geometry.rings)) {
              try {
                const rings = area.geometry.rings;
                if (rings && rings.length > 0) {
                  const latlngsArray: [number, number][][] = rings.map((ring: number[][]) => {
                    return ring.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                  });
                  
                  if (latlngsArray[0].length < 3) {
                    console.warn('USFS Colorado Roadless Area outer ring has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = area.isContaining;
                  const color = isContaining ? '#059669' : '#10b981';
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const areaPolygon = L.polygon(latlngsArray, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const areaName = area.areaName || area.AREANAME || area.AreaName || 'Unknown Roadless Area';
                  const areaType = area.areaType || area.AREATYPE || area.AreaType || null;
                  const forestName = area.forestName || area.FORESTNAME || area.ForestName || null;
                  const distance = area.distance_miles !== null && area.distance_miles !== undefined ? area.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏔️ ${areaName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${areaType ? `<div><strong>Type:</strong> ${areaType}</div>` : ''}
                        ${forestName ? `<div><strong>Forest:</strong> ${forestName}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;
                  
                  areaPolygon.bindPopup(popupContent);
                  areaPolygon.addTo(map);
                  areaCount++;
                  
                  const polygonBounds = areaPolygon.getBounds();
                  if (polygonBounds.isValid()) {
                    bounds.extend(polygonBounds);
                  }
                }
              } catch (error) {
                console.error('Error drawing USFS Colorado Roadless Area polygon:', error);
              }
            }
          });
          
          if (areaCount > 0) {
            if (!legendAccumulator['usfs_co_roadless_areas']) {
              legendAccumulator['usfs_co_roadless_areas'] = {
                icon: '🏔️',
                color: '#059669',
                title: 'USFS Colorado Roadless Areas',
                count: 0,
              };
            }
            legendAccumulator['usfs_co_roadless_areas'].count += areaCount;
          }
        }
      } catch (error) {
        console.error('Error processing USFS Colorado Roadless Areas:', error);
      }

      // Draw Houston METRO Rail Stations as point markers on the map
      try {
        if (enrichments.houston_metro_rail_stations_all && Array.isArray(enrichments.houston_metro_rail_stations_all)) {
          let stationCount = 0;
          enrichments.houston_metro_rail_stations_all.forEach((station: any) => {
            if (station.geometry && station.geometry.x !== undefined && station.geometry.y !== undefined) {
              try {
                // Extract coordinates from geometry (already in WGS84)
                const lat = station.geometry.y;
                const lon = station.geometry.x;
                
                const stationName = station.stationName || station.Stat_Name || station.STAT_NAME || 'Unknown Rail Station';
                const corridorName = station.corridorName || station.Corr_Name || station.CORR_NAME || null;
                const stationLocation = station.stationLocation || station.Stat_Loc || station.STAT_LOC || null;
                const lineColor = station.lineColor || station.LineColor || station.LINECOLOR || null;
                const status = station.status || station.Status || station.STATUS || null;
                const distance = station.distance_miles !== null && station.distance_miles !== undefined ? station.distance_miles : 0;
                
                // Create marker with rail icon
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚆', '#7c3aed')
                });
                
                // Build popup content
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚆 ${stationName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${corridorName ? `<div><strong>Corridor:</strong> ${corridorName}</div>` : ''}
                      ${stationLocation ? `<div><strong>Location:</strong> ${stationLocation}</div>` : ''}
                      ${lineColor ? `<div><strong>Line Color:</strong> ${lineColor}</div>` : ''}
                      ${status ? `<div><strong>Status:</strong> ${status}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all station attributes (excluding internal fields)
                const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'stationName', 'Stat_Name', 'STAT_NAME', 'corridorName', 'Corr_Name', 'CORR_NAME', 'stationLocation', 'Stat_Loc', 'STAT_LOC', 'lineColor', 'LineColor', 'LINECOLOR', 'status', 'Status', 'STATUS'];
                Object.entries(station).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent, { maxWidth: 400 });
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                stationCount++;
              } catch (error) {
                console.error('Error drawing Houston METRO Rail Station marker:', error);
              }
            }
          });
          
          if (stationCount > 0) {
            if (!legendAccumulator['houston_metro_rail_stations']) {
              legendAccumulator['houston_metro_rail_stations'] = {
                icon: '🚆',
                color: '#7c3aed',
                title: 'Houston METRO Rail Stations',
                count: 0,
              };
            }
            legendAccumulator['houston_metro_rail_stations'].count += stationCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston METRO Rail Stations:', error);
      }

      // Draw Houston Airports as polygons on the map
      try {
        if (enrichments.houston_airports_all && Array.isArray(enrichments.houston_airports_all)) {
          let airportCount = 0;
          enrichments.houston_airports_all.forEach((airport: any) => {
            if (airport.geometry && airport.geometry.rings && Array.isArray(airport.geometry.rings)) {
              try {
                const rings = airport.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Houston Airport polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = airport.isContaining;
                  const color = isContaining ? '#f59e0b' : '#fbbf24'; // Orange for containing, lighter for nearby
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const airportName = airport.airportName || airport.NAME || airport.name || airport.NAME1 || airport.name1 || 'Unknown Airport';
                  const airportId = airport.objectId || airport.OBJECTID || airport.objectid || null;
                  const distance = airport.distance_miles !== null && airport.distance_miles !== undefined ? airport.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ✈️ ${airportName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${airportId ? `<div><strong>Airport ID:</strong> ${airportId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all airport attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'airportName', 'NAME', 'name', 'NAME1', 'name1'];
                  Object.entries(airport).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  airportCount++;
                }
              } catch (error) {
                console.error('Error drawing Houston Airport polygon:', error);
              }
            }
          });
          
          if (airportCount > 0) {
            if (!legendAccumulator['houston_airports']) {
              legendAccumulator['houston_airports'] = {
                icon: '✈️',
                color: '#f59e0b',
                title: 'Houston Airports',
                count: 0,
              };
            }
            legendAccumulator['houston_airports'].count += airportCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston Airports:', error);
      }

      // Draw Houston OLC Grid 6-digit as polygons on the map
      try {
        if (enrichments.houston_olc_grid_6digit_all && Array.isArray(enrichments.houston_olc_grid_6digit_all)) {
          let gridCount = 0;
          enrichments.houston_olc_grid_6digit_all.forEach((grid: any) => {
            if (grid.geometry && grid.geometry.rings && Array.isArray(grid.geometry.rings)) {
              try {
                const rings = grid.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Houston OLC Grid 6-digit polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = grid.isContaining;
                  const color = isContaining ? '#8b5cf6' : '#c084fc'; // Purple for grids
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const olcCode = grid.olcCode || grid.OLC_CODE || grid.olc_code || 'Unknown';
                  const gridId = grid.objectId || grid.OBJECTID || grid.objectid || null;
                  const distance = grid.distance_miles !== null && grid.distance_miles !== undefined ? grid.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🗺️ OLC Grid 6-digit: ${olcCode}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${gridId ? `<div><strong>Grid ID:</strong> ${gridId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all grid attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'olcCode', 'OLC_CODE', 'olc_code', 'gridSize'];
                  Object.entries(grid).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  gridCount++;
                }
              } catch (error) {
                console.error('Error drawing Houston OLC Grid 6-digit polygon:', error);
              }
            }
          });
          
          if (gridCount > 0) {
            if (!legendAccumulator['houston_olc_grid_6digit']) {
              legendAccumulator['houston_olc_grid_6digit'] = {
                icon: '🗺️',
                color: '#8b5cf6',
                title: 'Houston OLC Grid - 6 Digits',
                count: 0,
              };
            }
            legendAccumulator['houston_olc_grid_6digit'].count += gridCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston OLC Grid 6-digit:', error);
      }

      // Draw Houston OLC Grid 8-digit as polygons on the map
      try {
        if (enrichments.houston_olc_grid_8digit_all && Array.isArray(enrichments.houston_olc_grid_8digit_all)) {
          let gridCount = 0;
          enrichments.houston_olc_grid_8digit_all.forEach((grid: any) => {
            if (grid.geometry && grid.geometry.rings && Array.isArray(grid.geometry.rings)) {
              try {
                const rings = grid.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('Houston OLC Grid 8-digit polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = grid.isContaining;
                  const color = isContaining ? '#a855f7' : '#c084fc'; // Purple for grids
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const olcCode = grid.olcCode || grid.OLC_CODE || grid.olc_code || 'Unknown';
                  const gridId = grid.objectId || grid.OBJECTID || grid.objectid || null;
                  const distance = grid.distance_miles !== null && grid.distance_miles !== undefined ? grid.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🗺️ OLC Grid 8-digit: ${olcCode}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${gridId ? `<div><strong>Grid ID:</strong> ${gridId}</div>` : ''}
                        ${isContaining ? '<div><strong>Status:</strong> Contains location</div>' : ''}
                        ${distance > 0 ? `<div><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all grid attributes (excluding internal fields)
                  const excludeFields = ['objectId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'isContaining', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'olcCode', 'OLC_CODE', 'olc_code', 'gridSize'];
                  Object.entries(grid).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent, { maxWidth: 400 });
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  gridCount++;
                }
              } catch (error) {
                console.error('Error drawing Houston OLC Grid 8-digit polygon:', error);
              }
            }
          });
          
          if (gridCount > 0) {
            if (!legendAccumulator['houston_olc_grid_8digit']) {
              legendAccumulator['houston_olc_grid_8digit'] = {
                icon: '🗺️',
                color: '#a855f7',
                title: 'Houston OLC Grid - 8 Digits',
                count: 0,
              };
            }
            legendAccumulator['houston_olc_grid_8digit'].count += gridCount;
          }
        }
      } catch (error) {
        console.error('Error processing Houston OLC Grid 8-digit:', error);
      }

      // Draw LA County Historic Cultural Monuments as polygons on the map
      try {
        if (enrichments.la_county_historic_cultural_monuments_all && Array.isArray(enrichments.la_county_historic_cultural_monuments_all)) {
          let monumentCount = 0;
          enrichments.la_county_historic_cultural_monuments_all.forEach((monument: any) => {
            if (monument.geometry && monument.geometry.rings) {
              try {
                const rings = monument.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('LA County Historic Cultural Monument polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = monument.isContaining;
                  const color = isContaining ? '#a855f7' : '#c084fc'; // Purple for monuments
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const name = monument.name || monument.NAME || monument.Name || 'Unknown Monument';
                  const monumentId = monument.monumentId || monument.OBJECTID || monument.objectid || null;
                  const histType = monument.histType || monument.HIST_TYPE || monument.hist_type || null;
                  const mntType = monument.mntType || monument.MNT_TYPE || monument.mnt_type || null;
                  const mntNum = monument.mntNum || monument.MNT_NUM || monument.mnt_num || null;
                  const location = monument.location || monument.LOCATION || monument.Location || null;
                  const dateActive = monument.dateActive || monument.DATE_ACTIVE || monument.date_active || null;
                  const notes = monument.notes || monument.NOTES || monument.Notes || null;
                  const shapeArea = monument.shapeArea || monument.Shape__Area || monument.shape_area || null;
                  const distance = monument.distance_miles !== null && monument.distance_miles !== undefined ? monument.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏛️ Historic Cultural Monument
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${name ? `<div><strong>Name:</strong> ${name}</div>` : ''}
                        ${monumentId ? `<div><strong>Monument ID:</strong> ${monumentId}</div>` : ''}
                        ${mntNum ? `<div><strong>Monument Number:</strong> ${mntNum}</div>` : ''}
                        ${histType ? `<div><strong>Historic Type:</strong> ${histType}</div>` : ''}
                        ${mntType ? `<div><strong>Monument Type:</strong> ${mntType}</div>` : ''}
                        ${location ? `<div><strong>Location:</strong> ${location}</div>` : ''}
                        ${dateActive ? `<div><strong>Date Active:</strong> ${dateActive}</div>` : ''}
                        ${notes ? `<div><strong>Notes:</strong> ${notes}</div>` : ''}
                        ${shapeArea !== null && shapeArea !== undefined ? `<div><strong>Area:</strong> ${shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this monument</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all monument attributes (excluding internal fields)
                  const excludeFields = ['monumentId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'name', 'NAME', 'Name', 'histType', 'HIST_TYPE', 'hist_type', 'mntType', 'MNT_TYPE', 'mnt_type', 'mntNum', 'MNT_NUM', 'mnt_num', 'location', 'LOCATION', 'Location', 'dateActive', 'DATE_ACTIVE', 'date_active', 'notes', 'NOTES', 'Notes', 'shapeArea', 'Shape__Area', 'shape_area', 'shapeLength', 'Shape__Length', 'shape_length', 'isContaining'];
                  Object.entries(monument).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  monumentCount++;
                }
              } catch (error) {
                console.error('Error drawing LA County Historic Cultural Monument polygon:', error);
              }
            }
          });
          
          if (monumentCount > 0) {
            if (!legendAccumulator['la_county_historic_cultural_monuments']) {
              legendAccumulator['la_county_historic_cultural_monuments'] = {
                icon: '🏛️',
                color: '#a855f7',
                title: 'LA County Historic Cultural Monuments',
                count: 0,
              };
            }
            legendAccumulator['la_county_historic_cultural_monuments'].count += monumentCount;
          }
        }
      } catch (error) {
        console.error('Error processing LA County Historic Cultural Monuments:', error);
      }

      // Draw LA County Housing with Potential Lead Risk as polygons on the map
      try {
        if (enrichments.la_county_housing_lead_risk_all && Array.isArray(enrichments.la_county_housing_lead_risk_all)) {
          let housingAreaCount = 0;
          enrichments.la_county_housing_lead_risk_all.forEach((area: any) => {
            if (area.geometry && area.geometry.rings) {
              try {
                const rings = area.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('LA County Housing Lead Risk polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = area.isContaining;
                  const color = isContaining ? '#dc2626' : '#ef4444'; // Red for lead risk
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const ct20 = area.ct20 || area.CT20 || area.Ct20 || null;
                  const housingRisk = area.housingRisk !== null && area.housingRisk !== undefined 
                                     ? parseFloat(area.housingRisk.toString())
                                     : (area.housing_risk !== null && area.housing_risk !== undefined
                                        ? parseFloat(area.housing_risk.toString())
                                        : null);
                  const laCity = area.laCity || area.la_city || area.LA_CITY || area.LaCity || null;
                  const housingId = area.housingId || area.OBJECTID || area.objectid || null;
                  const shapeArea = area.shapeArea || area.Shape__Area || area.shape_area || null;
                  const distance = area.distance_miles !== null && area.distance_miles !== undefined ? area.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏠 Housing with Potential Lead Risk
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${ct20 ? `<div><strong>Census Tract (2020):</strong> ${ct20}</div>` : ''}
                        ${housingRisk !== null && housingRisk !== undefined ? `<div><strong>Housing Risk:</strong> ${housingRisk.toFixed(1)}%</div>` : ''}
                        ${laCity ? `<div><strong>LA City:</strong> ${laCity}</div>` : ''}
                        ${housingId ? `<div><strong>Area ID:</strong> ${housingId}</div>` : ''}
                        ${shapeArea !== null && shapeArea !== undefined ? `<div><strong>Area:</strong> ${shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${isContaining ? `<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">⚠️ Location is within this lead risk area</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all area attributes (excluding internal fields)
                  const excludeFields = ['housingId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'ct20', 'CT20', 'Ct20', 'housingRisk', 'housing_risk', 'HousingRisk', 'laCity', 'la_city', 'LA_CITY', 'LaCity', 'shapeArea', 'Shape__Area', 'shape_area', 'shapeLength', 'Shape__Length', 'shape_length', 'isContaining'];
                  Object.entries(area).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  housingAreaCount++;
                }
              } catch (error) {
                console.error('Error drawing LA County Housing Lead Risk polygon:', error);
              }
            }
          });
          
          if (housingAreaCount > 0) {
            if (!legendAccumulator['la_county_housing_lead_risk']) {
              legendAccumulator['la_county_housing_lead_risk'] = {
                icon: '🏠',
                color: '#dc2626',
                title: 'LA County Housing with Potential Lead Risk',
                count: 0,
              };
            }
            legendAccumulator['la_county_housing_lead_risk'].count += housingAreaCount;
          }
        }
      } catch (error) {
        console.error('Error processing LA County Housing with Potential Lead Risk:', error);
      }

      // Draw LA County School District Boundaries as polygons on the map
      try {
        if (enrichments.la_county_school_district_boundaries_all && Array.isArray(enrichments.la_county_school_district_boundaries_all)) {
          let districtCount = 0;
          enrichments.la_county_school_district_boundaries_all.forEach((district: any) => {
            if (district.geometry && district.geometry.rings) {
              try {
                const rings = district.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });
                  
                  if (latlngs.length < 3) {
                    console.warn('LA County School District Boundary polygon has less than 3 coordinates, skipping');
                    return;
                  }
                  
                  const isContaining = district.isContaining;
                  const color = isContaining ? '#3b82f6' : '#60a5fa'; // Blue for school districts
                  const weight = isContaining ? 3 : 2;
                  const opacity = isContaining ? 0.8 : 0.5;
                  
                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: opacity,
                    fillColor: color,
                    fillOpacity: 0.2
                  });
                  
                  const districtName = district.districtName || district.LABEL || district.label || district.Label || null;
                  const districtCode = district.districtCode || district.ABBR || district.abbr || district.Abbr || null;
                  const districtType = district.districtType || district.DISTRICT_TYPE || district.district_type || district.DistrictType || null;
                  const districtId = district.districtId || district.OBJECTID || district.objectid || null;
                  const shapeArea = district.shapeArea || district.Shape__Area || district.shape_area || null;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏫 School District Boundary
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${districtName ? `<div><strong>District Name:</strong> ${districtName}</div>` : ''}
                        ${districtCode ? `<div><strong>District Code:</strong> ${districtCode}</div>` : ''}
                        ${districtType ? `<div><strong>District Type:</strong> ${districtType}</div>` : ''}
                        ${districtId ? `<div><strong>District ID:</strong> ${districtId}</div>` : ''}
                        ${shapeArea !== null && shapeArea !== undefined ? `<div><strong>Area:</strong> ${shapeArea.toFixed(2)} sq units</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this school district</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  // Add all district attributes (excluding internal fields)
                  const excludeFields = ['districtId', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'districtName', 'LABEL', 'label', 'Label', 'districtCode', 'ABBR', 'abbr', 'Abbr', 'districtType', 'DISTRICT_TYPE', 'district_type', 'DistrictType', 'shapeArea', 'Shape__Area', 'shape_area', 'shapeLength', 'Shape__Length', 'shape_length', 'isContaining'];
                  Object.entries(district).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  
                  // Extend bounds to include polygon
                  const polygonBounds = L.latLngBounds(latlngs);
                  bounds.extend(polygonBounds);
                  
                  districtCount++;
                }
              } catch (error) {
                console.error('Error drawing LA County School District Boundary polygon:', error);
              }
            }
          });
          
          if (districtCount > 0) {
            if (!legendAccumulator['la_county_school_district_boundaries']) {
              legendAccumulator['la_county_school_district_boundaries'] = {
                icon: '🏫',
                color: '#3b82f6',
                title: 'LA County School District Boundaries',
                count: 0,
              };
            }
            legendAccumulator['la_county_school_district_boundaries'].count += districtCount;
          }
        }
      } catch (error) {
        console.error('Error processing LA County School District Boundaries:', error);
      }

      // Draw LA County Street Inventory as polylines on the map
      try {
        if (enrichments.la_county_street_inventory_all && Array.isArray(enrichments.la_county_street_inventory_all)) {
          let streetCount = 0;
          enrichments.la_county_street_inventory_all.forEach((street: any) => {
            if (street.geometry && street.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = street.geometry.paths;
                if (paths && paths.length > 0) {
                  streetCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const streetName = street.streetName || street.ST_NAME || street.st_name || street.Name || street.NAME || 'Unknown Street';
                    const streetDir = street.streetDir || street.ST_DIR || street.st_dir || street.Dir || street.DIR || null;
                    const streetType = street.streetType || street.ST_TYPE || street.st_type || street.Type || street.TYPE || null;
                    const streetFrom = street.streetFrom || street.ST_FROM || street.st_from || street.From || street.FROM || null;
                    const streetTo = street.streetTo || street.ST_TO || street.st_to || street.To || street.TO || null;
                    const streetSurface = street.streetSurface || street.ST_SURFACE || street.st_surface || street.Surface || street.SURFACE || null;
                    const pciStatus = street.pciStatus || street.PCI_STATUS || street.pci_status || street.PciStatus || street.Status || street.STATUS || null;
                    const ncName = street.ncName || street.NC_NAME || street.nc_name || street.NcName || street.NCNAME || null;
                    const sectId = street.sectId || street.SECT_ID || street.sect_id || null;
                    const streetLength = street.streetLength || street.ST_LENGTH || street.st_length || null;
                    const streetWidth = street.streetWidth || street.ST_WIDTH || street.st_width || null;
                    const shapeLength = street.shapeLength || street.Shape__Length || street.shape_length || null;
                    const streetId = street.streetId || street.OBJECTID || street.objectid || null;
                    const distance = street.distance_miles !== null && street.distance_miles !== undefined ? street.distance_miles : 0;

                    // Build full street name
                    const fullStreetName = [streetDir, streetName, streetType].filter(Boolean).join(' ').trim() || streetName;

                    // Create polyline with yellow color for street inventory
                    const polyline = L.polyline(latlngs, {
                      color: '#fbbf24', // Yellow color for streets (better visibility on imagery basemap)
                      weight: 3,
                      opacity: 0.7,
                      smoothFactor: 1
                    });

                    // Build popup content with all street attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛣️ ${fullStreetName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${streetFrom && streetTo ? `<div><strong>From:</strong> ${streetFrom} <strong>To:</strong> ${streetTo}</div>` : ''}
                          ${streetSurface ? `<div><strong>Surface:</strong> ${streetSurface}</div>` : ''}
                          ${pciStatus ? `<div><strong>PCI Status:</strong> ${pciStatus}</div>` : ''}
                          ${ncName ? `<div><strong>Neighborhood:</strong> ${ncName}</div>` : ''}
                          ${sectId ? `<div><strong>Section ID:</strong> ${sectId}</div>` : ''}
                          ${streetLength !== null && streetLength !== undefined ? `<div><strong>Length:</strong> ${streetLength} ft</div>` : ''}
                          ${streetWidth !== null && streetWidth !== undefined ? `<div><strong>Width:</strong> ${streetWidth} ft</div>` : ''}
                          ${shapeLength !== null && shapeLength !== undefined ? `<div><strong>Shape Length:</strong> ${shapeLength.toFixed(2)} meters</div>` : ''}
                          ${streetId ? `<div><strong>Street ID:</strong> ${streetId}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all street attributes (excluding internal fields)
                    const excludeFields = ['streetId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'sectId', 'SECT_ID', 'sect_id', 'streetName', 'ST_NAME', 'st_name', 'Name', 'NAME', 'streetDir', 'ST_DIR', 'st_dir', 'Dir', 'DIR', 'streetType', 'ST_TYPE', 'st_type', 'Type', 'TYPE', 'streetFrom', 'ST_FROM', 'st_from', 'From', 'FROM', 'streetTo', 'ST_TO', 'st_to', 'To', 'TO', 'streetSurface', 'ST_SURFACE', 'st_surface', 'Surface', 'SURFACE', 'streetLength', 'ST_LENGTH', 'st_length', 'streetWidth', 'ST_WIDTH', 'st_width', 'pciStatus', 'PCI_STATUS', 'pci_status', 'PciStatus', 'Status', 'STATUS', 'ncName', 'NC_NAME', 'nc_name', 'NcName', 'NCNAME', 'ncname', 'shapeLength', 'Shape__Length', 'shape_length'];
                    Object.entries(street).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    
                    // Extend bounds to include polyline
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                  });
                }
              } catch (error) {
                console.error('Error drawing LA County Street Inventory polyline:', error);
              }
            }
          });
          
          if (streetCount > 0) {
            if (!legendAccumulator['la_county_street_inventory']) {
              legendAccumulator['la_county_street_inventory'] = {
                icon: '🛣️',
                color: '#fbbf24',
                title: 'LA County Street Inventory',
                count: 0,
              };
            }
            legendAccumulator['la_county_street_inventory'].count += streetCount;
          }
        }
      } catch (error) {
        console.error('Error processing LA County Street Inventory:', error);
      }

      // Draw LA County Hazards layers
      const laCountyHazardsLayers = [
        { key: 'la_county_fire_hazards_all', layerId: 0, icon: '🔥', color: '#dc2626', title: 'LA County Fire Hazards', isPoint: true },
        { key: 'la_county_fire_hazard_responsibility_areas_all', layerId: 1, icon: '🔥', color: '#ef4444', title: 'LA County Fire Hazard Responsibility Areas', isPoint: false },
        { key: 'la_county_fire_hazard_severity_zones_all', layerId: 2, icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones', isPoint: false },
        { key: 'la_county_fire_hazard_severity_zones_lra_all', layerId: 18, icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones LRA', isPoint: false },
        { key: 'la_county_fire_hazard_severity_zones_sra_all', layerId: 19, icon: '🔥', color: '#f97316', title: 'LA County Fire Hazard Severity Zones SRA', isPoint: false },
        { key: 'la_county_earthquake_hazards_all', layerId: 3, icon: '🌍', color: '#7c2d12', title: 'LA County Earthquake Hazards', isPoint: true },
        { key: 'la_county_alquist_priolo_fault_traces_all', layerId: 4, icon: '⚡', color: '#991b1b', title: 'LA County Alquist-Priolo Fault Traces', isPoint: false, isLine: true },
        { key: 'la_county_alquist_priolo_fault_zones_all', layerId: 5, icon: '⚡', color: '#b91c1c', title: 'LA County Alquist-Priolo Fault Zones', isPoint: false },
        { key: 'la_county_usgs_faults_all', layerId: 17, icon: '⚡', color: '#dc2626', title: 'LA County USGS Faults', isPoint: false, isLine: true },
        { key: 'la_county_tsunami_inundation_runup_line_all', layerId: 6, icon: '🌊', color: '#0ea5e9', title: 'LA County Tsunami Inundation Runup Line', isPoint: false, isLine: true },
        { key: 'la_county_tsunami_inundation_zones_all', layerId: 7, icon: '🌊', color: '#0284c7', title: 'LA County Tsunami Inundation Zones', isPoint: false },
        { key: 'la_county_landslide_zones_all', layerId: 8, icon: '⛰️', color: '#a16207', title: 'LA County Landslide Zones', isPoint: false },
        { key: 'la_county_liquefaction_zones_all', layerId: 9, icon: '🌋', color: '#ca8a04', title: 'LA County Liquefaction Zones', isPoint: false },
        { key: 'la_county_flood_hazards_all', layerId: 10, icon: '💧', color: '#0ea5e9', title: 'LA County Flood Hazards', isPoint: true },
        { key: 'la_county_100_year_flood_plain_all', layerId: 11, icon: '💧', color: '#0284c7', title: 'LA County 100-Year Flood Plain', isPoint: false },
        { key: 'la_county_500_year_flood_plain_all', layerId: 12, icon: '💧', color: '#0369a1', title: 'LA County 500-Year Flood Plain', isPoint: false },
        { key: 'la_county_dam_inundation_eta_all', layerId: 13, icon: '🏗️', color: '#1e40af', title: 'LA County Dam Inundation ETA', isPoint: false, isLine: true },
        { key: 'la_county_dam_inundation_areas_all', layerId: 14, icon: '🏗️', color: '#1e3a8a', title: 'LA County Dam Inundation Areas', isPoint: false }
      ];

      laCountyHazardsLayers.forEach(({ key, icon, color, title, isPoint, isLine }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((hazard: any) => {
              try {
                const geometry = hazard.geometry;
                const isContaining = hazard.isContaining;
                const distance = hazard.distance_miles !== null && hazard.distance_miles !== undefined ? hazard.distance_miles : 0;
                const hazardId = hazard.hazardId || hazard.OBJECTID || hazard.objectid || 'Unknown';
                
                // Check for point geometry (either from geometry.x/y or from attributes)
                const pointLat = isPoint ? (geometry?.y || geometry?.latitude || hazard.latitude || hazard.LATITUDE || hazard.lat || hazard.LAT) : null;
                const pointLon = isPoint ? (geometry?.x || geometry?.longitude || hazard.longitude || hazard.LONGITUDE || hazard.lon || hazard.LON) : null;
                
                if (isPoint && pointLat !== null && pointLat !== undefined && pointLon !== null && pointLon !== undefined) {
                  // Point geometry
                  const lat = pointLat;
                  const lon = pointLon;
                  
                  const marker = L.marker([lat, lon], {
                    icon: createPOIIcon(icon, color)
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${hazardId ? `<div><strong>Hazard ID:</strong> ${hazardId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['hazardId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                  Object.entries(hazard).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  featureCount++;
                } else if (isLine && geometry && geometry.paths) {
                  // Polyline geometry
                  const paths = geometry.paths;
                  if (paths && paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      const polyline = L.polyline(latlngs, {
                        color: color,
                        weight: 3,
                        opacity: 0.8,
                        smoothFactor: 1
                      });
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${icon} ${title}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${hazardId ? `<div><strong>Hazard ID:</strong> ${hazardId}</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;
                      
                      const excludeFields = ['hazardId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                      Object.entries(hazard).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) {
                            return;
                          }
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      
                      popupContent += `
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent);
                      polyline.addTo(primary);
                      const polylineBounds = L.latLngBounds(latlngs);
                      bounds.extend(polylineBounds);
                    });
                    featureCount++;
                  }
                } else if (!isPoint && geometry && geometry.rings) {
                  // Polygon geometry
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc'); // Lighter if not containing
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.2
                    });
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${hazardId ? `<div><strong>Hazard ID:</strong> ${hazardId}</div>` : ''}
                          ${isContaining ? `<div style="color: #dc2626; font-weight: 600; margin-top: 8px;">⚠️ Location is within this hazard area</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['hazardId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(hazard).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${title} feature:`, error);
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Basemaps and Grids layers
      const laCountyBasemapsGridsLayers = [
        { key: 'la_county_us_national_grid_all', layerId: 0, icon: '🗺️', color: '#6366f1', title: 'LA County US National Grid' },
        { key: 'la_county_usng_100k_all', layerId: 1, icon: '🗺️', color: '#818cf8', title: 'LA County USNG 100K' },
        { key: 'la_county_usng_10000m_all', layerId: 2, icon: '🗺️', color: '#a78bfa', title: 'LA County USNG 10000M' },
        { key: 'la_county_usng_1000m_all', layerId: 3, icon: '🗺️', color: '#c084fc', title: 'LA County USNG 1000M' },
        { key: 'la_county_usng_100m_all', layerId: 4, icon: '🗺️', color: '#d8b4fe', title: 'LA County USNG 100M' },
        { key: 'la_county_township_range_section_rancho_boundaries_all', layerId: 8, icon: '📐', color: '#4b5563', title: 'LA County Township Range Section Rancho Boundaries' }
      ];

      laCountyBasemapsGridsLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((grid: any) => {
              if (grid.geometry && grid.geometry.rings) {
                try {
                  const rings = grid.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = grid.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const gridId = grid.gridId || grid.OBJECTID || grid.objectid || 'Unknown';
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${gridId ? `<div><strong>Grid ID:</strong> ${gridId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this grid/boundary</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['gridId', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(grid).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw US National Grid layers
      const usNationalGridLayers = [
        { key: 'us_national_grid_usng_6x8_zones_all', layerId: 0, icon: '🗺️', color: '#3b82f6', title: 'USNG 6x8 Zones' },
        { key: 'us_national_grid_usng_100000m_all', layerId: 1, icon: '🗺️', color: '#2563eb', title: 'USNG 100000m' },
        { key: 'us_national_grid_usng_10000m_all', layerId: 2, icon: '🗺️', color: '#1d4ed8', title: 'USNG 10000m' },
        { key: 'us_national_grid_usng_1000m_all', layerId: 3, icon: '🗺️', color: '#1e40af', title: 'USNG 1000m' },
        { key: 'us_national_grid_usng_100m_all', layerId: 4, icon: '🗺️', color: '#1e3a8a', title: 'USNG 100m' }
      ];

      usNationalGridLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((grid: any) => {
              if (grid.geometry && grid.geometry.rings) {
                try {
                  const rings = grid.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = grid.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const gridId = grid.gridId || grid.OBJECTID || grid.objectid || 'Unknown';
                    const distanceMiles = grid.distance_miles !== undefined ? grid.distance_miles.toFixed(2) : null;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${gridId ? `<div><strong>Grid ID:</strong> ${gridId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this grid</div>` : distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['gridId', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining', 'distance_miles'];
                    Object.entries(grid).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw US Historical Cultural Political Points
      if (enrichments.us_historical_cultural_political_points_all && Array.isArray(enrichments.us_historical_cultural_political_points_all)) {
        try {
          let pointCount = 0;
          enrichments.us_historical_cultural_political_points_all.forEach((point: any) => {
            try {
              let pointLat: number | null = null;
              let pointLon: number | null = null;
              
              // Extract coordinates from geometry (multipoint or single point)
              if (point.geometry) {
                if (point.geometry.points && point.geometry.points.length > 0) {
                  // Multipoint geometry - use first point
                  const firstPoint = point.geometry.points[0];
                  pointLon = firstPoint[0];
                  pointLat = firstPoint[1];
                } else if (point.geometry.x !== undefined && point.geometry.y !== undefined) {
                  // Single point geometry
                  pointLon = point.geometry.x;
                  pointLat = point.geometry.y;
                }
              }
              
              // Fallback to attributes if geometry not available
              if (pointLat === null || pointLon === null) {
                // Try to get from attributes (though geometry should always be present)
                return;
              }
              
              const pointName = point.gaz_name || point.GAZ_NAME || point.name || 'Unknown Point';
              const featureClass = point.gaz_featureclass || point.GAZ_FEATURECLASS || point.feature_class || 'Unknown';
              const stateAlpha = point.state_alpha || point.STATE_ALPHA || '';
              const countyName = point.county_name || point.COUNTY_NAME || '';
              const distanceMiles = point.distance_miles !== undefined ? point.distance_miles.toFixed(2) : '';
              
              // Create a custom icon for historical points
              const icon = createPOIIcon('🏛️', '#8b5cf6'); // Purple icon for historical/cultural points
              
              const marker = L.marker([pointLat, pointLon], { icon });
              
              // Build popup content
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🏛️ ${pointName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${featureClass ? `<div><strong>Feature Class:</strong> ${featureClass}</div>` : ''}
                    ${stateAlpha ? `<div><strong>State:</strong> ${stateAlpha}</div>` : ''}
                    ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                    ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all attributes (excluding internal fields)
              const excludeFields = ['gaz_name', 'GAZ_NAME', 'name', 'gaz_featureclass', 'GAZ_FEATURECLASS', 'feature_class', 'state_alpha', 'STATE_ALPHA', 'county_name', 'COUNTY_NAME', 'geometry', 'pointId', 'distance_miles', 'OBJECTID', 'objectid'];
              Object.entries(point).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent);
              marker.addTo(primary);
              const pointBounds = L.latLngBounds([[pointLat, pointLon]]);
              bounds.extend(pointBounds);
              pointCount++;
            } catch (error) {
              console.error('Error drawing historical cultural political point:', error);
            }
          });
          
          if (pointCount > 0) {
            if (!legendAccumulator['us_historical_cultural_political_points']) {
              legendAccumulator['us_historical_cultural_political_points'] = {
                icon: '🏛️',
                color: '#8b5cf6',
                title: 'US Historical Cultural Political Points',
                count: 0,
              };
            }
            legendAccumulator['us_historical_cultural_political_points'].count += pointCount;
          }
        } catch (error) {
          console.error('Error processing US Historical Cultural Political Points:', error);
        }
      }

      // Draw US Historical Hydrographic Points
      if (enrichments.us_historical_hydrographic_points_all && Array.isArray(enrichments.us_historical_hydrographic_points_all)) {
        try {
          let pointCount = 0;
          enrichments.us_historical_hydrographic_points_all.forEach((point: any) => {
            try {
              let pointLat: number | null = null;
              let pointLon: number | null = null;
              
              // Extract coordinates from geometry (multipoint or single point)
              if (point.geometry) {
                if (point.geometry.points && point.geometry.points.length > 0) {
                  // Multipoint geometry - use first point
                  const firstPoint = point.geometry.points[0];
                  pointLon = firstPoint[0];
                  pointLat = firstPoint[1];
                } else if (point.geometry.x !== undefined && point.geometry.y !== undefined) {
                  // Single point geometry
                  pointLon = point.geometry.x;
                  pointLat = point.geometry.y;
                }
              }
              
              // Fallback to attributes if geometry not available
              if (pointLat === null || pointLon === null) {
                // Try to get from attributes (though geometry should always be present)
                return;
              }
              
              const pointName = point.gaz_name || point.GAZ_NAME || point.name || 'Unknown Point';
              const featureClass = point.gaz_featureclass || point.GAZ_FEATURECLASS || point.feature_class || 'Unknown';
              const stateAlpha = point.state_alpha || point.STATE_ALPHA || '';
              const countyName = point.county_name || point.COUNTY_NAME || '';
              const distanceMiles = point.distance_miles !== undefined ? point.distance_miles.toFixed(2) : '';
              
              // Create a custom icon for hydrographic points
              const icon = createPOIIcon('💧', '#06b6d4'); // Cyan/blue icon for hydrographic points
              
              const marker = L.marker([pointLat, pointLon], { icon });
              
              // Build popup content
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    💧 ${pointName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${featureClass ? `<div><strong>Feature Class:</strong> ${featureClass}</div>` : ''}
                    ${stateAlpha ? `<div><strong>State:</strong> ${stateAlpha}</div>` : ''}
                    ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                    ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all attributes (excluding internal fields)
              const excludeFields = ['gaz_name', 'GAZ_NAME', 'name', 'gaz_featureclass', 'GAZ_FEATURECLASS', 'feature_class', 'state_alpha', 'STATE_ALPHA', 'county_name', 'COUNTY_NAME', 'geometry', 'pointId', 'distance_miles', 'OBJECTID', 'objectid'];
              Object.entries(point).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent);
              marker.addTo(primary);
              const pointBounds = L.latLngBounds([[pointLat, pointLon]]);
              bounds.extend(pointBounds);
              pointCount++;
            } catch (error) {
              console.error('Error drawing historical hydrographic point:', error);
            }
          });
          
          if (pointCount > 0) {
            if (!legendAccumulator['us_historical_hydrographic_points']) {
              legendAccumulator['us_historical_hydrographic_points'] = {
                icon: '💧',
                color: '#06b6d4',
                title: 'US Historical Hydrographic Points',
                count: 0,
              };
            }
            legendAccumulator['us_historical_hydrographic_points'].count += pointCount;
          }
        } catch (error) {
          console.error('Error processing US Historical Hydrographic Points:', error);
        }
      }

      // Draw US Historical Physical Points
      if (enrichments.us_historical_physical_points_all && Array.isArray(enrichments.us_historical_physical_points_all)) {
        try {
          let pointCount = 0;
          enrichments.us_historical_physical_points_all.forEach((point: any) => {
            try {
              let pointLat: number | null = null;
              let pointLon: number | null = null;
              
              // Extract coordinates from geometry (multipoint or single point)
              if (point.geometry) {
                if (point.geometry.points && point.geometry.points.length > 0) {
                  // Multipoint geometry - use first point
                  const firstPoint = point.geometry.points[0];
                  pointLon = firstPoint[0];
                  pointLat = firstPoint[1];
                } else if (point.geometry.x !== undefined && point.geometry.y !== undefined) {
                  // Single point geometry
                  pointLon = point.geometry.x;
                  pointLat = point.geometry.y;
                }
              }
              
              // Fallback to attributes if geometry not available
              if (pointLat === null || pointLon === null) {
                // Try to get from attributes (though geometry should always be present)
                return;
              }
              
              const pointName = point.gaz_name || point.GAZ_NAME || point.name || 'Unknown Point';
              const featureClass = point.gaz_featureclass || point.GAZ_FEATURECLASS || point.feature_class || 'Unknown';
              const stateAlpha = point.state_alpha || point.STATE_ALPHA || '';
              const countyName = point.county_name || point.COUNTY_NAME || '';
              const distanceMiles = point.distance_miles !== undefined ? point.distance_miles.toFixed(2) : '';
              
              // Create a custom icon for physical points
              const icon = createPOIIcon('🏔️', '#10b981'); // Green icon for physical/geographic points
              
              const marker = L.marker([pointLat, pointLon], { icon });
              
              // Build popup content
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    🏔️ ${pointName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${featureClass ? `<div><strong>Feature Class:</strong> ${featureClass}</div>` : ''}
                    ${stateAlpha ? `<div><strong>State:</strong> ${stateAlpha}</div>` : ''}
                    ${countyName ? `<div><strong>County:</strong> ${countyName}</div>` : ''}
                    ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all attributes (excluding internal fields)
              const excludeFields = ['gaz_name', 'GAZ_NAME', 'name', 'gaz_featureclass', 'GAZ_FEATURECLASS', 'feature_class', 'state_alpha', 'STATE_ALPHA', 'county_name', 'COUNTY_NAME', 'geometry', 'pointId', 'distance_miles', 'OBJECTID', 'objectid'];
              Object.entries(point).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent);
              marker.addTo(primary);
              const pointBounds = L.latLngBounds([[pointLat, pointLon]]);
              bounds.extend(pointBounds);
              pointCount++;
            } catch (error) {
              console.error('Error drawing historical physical point:', error);
            }
          });
          
          if (pointCount > 0) {
            if (!legendAccumulator['us_historical_physical_points']) {
              legendAccumulator['us_historical_physical_points'] = {
                icon: '🏔️',
                color: '#10b981',
                title: 'US Historical Physical Points',
                count: 0,
              };
            }
            legendAccumulator['us_historical_physical_points'].count += pointCount;
          }
        } catch (error) {
          console.error('Error processing US Historical Physical Points:', error);
        }
      }

      // Draw Hurricane Evacuation Routes as polylines on the map
      if (enrichments.hurricane_evacuation_routes_all && Array.isArray(enrichments.hurricane_evacuation_routes_all)) {
        try {
          let routeCount = 0;
          enrichments.hurricane_evacuation_routes_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                // ESRI polylines have paths (array of coordinate arrays)
                const paths = route.geometry.paths;
                if (paths && paths.length > 0) {
                  routeCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = route.NAME || route.name || route.ROUTE_NAME || route.route_name || 'Unknown Route';
                    const routeType = route.TYPE || route.type || route.ROUTE_TYPE || route.route_type || 'Evacuation Route';
                    const distanceMiles = route.distance_miles !== undefined ? route.distance_miles.toFixed(2) : '';

                    // Create polyline with orange/red color for evacuation routes
                    const polyline = L.polyline(latlngs, {
                      color: '#f97316', // Orange color for evacuation routes
                      weight: 5,
                      opacity: 0.9,
                      smoothFactor: 1
                    });

                    // Build popup content with all route attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🌀 ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${routeType ? `<div><strong>Type:</strong> ${routeType}</div>` : ''}
                          ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all route attributes (excluding internal fields)
                    const excludeFields = ['NAME', 'name', 'ROUTE_NAME', 'route_name', 'TYPE', 'type', 'ROUTE_TYPE', 'route_type', 'geometry', 'routeId', 'distance_miles', 'OBJECTID', 'objectid'];
                    Object.entries(route).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Hurricane Evacuation Route polyline:', error);
              }
            }
          });
          
          if (routeCount > 0) {
            if (!legendAccumulator['hurricane_evacuation_routes']) {
              legendAccumulator['hurricane_evacuation_routes'] = {
                icon: '🌀',
                color: '#f97316',
                title: 'Hurricane Evacuation Routes',
                count: 0,
              };
            }
            legendAccumulator['hurricane_evacuation_routes'].count += routeCount;
          }
        } catch (error) {
          console.error('Error processing Hurricane Evacuation Routes:', error);
        }
      }

      // Draw USGS Trails as polylines on the map
      if (enrichments.usgs_trails_all && Array.isArray(enrichments.usgs_trails_all)) {
        try {
          console.log(`🥾 Drawing ${enrichments.usgs_trails_all.length} USGS Trails features`);
          let trailCount = 0;
          enrichments.usgs_trails_all.forEach((trail: any, index: number) => {
            console.log(`🥾 USGS Trail ${index}:`, {
              hasGeometry: !!trail.geometry,
              hasPaths: !!trail.geometry?.paths,
              pathsLength: trail.geometry?.paths?.length,
              trailName: trail.name || trail.namealternate
            });
            if (trail.geometry && trail.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = trail.geometry.paths;
                if (paths && paths.length > 0) {
                  trailCount++; // Count each trail feature once, not each path
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const trailName = trail.name || trail.namealternate || 'Unknown Trail';
                    const trailType = trail.trailtype || 'Unknown Type';
                    const nationalDesignation = trail.nationaltraildesignation || '';
                    const lengthMiles = trail.lengthmiles !== undefined ? trail.lengthmiles.toFixed(2) : '';
                    const distanceMiles = trail.distance_miles !== undefined ? trail.distance_miles.toFixed(2) : '';

                    // Determine color based on trail type
                    let trailColor = '#10b981'; // Default green for terra trails
                    if (trailType === 'Snow Trail') {
                      trailColor = '#7c51ad'; // Purple for snow trails
                    } else if (trailType === 'Water Trail') {
                      trailColor = '#2d89dd'; // Blue for water trails
                    }

                    // Create polyline with trail-specific color
                    const polyline = L.polyline(latlngs, {
                      color: trailColor,
                      weight: 4,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🥾 ${trailName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${trailType ? `<div><strong>Trail Type:</strong> ${trailType}</div>` : ''}
                          ${nationalDesignation ? `<div><strong>National Designation:</strong> ${nationalDesignation}</div>` : ''}
                          ${lengthMiles ? `<div><strong>Length:</strong> ${lengthMiles} miles</div>` : ''}
                          ${trail.trailnumber ? `<div><strong>Trail Number:</strong> ${trail.trailnumber}</div>` : ''}
                          ${trail.primarytrailmaintainer ? `<div><strong>Maintainer:</strong> ${trail.primarytrailmaintainer}</div>` : ''}
                          ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add trail use information
                    if (trail.hikerpedestrian === 'Y') popupContent += `<div><strong>Hiker/Pedestrian:</strong> Yes</div>`;
                    if (trail.bicycle === 'Y') popupContent += `<div><strong>Bicycle:</strong> Yes</div>`;
                    if (trail.packsaddle === 'Y') popupContent += `<div><strong>Pack and Saddle:</strong> Yes</div>`;
                    if (trail.atv === 'Y') popupContent += `<div><strong>ATV:</strong> Yes</div>`;
                    if (trail.motorcycle === 'Y') popupContent += `<div><strong>Motorcycle:</strong> Yes</div>`;
                    
                    // Add all other trail attributes
                    const excludeFields = ['name', 'namealternate', 'trailtype', 'nationaltraildesignation', 'lengthmiles', 'trailnumber', 'primarytrailmaintainer', 'hikerpedestrian', 'bicycle', 'packsaddle', 'atv', 'motorcycle', 'geometry', 'distance_miles', 'objectid', 'OBJECTID'];
                    Object.entries(trail).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing USGS Trail polyline:', error);
              }
            }
          });
          
          if (trailCount > 0) {
            if (!legendAccumulator['usgs_trails']) {
              legendAccumulator['usgs_trails'] = {
                icon: '🥾',
                color: '#10b981',
                title: 'USGS Trails',
                count: 0,
              };
            }
            legendAccumulator['usgs_trails'].count += trailCount;
          }
        } catch (error) {
          console.error('Error processing USGS Trails:', error);
        }
      }

      // Draw USGS Transportation layers
      const transportationLayers = [
        { key: 'usgs_transportation_airport_all', icon: '✈️', color: '#3b82f6', title: 'USGS Transportation - Airport', isPolygon: true },
        { key: 'usgs_transportation_airport_runway_all', icon: '🛫', color: '#2563eb', title: 'USGS Transportation - Airport Runway', isPolygon: true },
        { key: 'usgs_transportation_interstate_all', icon: '🛣️', color: '#dc2626', title: 'USGS Transportation - Interstate', isPolyline: true },
        { key: 'usgs_transportation_us_route_all', icon: '🛣️', color: '#ea580c', title: 'USGS Transportation - US Route', isPolyline: true },
        { key: 'usgs_transportation_state_route_all', icon: '🛣️', color: '#f59e0b', title: 'USGS Transportation - State Route', isPolyline: true },
        { key: 'usgs_transportation_us_railroad_all', icon: '🚂', color: '#7c2d12', title: 'USGS Transportation - US Railroad', isPolyline: true },
        { key: 'usgs_transportation_local_road_all', icon: '🛣️', color: '#78716c', title: 'USGS Transportation - Local Road', isPolyline: true },
        { key: 'usgs_transportation_trails_all', icon: '🥾', color: '#059669', title: 'USGS Transportation - Trails', isPolyline: true }
      ];

      transportationLayers.forEach((layerConfig) => {
        if (enrichments[layerConfig.key] && Array.isArray(enrichments[layerConfig.key])) {
          try {
            console.log(`🚗 Drawing ${enrichments[layerConfig.key].length} ${layerConfig.title} features`);
            let featureCount = 0;
            enrichments[layerConfig.key].forEach((feature: any) => {
              if (!feature.geometry) return;

              try {
                if (layerConfig.isPolyline && feature.geometry.paths && feature.geometry.paths.length > 0) {
                  // Draw polyline (roads, railroads, trails)
                  const paths = feature.geometry.paths;
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const featureName = feature.name || feature.fullname || feature.route || feature.rtnumber || 
                      feature.rtname || feature.facname || feature.facilityname || feature.layerName || 'Unknown';
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                    const polyline = L.polyline(latlngs, {
                      color: layerConfig.color,
                      weight: layerConfig.key.includes('interstate') ? 5 : layerConfig.key.includes('us_route') ? 4 : layerConfig.key.includes('state_route') ? 3 : 2,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${layerConfig.icon} ${featureName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['name', 'fullname', 'route', 'rtnumber', 'rtname', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                  featureCount++;
                } else if (layerConfig.isPolygon && feature.geometry.rings && feature.geometry.rings.length > 0) {
                  // Draw polygon (airports, runways)
                  const rings = feature.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    if (outerRing && outerRing.length >= 3) {
                      const latlngs = outerRing.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });

                      const featureName = feature.name || feature.fullname || feature.facname || feature.facilityname || 
                        feature.airportname || feature.runwayname || feature.layerName || 'Unknown';
                      const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                      const polygon = L.polygon(latlngs, {
                        color: layerConfig.color,
                        weight: 2,
                        opacity: 0.7,
                        fillColor: layerConfig.color,
                        fillOpacity: 0.3
                      });

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${layerConfig.icon} ${featureName}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;

                      const excludeFields = ['name', 'fullname', 'facname', 'facilityname', 'airportname', 'runwayname', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                      Object.entries(feature).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) return;
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });

                      popupContent += `</div></div>`;
                      polygon.bindPopup(popupContent, { maxWidth: 400 });
                      polygon.addTo(primary);
                      bounds.extend(polygon.getBounds());
                      featureCount++;
                    }
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${layerConfig.title} feature:`, error);
              }
            });

            if (featureCount > 0) {
              const legendKey = layerConfig.key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: layerConfig.icon,
                  color: layerConfig.color,
                  title: layerConfig.title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`Error processing ${layerConfig.title}:`, error);
          }
        }
      });

      // Draw USGS GeoNames layers
      const geonamesLayers = [
        { key: 'usgs_geonames_administrative_all', icon: '📍', color: '#3b82f6', title: 'USGS GeoNames - Administrative', isPoint: true },
        { key: 'usgs_geonames_transportation_all', icon: '🚗', color: '#2563eb', title: 'USGS GeoNames - Transportation', isPoint: true },
        { key: 'usgs_geonames_landform_all', icon: '⛰️', color: '#16a34a', title: 'USGS GeoNames - Landform', isPoint: true },
        { key: 'usgs_geonames_hydro_lines_all', icon: '💧', color: '#0284c7', title: 'USGS GeoNames - Hydro Lines', isPolyline: true },
        { key: 'usgs_geonames_hydro_points_all', icon: '💧', color: '#0ea5e9', title: 'USGS GeoNames - Hydro Points', isPoint: true },
        { key: 'usgs_geonames_antarctica_all', icon: '🧊', color: '#e0e7ff', title: 'USGS GeoNames - Antarctica', isPoint: true },
        { key: 'usgs_geonames_historical_all', icon: '📜', color: '#a855f7', title: 'USGS GeoNames - Historical', isPoint: true }
      ];

      geonamesLayers.forEach((layerConfig) => {
        if (enrichments[layerConfig.key] && Array.isArray(enrichments[layerConfig.key])) {
          try {
            console.log(`📍 Drawing ${enrichments[layerConfig.key].length} ${layerConfig.title} features`);
            let featureCount = 0;
            enrichments[layerConfig.key].forEach((feature: any) => {
              if (!feature.geometry) return;

              try {
                if (layerConfig.isPolyline && feature.geometry.paths && feature.geometry.paths.length > 0) {
                  // Draw polyline (hydro lines)
                  const paths = feature.geometry.paths;
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const featureName = feature.name || feature.FEATURE_NAME || feature.feature_name || 
                      feature.GNIS_NAME || feature.gnis_name || feature.NAME || feature.NAME1 || 
                      feature.NAME2 || feature.PRIMARY_NAME || feature.primary_name ||
                      (feature.attributes ? (feature.attributes.name || feature.attributes.FEATURE_NAME || feature.attributes.GNIS_NAME) : null) ||
                      feature.layerName || 'Unknown';
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                    const polyline = L.polyline(latlngs, {
                      color: layerConfig.color,
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${layerConfig.icon} ${featureName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['name', 'FEATURE_NAME', 'feature_name', 'GNIS_NAME', 'gnis_name', 'NAME', 'NAME1', 'NAME2', 'PRIMARY_NAME', 'primary_name', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                  featureCount++;
                } else if (layerConfig.isPoint && feature.geometry.x !== undefined && feature.geometry.y !== undefined) {
                  // Draw point (administrative, transportation, landform, hydro points, antarctica, historical)
                  const pointLat = feature.geometry.y;
                  const pointLon = feature.geometry.x;
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  const featureName = feature.name || feature.FEATURE_NAME || feature.feature_name || 
                    feature.GNIS_NAME || feature.gnis_name || feature.NAME || feature.NAME1 || 
                    feature.NAME2 || feature.PRIMARY_NAME || feature.primary_name ||
                    (feature.attributes ? (feature.attributes.name || feature.attributes.FEATURE_NAME || feature.attributes.GNIS_NAME) : null) ||
                    feature.layerName || 'Unknown';

                  const icon = createPOIIcon(layerConfig.icon, layerConfig.color);
                  const marker = L.marker([pointLat, pointLon], { icon });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${layerConfig.icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['name', 'FEATURE_NAME', 'feature_name', 'GNIS_NAME', 'gnis_name', 'NAME', 'NAME1', 'NAME2', 'PRIMARY_NAME', 'primary_name', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });

                  popupContent += `</div></div>`;
                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                }
              } catch (error) {
                console.error(`Error drawing ${layerConfig.title} feature:`, error);
              }
            });

            if (featureCount > 0) {
              const legendKey = layerConfig.key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: layerConfig.icon,
                  color: layerConfig.color,
                  title: layerConfig.title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`Error processing ${layerConfig.title}:`, error);
          }
        }
      });

      // Draw Alaska DNR layers using mapLayerConfig
      // Find all Alaska DNR entries in mapLayerConfig array
      const alaskaDNRLayers = [
        { key: 'alaska_dnr_astar_public_airports_0_all', icon: '✈️', color: '#3b82f6', title: 'Alaska DNR - ASTAR Public Airports', isPoint: true },
        { key: 'alaska_dnr_astar_alaska_ports_harbors_all', icon: '⚓', color: '#0ea5e9', title: 'Alaska DNR - ASTAR Alaska Ports Harbors (DOT)', isPoint: true },
        { key: 'alaska_dnr_astar_public_airports_2_all', icon: '🛫', color: '#60a5fa', title: 'Alaska DNR - ASTAR Public Airports (2)', isPoint: true },
        { key: 'alaska_dnr_astar_dew_line_sites_all', icon: '📡', color: '#7c3aed', title: 'Alaska DNR - ASTAR DEW Line Sites', isPoint: true },
        { key: 'alaska_dnr_astar_roads_dot_all', icon: '🛣️', color: '#dc2626', title: 'Alaska DNR - ASTAR Roads (DOT)', isPolyline: true },
        { key: 'alaska_dnr_astar_all_roads_nssi_all', icon: '🛣️', color: '#ea580c', title: 'Alaska DNR - ASTAR All Roads (NSSI)', isPolyline: true },
        { key: 'alaska_dnr_astar_village_roads_nsb_all', icon: '🛣️', color: '#f97316', title: 'Alaska DNR - ASTAR Village Roads (NSB)', isPolyline: true },
        { key: 'alaska_dnr_astar_trails_state_of_alaska_all', icon: '🥾', color: '#059669', title: 'Alaska DNR - ASTAR Trails (State of Alaska)', isPolyline: true },
        { key: 'alaska_dnr_astar_airport_runway_usgs_all', icon: '🛬', color: '#0284c7', title: 'Alaska DNR - ASTAR Airport Runway (USGS)', isPolyline: true },
        { key: 'alaska_dnr_astar_easements_nsb_all', icon: '🛤️', color: '#6366f1', title: 'Alaska DNR - ASTAR Easements (NSB)', isPolygon: true },
        { key: 'alaska_dnr_astar_parcels_nsb_all', icon: '🏘️', color: '#8b5cf6', title: 'Alaska DNR - ASTAR Parcels (NSB)', isPolygon: true },
        { key: 'alaska_dnr_astar_map_north_slope_communities_all', icon: '🏘️', color: '#3b82f6', title: 'Alaska DNR - ASTARMap North Slope Communities', isPoint: true },
        { key: 'alaska_dnr_astar_map_existing_mineral_resource_all', icon: '⛏️', color: '#f59e0b', title: 'Alaska DNR - ASTARMap Existing Mineral Resource', isPolygon: true },
        { key: 'alaska_dnr_astar_map_potential_marine_facilities_all', icon: '⚓', color: '#0ea5e9', title: 'Alaska DNR - ASTARMap Potential Marine Facilities', isPoint: true },
        { key: 'alaska_dnr_astar_map_resource_areas_all', icon: '🗺️', color: '#10b981', title: 'Alaska DNR - ASTARMap Resource Areas', isPolygon: true },
        { key: 'alaska_dnr_astar_map_transportation_corridors_potential_all', icon: '🛣️', color: '#f97316', title: 'Alaska DNR - ASTARMap Transportation Corridors Potential', isPolyline: true },
        { key: 'alaska_dnr_astar_map_asap_proposed_all', icon: '📋', color: '#6366f1', title: 'Alaska DNR - ASTARMap ASAP proposed', isPolyline: true },
        { key: 'alaska_dnr_astar_map_existing_roads_all', icon: '🛣️', color: '#dc2626', title: 'Alaska DNR - ASTARMap Existing Roads', isPolyline: true },
        { key: 'alaska_dnr_astar_map_existing_infrastructure_all', icon: '🏗️', color: '#7c3aed', title: 'Alaska DNR - ASTARMap Existing Infrastructure', isPoint: true },
        { key: 'alaska_dnr_astar_map_anwr_1002_boundary_all', icon: '🗺️', color: '#059669', title: 'Alaska DNR - ASTARMap ANWR 1002 Boundary', isPolygon: true },
        { key: 'alaska_dnr_astar_map_csu_all', icon: '📐', color: '#8b5cf6', title: 'Alaska DNR - ASTARMap CSU', isPolygon: true },
        { key: 'alaska_dnr_astar_map_usgs_mining_tracts_all', icon: '⛏️', color: '#f59e0b', title: 'Alaska DNR - ASTARMap USGS Mining Tracts', isPolygon: true },
        { key: 'alaska_dnr_astar_map_ownership_all', icon: '🏛️', color: '#3b82f6', title: 'Alaska DNR - ASTARMap Ownership', isPolygon: true },
        { key: 'alaska_dnr_ws_hydro_base_glacier_1mil_py_all', icon: '🧊', color: '#0ea5e9', title: 'Alaska DNR - WSHydroBase Glacier 1mil Py', isPolygon: true },
        { key: 'alaska_dnr_infrastructure_power_line_all', icon: '⚡', color: '#fbbf24', title: 'Alaska DNR - Infrastructure Power Line', isPolyline: true },
        { key: 'alaska_dnr_infrastructure_pipeline_all', icon: '🛢️', color: '#a855f7', title: 'Alaska DNR - Infrastructure Pipeline', isPolyline: true },
        { key: 'alaska_dnr_infrastructure_fiberoptic_cable_all', icon: '📡', color: '#06b6d4', title: 'Alaska DNR - Infrastructure Fiberoptic Cable', isPolyline: true },
        { key: 'alaska_dnr_ws_hydro_base_river_1mil_ln_all', icon: '🌊', color: '#0284c7', title: 'Alaska DNR - WSHydroBase River 1mil Ln', isPolyline: true },
        { key: 'alaska_dnr_ws_hydro_base_lake_1mil_py_all', icon: '💧', color: '#06b6d4', title: 'Alaska DNR - WSHydroBase Lake 1mil Py', isPolygon: true },
      ];

      alaskaDNRLayers.forEach((layerConfig) => {
        if (enrichments[layerConfig.key] && Array.isArray(enrichments[layerConfig.key])) {
          try {
            console.log(`🗺️ Drawing ${enrichments[layerConfig.key].length} ${layerConfig.title} features`);
            let featureCount = 0;
            enrichments[layerConfig.key].forEach((feature: any) => {
              const geometry = feature.geometry || feature.__geometry;
              if (!geometry) {
                console.warn(`⚠️ ${layerConfig.title}: Feature missing geometry`, feature);
                return;
              }

              try {
                if (layerConfig.isPoint && geometry.x !== undefined && geometry.y !== undefined) {
                  // Draw point
                  const pointLat = geometry.y;
                  const pointLon = geometry.x;
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  const featureName = feature.name || feature.NAME || feature.FEATURE_NAME || feature.layerName || 'Unknown';

                  const icon = createPOIIcon(layerConfig.icon, layerConfig.color);
                  const marker = L.marker([pointLat, pointLon], { icon });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${layerConfig.icon} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['name', 'NAME', 'FEATURE_NAME', 'geometry', '__geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName', 'isContaining'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });

                  popupContent += `</div></div>`;
                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                } else if (layerConfig.isPolyline && geometry.paths && geometry.paths.length > 0) {
                  // Draw polyline
                  const paths = geometry.paths;
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const featureName = feature.name || feature.NAME || feature.FEATURE_NAME || feature.layerName || 'Unknown';
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                    const polyline = L.polyline(latlngs, {
                      color: layerConfig.color,
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${layerConfig.icon} ${featureName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['name', 'NAME', 'FEATURE_NAME', 'geometry', '__geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName', 'isContaining'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                  featureCount++;
                } else if (layerConfig.isPolygon && geometry.rings && geometry.rings.length > 0) {
                  // Draw polygon
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    if (outerRing && outerRing.length >= 3) {
                      const latlngs = outerRing.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });

                      const featureName = feature.name || feature.NAME || feature.FEATURE_NAME || feature.layerName || 'Unknown';
                      const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';
                      const isContaining = feature.isContaining;

                      const polygonColor = getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color);
                      const polygon = L.polygon(latlngs, {
                        color: polygonColor,
                        weight: isContaining ? 3 : 2,
                        opacity: 0.8,
                        fillColor: polygonColor,
                        fillOpacity: isContaining ? 0.4 : 0.2
                      });

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${layerConfig.icon} ${featureName}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${isContaining ? `<div style="color: #059669; font-weight: 600;">📍 Location is within this area</div>` : distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;

                      const excludeFields = ['name', 'NAME', 'FEATURE_NAME', 'geometry', '__geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName', 'isContaining'];
                      Object.entries(feature).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) return;
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });

                      popupContent += `</div></div>`;
                      polygon.bindPopup(popupContent, { maxWidth: 400 });
                      polygon.addTo(primary);
                      bounds.extend(polygon.getBounds());
                      featureCount++;
                    }
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${layerConfig.title} feature:`, error);
              }
            });

            if (featureCount > 0) {
              const legendKey = layerConfig.key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                const polygonColor = layerConfig.isPolygon ? getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color) : layerConfig.color;
                legendAccumulator[legendKey] = {
                  icon: layerConfig.icon,
                  color: polygonColor,
                  title: layerConfig.title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`Error processing ${layerConfig.title}:`, error);
          }
        }
      });

      // Draw USGS Selectable Polygons layers
      const selectablePolygonsLayers = [
        { key: 'usgs_selectable_polygons_state_territory_all', icon: '🗺️', color: '#3b82f6', title: 'USGS Selectable Polygons - State or Territory' },
        { key: 'usgs_selectable_polygons_congressional_district_all', icon: '🏛️', color: '#2563eb', title: 'USGS Selectable Polygons - Congressional District' },
        { key: 'usgs_selectable_polygons_county_equivalent_all', icon: '🏘️', color: '#16a34a', title: 'USGS Selectable Polygons - County or Equivalent' },
        { key: 'usgs_selectable_polygons_incorporated_place_all', icon: '🏙️', color: '#dc2626', title: 'USGS Selectable Polygons - Incorporated Place' },
        { key: 'usgs_selectable_polygons_unincorporated_place_all', icon: '🏘️', color: '#ea580c', title: 'USGS Selectable Polygons - Unincorporated Place' },
        { key: 'usgs_selectable_polygons_1x1_degree_index_all', icon: '🗺️', color: '#7c2d12', title: 'USGS Selectable Polygons - 1x1 Degree Index' },
        { key: 'usgs_selectable_polygons_100k_index_all', icon: '🗺️', color: '#78350f', title: 'USGS Selectable Polygons - 1:100K Index' },
        { key: 'usgs_selectable_polygons_63k_index_all', icon: '🗺️', color: '#92400e', title: 'USGS Selectable Polygons - 1:63K Index (AK)' },
        { key: 'usgs_selectable_polygons_24k_index_all', icon: '🗺️', color: '#b45309', title: 'USGS Selectable Polygons - 1:24K Index' },
        { key: 'usgs_selectable_polygons_region_all', icon: '💧', color: '#0284c7', title: 'USGS Selectable Polygons - Hydrologic Unit Region' },
        { key: 'usgs_selectable_polygons_subregion_all', icon: '💧', color: '#0ea5e9', title: 'USGS Selectable Polygons - Hydrologic Unit Subregion' },
        { key: 'usgs_selectable_polygons_subbasin_all', icon: '💧', color: '#38bdf8', title: 'USGS Selectable Polygons - Hydrologic Unit Subbasin' }
      ];

      selectablePolygonsLayers.forEach((layerConfig) => {
        if (enrichments[layerConfig.key] && Array.isArray(enrichments[layerConfig.key])) {
          try {
            console.log(`📍 Drawing ${enrichments[layerConfig.key].length} ${layerConfig.title} features`);
            let featureCount = 0;
            enrichments[layerConfig.key].forEach((feature: any) => {
              if (!feature.geometry || !feature.geometry.rings) return;

              try {
                // Draw polygon
                const rings = feature.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  if (outerRing && outerRing.length >= 3) {
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const isContaining = feature.isContaining || feature.distance_miles === 0;
                    const featureName = feature.name || feature.NAME || feature.NAME1 || feature.NAME2 || 
                      feature.STATE_NAME || feature.state_name || feature.COUNTY_NAME || feature.county_name ||
                      feature.PLACE_NAME || feature.place_name || feature.DISTRICT || feature.district ||
                      feature.HUC || feature.huc || feature.REGION || feature.region ||
                      feature.SUBREGION || feature.subregion || feature.SUBBASIN || feature.subbasin ||
                      feature.INDEX || feature.index || feature.CELL_ID || feature.cell_id ||
                      feature.layerName || 'Unknown';
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : (isContaining ? '0.00' : '');

                    // Get unique color for this polygon layer to ensure distinct colors across layers
                    const polygonColor = getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color);
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: isContaining ? 3 : 2,
                      opacity: 0.8,
                      fillColor: polygonColor,
                      fillOpacity: isContaining ? 0.4 : 0.2
                    });

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${layerConfig.icon} ${featureName}${isContaining ? ' <span style="color: #16a34a;">(Contains Point)</span>' : ''}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance !== undefined && distance !== '' ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                          ${isContaining ? `<div style="color: #16a34a; font-weight: 600;">✓ Point is within this polygon</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['name', 'NAME', 'NAME1', 'NAME2', 'STATE_NAME', 'state_name', 'COUNTY_NAME', 'county_name', 'PLACE_NAME', 'place_name', 'DISTRICT', 'district', 'HUC', 'huc', 'REGION', 'region', 'SUBREGION', 'subregion', 'SUBBASIN', 'subbasin', 'INDEX', 'index', 'CELL_ID', 'cell_id', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'layerId', 'layerName', 'isContaining'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polygon.bindPopup(popupContent, { maxWidth: 400 });
                    polygon.addTo(primary);
                    bounds.extend(polygon.getBounds());
                    featureCount++;
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${layerConfig.title} feature:`, error);
              }
            });

            if (featureCount > 0) {
              const legendKey = layerConfig.key.replace('_all', '');
              
              // Get unique color for polygon layers to ensure distinct colors
              const uniqueColor = getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color);
              
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: layerConfig.icon,
                  color: uniqueColor,
                  title: layerConfig.title,
                  count: 0,
                };
              } else {
                // Update color to ensure it matches the rendered polygons
                legendAccumulator[legendKey].color = uniqueColor;
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`Error processing ${layerConfig.title}:`, error);
          }
        }
      });

      // Draw DC Urban Tree Canopy layers (polygons and points)
      const dcUtcLayerKeys = [
        'dc_utc_anc_2020_all', 'dc_utc_census_block_2020_all', 'dc_utc_census_block_group_2020_all',
        'dc_utc_2010_census_block_group_2020_all', 'dc_utc_dc_boundary_2020_all', 'dc_utc_dc_owned_property_2020_all',
        'dc_utc_generalized_ownership_parcel_2020_all', 'dc_utc_ownership_lot_2020_all', 'dc_utc_2019_right_of_way_2020_all',
        'dc_utc_single_member_district_2020_all', 'dc_utc_ward_2020_all', 'dc_utc_trees_all',
        'dc_utc_ownership_lot_2015_all', 'dc_utc_ward_2015_all', 'dc_utc_ufa_street_trees_all',
        'dc_utc_arborists_zone_all', 'dc_utc_anc_2015_all', 'dc_utc_census_block_group_2015_all',
        'dc_utc_census_block_2015_all', 'dc_utc_single_member_district_2015_all', 'dc_utc_2006_landuse_2015_all',
        'dc_utc_2011_landuse_2015_all', 'dc_utc_2015_landuse_2015_all'
      ];

      dcUtcLayerKeys.forEach((layerKey) => {
        const enrichmentKey = layerKey.replace('_all', '_all');
        if (enrichments[enrichmentKey] && Array.isArray(enrichments[enrichmentKey])) {
          try {
            // DC Trees (dc_utc_trees_all) is point-only, skip polygon drawing
            const isDCTrees = layerKey === 'dc_utc_trees_all';
            let featureCount = 0;
            enrichments[enrichmentKey].forEach((feature: any, index: number) => {
              const geometry = feature.geometry;
              if (!geometry) return;

              try {
                // Check if it's a polygon (has rings) or point (has x/y or points)
                // Skip polygon drawing for DC Trees as it's point-only
                if (geometry.rings && geometry.rings.length > 0 && !isDCTrees) {
                  // Draw polygon
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    if (!outerRing || outerRing.length < 3) return;

                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const isContaining = feature.isContaining || feature.distance_miles === 0;
                    const polygon = L.polygon(latlngs, {
                      color: isContaining ? '#16a34a' : '#22c55e',
                      weight: 2,
                      opacity: 0.7,
                      fillColor: isContaining ? '#16a34a' : '#22c55e',
                      fillOpacity: 0.3
                    });

                    // Build popup
                    const featureName = feature.NAME || feature.name || feature.OBJECTID || `Feature ${feature.objectid}`;
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🌳 ${featureName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['NAME', 'name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles', 'isContaining'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polygon.bindPopup(popupContent, { maxWidth: 400 });
                    polygon.addTo(primary);
                    bounds.extend(polygon.getBounds());
                    featureCount++;
                  }
                } else if (geometry.x !== undefined && geometry.y !== undefined) {
                  // Draw point
                  const pointLat = geometry.y;
                  const pointLon = geometry.x;
                  const isContaining = feature.isContaining || feature.distance_miles === 0;

                  const icon = createPOIIcon('🌳', isContaining ? '#16a34a' : '#22c55e');
                  const marker = L.marker([pointLat, pointLon], { icon });

                  const featureName = feature.NAME || feature.name || feature.OBJECTID || `Tree ${feature.objectid}`;
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌳 ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['NAME', 'name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles', 'isContaining'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });

                  popupContent += `</div></div>`;
                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                } else if (geometry.points && geometry.points.length > 0) {
                  // Draw multipoint (use first point)
                  const firstPoint = geometry.points[0];
                  const pointLat = firstPoint[1];
                  const pointLon = firstPoint[0];
                  const isContaining = feature.isContaining || feature.distance_miles === 0;

                  const icon = createPOIIcon('🌳', isContaining ? '#16a34a' : '#22c55e');
                  const marker = L.marker([pointLat, pointLon], { icon });

                  const featureName = feature.NAME || feature.name || feature.OBJECTID || `Tree ${feature.objectid}`;
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🌳 ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['NAME', 'name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles', 'isContaining'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });

                  popupContent += `</div></div>`;
                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                }
              } catch (error) {
                console.error(`❌ Error drawing DC Urban Tree Canopy feature ${index}:`, error);
              }
            });

            if (featureCount > 0) {
              // Use unique legend key for each DC layer based on the enrichment key
              // Map enrichment key (dc_utc_*) to POI config ID (dc_urban_tree_canopy_*)
              const layerKeyMap: Record<string, string> = {
                'dc_utc_anc_2020_all': 'dc_urban_tree_canopy_anc_2020',
                'dc_utc_census_block_2020_all': 'dc_urban_tree_canopy_census_block_2020',
                'dc_utc_census_block_group_2020_all': 'dc_urban_tree_canopy_census_block_group_2020',
                'dc_utc_2010_census_block_group_2020_all': 'dc_urban_tree_canopy_2010_census_block_group_2020',
                'dc_utc_dc_boundary_2020_all': 'dc_urban_tree_canopy_dc_boundary_2020',
                'dc_utc_dc_owned_property_2020_all': 'dc_urban_tree_canopy_dc_owned_property_2020',
                'dc_utc_generalized_ownership_parcel_2020_all': 'dc_urban_tree_canopy_generalized_ownership_parcel_2020',
                'dc_utc_ownership_lot_2020_all': 'dc_urban_tree_canopy_ownership_lot_2020',
                'dc_utc_2019_right_of_way_2020_all': 'dc_urban_tree_canopy_2019_right_of_way_2020',
                'dc_utc_single_member_district_2020_all': 'dc_urban_tree_canopy_single_member_district_2020',
                'dc_utc_ward_2020_all': 'dc_urban_tree_canopy_ward_2020',
                'dc_utc_trees_all': 'dc_trees',
                'dc_utc_ownership_lot_2015_all': 'dc_urban_tree_canopy_ownership_lot_2015',
                'dc_utc_ward_2015_all': 'dc_urban_tree_canopy_ward_2015',
                'dc_utc_ufa_street_trees_all': 'dc_ufa_street_trees',
                'dc_utc_arborists_zone_all': 'dc_arborists_zone',
                'dc_utc_anc_2015_all': 'dc_urban_tree_canopy_anc_2015',
                'dc_utc_census_block_group_2015_all': 'dc_urban_tree_canopy_census_block_group_2015',
                'dc_utc_census_block_2015_all': 'dc_urban_tree_canopy_census_block_2015',
                'dc_utc_single_member_district_2015_all': 'dc_urban_tree_canopy_single_member_district_2015',
                'dc_utc_2006_landuse_2015_all': 'dc_urban_tree_canopy_2006_landuse_2015',
                'dc_utc_2011_landuse_2015_all': 'dc_urban_tree_canopy_2011_landuse_2015',
                'dc_utc_2015_landuse_2015_all': 'dc_urban_tree_canopy_2015_landuse_2015',
              };
              
              const legendKey = layerKeyMap[layerKey] || layerKey.replace('_all', '');
              const poiInfo = POI_ICONS[legendKey];
              const layerTitle = poiInfo?.title || poiConfigManager.getPOIType(legendKey)?.label || legendKey.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
              
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: poiInfo?.icon || '🌳',
                  color: poiInfo?.color || '#22c55e',
                  title: layerTitle,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`❌ Error processing DC Urban Tree Canopy ${layerKey}:`, error);
          }
        }
      });

      // Draw DC Bike Trails layers (polylines and points)
      const dcBikeLayerKeys = [
        'dc_bike_trail_mile_marker_all',
        'dc_bike_planned_multi_use_trails_all',
        'dc_bike_bicycle_lanes_all',
        'dc_bike_bike_trails_all',
        'dc_bike_capital_bike_share_locations_all',
        'dc_bike_signed_bike_routes_all',
        'dc_bike_nps_trails_all',
        'dc_bike_public_bike_racks_all'
      ];

      dcBikeLayerKeys.forEach((layerKey) => {
        if (enrichments[layerKey] && Array.isArray(enrichments[layerKey])) {
          try {
            const layerIdMap: Record<string, string> = {
              'dc_bike_trail_mile_marker_all': 'dc_trail_mile_marker',
              'dc_bike_planned_multi_use_trails_all': 'dc_planned_multi_use_trails',
              'dc_bike_bicycle_lanes_all': 'dc_bicycle_lanes',
              'dc_bike_bike_trails_all': 'dc_bike_trails',
              'dc_bike_capital_bike_share_locations_all': 'dc_capital_bike_share_locations',
              'dc_bike_signed_bike_routes_all': 'dc_signed_bike_routes',
              'dc_bike_nps_trails_all': 'dc_nps_trails',
              'dc_bike_public_bike_racks_all': 'dc_public_bike_racks',
            };
            const legendKey = layerIdMap[layerKey];
            const poiInfo = POI_ICONS[legendKey];
            const iconEmoji = poiInfo?.icon || '🚴';
            const defaultColor = poiInfo?.color || '#3b82f6';
            let featureCount = 0;

            enrichments[layerKey].forEach((feature: any, index: number) => {
              const geometry = feature.geometry;
              if (!geometry) {
                console.warn(`⚠️ DC Bike Trails ${layerKey}: Feature ${index} has no geometry`);
                return;
              }

              try {
                // Check if it's a polyline (has paths) or point (has x/y or points)
                if (geometry.paths && geometry.paths.length > 0) {
                  // Draw polyline
                  const paths = geometry.paths;
                  if (paths && paths.length > 0) {
                    featureCount++; // Count each feature once
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);

                      const featureName = feature.NAME || feature.name || feature.ROUTE_NAME || feature.route_name || `Feature ${feature.objectid}`;
                      const distanceMiles = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                      const polyline = L.polyline(latlngs, {
                        color: defaultColor,
                        weight: 4,
                        opacity: 0.8,
                        smoothFactor: 1
                      });

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${iconEmoji} ${featureName}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${distanceMiles ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;

                      const excludeFields = ['NAME', 'name', 'ROUTE_NAME', 'route_name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles'];
                      Object.entries(feature).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) return;
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      popupContent += `</div></div>`;

                      polyline.bindPopup(popupContent, { maxWidth: 400 });
                      polyline.addTo(primary);
                      bounds.extend(polyline.getBounds());
                    });
                  }
                } else if (geometry.x !== undefined && geometry.y !== undefined) {
                  // Draw point
                  const pointLat = geometry.y;
                  const pointLon = geometry.x;
                  if (isNaN(pointLat) || isNaN(pointLon)) {
                    console.warn(`⚠️ DC Bike Trails ${layerKey}: Feature ${index} has invalid point coordinates`);
                    return;
                  }
                  const marker = L.marker([pointLat, pointLon], { icon: createPOIIcon(iconEmoji, defaultColor) });

                  const featureName = feature.NAME || feature.name || feature.LOCATION || feature.location || `Feature ${feature.objectid}`;
                  const distanceMiles = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${iconEmoji} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distanceMiles ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['NAME', 'name', 'LOCATION', 'location', 'geometry', 'objectid', 'OBJECTID', 'distance_miles'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  popupContent += `</div></div>`;

                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                } else if (geometry.points && geometry.points.length > 0) {
                  // Draw multipoint (use first point)
                  const firstPoint = geometry.points[0];
                  if (!firstPoint || firstPoint.length < 2) {
                    console.warn(`⚠️ DC Bike Trails ${layerKey}: Feature ${index} has invalid multipoint coordinates`);
                    return;
                  }
                  const pointLat = firstPoint[1];
                  const pointLon = firstPoint[0];
                  if (isNaN(pointLat) || isNaN(pointLon)) {
                    console.warn(`⚠️ DC Bike Trails ${layerKey}: Feature ${index} has invalid multipoint coordinates`);
                    return;
                  }
                  const marker = L.marker([pointLat, pointLon], { icon: createPOIIcon(iconEmoji, defaultColor) });

                  const featureName = feature.NAME || feature.name || feature.LOCATION || feature.location || `Feature ${feature.objectid}`;
                  const distanceMiles = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${iconEmoji} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distanceMiles ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['NAME', 'name', 'LOCATION', 'location', 'geometry', 'objectid', 'OBJECTID', 'distance_miles'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  popupContent += `</div></div>`;

                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                } else {
                  console.warn(`⚠️ DC Bike Trails ${layerKey}: Feature ${index} has unrecognized geometry type:`, {
                    hasPaths: !!geometry.paths,
                    hasX: geometry.x !== undefined,
                    hasY: geometry.y !== undefined,
                    hasPoints: !!geometry.points,
                    geometryType: geometry.type || 'unknown'
                  });
                }
              } catch (error) {
                console.error(`❌ Error drawing DC Bike Trails feature ${index}:`, error);
              }
            });

            if (featureCount > 0) {
              console.log(`✅ DC Bike Trails ${layerKey}: Drawing ${featureCount} features, legendKey: ${legendKey}`);
              if (!legendAccumulator[legendKey]) {
                const layerTitle = poiInfo?.title || poiConfigManager.getPOIType(legendKey)?.label || legendKey.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                console.log(`📝 Creating legend entry for ${legendKey}: ${layerTitle}`);
                legendAccumulator[legendKey] = {
                  icon: iconEmoji,
                  color: defaultColor,
                  title: layerTitle,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
              console.log(`📊 Updated legend count for ${legendKey}: ${legendAccumulator[legendKey].count}`);
            } else {
              console.warn(`⚠️ DC Bike Trails ${layerKey}: No features drawn (featureCount: ${featureCount}), legendKey: ${legendKey}`);
            }
          } catch (error) {
            console.error(`❌ Error processing DC Bike Trails ${layerKey}:`, error);
          }
        }
      });

      // Draw DC Property and Land layers (polygons, polylines, and points)
      // Create a mapping of all DC Property and Land enrichment keys to their layer info
      const dcPropertyLayerMap: Record<string, { layerId: number; layerName: string; legendKey: string }> = {
        'dc_property_air_rights_lot_points_all': { layerId: 0, layerName: 'Air Rights Lot Points', legendKey: 'dc_property_air_rights_lot_points' },
        'dc_property_alley_frontage_lines_all': { layerId: 1, layerName: 'Alley Frontage Lines', legendKey: 'dc_property_alley_frontage_lines' },
        'dc_property_air_rights_lots_historical_all': { layerId: 2, layerName: 'Air Rights Lots (Historical)', legendKey: 'dc_property_air_rights_lots_historical' },
        'dc_property_air_rights_lots_all': { layerId: 3, layerName: 'Air Rights Lots', legendKey: 'dc_property_air_rights_lots' },
        'dc_property_appropriation_points_all': { layerId: 4, layerName: 'Appropriation Points', legendKey: 'dc_property_appropriation_points' },
        'dc_property_appropriations_all': { layerId: 5, layerName: 'Appropriations', legendKey: 'dc_property_appropriations' },
        'dc_property_assessment_neighborhoods_all': { layerId: 6, layerName: 'Assessment Neighborhoods', legendKey: 'dc_property_assessment_neighborhoods' },
        'dc_property_assessment_sub_neighborhoods_all': { layerId: 7, layerName: 'Assessment Sub-Neighborhoods', legendKey: 'dc_property_assessment_sub_neighborhoods' },
        'dc_property_district_land_points_all': { layerId: 8, layerName: 'District Land Points', legendKey: 'dc_property_district_land_points' },
        'dc_property_building_restriction_lines_all': { layerId: 9, layerName: 'Building Restriction Lines', legendKey: 'dc_property_building_restriction_lines' },
        'dc_property_certificate_of_occupancy_points_all': { layerId: 10, layerName: 'Certificate Of Occupancy Points', legendKey: 'dc_property_certificate_of_occupancy_points' },
        'dc_property_military_bases_all': { layerId: 11, layerName: 'Military Bases', legendKey: 'dc_property_military_bases' },
        'dc_property_parcel_lot_points_all': { layerId: 18, layerName: 'Parcel Lot Points', legendKey: 'dc_property_parcel_lot_points' },
        'dc_property_record_lot_points_all': { layerId: 19, layerName: 'Record Lot Points', legendKey: 'dc_property_record_lot_points' },
        'dc_property_reservations_points_all': { layerId: 20, layerName: 'Reservations Points', legendKey: 'dc_property_reservations_points' },
        'dc_property_square_points_all': { layerId: 21, layerName: 'Square Points', legendKey: 'dc_property_square_points' },
        'dc_property_tax_lot_points_all': { layerId: 22, layerName: 'Tax Lot Points', legendKey: 'dc_property_tax_lot_points' },
        'dc_property_highway_plan_lines_all': { layerId: 29, layerName: 'Highway Plan Lines', legendKey: 'dc_property_highway_plan_lines' },
        'dc_property_parcel_lots_historical_all': { layerId: 32, layerName: 'Parcel Lots (Historical)', legendKey: 'dc_property_parcel_lots_historical' },
        'dc_property_parcel_lots_all': { layerId: 33, layerName: 'Parcel Lots', legendKey: 'dc_property_parcel_lots' },
        'dc_property_record_lots_historical_all': { layerId: 34, layerName: 'Record Lots (Historical)', legendKey: 'dc_property_record_lots_historical' },
        'dc_property_record_lots_all': { layerId: 35, layerName: 'Record Lots', legendKey: 'dc_property_record_lots' },
        'dc_property_reservations_historical_all': { layerId: 36, layerName: 'Reservations (Historical)', legendKey: 'dc_property_reservations_historical' },
        'dc_property_reservations_all': { layerId: 37, layerName: 'Reservations', legendKey: 'dc_property_reservations' },
        'dc_property_tax_lots_historical_all': { layerId: 38, layerName: 'Tax Lots (Historical)', legendKey: 'dc_property_tax_lots_historical' },
        'dc_property_tax_lots_all': { layerId: 39, layerName: 'Tax Lots', legendKey: 'dc_property_tax_lots' },
        'dc_property_owner_polygons_all': { layerId: 40, layerName: 'Owner Polygons (Common Ownership Layer)', legendKey: 'dc_property_owner_polygons' },
        'dc_property_square_boundaries_all': { layerId: 41, layerName: 'Square Boundaries', legendKey: 'dc_property_square_boundaries' },
        'dc_property_boundary_stones_location_all': { layerId: 42, layerName: 'Boundary Stones Location', legendKey: 'dc_property_boundary_stones_location' },
        'dc_property_condo_approval_lots_all': { layerId: 44, layerName: 'Condo Approval Lots', legendKey: 'dc_property_condo_approval_lots' },
        'dc_property_public_easement_lines_all': { layerId: 48, layerName: 'Public Easement Lines', legendKey: 'dc_property_public_easement_lines' },
        'dc_property_district_land_rpta_ownership_all': { layerId: 49, layerName: 'District Land (RPTA Ownership)', legendKey: 'dc_property_district_land_rpta_ownership' },
        'dc_property_federal_land_rpta_ownership_all': { layerId: 50, layerName: 'Federal Land (RPTA Ownership)', legendKey: 'dc_property_federal_land_rpta_ownership' },
        'dc_property_owner_lines_dimensions_all': { layerId: 51, layerName: 'Owner Lines (Dimensions)', legendKey: 'dc_property_owner_lines_dimensions' },
        'dc_property_district_land_all': { layerId: 61, layerName: 'District Land', legendKey: 'dc_property_district_land' },
        'dc_property_affordable_housing_all': { layerId: 62, layerName: 'Affordable Housing', legendKey: 'dc_property_affordable_housing' },
        'dc_property_real_estate_portfolio_all': { layerId: 63, layerName: 'Real Estate Portfolio', legendKey: 'dc_property_real_estate_portfolio' },
        'dc_property_district_land_lines_dimensions_all': { layerId: 73, layerName: 'District Land Lines (Dimensions)', legendKey: 'dc_property_district_land_lines_dimensions' },
        'dc_property_wdcep_development_point_all': { layerId: 74, layerName: 'WDCEP Development Point', legendKey: 'dc_property_wdcep_development_point' },
        'dc_property_alley_and_street_changes_all': { layerId: 75, layerName: 'Alley and Street Changes', legendKey: 'dc_property_alley_and_street_changes' },
        'dc_property_district_structures_all': { layerId: 77, layerName: 'District Structures', legendKey: 'dc_property_district_structures' },
        'dc_property_land_boundary_changes_all': { layerId: 78, layerName: 'Land Boundary Changes', legendKey: 'dc_property_land_boundary_changes' },
        'dc_property_alley_street_changes_dimensions_all': { layerId: 79, layerName: 'Alley Street Changes (Dimensions)', legendKey: 'dc_property_alley_street_changes_dimensions' },
        'dc_property_vacant_and_blighted_building_footprints_all': { layerId: 81, layerName: 'Vacant and Blighted Building Footprints', legendKey: 'dc_property_vacant_and_blighted_building_footprints' },
        'dc_property_vacant_and_blighted_building_addresses_all': { layerId: 82, layerName: 'Vacant and Blighted Building Addresses', legendKey: 'dc_property_vacant_and_blighted_building_addresses' },
      };

      Object.keys(dcPropertyLayerMap).forEach((enrichmentKey) => {
        if (enrichments[enrichmentKey] && Array.isArray(enrichments[enrichmentKey])) {
          try {
            const layerInfo = dcPropertyLayerMap[enrichmentKey];
            const legendKey = layerInfo.legendKey;
            const poiInfo = POI_ICONS[legendKey];
            const iconEmoji = poiInfo?.icon || '🏢';
            const defaultColor = poiInfo?.color || '#3b82f6';
            let featureCount = 0;

            enrichments[enrichmentKey].forEach((feature: any, index: number) => {
              const geometry = feature.geometry;
              if (!geometry) return;

              try {
                // Determine geometry type from layer name
                const isPointLayer = layerInfo.layerName.toLowerCase().endsWith('points');
                const isLineLayer = layerInfo.layerName.toLowerCase().endsWith('lines');
                const isPolygonLayer = !isPointLayer && !isLineLayer;

                if (isPolygonLayer && geometry.rings && geometry.rings.length > 0) {
                  // Draw polygon
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    if (!outerRing || outerRing.length < 3) return;

                    const latlngs = outerRing.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);

                    const isContaining = feature.isContaining || feature.distance_miles === 0;
                    const polygon = L.polygon(latlngs, {
                      color: isContaining ? '#16a34a' : defaultColor,
                      weight: 2,
                      opacity: 0.7,
                      fillColor: isContaining ? '#16a34a' : defaultColor,
                      fillOpacity: 0.3
                    });

                    const featureName = feature.NAME || feature.name || feature.OBJECTID || `Feature ${feature.objectid}`;
                    const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${iconEmoji} ${featureName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;

                    const excludeFields = ['NAME', 'name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles', 'isContaining'];
                    Object.entries(feature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) return;
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });

                    popupContent += `</div></div>`;
                    polygon.bindPopup(popupContent, { maxWidth: 400 });
                    polygon.addTo(primary);
                    bounds.extend(polygon.getBounds());
                    featureCount++;
                  }
                } else if (isLineLayer && geometry.paths && geometry.paths.length > 0) {
                  // Draw polyline
                  const paths = geometry.paths;
                  if (paths && paths.length > 0) {
                    featureCount++;
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => [coord[1], coord[0]] as [number, number]);

                      const featureName = feature.NAME || feature.name || feature.ROUTE_NAME || feature.route_name || `Feature ${feature.objectid}`;
                      const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                      const polyline = L.polyline(latlngs, {
                        color: defaultColor,
                        weight: 4,
                        opacity: 0.8,
                        smoothFactor: 1
                      });

                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${iconEmoji} ${featureName}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;

                      const excludeFields = ['NAME', 'name', 'ROUTE_NAME', 'route_name', 'geometry', 'objectid', 'OBJECTID', 'distance_miles'];
                      Object.entries(feature).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) return;
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      popupContent += `</div></div>`;

                      polyline.bindPopup(popupContent, { maxWidth: 400 });
                      polyline.addTo(primary);
                      bounds.extend(polyline.getBounds());
                    });
                  }
                } else if (isPointLayer && (geometry.x !== undefined && geometry.y !== undefined || geometry.points && geometry.points.length > 0)) {
                  // Draw point
                  let pointLat: number;
                  let pointLon: number;

                  if (geometry.x !== undefined && geometry.y !== undefined) {
                    pointLat = geometry.y;
                    pointLon = geometry.x;
                  } else if (geometry.points && geometry.points.length > 0) {
                    const firstPoint = geometry.points[0];
                    pointLat = firstPoint[1];
                    pointLon = firstPoint[0];
                  } else {
                    return;
                  }

                  const marker = L.marker([pointLat, pointLon], { icon: createPOIIcon(iconEmoji, defaultColor) });

                  const featureName = feature.NAME || feature.name || feature.LOCATION || feature.location || `Feature ${feature.objectid}`;
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${iconEmoji} ${featureName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['NAME', 'name', 'LOCATION', 'location', 'geometry', 'objectid', 'OBJECTID', 'distance_miles'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  popupContent += `</div></div>`;

                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend(marker.getLatLng());
                  featureCount++;
                }
              } catch (error) {
                console.error(`❌ Error drawing DC Property and Land feature ${index}:`, error);
              }
            });

            if (featureCount > 0) {
              if (!legendAccumulator[legendKey]) {
                const layerTitle = poiInfo?.title || poiConfigManager.getPOIType(legendKey)?.label || layerInfo.layerName;
                legendAccumulator[legendKey] = {
                  icon: iconEmoji,
                  color: defaultColor,
                  title: layerTitle,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`❌ Error processing DC Property and Land ${enrichmentKey}:`, error);
          }
        }
      });

      // Draw Hurricane Evacuation Routes (Natural Hazards) as polylines on the map
      if (enrichments.hurricane_evacuation_routes_hazards_all && Array.isArray(enrichments.hurricane_evacuation_routes_hazards_all)) {
        try {
          let routeCount = 0;
          enrichments.hurricane_evacuation_routes_hazards_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                // ESRI polylines have paths (array of coordinate arrays)
                const paths = route.geometry.paths;
                if (paths && paths.length > 0) {
                  routeCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = route.NAME || route.name || route.ROUTE_NAME || route.route_name || 'Unknown Route';
                    const routeType = route.TYPE || route.type || route.ROUTE_TYPE || route.route_type || 'Evacuation Route';
                    const distanceMiles = route.distance_miles !== undefined ? route.distance_miles.toFixed(2) : '';

                    // Create polyline with orange/red color for evacuation routes
                    const polyline = L.polyline(latlngs, {
                      color: '#f97316', // Orange color for evacuation routes
                      weight: 5,
                      opacity: 0.9,
                      smoothFactor: 1
                    });

                    // Build popup content with all route attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🌀 ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${routeType ? `<div><strong>Type:</strong> ${routeType}</div>` : ''}
                          ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all route attributes (excluding internal fields)
                    const excludeFields = ['NAME', 'name', 'ROUTE_NAME', 'route_name', 'TYPE', 'type', 'ROUTE_TYPE', 'route_type', 'geometry', 'routeId', 'distance_miles', 'OBJECTID', 'objectid'];
                    Object.entries(route).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(primary);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing Hurricane Evacuation Route (Natural Hazards) polyline:', error);
              }
            }
          });
          
          if (routeCount > 0) {
            if (!legendAccumulator['hurricane_evacuation_routes_hazards']) {
              legendAccumulator['hurricane_evacuation_routes_hazards'] = {
                icon: '🌀',
                color: '#f97316',
                title: 'Hurricane Evacuation Routes',
                count: 0,
              };
            }
            legendAccumulator['hurricane_evacuation_routes_hazards'].count += routeCount;
          }
        } catch (error) {
          console.error('Error processing Hurricane Evacuation Routes (Natural Hazards):', error);
        }
      }

      // Draw TNM Structures
      if (enrichments.tnm_structures_all && Array.isArray(enrichments.tnm_structures_all)) {
        try {
          let structureCount = 0;
          enrichments.tnm_structures_all.forEach((structure: any) => {
            try {
              let structureLat: number | null = null;
              let structureLon: number | null = null;
              
              // Extract coordinates from geometry (multipoint or single point)
              if (structure.geometry) {
                if (structure.geometry.points && structure.geometry.points.length > 0) {
                  // Multipoint geometry - use first point
                  const firstPoint = structure.geometry.points[0];
                  structureLon = firstPoint[0];
                  structureLat = firstPoint[1];
                } else if (structure.geometry.x !== undefined && structure.geometry.y !== undefined) {
                  // Single point geometry
                  structureLon = structure.geometry.x;
                  structureLat = structure.geometry.y;
                }
              }
              
              // Fallback to attributes if geometry not available
              if (structureLat === null || structureLon === null) {
                return;
              }
              
              const structureName = structure.NAME || structure.name || structure.STRUCTURE_NAME || structure.structure_name || 'Unknown Structure';
              const structureType = structure.TYPE || structure.type || structure.STRUCTURE_TYPE || structure.structure_type || structure.FUNCTION || structure.function || 'Unknown';
              const distanceMiles = structure.distance_miles !== undefined ? structure.distance_miles.toFixed(2) : '';
              
              // Choose icon based on structure type
              let icon = '🏢'; // Default icon
              let iconColor = '#3b82f6'; // Default color
              
              const typeLower = structureType.toLowerCase();
              if (typeLower.includes('school') || typeLower.includes('college') || typeLower.includes('university')) {
                icon = '🏫';
                iconColor = '#10b981';
              } else if (typeLower.includes('fire') || typeLower.includes('ems')) {
                icon = '🚒';
                iconColor = '#dc2626';
              } else if (typeLower.includes('police') || typeLower.includes('law enforcement')) {
                icon = '🚔';
                iconColor = '#1f2937';
              } else if (typeLower.includes('hospital') || typeLower.includes('medical')) {
                icon = '🏥';
                iconColor = '#f97316';
              } else if (typeLower.includes('cemetery')) {
                icon = '🪦';
                iconColor = '#64748b';
              } else if (typeLower.includes('post office')) {
                icon = '📮';
                iconColor = '#3b82f6';
              } else if (typeLower.includes('campground')) {
                icon = '🏕️';
                iconColor = '#059669';
              } else if (typeLower.includes('trailhead')) {
                icon = '🥾';
                iconColor = '#059669';
              } else if (typeLower.includes('visitor') || typeLower.includes('information')) {
                icon = 'ℹ️';
                iconColor = '#06b6d4';
              } else if (typeLower.includes('capitol')) {
                icon = '🏛️';
                iconColor = '#8b5cf6';
              } else if (typeLower.includes('prison') || typeLower.includes('correctional')) {
                icon = '🏛️';
                iconColor = '#64748b';
              } else if (typeLower.includes('ambulance')) {
                icon = '🚑';
                iconColor = '#ef4444';
              }
              
              // Create a custom icon for structures
              const customIcon = createPOIIcon(icon, iconColor);
              
              const marker = L.marker([structureLat, structureLon], { icon: customIcon });
              
              // Build popup content
              let popupContent = `
                <div style="min-width: 250px; max-width: 400px;">
                  <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                    ${icon} ${structureName}
                  </h3>
                  <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                    ${structureType ? `<div><strong>Type:</strong> ${structureType}</div>` : ''}
                    ${distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                  </div>
                  <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
              `;
              
              // Add all attributes (excluding internal fields)
              const excludeFields = ['NAME', 'name', 'STRUCTURE_NAME', 'structure_name', 'TYPE', 'type', 'STRUCTURE_TYPE', 'structure_type', 'FUNCTION', 'function', 'geometry', 'structureId', 'distance_miles', 'OBJECTID', 'objectid'];
              Object.entries(structure).forEach(([key, value]) => {
                if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                  if (typeof value === 'object' && !Array.isArray(value)) {
                    return;
                  }
                  const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                  popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                }
              });
              
              popupContent += `
                  </div>
                </div>
              `;
              
              marker.bindPopup(popupContent);
              marker.addTo(primary);
              const structureBounds = L.latLngBounds([[structureLat, structureLon]]);
              bounds.extend(structureBounds);
              structureCount++;
            } catch (error) {
              console.error('Error drawing TNM Structure:', error);
            }
          });
          
          if (structureCount > 0) {
            if (!legendAccumulator['tnm_structures']) {
              legendAccumulator['tnm_structures'] = {
                icon: '🏢',
                color: '#3b82f6',
                title: 'TNM Structures',
                count: 0,
              };
            }
            legendAccumulator['tnm_structures'].count += structureCount;
          }
        } catch (error) {
          console.error('Error processing TNM Structures:', error);
        }
      }

      // Draw USGS Government Units layers
      const usgsGovUnitsLayers = [
        { key: 'usgs_gov_incorporated_place_all', layerId: 19, icon: '🏛️', color: '#3b82f6', title: 'USGS Incorporated Place' },
        { key: 'usgs_gov_unincorporated_place_all', layerId: 20, icon: '🏘️', color: '#2563eb', title: 'USGS Unincorporated Place' },
        { key: 'usgs_gov_minor_civil_division_all', layerId: 21, icon: '🏘️', color: '#1d4ed8', title: 'USGS Minor Civil Division' },
        { key: 'usgs_gov_native_american_area_all', layerId: 22, icon: '🏕️', color: '#1e40af', title: 'USGS Native American Area' },
        { key: 'usgs_gov_national_park_all', layerId: 23, icon: '🏞️', color: '#059669', title: 'USGS National Park' },
        { key: 'usgs_gov_national_forest_all', layerId: 24, icon: '🌲', color: '#047857', title: 'USGS National Forest' },
        { key: 'usgs_gov_national_wilderness_all', layerId: 25, icon: '⛰️', color: '#065f46', title: 'USGS National Wilderness' },
        { key: 'usgs_gov_fish_wildlife_service_all', layerId: 26, icon: '🦅', color: '#0d9488', title: 'USGS US Fish & Wildlife Service' },
        { key: 'usgs_gov_national_grassland_all', layerId: 27, icon: '🌾', color: '#84cc16', title: 'USGS National Grassland' },
        { key: 'usgs_gov_national_cemetery_all', layerId: 28, icon: '🪦', color: '#64748b', title: 'USGS National Cemetery' },
        { key: 'usgs_gov_military_reserve_all', layerId: 29, icon: '🎖️', color: '#dc2626', title: 'USGS Military Reserve' },
        { key: 'usgs_gov_nasa_facility_all', layerId: 30, icon: '🚀', color: '#7c3aed', title: 'USGS NASA Facility' },
        { key: 'usgs_gov_met_washington_airport_all', layerId: 31, icon: '✈️', color: '#6366f1', title: 'USGS Met. Washington Airport' },
        { key: 'usgs_gov_tennessee_valley_authority_all', layerId: 32, icon: '⚡', color: '#f59e0b', title: 'USGS Tennessee Valley Authority' },
        { key: 'usgs_gov_bureau_land_management_all', layerId: 33, icon: '🌵', color: '#d97706', title: 'USGS Bureau of Land Management' },
        { key: 'usgs_gov_congressional_district_all', layerId: 34, icon: '🗳️', color: '#8b5cf6', title: 'USGS Congressional District' },
        { key: 'usgs_gov_county_equivalent_all', layerId: 35, icon: '🗺️', color: '#3b82f6', title: 'USGS County or Equivalent' },
        { key: 'usgs_gov_state_territory_small_scale_all', layerId: 36, icon: '🗺️', color: '#2563eb', title: 'USGS State or Territory (Small-Scale)' },
        { key: 'usgs_gov_state_territory_large_scale_all', layerId: 37, icon: '🗺️', color: '#1d4ed8', title: 'USGS State or Territory (Large-Scale)' }
      ];
      
      usgsGovUnitsLayers.forEach(({ key, icon, color, title }) => {
        if (enrichments[key] && Array.isArray(enrichments[key])) {
          try {
            let featureCount = 0;
            enrichments[key].forEach((unit: any) => {
              if (unit.geometry && unit.geometry.rings) {
                try {
                  const rings = unit.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    const isContaining = unit.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const unitName = unit.NAME || unit.name || unit.FULL_NAME || unit.full_name || unit.unitId || 'Unknown';
                    const distanceMiles = unit.distance_miles !== undefined ? unit.distance_miles.toFixed(2) : null;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${unitName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this ${title.toLowerCase()}</div>` : distanceMiles ? `<div style="color: #d97706; font-weight: 600; margin-top: 8px;">📍 Distance: ${distanceMiles} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['unitId', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'isContaining', 'distance_miles', 'NAME', 'name', 'FULL_NAME', 'full_name'];
                    Object.entries(unit).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          } catch (error) {
            console.error(`Error processing ${title}:`, error);
          }
        }
      });

      // Draw LA County Hydrology layers
      const laCountyHydrologyLayers = [
        { key: 'la_county_hydrology_complete_all', layerId: 0, icon: '💧', color: '#0ea5e9', title: 'LA County Hydrology (Complete)', isPoint: false },
        { key: 'la_county_hydrology_lakes_all', layerId: 2, icon: '🏞️', color: '#0284c7', title: 'LA County Lakes', isPoint: false },
        { key: 'la_county_hydrology_streams_rivers_all', layerId: 3, icon: '🌊', color: '#0369a1', title: 'LA County Streams and Rivers', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_watershed_boundaries_all', layerId: 4, icon: '🗺️', color: '#075985', title: 'LA County Watershed Boundaries', isPoint: false },
        { key: 'la_county_hydrology_wbd_hu12_all', layerId: 5, icon: '🗺️', color: '#0c4a6e', title: 'LA County WBD HU12', isPoint: false },
        { key: 'la_county_hydrology_wbd_hu10_all', layerId: 6, icon: '🗺️', color: '#082f49', title: 'LA County WBD HU10', isPoint: false },
        { key: 'la_county_hydrology_wbd_hu8_all', layerId: 7, icon: '🗺️', color: '#164e63', title: 'LA County WBD HU8', isPoint: false },
        { key: 'la_county_hydrology_simpler_all', layerId: 8, icon: '💧', color: '#0891b2', title: 'LA County Hydrology (Simpler)', isPoint: false },
        { key: 'la_county_hydrology_lakes_simpler_all', layerId: 9, icon: '🏞️', color: '#0e7490', title: 'LA County Lakes (Simpler)', isPoint: false },
        { key: 'la_county_hydrology_nhd_streams_all', layerId: 10, icon: '🌊', color: '#155e75', title: 'LA County NHD Streams', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_storm_drain_network_all', layerId: 11, icon: '🌧️', color: '#164e63', title: 'LA County Storm Drain Network', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_inlets_outlets_all', layerId: 12, icon: '🚰', color: '#1e40af', title: 'LA County Inlets/Outlets', isPoint: true },
        { key: 'la_county_hydrology_maintenance_holes_all', layerId: 13, icon: '🕳️', color: '#1e3a8a', title: 'LA County Maintenance Holes', isPoint: true },
        { key: 'la_county_hydrology_maintenance_holes_lacfcd_all', layerId: 14, icon: '🕳️', color: '#1e3a8a', title: 'LA County Maintenance Holes (LACFCD)', isPoint: true },
        { key: 'la_county_hydrology_maintenance_holes_city_all', layerId: 15, icon: '🕳️', color: '#1e3a8a', title: 'LA County Maintenance Holes (City)', isPoint: true },
        { key: 'la_county_hydrology_maintenance_holes_unknown_all', layerId: 16, icon: '🕳️', color: '#1e3a8a', title: 'LA County Maintenance Holes (Unknown)', isPoint: true },
        { key: 'la_county_hydrology_basins_all', layerId: 17, icon: '🏗️', color: '#2563eb', title: 'LA County Basins', isPoint: false },
        { key: 'la_county_hydrology_debris_basins_lacfcd_all', layerId: 18, icon: '🏗️', color: '#2563eb', title: 'LA County Debris Basins (LACFCD)', isPoint: false },
        { key: 'la_county_hydrology_debris_basins_city_all', layerId: 19, icon: '🏗️', color: '#2563eb', title: 'LA County Debris Basins (City)', isPoint: false },
        { key: 'la_county_hydrology_debris_basins_caltrans_all', layerId: 20, icon: '🏗️', color: '#2563eb', title: 'LA County Debris Basins (Caltrans)', isPoint: false },
        { key: 'la_county_hydrology_debris_basins_unknown_all', layerId: 21, icon: '🏗️', color: '#2563eb', title: 'LA County Debris Basins (Unknown)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_all', layerId: 22, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_lacfcd_all', layerId: 23, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (LACFCD)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_city_all', layerId: 24, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (City)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_rmd_all', layerId: 25, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (RMD)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_others_all', layerId: 26, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (Others)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_caltrans_all', layerId: 27, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (Caltrans)', isPoint: false },
        { key: 'la_county_hydrology_catch_basins_unknown_all', layerId: 28, icon: '🏗️', color: '#3b82f6', title: 'LA County Catch Basins (Unknown)', isPoint: false },
        { key: 'la_county_hydrology_low_flow_diversion_all', layerId: 29, icon: '🌊', color: '#60a5fa', title: 'LA County Low Flow Diversion', isPoint: false },
        { key: 'la_county_hydrology_lfd_lacfcd_all', layerId: 30, icon: '🌊', color: '#60a5fa', title: 'LA County LFD (LACFCD)', isPoint: false },
        { key: 'la_county_hydrology_lfd_city_all', layerId: 31, icon: '🌊', color: '#60a5fa', title: 'LA County LFD (City)', isPoint: false },
        { key: 'la_county_hydrology_lfd_unknown_all', layerId: 32, icon: '🌊', color: '#60a5fa', title: 'LA County LFD (Unknown)', isPoint: false },
        { key: 'la_county_hydrology_pump_stations_all', layerId: 33, icon: '⚙️', color: '#93c5fd', title: 'LA County Pump Stations', isPoint: true },
        { key: 'la_county_hydrology_pump_stations_completed_all', layerId: 34, icon: '⚙️', color: '#93c5fd', title: 'LA County Pump Stations (Completed)', isPoint: true },
        { key: 'la_county_hydrology_pump_stations_city_la_all', layerId: 35, icon: '⚙️', color: '#93c5fd', title: 'LA County Pump Stations (City of LA)', isPoint: true },
        { key: 'la_county_hydrology_pump_stations_investigate_all', layerId: 36, icon: '⚙️', color: '#93c5fd', title: 'LA County Pump Stations (To Investigate)', isPoint: true },
        { key: 'la_county_hydrology_channels_all', layerId: 37, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_channels_lacfcd_all', layerId: 38, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels (LACFCD)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_channels_city_all', layerId: 39, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels (City)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_channels_usace_all', layerId: 40, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels (USACE)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_channels_caltrans_all', layerId: 41, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels (Caltrans)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_channels_unknown_all', layerId: 42, icon: '🏞️', color: '#bfdbfe', title: 'LA County Channels (Unknown)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_all', layerId: 43, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_lacfcd_all', layerId: 44, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (LACFCD)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_city_all', layerId: 45, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (City)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_road_all', layerId: 46, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (Road)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_metro_parks_all', layerId: 47, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (Metro/Parks)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_private_all', layerId: 48, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (Private)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_caltrans_all', layerId: 49, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (Caltrans)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_drains_unknown_all', layerId: 50, icon: '🌧️', color: '#dbeafe', title: 'LA County Drains (Unknown)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_all', layerId: 51, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_lacfcd_all', layerId: 52, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (LACFCD)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_city_all', layerId: 53, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (City)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_road_all', layerId: 54, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (Road)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_metro_parks_all', layerId: 55, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (Metro/Parks)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_private_all', layerId: 56, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (Private)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_caltrans_all', layerId: 57, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (Caltrans)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_laterals_unknown_all', layerId: 58, icon: '🌊', color: '#eff6ff', title: 'LA County Laterals (Unknown)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_culverts_all', layerId: 59, icon: '🚇', color: '#f0f9ff', title: 'LA County Culverts', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_culverts_completed_all', layerId: 60, icon: '🚇', color: '#f0f9ff', title: 'LA County Culverts (Completed)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_culverts_investigate_all', layerId: 61, icon: '🚇', color: '#f0f9ff', title: 'LA County Culverts (To Investigate)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_culverts_city_la_all', layerId: 62, icon: '🚇', color: '#f0f9ff', title: 'LA County Culverts (City of LA)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_permitted_connections_all', layerId: 63, icon: '🔌', color: '#e0f2fe', title: 'LA County Permitted Connections', isPoint: true },
        { key: 'la_county_hydrology_force_mains_all', layerId: 64, icon: '💧', color: '#bae6fd', title: 'LA County Force Mains', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_force_mains_completed_all', layerId: 65, icon: '💧', color: '#bae6fd', title: 'LA County Force Mains (Completed)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_force_mains_investigate_all', layerId: 66, icon: '💧', color: '#bae6fd', title: 'LA County Force Mains (To Investigate)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_force_mains_city_la_all', layerId: 67, icon: '💧', color: '#bae6fd', title: 'LA County Force Mains (City of LA)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_force_mains_caltrans_all', layerId: 68, icon: '💧', color: '#bae6fd', title: 'LA County Force Mains (Caltrans)', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_natural_drainage_all', layerId: 69, icon: '🌿', color: '#7dd3fc', title: 'LA County Natural Drainage', isPoint: false },
        { key: 'la_county_hydrology_pseudo_line_all', layerId: 70, icon: '📏', color: '#38bdf8', title: 'LA County Pseudo Line', isPoint: false, isLine: true },
        { key: 'la_county_hydrology_embankment_all', layerId: 71, icon: '⛰️', color: '#0ea5e9', title: 'LA County Embankment', isPoint: false }
      ];

      laCountyHydrologyLayers.forEach(({ key, icon, color, title, isPoint, isLine }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((hydrology: any) => {
              try {
                const geometry = hydrology.geometry;
                const isContaining = hydrology.isContaining;
                const distance = hydrology.distance_miles !== null && hydrology.distance_miles !== undefined ? hydrology.distance_miles : 0;
                const hydrologyId = hydrology.hydrologyId || hydrology.OBJECTID || hydrology.objectid || 'Unknown';
                
                // Check for point geometry (either from geometry.x/y or from attributes)
                const pointLat = isPoint ? (geometry?.y || geometry?.latitude || hydrology.latitude || hydrology.LATITUDE || hydrology.lat || hydrology.LAT) : null;
                const pointLon = isPoint ? (geometry?.x || geometry?.longitude || hydrology.longitude || hydrology.LONGITUDE || hydrology.lon || hydrology.LON) : null;
                
                if (isPoint && pointLat !== null && pointLat !== undefined && pointLon !== null && pointLon !== undefined) {
                  // Point geometry
                  const lat = pointLat;
                  const lon = pointLon;
                  
                  const marker = L.marker([lat, lon], {
                    icon: createPOIIcon(icon, color)
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${hydrologyId ? `<div><strong>ID:</strong> ${hydrologyId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['hydrologyId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                  Object.entries(hydrology).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  featureCount++;
                } else if (isLine && (geometry?.paths || geometry?.rings)) {
                  // Line geometry
                  const paths = geometry.paths || (geometry.rings ? geometry.rings : []);
                  if (paths && paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      if (latlngs.length < 2) {
                        console.warn(`${title} line has less than 2 coordinates, skipping`);
                        return;
                      }
                      
                      const polyline = L.polyline(latlngs, {
                        color: color,
                        weight: 3,
                        opacity: 0.8
                      });
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${icon} ${title}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${hydrologyId ? `<div><strong>ID:</strong> ${hydrologyId}</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;
                      
                      const excludeFields = ['hydrologyId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                      Object.entries(hydrology).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) {
                            return;
                          }
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      
                      popupContent += `
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent);
                      polyline.addTo(primary);
                      const polylineBounds = L.latLngBounds(latlngs);
                      bounds.extend(polylineBounds);
                      featureCount++;
                    });
                  }
                } else if (geometry && geometry.rings) {
                  // Polygon geometry
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${hydrologyId ? `<div><strong>ID:</strong> ${hydrologyId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this feature</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['hydrologyId', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(hydrology).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${title} feature:`, error);
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Infrastructure layers
      const laCountyInfrastructureLayers = [
        { key: 'la_county_infrastructure_county_facilities_all', layerId: 0, icon: '🏛️', color: '#7c3aed', title: 'LA County Facilities', isPoint: true },
        { key: 'la_county_infrastructure_county_buildings_all', layerId: 1, icon: '🏢', color: '#8b5cf6', title: 'LA County-owned Buildings', isPoint: false },
        { key: 'la_county_infrastructure_schools_all', layerId: 2, icon: '🏫', color: '#a78bfa', title: 'LA County Schools', isPoint: false },
        { key: 'la_county_infrastructure_county_parcels_all', layerId: 3, icon: '📋', color: '#c084fc', title: 'LA County-owned Parcels', isPoint: false },
        { key: 'la_county_infrastructure_government_parcels_all', layerId: 4, icon: '📋', color: '#d8b4fe', title: 'LA County Government-owned Parcels', isPoint: false }
      ];

      laCountyInfrastructureLayers.forEach(({ key, icon, color, title, isPoint }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((infrastructure: any) => {
              try {
                const geometry = infrastructure.geometry;
                const isContaining = infrastructure.isContaining;
                const distance = infrastructure.distance_miles !== null && infrastructure.distance_miles !== undefined ? infrastructure.distance_miles : 0;
                const infrastructureId = infrastructure.infrastructureId || infrastructure.LACO || infrastructure.laco || infrastructure.OBJECTID || infrastructure.objectid || 'Unknown';
                
                // Check for point geometry
                const pointLat = isPoint ? (geometry?.y || geometry?.latitude || infrastructure.latitude || infrastructure.LATITUDE || infrastructure.lat || infrastructure.LAT) : null;
                const pointLon = isPoint ? (geometry?.x || geometry?.longitude || infrastructure.longitude || infrastructure.LONGITUDE || infrastructure.lon || infrastructure.LON) : null;
                
                if (isPoint && pointLat !== null && pointLat !== undefined && pointLon !== null && pointLon !== undefined) {
                  // Point geometry
                  const lat = pointLat;
                  const lon = pointLon;
                  
                  const marker = L.marker([lat, lon], {
                    icon: createPOIIcon(icon, color)
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${infrastructureId ? `<div><strong>ID:</strong> ${infrastructureId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['infrastructureId', 'LACO', 'laco', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                  Object.entries(infrastructure).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  featureCount++;
                } else if (geometry && geometry.rings) {
                  // Polygon geometry
                  const rings = geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${infrastructureId ? `<div><strong>ID:</strong> ${infrastructureId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this feature</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['infrastructureId', 'LACO', 'laco', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(infrastructure).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${title} feature:`, error);
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Administrative Boundaries layers
      const laCountyAdminBoundariesLayers = [
        { key: 'la_county_admin_boundaries_isd_facilities_all', layerId: 24, icon: '🏢', color: '#6366f1', title: 'LA County ISD Facilities Operations Service Maintenance Districts' },
        { key: 'la_county_admin_boundaries_school_districts_all', layerId: 0, icon: '🏫', color: '#7c3aed', title: 'LA County School District Boundaries' },
        { key: 'la_county_admin_boundaries_park_planning_areas_all', layerId: 1, icon: '🏞️', color: '#8b5cf6', title: 'LA County Park Planning Areas' },
        { key: 'la_county_admin_boundaries_dcfs_office_all', layerId: 2, icon: '🏛️', color: '#a78bfa', title: 'LA County DCFS Office Boundaries' },
        { key: 'la_county_admin_boundaries_health_districts_2022_all', layerId: 22, icon: '🏥', color: '#c084fc', title: 'LA County Health Districts (2022)' },
        { key: 'la_county_admin_boundaries_health_districts_2012_all', layerId: 3, icon: '🏥', color: '#c084fc', title: 'LA County Health Districts (2012)' },
        { key: 'la_county_admin_boundaries_service_planning_areas_2022_all', layerId: 23, icon: '🗺️', color: '#d8b4fe', title: 'LA County Service Planning Areas (2022)' },
        { key: 'la_county_admin_boundaries_service_planning_areas_2012_all', layerId: 4, icon: '🗺️', color: '#d8b4fe', title: 'LA County Service Planning Areas (2012)' },
        { key: 'la_county_admin_boundaries_disaster_management_areas_all', layerId: 18, icon: '⚠️', color: '#e879f9', title: 'LA County Disaster Management Areas' },
        { key: 'la_county_admin_boundaries_zipcodes_all', layerId: 5, icon: '📮', color: '#f0abfc', title: 'LA County Zipcodes' },
        { key: 'la_county_admin_boundaries_regional_centers_all', layerId: 6, icon: '📍', color: '#f5d0fe', title: 'LA County Regional Centers (2014)' },
        { key: 'la_county_admin_boundaries_public_safety_all', layerId: 7, icon: '🚨', color: '#fae8ff', title: 'LA County Public Safety' },
        { key: 'la_county_admin_boundaries_reporting_districts_all', layerId: 8, icon: '📊', color: '#fce7f3', title: 'LA County Reporting Districts' },
        { key: 'la_county_admin_boundaries_station_boundaries_all', layerId: 9, icon: '🚓', color: '#fdf2f8', title: 'LA County Station Boundaries' },
        { key: 'la_county_admin_boundaries_fire_station_boundaries_all', layerId: 19, icon: '🚒', color: '#fef3c7', title: 'LA County Fire Station Boundaries' },
        { key: 'la_county_admin_boundaries_psap_boundaries_all', layerId: 20, icon: '📞', color: '#fde68a', title: 'LA County PSAP Boundaries' },
        { key: 'la_county_admin_boundaries_library_all', layerId: 10, icon: '📚', color: '#fcd34d', title: 'LA County Library' },
        { key: 'la_county_admin_boundaries_library_planning_areas_all', layerId: 11, icon: '📚', color: '#fbbf24', title: 'LA County Library Planning Areas' },
        { key: 'la_county_admin_boundaries_library_service_areas_all', layerId: 12, icon: '📚', color: '#f59e0b', title: 'LA County Library Service Areas' },
        { key: 'la_county_admin_boundaries_state_enterprise_zones_all', layerId: 16, icon: '💼', color: '#d97706', title: 'LA County State Enterprise Zones' },
        { key: 'la_county_admin_boundaries_animal_care_control_all', layerId: 21, icon: '🐾', color: '#92400e', title: 'LA County Animal Care and Control Service Areas' }
      ];

      laCountyAdminBoundariesLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((boundary: any) => {
              if (boundary.geometry && boundary.geometry.rings) {
                try {
                  const rings = boundary.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = boundary.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const boundaryId = boundary.boundaryId || boundary.NAME || boundary.Name || boundary.name || boundary.OBJECTID || boundary.objectid || 'Unknown';
                    const distance = boundary.distance_miles !== null && boundary.distance_miles !== undefined ? boundary.distance_miles : 0;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${boundaryId ? `<div><strong>Boundary ID:</strong> ${boundaryId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this boundary</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['boundaryId', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(boundary).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Elevation layers (contours and points)
      const laCountyElevationLayers = [
        { key: 'la_county_elevation_contours_l4_all', layerId: 10, icon: '⛰️', color: '#8b5cf6', title: 'LA County Contours L4', isLine: true },
        { key: 'la_county_elevation_contours_1000ft_l4_all', layerId: 11, icon: '⛰️', color: '#7c3aed', title: 'LA County LARIAC Contours 1000FT L4', isLine: true },
        { key: 'la_county_elevation_contours_250ft_l4_all', layerId: 12, icon: '⛰️', color: '#6366f1', title: 'LA County LARIAC Contours 250FT L4', isLine: true },
        { key: 'la_county_elevation_contours_50ft_l4_all', layerId: 13, icon: '⛰️', color: '#5b21b6', title: 'LA County LARIAC Contours 50FT L4', isLine: true },
        { key: 'la_county_elevation_contours_10ft_l4_all', layerId: 14, icon: '⛰️', color: '#4c1d95', title: 'LA County LARIAC Contours 10FT L4', isLine: true },
        { key: 'la_county_elevation_contours_2ft_l4_all', layerId: 15, icon: '⛰️', color: '#3b0764', title: 'LA County LARIAC Contours 2FT L4', isLine: true },
        { key: 'la_county_elevation_contours_1ft_l4_all', layerId: 16, icon: '⛰️', color: '#2e1065', title: 'LA County LARIAC Contours 1FT L4', isLine: true },
        { key: 'la_county_elevation_contours_all', layerId: 0, icon: '⛰️', color: '#a78bfa', title: 'LA County Contours', isLine: true },
        { key: 'la_county_elevation_contours_250ft_all', layerId: 1, icon: '⛰️', color: '#9333ea', title: 'LA County LARIAC Contours 250ft', isLine: true },
        { key: 'la_county_elevation_contours_50ft_all', layerId: 2, icon: '⛰️', color: '#7e22ce', title: 'LA County LARIAC Contours 50ft', isLine: true },
        { key: 'la_county_elevation_contours_10ft_all', layerId: 3, icon: '⛰️', color: '#6b21a8', title: 'LA County LARIAC Contours 10ft', isLine: true },
        { key: 'la_county_elevation_points_all', layerId: 9, icon: '📍', color: '#ec4899', title: 'LA County Elevation Points', isLine: false }
      ];

      laCountyElevationLayers.forEach(({ key, icon, color, title, isLine }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((elevation: any) => {
              if (isLine && elevation.geometry && elevation.geometry.paths) {
                // Draw contour lines (polylines)
                try {
                  const paths = elevation.geometry.paths;
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 2) {
                      return;
                    }
                    
                    const polyline = L.polyline(latlngs, {
                      color: color,
                      weight: 2,
                      opacity: 0.7
                    });
                    
                    const elevationId = elevation.elevationId || elevation.ELEVATION || elevation.Elevation || elevation.CONTOUR || elevation.Contour || 'Unknown';
                    const distance = elevation.distance_miles !== null && elevation.distance_miles !== undefined ? elevation.distance_miles : 0;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${elevationId ? `<div><strong>Elevation/Contour:</strong> ${elevationId}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['elevationId', 'ELEVATION', 'Elevation', 'elevation', 'CONTOUR', 'Contour', 'contour', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                    Object.entries(elevation).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent);
                    polyline.addTo(primary);
                    const polylineBounds = L.latLngBounds(latlngs);
                    bounds.extend(polylineBounds);
                    featureCount++;
                  });
                } catch (error) {
                  console.error(`Error drawing ${title} polyline:`, error);
                }
              } else if (!isLine && elevation.geometry && elevation.geometry.x !== undefined && elevation.geometry.y !== undefined) {
                // Draw elevation points
                try {
                  const pointLat = elevation.geometry.y;
                  const pointLon = elevation.geometry.x;
                  
                  const marker = L.marker([pointLat, pointLon], {
                    icon: L.divIcon({
                      className: 'custom-marker-icon',
                      html: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 12px;">${icon}</div>`,
                      iconSize: [20, 20],
                      iconAnchor: [10, 10]
                    })
                  });
                  
                  const elevationId = elevation.elevationId || elevation.ELEVATION || elevation.Elevation || 'Unknown';
                  const distance = elevation.distance_miles !== null && elevation.distance_miles !== undefined ? elevation.distance_miles : 0;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${elevationId ? `<div><strong>Elevation:</strong> ${elevationId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['elevationId', 'ELEVATION', 'Elevation', 'elevation', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID'];
                  Object.entries(elevation).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([pointLat, pointLon]);
                  featureCount++;
                } catch (error) {
                  console.error(`Error drawing ${title} point:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Add raster layers for visualization (if enabled)
      // Use ArcGIS MapServer export endpoint with proper coordinate system
      const rasterLayers = [
        { key: 'la_county_elevation_raster_enabled', layerId: 5, title: 'LA County Elevation Data (Raster)', icon: '🗺️', color: '#8b5cf6' },
        { key: 'la_county_elevation_hillshade_enabled', layerId: 6, title: 'LA County LARIAC Hillshade (2006)', icon: '⛰️', color: '#7c3aed' },
        { key: 'la_county_elevation_dem_enabled', layerId: 7, title: 'LA County LARIAC Digital Elevation Model (2006)', icon: '🏔️', color: '#6366f1' },
        { key: 'la_county_elevation_dsm_enabled', layerId: 8, title: 'LA County LARIAC Digital Surface Model (2006)', icon: '⛰️', color: '#5b21b6' }
      ];

      rasterLayers.forEach(({ key, layerId, title, icon, color }) => {
        try {
          if (enrichments[key] && map && map.getBounds) {
            const mapBounds = map.getBounds();
            const sw = mapBounds.getSouthWest();
            const ne = mapBounds.getNorthEast();
            
            // Get map container size for image size
            const mapSize = map.getSize();
            const imageWidth = Math.max(512, Math.min(2048, mapSize.x || 1024));
            const imageHeight = Math.max(512, Math.min(2048, mapSize.y || 1024));
            
            // Service uses spatial reference 2229 (California State Plane Zone 5)
            // But we'll request in 4326 and let ArcGIS transform, or try Web Mercator (3857)
            // Format: minX,minY,maxX,maxY
            const bbox4326 = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
            
            // Convert to Web Mercator (3857) - standard for web maps
            const toWebMercator = (lat: number, lon: number) => {
              const x = lon * 20037508.34 / 180;
              let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
              y = y * 20037508.34 / 180;
              return { x, y };
            };
            
            const swMerc = toWebMercator(sw.lat, sw.lng);
            const neMerc = toWebMercator(ne.lat, ne.lng);
            const bbox3857 = `${swMerc.x},${swMerc.y},${neMerc.x},${neMerc.y}`;
            
            // Try Web Mercator first (most reliable for web maps)
            let exportUrl = `https://arcgis.gis.lacounty.gov/arcgis/rest/services/LACounty_Dynamic/Elevation/MapServer/export?bbox=${bbox3857}&bboxSR=3857&imageSR=3857&size=${imageWidth},${imageHeight}&f=image&layers=show:${layerId}&transparent=true&format=png`;
            
            console.log(`🗺️ Adding ${title} raster layer (Layer ${layerId})`);
            console.log(`   Map bounds:`, { sw: sw, ne: ne });
            console.log(`   Image size:`, { width: imageWidth, height: imageHeight });
            console.log(`   Export URL:`, exportUrl);
            
            // Create ImageOverlay with current map bounds
            const imageOverlay = L.imageOverlay(exportUrl, mapBounds, {
              opacity: 0.7,
              zIndex: 100,
              attribution: 'LA County Public GIS',
              interactive: false
            });
            
            // Add error handler - if Web Mercator fails, try WGS84
            imageOverlay.on('error', () => {
              console.warn(`⚠️ Web Mercator export failed for ${title}, trying WGS84...`);
              
              // Fallback to WGS84
              const fallbackUrl = `https://arcgis.gis.lacounty.gov/arcgis/rest/services/LACounty_Dynamic/Elevation/MapServer/export?bbox=${bbox4326}&bboxSR=4326&imageSR=4326&size=${imageWidth},${imageHeight}&f=image&layers=show:${layerId}&transparent=true&format=png`;
              
              // Remove failed overlay and try again
              if (map.hasLayer(imageOverlay)) {
                imageOverlay.remove();
              }
              
              const fallbackOverlay = L.imageOverlay(fallbackUrl, mapBounds, {
                opacity: 0.7,
                zIndex: 100,
                attribution: 'LA County Public GIS',
                interactive: false
              });
              
              fallbackOverlay.on('error', (err: any) => {
                console.error(`❌ Failed to load ${title} raster image with both coordinate systems:`, err);
              });
              
              fallbackOverlay.on('load', () => {
                console.log(`✅ Successfully loaded ${title} raster image using WGS84 fallback`);
              });
              
              fallbackOverlay.addTo(map);
            });
            
            imageOverlay.on('load', () => {
              console.log(`✅ Successfully loaded ${title} raster image using Web Mercator`);
            });
            
            imageOverlay.addTo(map);
            
            // Add to legend
            const legendKey = key.replace('_enabled', '');
            if (!legendAccumulator[legendKey]) {
              legendAccumulator[legendKey] = {
                icon: icon,
                color: color,
                title: title,
                count: 1, // Raster layers show as enabled
              };
            }
            
            console.log(`✅ Added ${title} raster layer to map`);
          } else {
            console.log(`⚠️ ${title} not enabled or map not ready:`, { 
              enabled: enrichments[key], 
              hasMap: !!map,
              hasGetBounds: map && typeof map.getBounds === 'function',
              mapReady: map !== null
            });
          }
        } catch (error) {
          console.error(`❌ Error adding ${title} raster layer:`, error);
        }
      });

      // Draw LA County Demographics layers
      const laCountyDemographicsLayers = [
        { key: 'la_county_demographics_2020_census_all', layerId: 13, icon: '📊', color: '#8b5cf6', title: 'LA County 2020 Census' },
        { key: 'la_county_demographics_2020_tracts_all', layerId: 14, icon: '📊', color: '#7c3aed', title: 'LA County 2020 Census Tracts' },
        { key: 'la_county_demographics_2020_block_groups_all', layerId: 15, icon: '📊', color: '#6366f1', title: 'LA County 2020 Census Block Groups' },
        { key: 'la_county_demographics_2020_blocks_all', layerId: 16, icon: '📊', color: '#5b21b6', title: 'LA County 2020 Census Blocks' },
        { key: 'la_county_demographics_2018_estimates_all', layerId: 10, icon: '📈', color: '#4c1d95', title: 'LA County 2018 Estimates' },
        { key: 'la_county_demographics_2018_population_poverty_all', layerId: 11, icon: '📈', color: '#3b0764', title: 'LA County 2018 Population and Poverty by Tract' },
        { key: 'la_county_demographics_2018_median_income_all', layerId: 12, icon: '📈', color: '#2e1065', title: 'LA County 2018 Median Household Income by Tract' },
        { key: 'la_county_demographics_2010_census_all', layerId: 0, icon: '📋', color: '#a78bfa', title: 'LA County 2010 Census' },
        { key: 'la_county_demographics_2010_tracts_all', layerId: 1, icon: '📋', color: '#9333ea', title: 'LA County 2010 Census Data by Tract' },
        { key: 'la_county_demographics_2010_block_groups_all', layerId: 2, icon: '📋', color: '#7e22ce', title: 'LA County 2010 Census Block Groups' },
        { key: 'la_county_demographics_2010_blocks_all', layerId: 3, icon: '📋', color: '#6b21a8', title: 'LA County 2010 Census Data By Block' },
        { key: 'la_county_demographics_2000_census_all', layerId: 4, icon: '📄', color: '#ec4899', title: 'LA County 2000 Census' },
        { key: 'la_county_demographics_2000_tracts_all', layerId: 5, icon: '📄', color: '#db2777', title: 'LA County 2000 Census Tracts' },
        { key: 'la_county_demographics_2000_block_groups_all', layerId: 6, icon: '📄', color: '#be185d', title: 'LA County 2000 Census Block Groups' },
        { key: 'la_county_demographics_2000_blocks_all', layerId: 7, icon: '📄', color: '#9f1239', title: 'LA County 2000 Census Blocks' },
        { key: 'la_county_demographics_1990_census_all', layerId: 8, icon: '📜', color: '#f472b6', title: 'LA County 1990 Census' },
        { key: 'la_county_demographics_1990_tracts_all', layerId: 9, icon: '📜', color: '#f43f5e', title: 'LA County 1990 Census Tracts' }
      ];

      laCountyDemographicsLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((demographic: any) => {
              if (demographic.geometry && demographic.geometry.rings) {
                try {
                  const rings = demographic.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = demographic.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const demographicId = demographic.demographicId || demographic.GEOID || demographic.geoid || demographic.TRACT || demographic.tract || demographic.BLOCK_GROUP || demographic.block_group || demographic.BLOCK || demographic.block || demographic.OBJECTID || demographic.objectid || 'Unknown';
                    const distance = demographic.distance_miles !== null && demographic.distance_miles !== undefined ? demographic.distance_miles : 0;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${demographicId ? `<div><strong>ID:</strong> ${demographicId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this boundary</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['demographicId', 'GEOID', 'geoid', 'TRACT', 'tract', 'BLOCK_GROUP', 'block_group', 'BLOCK', 'block', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(demographic).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County LMS Data layers
      // Create a comprehensive list of all LMS layers with their metadata
      const laCountyLMSLayers = Array.from({ length: 193 }, (_, i) => {
        const layerNames: Record<number, { key: string; icon: string; color: string; title: string }> = {
          0: { key: 'la_county_lms_arts_recreation_all', icon: '🎨', color: '#ef4444', title: 'LA County LMS Data Arts and Recreation' },
          1: { key: 'la_county_lms_beaches_marinas_all', icon: '🏖️', color: '#f59e0b', title: 'LA County LMS Data Beaches and Marinas' },
          2: { key: 'la_county_lms_campgrounds_all', icon: '⛺', color: '#10b981', title: 'LA County LMS Data Campgrounds' },
          3: { key: 'la_county_lms_cruise_line_terminals_all', icon: '🚢', color: '#3b82f6', title: 'LA County LMS Data Cruise Line Terminals' },
          4: { key: 'la_county_lms_cultural_performing_arts_all', icon: '🎭', color: '#8b5cf6', title: 'LA County LMS Data Cultural and Performing Arts Centers' },
          5: { key: 'la_county_lms_golf_courses_all', icon: '⛳', color: '#06b6d4', title: 'LA County LMS Data Golf Courses' },
          6: { key: 'la_county_lms_museums_aquariums_all', icon: '🏛️', color: '#6366f1', title: 'LA County LMS Data Museums and Aquariums' },
          7: { key: 'la_county_lms_natural_areas_wildlife_all', icon: '🌿', color: '#14b8a6', title: 'LA County LMS Data Natural Areas and Wildlife Sanctuaries' },
          8: { key: 'la_county_lms_parks_gardens_all', icon: '🌳', color: '#22c55e', title: 'LA County LMS Data Parks and Gardens' },
          9: { key: 'la_county_lms_picnic_areas_all', icon: '🧺', color: '#84cc16', title: 'LA County LMS Data Picnic Areas' },
          10: { key: 'la_county_lms_pools_all', icon: '🏊', color: '#65a30d', title: 'LA County LMS Data Pools' },
          11: { key: 'la_county_lms_ranches_all', icon: '🐴', color: '#a3e635', title: 'LA County LMS Data Ranches' },
          12: { key: 'la_county_lms_recreation_centers_all', icon: '🏃', color: '#4ade80', title: 'LA County LMS Data Recreation Centers' },
          13: { key: 'la_county_lms_recreation_clubs_all', icon: '🎪', color: '#34d399', title: 'LA County LMS Data Recreation Clubs' },
          14: { key: 'la_county_lms_recreation_programs_all', icon: '🎯', color: '#2dd4bf', title: 'LA County LMS Data Recreation Programs' },
          15: { key: 'la_county_lms_ski_areas_all', icon: '⛷️', color: '#06b6d4', title: 'LA County LMS Data Ski Areas' },
          16: { key: 'la_county_lms_sports_venues_all', icon: '🏟️', color: '#0ea5e9', title: 'LA County LMS Data Sports Venues' },
          17: { key: 'la_county_lms_tourist_assistance_all', icon: '🗺️', color: '#3b82f6', title: 'LA County LMS Data Tourist Assistance' },
          18: { key: 'la_county_lms_trails_all', icon: '🥾', color: '#2563eb', title: 'LA County LMS Data Trails' },
          19: { key: 'la_county_lms_wineries_all', icon: '🍷', color: '#1d4ed8', title: 'LA County LMS Data Wineries' },
          20: { key: 'la_county_lms_communications_all', icon: '📡', color: '#7c3aed', title: 'LA County LMS Data Communications' },
          21: { key: 'la_county_lms_am_antennas_all', icon: '📻', color: '#6d28d9', title: 'LA County LMS Data AM Antennas' },
          22: { key: 'la_county_lms_antenna_structure_registration_all', icon: '📡', color: '#5b21b6', title: 'LA County LMS Data Antenna Structure Registration' },
          23: { key: 'la_county_lms_brs_ebs_transmitters_all', icon: '📺', color: '#4c1d95', title: 'LA County LMS Data BRS and EBS Transmitters' },
          24: { key: 'la_county_lms_cellular_towers_all', icon: '📱', color: '#3b0764', title: 'LA County LMS Data Cellular Towers' },
          25: { key: 'la_county_lms_digital_tv_all', icon: '📺', color: '#2e1065', title: 'LA County LMS Data Digital TV' },
          26: { key: 'la_county_lms_fm_antennas_all', icon: '📻', color: '#1e1b4b', title: 'LA County LMS Data FM Antennas' },
          27: { key: 'la_county_lms_internet_exchange_points_all', icon: '🌐', color: '#9333ea', title: 'LA County LMS Data Internet Exchange Points' },
          28: { key: 'la_county_lms_internet_service_providers_all', icon: '💻', color: '#a855f7', title: 'LA County LMS Data Internet Service Providers' },
          29: { key: 'la_county_lms_it_portal_locations_all', icon: '🖥️', color: '#c084fc', title: 'LA County LMS Data IT Portal Locations' },
          30: { key: 'la_county_lms_land_mobile_broadcast_all', icon: '📡', color: '#d946ef', title: 'LA County LMS Data Land Mobile Broadcast' },
          31: { key: 'la_county_lms_land_mobile_commercial_towers_all', icon: '📡', color: '#e879f9', title: 'LA County LMS Data Land Mobile Commercial Towers' },
          32: { key: 'la_county_lms_land_mobile_private_all', icon: '📡', color: '#f0abfc', title: 'LA County LMS Data Land Mobile Private' },
          33: { key: 'la_county_lms_microwave_towers_all', icon: '📡', color: '#f472b6', title: 'LA County LMS Data Microwave Towers' },
          34: { key: 'la_county_lms_ntsc_tv_all', icon: '📺', color: '#fb7185', title: 'LA County LMS Data NTSC TV' },
          35: { key: 'la_county_lms_paging_towers_all', icon: '📡', color: '#fda4af', title: 'LA County LMS Data Paging Towers' },
          36: { key: 'la_county_lms_towers_all', icon: '📡', color: '#fecdd3', title: 'LA County LMS Data Towers' },
          37: { key: 'la_county_lms_community_groups_all', icon: '👥', color: '#ec4899', title: 'LA County LMS Data Community Groups' },
          38: { key: 'la_county_lms_churches_all', icon: '⛪', color: '#db2777', title: 'LA County LMS Data Churches' },
          39: { key: 'la_county_lms_community_organizations_all', icon: '🤝', color: '#be185d', title: 'LA County LMS Data Community Organizations' },
          40: { key: 'la_county_lms_farmers_markets_all', icon: '🥬', color: '#9f1239', title: 'LA County LMS Data Farmers Markets' },
          41: { key: 'la_county_lms_red_cross_offices_all', icon: '➕', color: '#831843', title: 'LA County LMS Data Red Cross Offices' },
          42: { key: 'la_county_lms_volunteer_opportunities_all', icon: '🙋', color: '#701a75', title: 'LA County LMS Data Volunteer Opportunities' },
          43: { key: 'la_county_lms_education_all', icon: '📚', color: '#dc2626', title: 'LA County LMS Data Education' },
          44: { key: 'la_county_lms_adult_education_all', icon: '👨‍🎓', color: '#b91c1c', title: 'LA County LMS Data Adult Education' },
          45: { key: 'la_county_lms_colleges_universities_all', icon: '🏫', color: '#991b1b', title: 'LA County LMS Data Colleges and Universities' },
          46: { key: 'la_county_lms_early_childhood_education_all', icon: '🧒', color: '#7f1d1d', title: 'LA County LMS Data Early Childhood Education and Head Start' },
          47: { key: 'la_county_lms_guidance_tutoring_all', icon: '📖', color: '#450a0a', title: 'LA County LMS Data Guidance and Tutoring Programs' },
          48: { key: 'la_county_lms_private_charter_schools_all', icon: '🏫', color: '#f97316', title: 'LA County LMS Data Private and Charter Schools' },
          49: { key: 'la_county_lms_public_elementary_schools_all', icon: '🏫', color: '#ea580c', title: 'LA County LMS Data Public Elementary Schools' },
          50: { key: 'la_county_lms_public_high_schools_all', icon: '🏫', color: '#c2410c', title: 'LA County LMS Data Public High Schools' },
          51: { key: 'la_county_lms_public_middle_school_all', icon: '🏫', color: '#9a3412', title: 'LA County LMS Data Public Middle School' },
          52: { key: 'la_county_lms_school_districts_all', icon: '🏛️', color: '#7c2d12', title: 'LA County LMS Data School Districts' },
          53: { key: 'la_county_lms_special_curriculum_schools_all', icon: '🎓', color: '#431407', title: 'LA County LMS Data Special Curriculum Schools and Programs' },
          54: { key: 'la_county_lms_emergency_response_all', icon: '🚨', color: '#f59e0b', title: 'LA County LMS Data Emergency Response' },
          55: { key: 'la_county_lms_cooling_centers_all', icon: '❄️', color: '#d97706', title: 'LA County LMS Data Cooling Centers' },
          56: { key: 'la_county_lms_emergency_disaster_offices_all', icon: '🏢', color: '#b45309', title: 'LA County LMS Data Emergency and Disaster Offices' },
          57: { key: 'la_county_lms_environment_all', icon: '🌍', color: '#84cc16', title: 'LA County LMS Data Environment' },
          58: { key: 'la_county_lms_conservation_programs_all', icon: '🌱', color: '#65a30d', title: 'LA County LMS Data Conservation Programs' },
          59: { key: 'la_county_lms_epa_facility_registration_all', icon: '🏭', color: '#4ade80', title: 'LA County LMS Data EPA Facility Registration System' },
          60: { key: 'la_county_lms_epa_superfund_sites_all', icon: '⚠️', color: '#22c55e', title: 'LA County LMS Data EPA Superfund Sites' },
          61: { key: 'la_county_lms_hazardous_waste_disposal_all', icon: '☢️', color: '#16a34a', title: 'LA County LMS Data Hazardous Waste Disposal' },
          62: { key: 'la_county_lms_historic_earthquakes_all', icon: '🌋', color: '#15803d', title: 'LA County LMS Data Historic Earthquakes' },
          63: { key: 'la_county_lms_recycling_all', icon: '♻️', color: '#166534', title: 'LA County LMS Data Recycling' },
          64: { key: 'la_county_lms_tsunami_tide_gauges_all', icon: '🌊', color: '#14532d', title: 'LA County LMS Data Tsunami Tide Gauges' },
          65: { key: 'la_county_lms_government_all', icon: '🏛️', color: '#0ea5e9', title: 'LA County LMS Data Government' },
          66: { key: 'la_county_lms_chambers_of_commerce_all', icon: '💼', color: '#0284c7', title: 'LA County LMS Data Chambers of Commerce' },
          67: { key: 'la_county_lms_city_halls_all', icon: '🏛️', color: '#0369a1', title: 'LA County LMS Data City Halls' },
          68: { key: 'la_county_lms_consulate_offices_all', icon: '🏢', color: '#075985', title: 'LA County LMS Data Consulate Offices' },
          69: { key: 'la_county_lms_county_offices_all', icon: '🏛️', color: '#0c4a6e', title: 'LA County LMS Data County Offices' },
          70: { key: 'la_county_lms_government_offices_all', icon: '🏢', color: '#082f49', title: 'LA County LMS Data Government Offices' },
          71: { key: 'la_county_lms_passports_all', icon: '📘', color: '#3b82f6', title: 'LA County LMS Data Passports' },
          72: { key: 'la_county_lms_representative_offices_all', icon: '👤', color: '#2563eb', title: 'LA County LMS Data Representative Offices' },
          73: { key: 'la_county_lms_social_security_administration_all', icon: '💳', color: '#1d4ed8', title: 'LA County LMS Data Social Security Administration' },
          74: { key: 'la_county_lms_health_mental_health_all', icon: '🏥', color: '#ef4444', title: 'LA County LMS Data Health and Mental Health' },
          75: { key: 'la_county_lms_dental_care_all', icon: '🦷', color: '#dc2626', title: 'LA County LMS Data Dental Care' },
          76: { key: 'la_county_lms_dhs_health_clinics_all', icon: '🏥', color: '#b91c1c', title: 'LA County LMS Data DHS Health Clinics' },
          77: { key: 'la_county_lms_health_centers_all', icon: '🏥', color: '#991b1b', title: 'LA County LMS Data Health Centers' },
          78: { key: 'la_county_lms_health_clinics_all', icon: '🏥', color: '#7f1d1d', title: 'LA County LMS Data Health Clinics' },
          79: { key: 'la_county_lms_health_education_counseling_all', icon: '💬', color: '#450a0a', title: 'LA County LMS Data Health Education and Counseling' },
          80: { key: 'la_county_lms_health_screening_testing_all', icon: '🧪', color: '#f97316', title: 'LA County LMS Data Health Screening and Testing' },
          81: { key: 'la_county_lms_hospitals_medical_centers_all', icon: '🏥', color: '#ea580c', title: 'LA County LMS Data Hospitals and Medical Centers' },
          82: { key: 'la_county_lms_immunization_all', icon: '💉', color: '#c2410c', title: 'LA County LMS Data Immunization' },
          83: { key: 'la_county_lms_medicare_medicaid_offices_all', icon: '💊', color: '#9a3412', title: 'LA County LMS Data Medicare and Medicaid Offices' },
          84: { key: 'la_county_lms_mental_health_centers_all', icon: '🧠', color: '#7c2d12', title: 'LA County LMS Data Mental Health Centers' },
          85: { key: 'la_county_lms_mental_health_counseling_all', icon: '💭', color: '#431407', title: 'LA County LMS Data Mental Health Counseling' },
          86: { key: 'la_county_lms_mental_health_programs_all', icon: '🧘', color: '#f59e0b', title: 'LA County LMS Data Mental Health Programs' },
          87: { key: 'la_county_lms_public_health_programs_all', icon: '🏥', color: '#d97706', title: 'LA County LMS Data Public Health Programs' },
          88: { key: 'la_county_lms_safe_havens_all', icon: '🛡️', color: '#b45309', title: 'LA County LMS Data Safe Havens' },
          89: { key: 'la_county_lms_substance_abuse_programs_all', icon: '💊', color: '#92400e', title: 'LA County LMS Data Substance Abuse Programs' },
          90: { key: 'la_county_lms_municipal_services_all', icon: '🏛️', color: '#10b981', title: 'LA County LMS Data Municipal Services' },
          91: { key: 'la_county_lms_animals_pets_all', icon: '🐾', color: '#059669', title: 'LA County LMS Data Animals and Pets' },
          92: { key: 'la_county_lms_building_inspections_all', icon: '🔍', color: '#047857', title: 'LA County LMS Data Building Inspections' },
          93: { key: 'la_county_lms_cemeteries_all', icon: '🪦', color: '#065f46', title: 'LA County LMS Data Cemeteries' },
          94: { key: 'la_county_lms_community_services_all', icon: '🤝', color: '#064e3b', title: 'LA County LMS Data Community Services' },
          95: { key: 'la_county_lms_consumer_services_all', icon: '🛒', color: '#022c22', title: 'LA County LMS Data Consumer Services' },
          96: { key: 'la_county_lms_economic_development_all', icon: '💼', color: '#06b6d4', title: 'LA County LMS Data Economic Development' },
          97: { key: 'la_county_lms_elections_all', icon: '🗳️', color: '#0891b2', title: 'LA County LMS Data Elections' },
          98: { key: 'la_county_lms_environmental_programs_all', icon: '🌱', color: '#0e7490', title: 'LA County LMS Data Environmental Programs' },
          99: { key: 'la_county_lms_health_housing_inspections_all', icon: '🏠', color: '#155e75', title: 'LA County LMS Data Health and Housing Inspections' },
          100: { key: 'la_county_lms_libraries_all', icon: '📚', color: '#164e63', title: 'LA County LMS Data Libraries' },
          101: { key: 'la_county_lms_licenses_permits_all', icon: '📄', color: '#083344', title: 'LA County LMS Data Licenses and Permits' },
          102: { key: 'la_county_lms_planning_zoning_all', icon: '🗺️', color: '#6366f1', title: 'LA County LMS Data Planning and Zoning' },
          103: { key: 'la_county_lms_property_tax_all', icon: '💰', color: '#4f46e5', title: 'LA County LMS Data Property and Tax' },
          104: { key: 'la_county_lms_public_internet_access_all', icon: '💻', color: '#4338ca', title: 'LA County LMS Data Public Internet Access' },
          105: { key: 'la_county_lms_public_records_all', icon: '📋', color: '#3730a3', title: 'LA County LMS Data Public Records' },
          106: { key: 'la_county_lms_rubbish_disposal_all', icon: '🗑️', color: '#312e81', title: 'LA County LMS Data Rubbish Disposal' },
          107: { key: 'la_county_lms_street_maintenance_all', icon: '🛣️', color: '#1e1b4b', title: 'LA County LMS Data Street Maintenance' },
          108: { key: 'la_county_lms_utilities_all', icon: '⚡', color: '#9333ea', title: 'LA County LMS Data Utilities' },
          109: { key: 'la_county_lms_physical_features_all', icon: '🏔️', color: '#8b5cf6', title: 'LA County LMS Data Physical Features' },
          110: { key: 'la_county_lms_electrical_substations_all', icon: '⚡', color: '#7c3aed', title: 'LA County LMS Data Electrical Sub-Stations' },
          111: { key: 'la_county_lms_named_locations_all', icon: '📍', color: '#6d28d9', title: 'LA County LMS Data Named Locations' },
          112: { key: 'la_county_lms_power_plants_all', icon: '🏭', color: '#5b21b6', title: 'LA County LMS Data Power Plants' },
          113: { key: 'la_county_lms_water_all', icon: '💧', color: '#4c1d95', title: 'LA County LMS Data Water' },
          114: { key: 'la_county_lms_postal_all', icon: '📮', color: '#f59e0b', title: 'LA County LMS Data Postal' },
          115: { key: 'la_county_lms_dhl_locations_all', icon: '📦', color: '#d97706', title: 'LA County LMS Data DHL Locations' },
          116: { key: 'la_county_lms_federal_express_locations_all', icon: '📦', color: '#b45309', title: 'LA County LMS Data Federal Express Locations' },
          117: { key: 'la_county_lms_post_offices_all', icon: '📮', color: '#92400e', title: 'LA County LMS Data Post Offices' },
          118: { key: 'la_county_lms_private_non_retail_shipping_all', icon: '📦', color: '#78350f', title: 'LA County LMS Data Private Non Retail Shipping Locations' },
          119: { key: 'la_county_lms_ups_locations_all', icon: '📦', color: '#713f12', title: 'LA County LMS Data UPS Locations' },
          120: { key: 'la_county_lms_usps_mail_collection_boxes_all', icon: '📬', color: '#65a30d', title: 'LA County LMS Data USPS Mail Collection Boxes' },
          121: { key: 'la_county_lms_private_industry_all', icon: '🏭', color: '#4ade80', title: 'LA County LMS Data Private Industry' },
          122: { key: 'la_county_lms_agriculture_food_all', icon: '🌾', color: '#22c55e', title: 'LA County LMS Data Agriculture and Food' },
          123: { key: 'la_county_lms_banking_finance_all', icon: '🏦', color: '#16a34a', title: 'LA County LMS Data Banking and Finance' },
          124: { key: 'la_county_lms_business_centers_all', icon: '🏢', color: '#15803d', title: 'LA County LMS Data Business Centers' },
          125: { key: 'la_county_lms_corporate_headquarters_all', icon: '🏢', color: '#166534', title: 'LA County LMS Data Corporate Headquarters' },
          126: { key: 'la_county_lms_manufacturing_all', icon: '🏭', color: '#14532d', title: 'LA County LMS Data Manufacturing' },
          127: { key: 'la_county_lms_mines_all', icon: '⛏️', color: '#0ea5e9', title: 'LA County LMS Data Mines' },
          128: { key: 'la_county_lms_oilfields_all', icon: '🛢️', color: '#0284c7', title: 'LA County LMS Data Oilfields' },
          129: { key: 'la_county_lms_shopping_centers_all', icon: '🛍️', color: '#0369a1', title: 'LA County LMS Data Shopping Centers' },
          130: { key: 'la_county_lms_tv_movie_studios_all', icon: '🎬', color: '#075985', title: 'LA County LMS Data TV and Movie Studios' },
          131: { key: 'la_county_lms_public_safety_all', icon: '🚨', color: '#0c4a6e', title: 'LA County LMS Data Public Safety' },
          132: { key: 'la_county_lms_courthouses_all', icon: '⚖️', color: '#082f49', title: 'LA County LMS Data Courthouses' },
          133: { key: 'la_county_lms_crime_prevention_support_all', icon: '🛡️', color: '#3b82f6', title: 'LA County LMS Data Crime Prevention and Support' },
          134: { key: 'la_county_lms_crime_reporting_investigation_all', icon: '🔍', color: '#2563eb', title: 'LA County LMS Data Crime Reporting and Investigation' },
          135: { key: 'la_county_lms_district_attorney_all', icon: '⚖️', color: '#1d4ed8', title: 'LA County LMS Data District Attorney' },
          136: { key: 'la_county_lms_fingerprinting_all', icon: '👆', color: '#1e40af', title: 'LA County LMS Data Fingerprinting' },
          137: { key: 'la_county_lms_fire_stations_all', icon: '🚒', color: '#1e3a8a', title: 'LA County LMS Data Fire Stations' },
          138: { key: 'la_county_lms_jails_prisons_all', icon: '🔒', color: '#172554', title: 'LA County LMS Data Jails and Prisons' },
          139: { key: 'la_county_lms_legal_services_counseling_all', icon: '⚖️', color: '#0f172a', title: 'LA County LMS Data Legal Services and Counseling' },
          140: { key: 'la_county_lms_lifeguard_towers_all', icon: '🏖️', color: '#ef4444', title: 'LA County LMS Data Lifeguard Towers' },
          141: { key: 'la_county_lms_parole_offender_assistance_all', icon: '👤', color: '#dc2626', title: 'LA County LMS Data Parole and Offender Assistance' },
          142: { key: 'la_county_lms_probation_camps_juvenile_halls_all', icon: '🏫', color: '#b91c1c', title: 'LA County LMS Data Probation Camps and Juvenile Halls' },
          143: { key: 'la_county_lms_probation_offices_all', icon: '🏢', color: '#991b1b', title: 'LA County LMS Data Probation Offices' },
          144: { key: 'la_county_lms_public_defender_all', icon: '⚖️', color: '#7f1d1d', title: 'LA County LMS Data Public Defender' },
          145: { key: 'la_county_lms_self_help_legal_centers_all', icon: '📚', color: '#450a0a', title: 'LA County LMS Data Self-Help Legal Centers' },
          146: { key: 'la_county_lms_sheriff_police_stations_all', icon: '🚔', color: '#f97316', title: 'LA County LMS Data Sheriff and Police Stations' },
          147: { key: 'la_county_lms_social_services_all', icon: '🤝', color: '#ea580c', title: 'LA County LMS Data Social Services' },
          148: { key: 'la_county_lms_adoption_all', icon: '👶', color: '#c2410c', title: 'LA County LMS Data Adoption' },
          149: { key: 'la_county_lms_child_care_all', icon: '👶', color: '#9a3412', title: 'LA County LMS Data Child Care' },
          150: { key: 'la_county_lms_child_support_services_all', icon: '👨‍👩‍👧‍👦', color: '#7c2d12', title: 'LA County LMS Data Child Support Services' },
          151: { key: 'la_county_lms_children_family_services_all', icon: '👨‍👩‍👧‍👦', color: '#431407', title: 'LA County LMS Data Children and Family Services' },
          152: { key: 'la_county_lms_clothing_all', icon: '👕', color: '#f59e0b', title: 'LA County LMS Data Clothing' },
          153: { key: 'la_county_lms_disability_support_services_all', icon: '♿', color: '#d97706', title: 'LA County LMS Data Disability Support Services' },
          154: { key: 'la_county_lms_domestic_violence_services_all', icon: '🛡️', color: '#b45309', title: 'LA County LMS Data Domestic Violence Services' },
          155: { key: 'la_county_lms_donation_services_all', icon: '🎁', color: '#92400e', title: 'LA County LMS Data Donation Services' },
          156: { key: 'la_county_lms_food_assistance_all', icon: '🍽️', color: '#78350f', title: 'LA County LMS Data Food Assistance' },
          157: { key: 'la_county_lms_forms_assistance_all', icon: '📝', color: '#713f12', title: 'LA County LMS Data Forms Assistance' },
          158: { key: 'la_county_lms_homeless_shelters_services_all', icon: '🏠', color: '#65a30d', title: 'LA County LMS Data Homeless Shelters and Services' },
          159: { key: 'la_county_lms_housing_assistance_information_all', icon: '🏘️', color: '#4ade80', title: 'LA County LMS Data Housing Assistance and Information' },
          160: { key: 'la_county_lms_immigration_all', icon: '🛂', color: '#22c55e', title: 'LA County LMS Data Immigration' },
          161: { key: 'la_county_lms_job_training_all', icon: '💼', color: '#16a34a', title: 'LA County LMS Data Job Training' },
          162: { key: 'la_county_lms_neg_program_worksource_centers_all', icon: '💼', color: '#15803d', title: 'LA County LMS Data NEG Program WorkSource Centers' },
          163: { key: 'la_county_lms_payment_assistance_all', icon: '💰', color: '#166534', title: 'LA County LMS Data Payment Assistance' },
          164: { key: 'la_county_lms_public_housing_all', icon: '🏘️', color: '#14532d', title: 'LA County LMS Data Public Housing' },
          165: { key: 'la_county_lms_public_information_services_all', icon: 'ℹ️', color: '#0ea5e9', title: 'LA County LMS Data Public Information Services' },
          166: { key: 'la_county_lms_senior_services_all', icon: '👴', color: '#0284c7', title: 'LA County LMS Data Senior Services' },
          167: { key: 'la_county_lms_support_groups_all', icon: '👥', color: '#0369a1', title: 'LA County LMS Data Support Groups' },
          168: { key: 'la_county_lms_thrift_shops_all', icon: '🛍️', color: '#075985', title: 'LA County LMS Data Thrift Shops' },
          169: { key: 'la_county_lms_transportation_assistance_all', icon: '🚗', color: '#0c4a6e', title: 'LA County LMS Data Transportation Assistance' },
          170: { key: 'la_county_lms_unemployment_insurance_offices_all', icon: '💼', color: '#082f49', title: 'LA County LMS Data Unemployment Insurance Offices' },
          171: { key: 'la_county_lms_veterans_services_all', icon: '🎖️', color: '#3b82f6', title: 'LA County LMS Data Veterans Services' },
          172: { key: 'la_county_lms_welfare_offices_programs_all', icon: '💳', color: '#2563eb', title: 'LA County LMS Data Welfare Offices and Programs' },
          173: { key: 'la_county_lms_transportation_all', icon: '🚗', color: '#1d4ed8', title: 'LA County LMS Data Transportation' },
          174: { key: 'la_county_lms_airports_all', icon: '✈️', color: '#1e40af', title: 'LA County LMS Data Airports' },
          175: { key: 'la_county_lms_alternative_fuel_all', icon: '⛽', color: '#1e3a8a', title: 'LA County LMS Data Alternative Fuel' },
          176: { key: 'la_county_lms_amtrak_stations_all', icon: '🚂', color: '#172554', title: 'LA County LMS Data Amtrak Stations' },
          177: { key: 'la_county_lms_anchorages_all', icon: '⚓', color: '#0f172a', title: 'LA County LMS Data Anchorages' },
          178: { key: 'la_county_lms_automatic_traffic_counters_all', icon: '📊', color: '#ef4444', title: 'LA County LMS Data Automatic Traffic Counters' },
          179: { key: 'la_county_lms_breakwaters_all', icon: '🌊', color: '#dc2626', title: 'LA County LMS Data Breakwaters' },
          180: { key: 'la_county_lms_bridges_all', icon: '🌉', color: '#b91c1c', title: 'LA County LMS Data Bridges' },
          181: { key: 'la_county_lms_ferries_all', icon: '⛴️', color: '#991b1b', title: 'LA County LMS Data Ferries' },
          182: { key: 'la_county_lms_freeway_exits_all', icon: '🛣️', color: '#7f1d1d', title: 'LA County LMS Data Freeway Exits' },
          183: { key: 'la_county_lms_heliports_all', icon: '🚁', color: '#450a0a', title: 'LA County LMS Data Heliports' },
          184: { key: 'la_county_lms_intermodal_terminal_facilities_all', icon: '🚚', color: '#f97316', title: 'LA County LMS Data Intermodal Terminal Facilities' },
          185: { key: 'la_county_lms_metro_stations_all', icon: '🚇', color: '#ea580c', title: 'LA County LMS Data Metro Stations' },
          186: { key: 'la_county_lms_metrolink_stations_all', icon: '🚆', color: '#c2410c', title: 'LA County LMS Data Metrolink Stations' },
          187: { key: 'la_county_lms_park_and_ride_locations_all', icon: '🅿️', color: '#9a3412', title: 'LA County LMS Data Park and Ride Locations' },
          188: { key: 'la_county_lms_transit_systems_all', icon: '🚌', color: '#7c2d12', title: 'LA County LMS Data Transit Systems' },
          189: { key: 'la_county_lms_tunnels_all', icon: '🚇', color: '#431407', title: 'LA County LMS Data Tunnels' },
          190: { key: 'la_county_lms_county_fueling_stations_all', icon: '⛽', color: '#f59e0b', title: 'LA County LMS Data County Fueling Stations' },
          191: { key: 'la_county_lms_county_electric_charging_stations_all', icon: '🔌', color: '#d97706', title: 'LA County LMS Data County Electric Charging Stations' },
          192: { key: 'la_county_lms_warming_centers_all', icon: '🔥', color: '#b45309', title: 'LA County LMS Data Warming Centers' }
        };
        return layerNames[i] || { key: `la_county_lms_layer_${i}_all`, icon: '📍', color: '#6366f1', title: `LA County LMS Data Layer ${i}` };
      });

      laCountyLMSLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((lmsFeature: any) => {
              try {
                // Handle point geometry
                if (lmsFeature.geometry && lmsFeature.geometry.x && lmsFeature.geometry.y) {
                  const lat = lmsFeature.geometry.y;
                  const lon = lmsFeature.geometry.x;
                  
                  const marker = L.marker([lat, lon], {
                    icon: createPOIIcon(icon, color)
                  });
                  
                  const lmsId = lmsFeature.lmsId || lmsFeature.OBJECTID || lmsFeature.objectid || lmsFeature.ID || lmsFeature.id || lmsFeature.NAME || lmsFeature.Name || lmsFeature.name || 'Unknown';
                  const distance = lmsFeature.distance_miles !== null && lmsFeature.distance_miles !== undefined ? lmsFeature.distance_miles : 0;
                  const isContaining = lmsFeature.isContaining;
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${lmsId ? `<div><strong>ID:</strong> ${lmsId}</div>` : ''}
                        ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this feature</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['lmsId', 'OBJECTID', 'objectid', 'ID', 'id', 'NAME', 'Name', 'name', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                  Object.entries(lmsFeature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  featureCount++;
                }
                // Handle polygon geometry
                else if (lmsFeature.geometry && lmsFeature.geometry.rings) {
                  const rings = lmsFeature.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = lmsFeature.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const lmsId = lmsFeature.lmsId || lmsFeature.OBJECTID || lmsFeature.objectid || lmsFeature.ID || lmsFeature.id || lmsFeature.NAME || lmsFeature.Name || lmsFeature.name || 'Unknown';
                    const distance = lmsFeature.distance_miles !== null && lmsFeature.distance_miles !== undefined ? lmsFeature.distance_miles : 0;
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${lmsId ? `<div><strong>ID:</strong> ${lmsId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this boundary</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['lmsId', 'OBJECTID', 'objectid', 'ID', 'id', 'NAME', 'Name', 'name', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(lmsFeature).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                }
                // Handle polyline geometry
                else if (lmsFeature.geometry && lmsFeature.geometry.paths) {
                  const paths = lmsFeature.geometry.paths;
                  if (paths && paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      const isContaining = lmsFeature.isContaining;
                      const lineColor = isContaining ? color : color.replace('ff', 'cc');
                      const weight = isContaining ? 4 : 2;
                      const opacity = isContaining ? 0.9 : 0.6;
                      
                      const polyline = L.polyline(latlngs, {
                        color: lineColor,
                        weight: weight,
                        opacity: opacity
                      });
                      
                      const lmsId = lmsFeature.lmsId || lmsFeature.OBJECTID || lmsFeature.objectid || lmsFeature.ID || lmsFeature.id || lmsFeature.NAME || lmsFeature.Name || lmsFeature.name || 'Unknown';
                      const distance = lmsFeature.distance_miles !== null && lmsFeature.distance_miles !== undefined ? lmsFeature.distance_miles : 0;
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${icon} ${title}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${lmsId ? `<div><strong>ID:</strong> ${lmsId}</div>` : ''}
                            ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is on this line</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;
                      
                      const excludeFields = ['lmsId', 'OBJECTID', 'objectid', 'ID', 'id', 'NAME', 'Name', 'name', 'geometry', 'distance_miles', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                      Object.entries(lmsFeature).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) {
                            return;
                          }
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      
                      popupContent += `
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent);
                      polyline.addTo(primary);
                      const polylineBounds = L.latLngBounds(latlngs);
                      bounds.extend(polylineBounds);
                      featureCount++;
                    });
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${title} feature:`, error);
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Political Boundaries layers
      const laCountyPoliticalBoundariesLayers = [
        { key: 'la_county_political_boundaries_districts_2021_all', layerId: 24, icon: '🗳️', color: '#3b82f6', title: 'LA County Districts (2021)' },
        { key: 'la_county_political_boundaries_supervisorial_current_all', layerId: 27, icon: '🏛️', color: '#2563eb', title: 'LA County Supervisorial District (Current)' },
        { key: 'la_county_political_boundaries_supervisorial_2021_all', layerId: 26, icon: '🏛️', color: '#1d4ed8', title: 'LA County Supervisorial District (2021)' },
        { key: 'la_county_political_boundaries_congressional_2021_all', layerId: 29, icon: '🏛️', color: '#1e40af', title: 'LA County Congressional District (2021)' },
        { key: 'la_county_political_boundaries_state_assembly_2021_all', layerId: 30, icon: '🏛️', color: '#1e3a8a', title: 'LA County State Assembly District (2021)' },
        { key: 'la_county_political_boundaries_state_senate_2021_all', layerId: 31, icon: '🏛️', color: '#172554', title: 'LA County State Senate District (2021)' },
        { key: 'la_county_political_boundaries_board_equalization_2021_all', layerId: 32, icon: '⚖️', color: '#0f172a', title: 'LA County Board of Equalization (2021)' },
        { key: 'la_county_political_boundaries_city_council_2021_all', layerId: 33, icon: '🏛️', color: '#6366f1', title: 'LA City Council Districts (2021)' },
        { key: 'la_county_political_boundaries_districts_2011_all', layerId: 0, icon: '🗳️', color: '#4f46e5', title: 'LA County Districts (2011)' },
        { key: 'la_county_political_boundaries_supervisorial_2011_all', layerId: 1, icon: '🏛️', color: '#4338ca', title: 'LA County Supervisorial District (2011)' },
        { key: 'la_county_political_boundaries_congressional_2011_all', layerId: 2, icon: '🏛️', color: '#3730a3', title: 'LA County Congressional District (2011)' },
        { key: 'la_county_political_boundaries_state_assembly_2011_all', layerId: 3, icon: '🏛️', color: '#312e81', title: 'LA County State Assembly District (2011)' },
        { key: 'la_county_political_boundaries_state_senate_2011_all', layerId: 4, icon: '🏛️', color: '#1e1b4b', title: 'LA County State Senate District (2011)' },
        { key: 'la_county_political_boundaries_board_equalization_2011_all', layerId: 5, icon: '⚖️', color: '#9333ea', title: 'LA County Board of Equalization (2011)' },
        { key: 'la_county_political_boundaries_city_council_2012_all', layerId: 6, icon: '🏛️', color: '#8b5cf6', title: 'LA City Council Districts (2012)' },
        { key: 'la_county_political_boundaries_districts_2001_all', layerId: 7, icon: '🗳️', color: '#7c3aed', title: 'LA County Districts (2001)' },
        { key: 'la_county_political_boundaries_supervisorial_2001_all', layerId: 8, icon: '🏛️', color: '#6d28d9', title: 'LA County Supervisorial Districts (2001)' },
        { key: 'la_county_political_boundaries_congressional_2001_all', layerId: 9, icon: '🏛️', color: '#5b21b6', title: 'LA County Congressional Districts (2001)' },
        { key: 'la_county_political_boundaries_state_assembly_2001_all', layerId: 10, icon: '🏛️', color: '#4c1d95', title: 'LA County State Assembly Districts (2001)' },
        { key: 'la_county_political_boundaries_state_senate_2001_all', layerId: 11, icon: '🏛️', color: '#3b0764', title: 'LA County State Senate Districts (2001)' },
        { key: 'la_county_political_boundaries_city_council_2002_all', layerId: 12, icon: '🏛️', color: '#2e1065', title: 'LA City Council Districts (2002)' },
        { key: 'la_county_political_boundaries_districts_1971_1991_all', layerId: 13, icon: '🗳️', color: '#1e1b4b', title: 'LA County Districts (1971-1991)' },
        { key: 'la_county_political_boundaries_supervisorial_1991_all', layerId: 14, icon: '🏛️', color: '#ec4899', title: 'LA County Supervisorial Districts (1991)' },
        { key: 'la_county_political_boundaries_supervisorial_1981_all', layerId: 15, icon: '🏛️', color: '#db2777', title: 'LA County Supervisorial Districts (1981)' },
        { key: 'la_county_political_boundaries_supervisorial_1971_all', layerId: 16, icon: '🏛️', color: '#be185d', title: 'LA County Supervisorial Districts (1971)' },
        { key: 'la_county_political_boundaries_other_all', layerId: 36, icon: '🗺️', color: '#9f1239', title: 'LA County Other Political Boundaries' },
        { key: 'la_county_political_boundaries_school_districts_all', layerId: 25, icon: '🏫', color: '#831843', title: 'LA County School Districts' },
        { key: 'la_county_political_boundaries_registrar_precincts_all', layerId: 34, icon: '🗳️', color: '#701a75', title: 'LA County Registrar Recorder Precincts' },
        { key: 'la_county_political_boundaries_election_precincts_all', layerId: 37, icon: '🗳️', color: '#f59e0b', title: 'LA County Registrar Recorder Election Precincts' },
        { key: 'la_county_political_boundaries_city_county_all', layerId: 17, icon: '🏘️', color: '#d97706', title: 'LA County City and County Boundaries' },
        { key: 'la_county_political_boundaries_county_boundaries_all', layerId: 18, icon: '🗺️', color: '#b45309', title: 'LA County County Boundaries' },
        { key: 'la_county_political_boundaries_city_boundaries_all', layerId: 19, icon: '🏘️', color: '#92400e', title: 'LA County City Boundaries' },
        { key: 'la_county_political_boundaries_community_boundaries_all', layerId: 23, icon: '🏘️', color: '#78350f', title: 'LA County Community Boundaries (CSA)' },
        { key: 'la_county_political_boundaries_city_annexations_all', layerId: 21, icon: '📋', color: '#713f12', title: 'LA County City Annexations' }
      ];

      laCountyPoliticalBoundariesLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((boundary: any) => {
              if (boundary.geometry && boundary.geometry.rings) {
                try {
                  const rings = boundary.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = boundary.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const boundaryId = boundary.boundaryId || boundary.DISTRICT || boundary.district || boundary.DISTRICT_NUM || boundary.district_num || boundary.DISTRICT_NUMBER || boundary.district_number || boundary.NAME || boundary.Name || boundary.name || boundary.OBJECTID || boundary.objectid || 'Unknown';
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${boundaryId ? `<div><strong>ID:</strong> ${boundaryId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this boundary</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['boundaryId', 'DISTRICT', 'district', 'DISTRICT_NUM', 'district_num', 'DISTRICT_NUMBER', 'district_number', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining'];
                    Object.entries(boundary).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Redistricting Data layers
      // Create a comprehensive list of all redistricting layers with their metadata
      const laCountyRedistrictingLayers = [
        { key: 'la_county_redistricting_geography_all', layerId: 0, icon: '🗺️', color: '#3b82f6', title: 'LA County Redistricting Geography' },
        { key: 'la_county_redistricting_communities_2011_all', layerId: 1, icon: '🏘️', color: '#2563eb', title: 'LA County Redistricting Communities (2011)' },
        { key: 'la_county_redistricting_home_income_info_all', layerId: 3, icon: '🏠', color: '#1d4ed8', title: 'LA County Home and Income Information' },
        { key: 'la_county_redistricting_housing_data_all', layerId: 4, icon: '🏘️', color: '#1e40af', title: 'LA County Housing Data' },
        { key: 'la_county_redistricting_pct_owners_all', layerId: 5, icon: '🏡', color: '#1e3a8a', title: 'LA County % Owners' },
        { key: 'la_county_redistricting_pct_renters_all', layerId: 6, icon: '🏠', color: '#172554', title: 'LA County % Renters' },
        { key: 'la_county_redistricting_homes_lt_200k_all', layerId: 7, icon: '💰', color: '#0f172a', title: 'LA County % Homes < $200,000' },
        { key: 'la_county_redistricting_homes_200k_399k_all', layerId: 8, icon: '💰', color: '#6366f1', title: 'LA County % Homes $200,000 - $399,000' },
        { key: 'la_county_redistricting_homes_400k_749k_all', layerId: 9, icon: '💰', color: '#4f46e5', title: 'LA County % Homes $400,000 - $749,000' },
        { key: 'la_county_redistricting_homes_750k_plus_all', layerId: 10, icon: '💰', color: '#4338ca', title: 'LA County % Homes $750,000+' },
        { key: 'la_county_redistricting_home_value_preponderance_all', layerId: 11, icon: '📊', color: '#3730a3', title: 'LA County Home Value Preponderance' },
        { key: 'la_county_redistricting_income_data_all', layerId: 12, icon: '💵', color: '#312e81', title: 'LA County Income Data' },
        { key: 'la_county_redistricting_income_lt_25k_all', layerId: 13, icon: '💵', color: '#1e1b4b', title: 'LA County % Households w/ Income < $25,000' },
        { key: 'la_county_redistricting_income_25k_49k_all', layerId: 14, icon: '💵', color: '#9333ea', title: 'LA County % Households w/ Income $25,000 - $49,999' },
        { key: 'la_county_redistricting_income_50k_99k_all', layerId: 15, icon: '💵', color: '#8b5cf6', title: 'LA County % Households w/ Income $50,000 - $99,999' },
        { key: 'la_county_redistricting_income_100k_plus_all', layerId: 16, icon: '💵', color: '#7c3aed', title: 'LA County % Households w/ Income $100,000+' },
        { key: 'la_county_redistricting_income_preponderance_all', layerId: 17, icon: '📊', color: '#6d28d9', title: 'LA County Household Income Preponderance' },
        { key: 'la_county_redistricting_other_all', layerId: 18, icon: '📋', color: '#5b21b6', title: 'LA County Other' },
        { key: 'la_county_redistricting_population_density_all', layerId: 19, icon: '👥', color: '#4c1d95', title: 'LA County Population Density (Residential)' },
        { key: 'la_county_redistricting_pct_over_18_all', layerId: 20, icon: '👤', color: '#3b0764', title: 'LA County % Population Over 18' },
        { key: 'la_county_redistricting_pct_no_hs_diploma_all', layerId: 21, icon: '🎓', color: '#2e1065', title: 'LA County % No High School Diploma' },
        { key: 'la_county_redistricting_pct_below_poverty_all', layerId: 22, icon: '📉', color: '#1e1b4b', title: 'LA County % Below Poverty Level' },
        { key: 'la_county_redistricting_voter_registration_all', layerId: 23, icon: '🗳️', color: '#ec4899', title: 'LA County Voter Registration Data' },
        { key: 'la_county_redistricting_registration_by_age_all', layerId: 24, icon: '👥', color: '#db2777', title: 'LA County Registration by Age' },
        { key: 'la_county_redistricting_voter_age_18_34_all', layerId: 25, icon: '👤', color: '#be185d', title: 'LA County % Voter Age 18 to 34' },
        { key: 'la_county_redistricting_voter_age_35_49_all', layerId: 26, icon: '👤', color: '#9f1239', title: 'LA County % Voter Age 35 - 49' },
        { key: 'la_county_redistricting_voter_age_50_64_all', layerId: 27, icon: '👤', color: '#831843', title: 'LA County % Voter Age 50 - 64' },
        { key: 'la_county_redistricting_voter_age_65_plus_all', layerId: 28, icon: '👤', color: '#701a75', title: 'LA County % Voter Age 65+' },
        { key: 'la_county_redistricting_registration_by_surname_all', layerId: 29, icon: '📝', color: '#f59e0b', title: 'LA County Registration by Surname' },
        { key: 'la_county_redistricting_surname_not_classified_all', layerId: 30, icon: '❓', color: '#d97706', title: 'LA County % Surname Not Classified' },
        { key: 'la_county_redistricting_surname_spanish_all', layerId: 31, icon: '🇪🇸', color: '#b45309', title: 'LA County % Spanish Surname' },
        { key: 'la_county_redistricting_surname_asian_all', layerId: 32, icon: '🇦🇸', color: '#92400e', title: 'LA County % Asian Surname' },
        { key: 'la_county_redistricting_registration_by_party_all', layerId: 33, icon: '🏛️', color: '#78350f', title: 'LA County Registration by Party' },
        { key: 'la_county_redistricting_party_decline_to_state_all', layerId: 34, icon: '⚪', color: '#713f12', title: 'LA County % Decline to State' },
        { key: 'la_county_redistricting_party_republican_all', layerId: 35, icon: '🔴', color: '#dc2626', title: 'LA County % Republican' },
        { key: 'la_county_redistricting_party_democratic_all', layerId: 36, icon: '🔵', color: '#2563eb', title: 'LA County % Democratic Registration' },
        { key: 'la_county_redistricting_registration_by_sex_all', layerId: 37, icon: '👥', color: '#1d4ed8', title: 'LA County Registration by Sex' },
        { key: 'la_county_redistricting_sex_male_all', layerId: 38, icon: '♂️', color: '#1e40af', title: 'LA County % Male' },
        { key: 'la_county_redistricting_sex_female_all', layerId: 39, icon: '♀️', color: '#1e3a8a', title: 'LA County % Female' },
        { key: 'la_county_redistricting_citizen_voting_age_pop_all', layerId: 40, icon: '🗳️', color: '#172554', title: 'LA County Citizen Voting Age Population' },
        { key: 'la_county_redistricting_cvap_hispanic_all', layerId: 41, icon: '👤', color: '#0f172a', title: 'LA County % Hispanic Citizen Voting Age' },
        { key: 'la_county_redistricting_cvap_white_all', layerId: 42, icon: '👤', color: '#6366f1', title: 'LA County % White Citizen Voting Age' },
        { key: 'la_county_redistricting_cvap_african_american_all', layerId: 43, icon: '👤', color: '#4f46e5', title: 'LA County % African American Citizen Voting Age' },
        { key: 'la_county_redistricting_cvap_asian_all', layerId: 44, icon: '👤', color: '#4338ca', title: 'LA County % Asian Citizen Voting Age' },
        { key: 'la_county_redistricting_demographic_data_all', layerId: 45, icon: '📊', color: '#3730a3', title: 'LA County Demographic Data' },
        { key: 'la_county_redistricting_pop_2010_by_race_all', layerId: 46, icon: '👥', color: '#312e81', title: 'LA County 2010 Population by Race' },
        { key: 'la_county_redistricting_pop_2010_hispanic_all', layerId: 47, icon: '👤', color: '#1e1b4b', title: 'LA County % 2010 Population that is Hispanic' },
        { key: 'la_county_redistricting_pop_2010_nh_white_all', layerId: 48, icon: '👤', color: '#9333ea', title: 'LA County % 2010 Population that is NH-White' },
        { key: 'la_county_redistricting_pop_2010_nh_african_american_all', layerId: 49, icon: '👤', color: '#8b5cf6', title: 'LA County % 2010 Population that is NH-African American' },
        { key: 'la_county_redistricting_pop_2010_nh_asian_all', layerId: 50, icon: '👤', color: '#7c3aed', title: 'LA County % 2010 Population that is NH-Asian' },
        { key: 'la_county_redistricting_pop_2010_over_18_by_race_all', layerId: 51, icon: '👥', color: '#6d28d9', title: 'LA County 2010 Population over 18 by Race' },
        { key: 'la_county_redistricting_pop_over_18_hispanic_all', layerId: 52, icon: '👤', color: '#5b21b6', title: 'LA County % 2010 Pop over 18 - Hispanic' },
        { key: 'la_county_redistricting_pop_over_18_nh_white_all', layerId: 53, icon: '👤', color: '#4c1d95', title: 'LA County % 2010 Pop over 18 - NH-White' },
        { key: 'la_county_redistricting_pop_over_18_nh_african_american_all', layerId: 54, icon: '👤', color: '#3b0764', title: 'LA County % 2010 Pop over 18 - NH-African American' },
        { key: 'la_county_redistricting_pop_over_18_nh_asian_all', layerId: 55, icon: '👤', color: '#2e1065', title: 'LA County % 2010 Pop over 18 - NH-Asian' },
        { key: 'la_county_redistricting_pop_2010_by_race_inclusive_all', layerId: 56, icon: '👥', color: '#1e1b4b', title: 'LA County 2010 Population by Race (Inclusive)' },
        { key: 'la_county_redistricting_pop_incl_hispanic_all', layerId: 57, icon: '👤', color: '#ec4899', title: 'LA County % 2010 Pop (Incl) - Hispanic' },
        { key: 'la_county_redistricting_pop_incl_nh_white_all', layerId: 58, icon: '👤', color: '#db2777', title: 'LA County % 2010 Pop (Incl) - NH-White' },
        { key: 'la_county_redistricting_pop_incl_nh_african_american_all', layerId: 59, icon: '👤', color: '#be185d', title: 'LA County % 2010 Pop (Incl) - NH-African American' },
        { key: 'la_county_redistricting_pop_incl_nh_asian_all', layerId: 60, icon: '👤', color: '#9f1239', title: 'LA County % 2010 Pop (Incl) - NH-Asian' },
        { key: 'la_county_redistricting_cvap_2010_all', layerId: 61, icon: '🗳️', color: '#831843', title: 'LA County 2010 Citizen Voting Age Population (CVAP)' },
        { key: 'la_county_redistricting_cvap_2010_hispanic_all', layerId: 62, icon: '👤', color: '#701a75', title: 'LA County % 2010 CVAP Population - Hispanic' },
        { key: 'la_county_redistricting_cvap_2010_nh_white_all', layerId: 63, icon: '👤', color: '#f59e0b', title: 'LA County % 2010 CVAP Population - NH-White' },
        { key: 'la_county_redistricting_cvap_2010_nh_african_american_all', layerId: 64, icon: '👤', color: '#d97706', title: 'LA County % 2010 CVAP Population - NH-African American' },
        { key: 'la_county_redistricting_cvap_2010_nh_asian_all', layerId: 65, icon: '👤', color: '#b45309', title: 'LA County % 2010 CVAP Population - NH-Asian' },
        { key: 'la_county_redistricting_language_all', layerId: 66, icon: '🗣️', color: '#92400e', title: 'LA County Language' },
        { key: 'la_county_redistricting_pct_not_fluent_english_all', layerId: 67, icon: '❌', color: '#78350f', title: 'LA County % Not Fluent in English' },
        { key: 'la_county_redistricting_lang_arabic_all', layerId: 68, icon: '🇸🇦', color: '#713f12', title: 'LA County % Arabic Primary Language' },
        { key: 'la_county_redistricting_lang_armenian_all', layerId: 69, icon: '🇦🇲', color: '#dc2626', title: 'LA County % Armenian Primary Language' },
        { key: 'la_county_redistricting_lang_chinese_all', layerId: 70, icon: '🇨🇳', color: '#2563eb', title: 'LA County % Chinese Primary Language' },
        { key: 'la_county_redistricting_lang_cambodian_all', layerId: 71, icon: '🇰🇭', color: '#1d4ed8', title: 'LA County % Cambodian Primary Language' },
        { key: 'la_county_redistricting_lang_english_all', layerId: 72, icon: '🇺🇸', color: '#1e40af', title: 'LA County % English Primary Language' },
        { key: 'la_county_redistricting_lang_farsi_all', layerId: 73, icon: '🇮🇷', color: '#1e3a8a', title: 'LA County % Farsi Primary Language' },
        { key: 'la_county_redistricting_lang_korean_all', layerId: 74, icon: '🇰🇷', color: '#172554', title: 'LA County % Korean Primary Language' },
        { key: 'la_county_redistricting_lang_russian_all', layerId: 75, icon: '🇷🇺', color: '#0f172a', title: 'LA County % Russian Primary Language' },
        { key: 'la_county_redistricting_lang_spanish_all', layerId: 76, icon: '🇪🇸', color: '#6366f1', title: 'LA County % Spanish Primary Language' },
        { key: 'la_county_redistricting_lang_tagalog_all', layerId: 77, icon: '🇵🇭', color: '#4f46e5', title: 'LA County % Tagalog Primary Language' },
        { key: 'la_county_redistricting_lang_vietnamese_all', layerId: 78, icon: '🇻🇳', color: '#4338ca', title: 'LA County % Vietnamese Primary Language' },
        { key: 'la_county_redistricting_lang_other_all', layerId: 79, icon: '🌐', color: '#3730a3', title: 'LA County % Some Other Language Primary Language' }
      ];

      laCountyRedistrictingLayers.forEach(({ key, icon, color, title }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((redistricting: any) => {
              if (redistricting.geometry && redistricting.geometry.rings) {
                try {
                  const rings = redistricting.geometry.rings;
                  if (rings && rings.length > 0) {
                    const outerRing = rings[0];
                    const latlngs = outerRing.map((coord: number[]) => {
                      return [coord[1], coord[0]] as [number, number];
                    });
                    
                    if (latlngs.length < 3) {
                      console.warn(`${title} polygon has less than 3 coordinates, skipping`);
                      return;
                    }
                    
                    const isContaining = redistricting.isContaining;
                    const polygonColor = isContaining ? color : color.replace('ff', 'cc');
                    const weight = isContaining ? 3 : 2;
                    const opacity = isContaining ? 0.8 : 0.5;
                    
                    const polygon = L.polygon(latlngs, {
                      color: polygonColor,
                      weight: weight,
                      opacity: opacity,
                      fillColor: color,
                      fillOpacity: 0.15
                    });
                    
                    const redistrictingId = redistricting.redistrictingId || redistricting.COMMUNITY || redistricting.community || redistricting.COMMUNITY_NAME || redistricting.community_name || redistricting.NAME || redistricting.Name || redistricting.name || redistricting.OBJECTID || redistricting.objectid || 'Unknown';
                    
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          ${icon} ${title}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${redistrictingId ? `<div><strong>ID:</strong> ${redistrictingId}</div>` : ''}
                          ${isContaining ? `<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Location is within this boundary</div>` : ''}
                          ${redistricting.distance_miles !== null && redistricting.distance_miles !== undefined && redistricting.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${redistricting.distance_miles.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    const excludeFields = ['redistrictingId', 'COMMUNITY', 'community', 'COMMUNITY_NAME', 'community_name', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'isContaining', 'distance_miles'];
                    Object.entries(redistricting).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                        popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polygon.bindPopup(popupContent);
                    polygon.addTo(primary);
                    const polygonBounds = L.latLngBounds(latlngs);
                    bounds.extend(polygonBounds);
                    featureCount++;
                  }
                } catch (error) {
                  console.error(`Error drawing ${title} polygon:`, error);
                }
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw LA County Transportation layers
      const laCountyTransportationLayers = [
        { key: 'la_county_transportation_all', layerId: 0, icon: '🚗', color: '#3b82f6', title: 'LA County Transportation', isPoint: true, isLine: true },
        { key: 'la_county_milepost_markers_all', layerId: 1, icon: '📍', color: '#2563eb', title: 'LA County Milepost Markers', isPoint: true, isLine: false },
        { key: 'la_county_rail_transportation_all', layerId: 2, icon: '🚂', color: '#1d4ed8', title: 'LA County Rail Transportation', isPoint: true, isLine: true },
        { key: 'la_county_freeways_all', layerId: 3, icon: '🛣️', color: '#1e40af', title: 'LA County Freeways', isPoint: true, isLine: true },
        { key: 'la_county_disaster_routes_all', layerId: 4, icon: '🚨', color: '#1e3a8a', title: 'LA County Disaster Routes', isPoint: false, isLine: true },
        { key: 'la_county_highway_shields_all', layerId: 5, icon: '🛡️', color: '#172554', title: 'LA County Highway Shields', isPoint: true, isLine: false },
        { key: 'la_county_freeways_lines_all', layerId: 6, icon: '🛣️', color: '#0f172a', title: 'LA County Freeways (Lines)', isPoint: false, isLine: true },
        { key: 'la_county_metro_park_ride_all', layerId: 7, icon: '🅿️', color: '#6366f1', title: 'LA County Metro Park and Ride', isPoint: true, isLine: false },
        { key: 'la_county_metro_stations_all', layerId: 8, icon: '🚇', color: '#4f46e5', title: 'LA County Metro Stations', isPoint: true, isLine: false },
        { key: 'la_county_metrolink_stations_all', layerId: 9, icon: '🚆', color: '#4338ca', title: 'LA County Metrolink Stations', isPoint: true, isLine: false },
        { key: 'la_county_metrolink_lines_all', layerId: 10, icon: '🚆', color: '#3730a3', title: 'LA County Metrolink Lines', isPoint: false, isLine: true },
        { key: 'la_county_metro_lines_all', layerId: 11, icon: '🚇', color: '#312e81', title: 'LA County Metro Lines', isPoint: false, isLine: true },
        { key: 'la_county_railroads_all', layerId: 12, icon: '🚂', color: '#1e1b4b', title: 'LA County Railroads', isPoint: false, isLine: true }
      ];

      laCountyTransportationLayers.forEach(({ key, icon, color, title, isPoint, isLine }) => {
        try {
          if (enrichments[key] && Array.isArray(enrichments[key])) {
            let featureCount = 0;
            enrichments[key].forEach((transportation: any) => {
              try {
                // Handle point geometry
                if (isPoint && transportation.geometry && transportation.geometry.x !== undefined && transportation.geometry.y !== undefined) {
                  const lat = transportation.geometry.y;
                  const lon = transportation.geometry.x;
                  
                  const transportationId = transportation.transportationId || transportation.STATION_NAME || transportation.station_name || transportation.STATION || transportation.station || transportation.NAME || transportation.Name || transportation.name || transportation.OBJECTID || transportation.objectid || 'Unknown';
                  const distance = transportation.distance_miles !== null && transportation.distance_miles !== undefined ? transportation.distance_miles : 0;
                  
                  const marker = L.marker([lat, lon], {
                    icon: L.divIcon({
                      className: 'custom-marker',
                      html: `<div style="background-color: ${color}; width: 24px; height: 24px; border-radius: 50%; border: 2px solid white; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${icon}</div>`,
                      iconSize: [24, 24],
                      iconAnchor: [12, 12]
                    })
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${icon} ${title}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${transportationId ? `<div><strong>ID:</strong> ${transportationId}</div>` : ''}
                        ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;
                  
                  const excludeFields = ['transportationId', 'STATION_NAME', 'station_name', 'STATION', 'station', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'distance_miles'];
                  Object.entries(transportation).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) {
                        return;
                      }
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });
                  
                  popupContent += `
                      </div>
                    </div>
                  `;
                  
                  marker.bindPopup(popupContent);
                  marker.addTo(primary);
                  bounds.extend([lat, lon]);
                  featureCount++;
                }
                // Handle line geometry
                else if (isLine && transportation.geometry && transportation.geometry.paths) {
                  const paths = transportation.geometry.paths;
                  if (paths && paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      const latlngs = path.map((coord: number[]) => {
                        return [coord[1], coord[0]] as [number, number];
                      });
                      
                      const transportationId = transportation.transportationId || transportation.LINE || transportation.line || transportation.ROUTE || transportation.route || transportation.NAME || transportation.Name || transportation.name || 'Unknown';
                      const distance = transportation.distance_miles !== null && transportation.distance_miles !== undefined ? transportation.distance_miles : 0;
                      
                      const polyline = L.polyline(latlngs, {
                        color: color,
                        weight: 3,
                        opacity: 0.7,
                        smoothFactor: 1
                      });
                      
                      let popupContent = `
                        <div style="min-width: 250px; max-width: 400px;">
                          <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                            ${icon} ${title}
                          </h3>
                          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                            ${transportationId ? `<div><strong>ID:</strong> ${transportationId}</div>` : ''}
                            ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                          </div>
                          <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                      `;
                      
                      const excludeFields = ['transportationId', 'LINE', 'line', 'ROUTE', 'route', 'NAME', 'Name', 'name', 'OBJECTID', 'objectid', 'geometry', 'FID', 'fid', 'GlobalID', 'GLOBALID', 'distance_miles'];
                      Object.entries(transportation).forEach(([key, value]) => {
                        if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                          if (typeof value === 'object' && !Array.isArray(value)) {
                            return;
                          }
                          const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                          popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                        }
                      });
                      
                      popupContent += `
                          </div>
                        </div>
                      `;
                      
                      polyline.bindPopup(popupContent);
                      polyline.addTo(primary);
                      const polylineBounds = L.latLngBounds(latlngs);
                      bounds.extend(polylineBounds);
                      featureCount++;
                    });
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${title} feature:`, error);
              }
            });
            
            if (featureCount > 0) {
              const legendKey = key.replace('_all', '');
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: icon,
                  color: color,
                  title: title,
                  count: 0,
                };
              }
              legendAccumulator[legendKey].count += featureCount;
            }
          }
        } catch (error) {
          console.error(`Error processing ${title}:`, error);
        }
      });

      // Draw CA State Parks Entry Points
      try {
        if (enrichments.ca_state_parks_entry_points_all && Array.isArray(enrichments.ca_state_parks_entry_points_all)) {
          let entryPointCount = 0;
          enrichments.ca_state_parks_entry_points_all.forEach((entryPoint: any) => {
            if (entryPoint.geometry && entryPoint.geometry.x && entryPoint.geometry.y) {
              try {
                const lat = entryPoint.geometry.y;
                const lon = entryPoint.geometry.x;
                
                const parkUnitName = entryPoint.parkUnitName || entryPoint.PARK_NAME || entryPoint.park_name || entryPoint.ParkName || entryPoint.NAME || entryPoint.name || 'Unknown Park';
                const streetAddress = entryPoint.streetAddress || entryPoint.ADDRESS || entryPoint.address || entryPoint.Address || null;
                const city = entryPoint.city || entryPoint.CITY || entryPoint.City || null;
                const zipCode = entryPoint.zipCode || entryPoint.ZIP || entryPoint.zip || entryPoint.ZIP_CODE || entryPoint.zip_code || null;
                const phone = entryPoint.phone || entryPoint.PHONE || entryPoint.Phone || null;
                const website = entryPoint.website || entryPoint.WEBSITE || entryPoint.Website || entryPoint.URL || entryPoint.url || null;
                const distance = entryPoint.distance_miles !== null && entryPoint.distance_miles !== undefined ? entryPoint.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🏞️', '#059669')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🏞️ ${parkUnitName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${streetAddress ? `<div><strong>Address:</strong> ${streetAddress}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${zipCode ? `<div><strong>ZIP:</strong> ${zipCode}</div>` : ''}
                      ${phone ? `<div><strong>Phone:</strong> ${phone}</div>` : ''}
                      ${website ? `<div><strong>Website:</strong> <a href="${website}" target="_blank" rel="noopener noreferrer">${website}</a></div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                entryPointCount++;
              } catch (error) {
                console.error('Error drawing CA State Parks Entry Point:', error);
              }
            }
          });
          
          if (entryPointCount > 0) {
            if (!legendAccumulator['ca_state_parks_entry_points']) {
              legendAccumulator['ca_state_parks_entry_points'] = {
                icon: '🏞️',
                color: '#059669',
                title: 'CA State Parks Entry Points',
                count: 0,
              };
            }
            legendAccumulator['ca_state_parks_entry_points'].count += entryPointCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA State Parks Entry Points:', error);
      }

      // Draw CA State Parks Parking Lots
      try {
        if (enrichments.ca_state_parks_parking_lots_all && Array.isArray(enrichments.ca_state_parks_parking_lots_all)) {
          let parkingLotCount = 0;
          enrichments.ca_state_parks_parking_lots_all.forEach((parkingLot: any) => {
            if (parkingLot.geometry && parkingLot.geometry.x && parkingLot.geometry.y) {
              try {
                const lat = parkingLot.geometry.y;
                const lon = parkingLot.geometry.x;
                
                const name = parkingLot.name || parkingLot.NAME || parkingLot.Name || 'Unknown Parking Lot';
                const unitName = parkingLot.unitName || parkingLot.UNITNAME || parkingLot.unitName || null;
                const type = parkingLot.type || parkingLot.TYPE || parkingLot.Type || null;
                const subType = parkingLot.subType || parkingLot.SUBTYPE || parkingLot.subType || null;
                const useType = parkingLot.useType || parkingLot.USETYPE || parkingLot.useType || null;
                const trailhead = parkingLot.trailhead || parkingLot.TRAILHEAD || parkingLot.trailhead || null;
                const distance = parkingLot.distance_miles !== null && parkingLot.distance_miles !== undefined ? parkingLot.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🅿️', '#0891b2')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🅿️ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${unitName ? `<div><strong>Park Unit:</strong> ${unitName}</div>` : ''}
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${subType ? `<div><strong>Sub Type:</strong> ${subType}</div>` : ''}
                      ${useType ? `<div><strong>Use Type:</strong> ${useType}</div>` : ''}
                      ${trailhead ? `<div><strong>Trailhead:</strong> ${trailhead}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                parkingLotCount++;
              } catch (error) {
                console.error('Error drawing CA State Parks Parking Lot:', error);
              }
            }
          });
          
          if (parkingLotCount > 0) {
            if (!legendAccumulator['ca_state_parks_parking_lots']) {
              legendAccumulator['ca_state_parks_parking_lots'] = {
                icon: '🅿️',
                color: '#0891b2',
                title: 'CA State Parks Parking Lots',
                count: 0,
              };
            }
            legendAccumulator['ca_state_parks_parking_lots'].count += parkingLotCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA State Parks Parking Lots:', error);
      }

      // Draw CA State Parks Boundaries
      try {
        if (enrichments.ca_state_parks_boundaries_all && Array.isArray(enrichments.ca_state_parks_boundaries_all)) {
          let boundaryCount = 0;
          enrichments.ca_state_parks_boundaries_all.forEach((boundary: any) => {
            if (boundary.geometry && boundary.geometry.rings) {
              try {
                const rings = boundary.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latlngs = outerRing.map((coord: number[]) => {
                    return [coord[1], coord[0]] as [number, number];
                  });

                  if (latlngs.length < 3) {
                    console.warn('CA State Parks Boundary polygon has less than 3 coordinates, skipping');
                    return;
                  }

                  const color = '#10b981'; // Green for park boundaries
                  const weight = 2;

                  const unitName = boundary.unitName || boundary.UNITNAME || boundary.unitName || 'Unknown Park';
                  const subType = boundary.subType || boundary.SUBTYPE || boundary.subType || null;
                  const unitNbr = boundary.unitNbr || boundary.UNITNBR || boundary.unitNbr || null;

                  const polygon = L.polygon(latlngs, {
                    color: color,
                    weight: weight,
                    opacity: 0.7,
                    fillColor: color,
                    fillOpacity: 0.2
                  });

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        🏞️ ${unitName}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${subType ? `<div><strong>Sub Type:</strong> ${subType}</div>` : ''}
                        ${unitNbr ? `<div><strong>Unit Number:</strong> ${unitNbr}</div>` : ''}
                        ${boundary.isContaining ? '<div style="color: #059669; font-weight: 600; margin-top: 8px;">📍 Contains Location</div>' : ''}
                        ${boundary.distance_miles && boundary.distance_miles > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${boundary.distance_miles.toFixed(2)} miles</div>` : ''}
                      </div>
                    </div>
                  `;

                  polygon.bindPopup(popupContent);
                  polygon.addTo(primary);
                  bounds.extend(polygon.getBounds());
                  boundaryCount++;
                }
              } catch (error) {
                console.error('Error drawing CA State Parks Boundary polygon:', error);
              }
            }
          });
          
          if (boundaryCount > 0) {
            if (!legendAccumulator['ca_state_parks_boundaries']) {
              legendAccumulator['ca_state_parks_boundaries'] = {
                icon: '🏞️',
                color: '#10b981',
                title: 'CA State Parks Boundaries',
                count: 0,
              };
            }
            legendAccumulator['ca_state_parks_boundaries'].count += boundaryCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA State Parks Boundaries:', error);
      }

      // Draw CA State Parks Campgrounds
      try {
        if (enrichments.ca_state_parks_campgrounds_all && Array.isArray(enrichments.ca_state_parks_campgrounds_all)) {
          let campgroundCount = 0;
          enrichments.ca_state_parks_campgrounds_all.forEach((campground: any) => {
            if (campground.geometry && campground.geometry.x && campground.geometry.y) {
              try {
                const lat = campground.geometry.y;
                const lon = campground.geometry.x;
                
                const name = campground.name || campground.NAME || campground.Name || 'Unknown Campground';
                const unitName = campground.unitName || campground.UNITNAME || campground.unitName || null;
                const type = campground.type || campground.TYPE || campground.Type || null;
                const subType = campground.subType || campground.SUBTYPE || campground.subType || null;
                const useType = campground.useType || campground.USETYPE || campground.useType || null;
                const distance = campground.distance_miles !== null && campground.distance_miles !== undefined ? campground.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('⛺', '#f59e0b')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      ⛺ ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${unitName ? `<div><strong>Park Unit:</strong> ${unitName}</div>` : ''}
                      ${type ? `<div><strong>Type:</strong> ${type}</div>` : ''}
                      ${subType ? `<div><strong>Sub Type:</strong> ${subType}</div>` : ''}
                      ${useType ? `<div><strong>Use Type:</strong> ${useType}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                campgroundCount++;
              } catch (error) {
                console.error('Error drawing CA State Parks Campground:', error);
              }
            }
          });
          
          if (campgroundCount > 0) {
            if (!legendAccumulator['ca_state_parks_campgrounds']) {
              legendAccumulator['ca_state_parks_campgrounds'] = {
                icon: '⛺',
                color: '#f59e0b',
                title: 'CA State Parks Campgrounds',
                count: 0,
              };
            }
            legendAccumulator['ca_state_parks_campgrounds'].count += campgroundCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA State Parks Campgrounds:', error);
      }

      // Draw CA State Parks Recreational Routes as polylines on the map
      try {
        if (enrichments.ca_state_parks_recreational_routes_all && Array.isArray(enrichments.ca_state_parks_recreational_routes_all)) {
          let routeCount = 0;
          enrichments.ca_state_parks_recreational_routes_all.forEach((route: any) => {
            if (route.geometry && route.geometry.paths) {
              try {
                // Convert ESRI polyline paths to Leaflet LatLng arrays
                const paths = route.geometry.paths;
                if (paths && paths.length > 0) {
                  routeCount++;
                  // For each path in the polyline, create a separate polyline
                  paths.forEach((path: number[][]) => {
                    const latlngs = path.map((coord: number[]) => {
                      // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                      // Since we requested outSR=4326, coordinates should already be in WGS84
                      // Convert [lon, lat] to [lat, lon] for Leaflet
                      return [coord[1], coord[0]] as [number, number];
                    });

                    const routeName = route.routeName || route.ROUTENAME || route.RouteName || route.NAME || route.name || 'Unknown Route';
                    const routeClass = route.routeClass || route.ROUTECLASS || route.RouteClass || null;
                    const routeCategory = route.routeCategory || route.ROUTECAT || route.RouteCat || route.routeCat || null;
                    const routeType = route.routeType || route.ROUTETYPE || route.RouteType || null;
                    const unitName = route.unitName || route.UNITNAME || route.UnitName || null;
                    const segmentLength = route.segmentLength || route.SEGLNGTH || route.segLngth || route.Shape_Length || route.shape_length || null;
                    const share = route.share || route.SHARE || route.Share || null;
                    const routeDescription = route.routeDescription || route.ROUTEDES || route.routeDes || null;
                    const trailDescription = route.trailDescription || route.TRAILDES || route.trailDes || null;
                    const distance = route.distance_miles !== null && route.distance_miles !== undefined ? route.distance_miles : 0;

                    // Create polyline with green color for recreational routes
                    const polyline = L.polyline(latlngs, {
                      color: '#fbbf24', // Yellow color for recreational routes (better visibility on imagery basemap)
                      weight: 3,
                      opacity: 0.8,
                      smoothFactor: 1
                    });

                    // Build popup content with all route attributes
                    let popupContent = `
                      <div style="min-width: 250px; max-width: 400px;">
                        <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                          🛤️ ${routeName}
                        </h3>
                        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                          ${unitName ? `<div><strong>Park Unit:</strong> ${unitName}</div>` : ''}
                          ${routeClass ? `<div><strong>Class:</strong> ${routeClass}</div>` : ''}
                          ${routeCategory ? `<div><strong>Category:</strong> ${routeCategory}</div>` : ''}
                          ${routeType ? `<div><strong>Type:</strong> ${routeType}</div>` : ''}
                          ${segmentLength !== null && segmentLength !== undefined ? `<div><strong>Segment Length:</strong> ${segmentLength.toFixed(2)} meters</div>` : ''}
                          ${share ? `<div><strong>Share:</strong> ${share}</div>` : ''}
                          ${routeDescription ? `<div><strong>Route Description:</strong> ${routeDescription}</div>` : ''}
                          ${trailDescription ? `<div><strong>Trail Description:</strong> ${trailDescription}</div>` : ''}
                          ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                    `;
                    
                    // Add all route attributes (excluding internal fields)
                    const excludeFields = ['routeName', 'routeClass', 'routeCategory', 'routeType', 'unitName', 'segmentLength', 'share', 'routeDescription', 'trailDescription', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID', 'ROUTENAME', 'ROUTECLASS', 'ROUTECAT', 'ROUTETYPE', 'UNITNAME', 'SEGLNGTH', 'SHARE', 'ROUTEDES', 'TRAILDES'];
                    Object.entries(route).forEach(([key, value]) => {
                      if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                        if (typeof value === 'object' && !Array.isArray(value)) {
                          return;
                        }
                        const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        let displayValue = '';
                        
                        if (typeof value === 'object') {
                          displayValue = JSON.stringify(value);
                        } else if (typeof value === 'number') {
                          displayValue = value.toLocaleString();
                        } else {
                          displayValue = String(value);
                        }
                        
                        popupContent += `<div style="margin-bottom: 4px;"><strong>${displayKey}:</strong> ${displayValue}</div>`;
                      }
                    });
                    
                    popupContent += `
                        </div>
                      </div>
                    `;
                    
                    polyline.bindPopup(popupContent, { maxWidth: 400 });
                    polyline.addTo(poi);
                    bounds.extend(polyline.getBounds());
                  });
                }
              } catch (error) {
                console.error('Error drawing CA State Parks Recreational Route polyline:', error);
              }
            }
          });
          
          if (routeCount > 0) {
            if (!legendAccumulator['ca_state_parks_recreational_routes']) {
              legendAccumulator['ca_state_parks_recreational_routes'] = {
                icon: '🛤️',
                color: '#fbbf24',
                title: 'CA State Parks Recreational Routes',
                count: 0,
              };
            }
            legendAccumulator['ca_state_parks_recreational_routes'].count += routeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA State Parks Recreational Routes:', error);
      }

      // Draw CA Condor Range as polygons on the map
      try {
        if (enrichments.ca_condor_range_all && Array.isArray(enrichments.ca_condor_range_all)) {
          let rangeCount = 0;
          enrichments.ca_condor_range_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const shapeName = range.shapeName || range.Shape_Name || range.ShapeName || 'Unknown Range';
                  const commonName = range.commonName || range.CName || range.cname || null;
                  const scientificName = range.scientificName || range.SName || range.sname || null;
                  const symbol = range.symbol || range.Symbol || null;
                  const occYears = range.occYears || range.Occ_Years || range.OccYears || null;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#7c3aed',
                    fillColor: '#7c3aed',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #7c3aed;">🦅 ${shapeName}</h3>
                  `;
                  
                  if (commonName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Common Name:</strong> ${commonName}</p>`;
                  }
                  
                  if (scientificName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Scientific Name:</strong> ${scientificName}</p>`;
                  }
                  
                  if (symbol) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Symbol:</strong> ${symbol}</p>`;
                  }
                  
                  if (occYears) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Occurrence Years:</strong> ${occYears}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  // Add all other attributes
                  const allAttributes = { ...range };
                  delete allAttributes.geometry;
                  delete allAttributes.shapeName;
                  delete allAttributes.commonName;
                  delete allAttributes.scientificName;
                  delete allAttributes.symbol;
                  delete allAttributes.occYears;
                  delete allAttributes.distance_miles;
                  delete allAttributes.rangeId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  rangeCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Condor Range polygon:', error);
              }
            }
          });
          
          if (rangeCount > 0) {
            if (!legendAccumulator['ca_condor_range']) {
              legendAccumulator['ca_condor_range'] = {
                icon: '🦅',
                color: '#7c3aed',
                title: 'CA Condor Range',
                count: 0,
              };
            }
            legendAccumulator['ca_condor_range'].count += rangeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Condor Range:', error);
      }

      // Draw CA Black Bear Range as polygons on the map
      try {
        if (enrichments.ca_black_bear_range_all && Array.isArray(enrichments.ca_black_bear_range_all)) {
          let rangeCount = 0;
          enrichments.ca_black_bear_range_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const shapeName = range.shapeName || range.Shape_Name || range.ShapeName || 'Unknown Range';
                  const commonName = range.commonName || range.CName || range.cname || null;
                  const scientificName = range.scientificName || range.SName || range.sname || null;
                  const symbol = range.symbol || range.Symbol || null;
                  const occYears = range.occYears || range.Occ_Years || range.OccYears || null;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#1f2937',
                    fillColor: '#1f2937',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #1f2937;">🐻 ${shapeName}</h3>
                  `;
                  
                  if (commonName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Common Name:</strong> ${commonName}</p>`;
                  }
                  
                  if (scientificName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Scientific Name:</strong> ${scientificName}</p>`;
                  }
                  
                  if (symbol) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Symbol:</strong> ${symbol}</p>`;
                  }
                  
                  if (occYears) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Occurrence Years:</strong> ${occYears}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  const allAttributes = { ...range };
                  delete allAttributes.geometry;
                  delete allAttributes.shapeName;
                  delete allAttributes.commonName;
                  delete allAttributes.scientificName;
                  delete allAttributes.symbol;
                  delete allAttributes.occYears;
                  delete allAttributes.distance_miles;
                  delete allAttributes.rangeId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  rangeCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Black Bear Range polygon:', error);
              }
            }
          });
          
          if (rangeCount > 0) {
            if (!legendAccumulator['ca_black_bear_range']) {
              legendAccumulator['ca_black_bear_range'] = {
                icon: '🐻',
                color: '#1f2937',
                title: 'CA Black Bear Range',
                count: 0,
              };
            }
            legendAccumulator['ca_black_bear_range'].count += rangeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Black Bear Range:', error);
      }

      // Draw CA Brush Rabbit Range as polygons on the map
      try {
        if (enrichments.ca_brush_rabbit_range_all && Array.isArray(enrichments.ca_brush_rabbit_range_all)) {
          let rangeCount = 0;
          enrichments.ca_brush_rabbit_range_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const shapeName = range.shapeName || range.Shape_Name || range.ShapeName || 'Unknown Range';
                  const commonName = range.commonName || range.CName || range.cname || null;
                  const scientificName = range.scientificName || range.SName || range.sname || null;
                  const symbol = range.symbol || range.Symbol || null;
                  const occYears = range.occYears || range.Occ_Years || range.OccYears || null;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#92400e',
                    fillColor: '#92400e',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #92400e;">🐰 ${shapeName}</h3>
                  `;
                  
                  if (commonName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Common Name:</strong> ${commonName}</p>`;
                  }
                  
                  if (scientificName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Scientific Name:</strong> ${scientificName}</p>`;
                  }
                  
                  if (symbol) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Symbol:</strong> ${symbol}</p>`;
                  }
                  
                  if (occYears) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Occurrence Years:</strong> ${occYears}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  const allAttributes = { ...range };
                  delete allAttributes.geometry;
                  delete allAttributes.shapeName;
                  delete allAttributes.commonName;
                  delete allAttributes.scientificName;
                  delete allAttributes.symbol;
                  delete allAttributes.occYears;
                  delete allAttributes.distance_miles;
                  delete allAttributes.rangeId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  rangeCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Brush Rabbit Range polygon:', error);
              }
            }
          });
          
          if (rangeCount > 0) {
            if (!legendAccumulator['ca_brush_rabbit_range']) {
              legendAccumulator['ca_brush_rabbit_range'] = {
                icon: '🐰',
                color: '#92400e',
                title: 'CA Brush Rabbit Range',
                count: 0,
              };
            }
            legendAccumulator['ca_brush_rabbit_range'].count += rangeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Brush Rabbit Range:', error);
      }

      // Draw CA Great Gray Owl Range as polygons on the map
      try {
        if (enrichments.ca_great_gray_owl_range_all && Array.isArray(enrichments.ca_great_gray_owl_range_all)) {
          let rangeCount = 0;
          enrichments.ca_great_gray_owl_range_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const shapeName = range.shapeName || range.Shape_Name || range.ShapeName || 'Unknown Range';
                  const commonName = range.commonName || range.CName || range.cname || null;
                  const scientificName = range.scientificName || range.SName || range.sname || null;
                  const symbol = range.symbol || range.Symbol || null;
                  const occYears = range.occYears || range.Occ_Years || range.OccYears || null;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#374151',
                    fillColor: '#374151',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #374151;">🦉 ${shapeName}</h3>
                  `;
                  
                  if (commonName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Common Name:</strong> ${commonName}</p>`;
                  }
                  
                  if (scientificName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Scientific Name:</strong> ${scientificName}</p>`;
                  }
                  
                  if (symbol) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Symbol:</strong> ${symbol}</p>`;
                  }
                  
                  if (occYears) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Occurrence Years:</strong> ${occYears}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  const allAttributes = { ...range };
                  delete allAttributes.geometry;
                  delete allAttributes.shapeName;
                  delete allAttributes.commonName;
                  delete allAttributes.scientificName;
                  delete allAttributes.symbol;
                  delete allAttributes.occYears;
                  delete allAttributes.distance_miles;
                  delete allAttributes.rangeId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  rangeCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Great Gray Owl Range polygon:', error);
              }
            }
          });
          
          if (rangeCount > 0) {
            if (!legendAccumulator['ca_great_gray_owl_range']) {
              legendAccumulator['ca_great_gray_owl_range'] = {
                icon: '🦉',
                color: '#374151',
                title: 'CA Great Gray Owl Range',
                count: 0,
              };
            }
            legendAccumulator['ca_great_gray_owl_range'].count += rangeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Great Gray Owl Range:', error);
      }

      // Draw CA Sandhill Crane Range as polygons on the map
      try {
        if (enrichments.ca_sandhill_crane_range_all && Array.isArray(enrichments.ca_sandhill_crane_range_all)) {
          let rangeCount = 0;
          enrichments.ca_sandhill_crane_range_all.forEach((range: any) => {
            if (range.geometry && range.geometry.rings) {
              try {
                const rings = range.geometry.rings;
                if (rings && rings.length > 0) {
                  const outerRing = rings[0];
                  const latLngs = outerRing.map((coord: number[]) => [coord[1], coord[0]]);
                  
                  const shapeName = range.shapeName || range.Shape_Name || range.ShapeName || 'Unknown Range';
                  const commonName = range.commonName || range.CName || range.cname || null;
                  const scientificName = range.scientificName || range.SName || range.sname || null;
                  const symbol = range.symbol || range.Symbol || null;
                  const occYears = range.occYears || range.Occ_Years || range.OccYears || null;
                  const distance = range.distance_miles !== null && range.distance_miles !== undefined ? range.distance_miles : 0;
                  
                  const polygon = L.polygon(latLngs, {
                    color: '#059669',
                    fillColor: '#059669',
                    fillOpacity: 0.3,
                    weight: 2
                  });
                  
                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 10px 0; font-weight: bold; color: #059669;">🦩 ${shapeName}</h3>
                  `;
                  
                  if (commonName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Common Name:</strong> ${commonName}</p>`;
                  }
                  
                  if (scientificName) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Scientific Name:</strong> ${scientificName}</p>`;
                  }
                  
                  if (symbol) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Symbol:</strong> ${symbol}</p>`;
                  }
                  
                  if (occYears) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Occurrence Years:</strong> ${occYears}</p>`;
                  }
                  
                  if (distance > 0) {
                    popupContent += `<p style="margin: 5px 0;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</p>`;
                  }
                  
                  const allAttributes = { ...range };
                  delete allAttributes.geometry;
                  delete allAttributes.shapeName;
                  delete allAttributes.commonName;
                  delete allAttributes.scientificName;
                  delete allAttributes.symbol;
                  delete allAttributes.occYears;
                  delete allAttributes.distance_miles;
                  delete allAttributes.rangeId;
                  
                  const remainingAttributes = Object.entries(allAttributes)
                    .filter(([, value]) => value !== null && value !== undefined && value !== '')
                    .map(([attrKey, attrValue]) => `<p style="margin: 5px 0;"><strong>${formatPopupFieldName(attrKey)}:</strong> ${attrValue}</p>`)
                    .join('');
                  
                  if (remainingAttributes) {
                    popupContent += remainingAttributes;
                  }
                  
                  popupContent += `</div>`;
                  
                  polygon.bindPopup(popupContent);
                  polygon.addTo(map);
                  rangeCount++;
                }
              } catch (error) {
                console.error('Error drawing CA Sandhill Crane Range polygon:', error);
              }
            }
          });
          
          if (rangeCount > 0) {
            if (!legendAccumulator['ca_sandhill_crane_range']) {
              legendAccumulator['ca_sandhill_crane_range'] = {
                icon: '🦩',
                color: '#059669',
                title: 'CA Sandhill Crane Range',
                count: 0,
              };
            }
            legendAccumulator['ca_sandhill_crane_range'].count += rangeCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Sandhill Crane Range:', error);
      }

      // Draw CA Highway Rest Areas as point markers on the map
      try {
        if (enrichments.ca_highway_rest_areas_all && Array.isArray(enrichments.ca_highway_rest_areas_all)) {
          let restAreaCount = 0;
          enrichments.ca_highway_rest_areas_all.forEach((restArea: any) => {
            if (restArea.geometry && restArea.geometry.x && restArea.geometry.y) {
              try {
                const lat = restArea.geometry.y;
                const lon = restArea.geometry.x;
                
                const name = restArea.name || restArea.Name || restArea.NAME || restArea.REST_AREA_NAME || restArea.rest_area_name || 'Unknown Rest Area';
                const route = restArea.route || restArea.Route || restArea.ROUTE || null;
                const direction = restArea.direction || restArea.Direction || restArea.DIRECTION || null;
                const county = restArea.county || restArea.County || restArea.COUNTY || null;
                const city = restArea.city || restArea.City || restArea.CITY || null;
                const amenities = restArea.amenities || restArea.Amenities || restArea.AMENITIES || null;
                const distance = restArea.distance_miles !== null && restArea.distance_miles !== undefined ? restArea.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🚗', '#dc2626')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🚗 ${name}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${route ? `<div><strong>Route:</strong> ${route}</div>` : ''}
                      ${direction ? `<div><strong>Direction:</strong> ${direction}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${amenities ? `<div><strong>Amenities:</strong> ${amenities}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(map);
                restAreaCount++;
              } catch (error) {
                console.error('Error drawing CA Highway Rest Area marker:', error);
              }
            }
          });
          
          if (restAreaCount > 0) {
            if (!legendAccumulator['ca_highway_rest_areas']) {
              legendAccumulator['ca_highway_rest_areas'] = {
                icon: '🚗',
                color: '#dc2626',
                title: 'CA Highway Rest Areas',
                count: 0,
              };
            }
            legendAccumulator['ca_highway_rest_areas'].count += restAreaCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Highway Rest Areas:', error);
      }

      // Draw CA Marine Oil Terminals as point markers on the map
      try {
        if (enrichments.ca_marine_oil_terminals_all && Array.isArray(enrichments.ca_marine_oil_terminals_all)) {
          let terminalCount = 0;
          enrichments.ca_marine_oil_terminals_all.forEach((terminal: any) => {
            // Check for geometry with x/y (point geometry)
            const lat = terminal.geometry?.y || terminal.latitude || null;
            const lon = terminal.geometry?.x || terminal.longitude || null;
            
            if (lat !== null && lon !== null) {
              try {
                const terminalName = terminal.terminalName || terminal.Terminal_Name || terminal.terminal_name || terminal.NAME || terminal.name || 'Unknown Terminal';
                const wo = terminal.wo || terminal.WO_ || terminal.wo_ || null;
                const woBerthId = terminal.woBerthId || terminal.WO_Berth_ID || terminal.wo_berth_id || null;
                const city = terminal.city || terminal.City || terminal.CITY || null;
                const county = terminal.county || terminal.County || terminal.COUNTY || null;
                const displayName = terminal.displayName || terminal.DisplayName || terminal.display_name || null;
                const distance = terminal.distance_miles !== null && terminal.distance_miles !== undefined ? terminal.distance_miles : 0;
                
                const marker = L.marker([lat, lon], {
                  icon: createPOIIcon('🛢️', '#1f2937')
                });
                
                let popupContent = `
                  <div style="min-width: 250px; max-width: 400px;">
                    <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                      🛢️ ${terminalName}
                    </h3>
                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                      ${displayName ? `<div><strong>Display Name:</strong> ${displayName}</div>` : ''}
                      ${wo ? `<div><strong>WO:</strong> ${wo}</div>` : ''}
                      ${woBerthId ? `<div><strong>Berth ID:</strong> ${woBerthId}</div>` : ''}
                      ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                      ${county ? `<div><strong>County:</strong> ${county}</div>` : ''}
                      ${distance > 0 ? `<div style="margin-top: 8px;"><strong>Distance:</strong> ${distance.toFixed(2)} miles</div>` : ''}
                    </div>
                    <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                `;
                
                // Add all terminal attributes (excluding internal fields)
                const excludeFields = ['terminalName', 'terminal_name', 'Terminal_Name', 'wo', 'WO_', 'wo_', 'woBerthId', 'WO_Berth_ID', 'wo_berth_id', 'city', 'City', 'CITY', 'county', 'County', 'COUNTY', 'displayName', 'DisplayName', 'display_name', 'latitude', 'Latitude', 'LATITUDE', 'longitude', 'Longitude', 'LONGITUDE', 'geometry', 'distance_miles', 'FID', 'fid', 'OBJECTID', 'objectid', 'GlobalID'];
                Object.entries(terminal).forEach(([key, value]) => {
                  if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                    if (typeof value === 'object' && !Array.isArray(value)) {
                      return;
                    }
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                    popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                  }
                });
                
                popupContent += `
                    </div>
                  </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(primary);
                bounds.extend([lat, lon]);
                terminalCount++;
              } catch (error) {
                console.error('Error drawing CA Marine Oil Terminal marker:', error);
              }
            }
          });
          
          if (terminalCount > 0) {
            if (!legendAccumulator['ca_marine_oil_terminals']) {
              legendAccumulator['ca_marine_oil_terminals'] = {
                icon: '🛢️',
                color: '#1f2937',
                title: 'CA Marine Oil Terminals',
                count: 0,
              };
            }
            legendAccumulator['ca_marine_oil_terminals'].count += terminalCount;
          }
        }
      } catch (error) {
        console.error('Error processing CA Marine Oil Terminals:', error);
      }

      // Draw Tornado Tracks 1950-2017 as polylines (ESRI geometry.paths)
      try {
        const tornadoKey = 'tornado_tracks_1950_2017_all';
        if (enrichments[tornadoKey] && Array.isArray(enrichments[tornadoKey])) {
          // Ensure tornado tracks sit above the basemap and are easy to tap
          try {
            const map = mapInstanceRef.current;
            if (map && !map.getPane('tornadoTracksPane')) {
              const pane = map.createPane('tornadoTracksPane');
              pane.style.zIndex = '680'; // above markerPane(600) and most overlays
            }
          } catch {
            // ignore
          }

          let tornadoCount = 0;
          (enrichments[tornadoKey] as any[]).forEach((track: any) => {
            const geom = track?.geometry;
            if (!geom || !Array.isArray(geom.paths)) return;

            try {
              const paths = geom.paths as number[][][];
              paths.forEach((path: number[][]) => {
                if (!Array.isArray(path) || path.length < 2) return;
                const latlngs = path
                  .filter((coord: any) => Array.isArray(coord) && coord.length >= 2)
                  .map((coord: number[]) => [coord[1], coord[0]] as [number, number]); // [lat, lon]
                if (latlngs.length < 2) return;

                tornadoCount++;
                const polyline = L.polyline(latlngs, {
                  color: '#7c3aed', // purple
                  weight: 6, // easier to tap on mobile
                  opacity: 0.85,
                  interactive: true,
                  bubblingMouseEvents: true,
                  pane: 'tornadoTracksPane',
                });

                const attrs = track?.attributes || {};
                const yr = attrs.yr ?? attrs.YR ?? attrs.Year ?? null;
                const mag = attrs.mag ?? attrs.MAG ?? attrs.Magnitude ?? null;
                const len = attrs.len ?? attrs.LEN ?? attrs.Length ?? null;
                const wid = attrs.wid ?? attrs.WID ?? attrs.Width ?? null;

                const popupContent = `
                  <div style="max-width: 320px;">
                    <div style="font-weight: 700; margin-bottom: 6px;">🌪️ Tornado Track</div>
                    ${yr !== null ? `<div><strong>Year:</strong> ${yr}</div>` : ''}
                    ${mag !== null ? `<div><strong>Magnitude:</strong> ${mag}</div>` : ''}
                    ${len !== null ? `<div><strong>Length (mi):</strong> ${len}</div>` : ''}
                    ${wid !== null ? `<div><strong>Width (yd):</strong> ${wid}</div>` : ''}
                  </div>
                `;
                polyline.bindPopup(popupContent, { maxWidth: 360 });
                // On mobile, Leaflet sometimes doesn't open polyline popups reliably without an explicit handler.
                polyline.on('click', () => polyline.openPopup());
                polyline.on('touchstart', () => polyline.openPopup());
                polyline.addTo(primary);
                bounds.extend(polyline.getBounds());
              });
            } catch (e) {
              console.error('Error drawing tornado track polyline:', e);
            }
          });

          if (!legendAccumulator['tornado_tracks_1950_2017']) {
            legendAccumulator['tornado_tracks_1950_2017'] = {
              icon: '🌪️',
              color: '#7c3aed',
              title: 'Tornado Tracks 1950-2017',
              count: 0,
            };
          }
          legendAccumulator['tornado_tracks_1950_2017'].count += tornadoCount;
        }
      } catch (error) {
        console.error('Error processing Tornado Tracks:', error);
      }

      // Draw NRI Hurricane Annualized Frequency layers (County + Census Tract) as polygons
      try {
        const pointInPolygon = (point: L.LatLng, poly: L.LatLng[]): boolean => {
          // Ray casting algorithm
          let inside = false;
          for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].lng, yi = poly[i].lat;
            const xj = poly[j].lng, yj = poly[j].lat;
            const intersect =
              ((yi > point.lat) !== (yj > point.lat)) &&
              (point.lng < (xj - xi) * (point.lat - yi) / (yj - yi + 0.0) + xi);
            if (intersect) inside = !inside;
          }
          return inside;
        };

        // Compare two polygon rings to see if they have the same geometry (within tolerance)
        // Handles cases where coordinates might be in different order or slightly offset
        const polygonsHaveSameGeometry = (
          ring1: Array<{ lat: number; lng: number }>, 
          ring2: Array<{ lat: number; lng: number }>, 
          tolerance = 0.0001
        ): boolean => {
          if (!ring1 || !ring2) return false;
          if (ring1.length !== ring2.length) return false;
          if (ring1.length < 3) return false;
          
          // Try matching from start of ring1
          let matchForward = true;
          for (let i = 0; i < ring1.length; i++) {
            const latDiff = Math.abs(ring1[i].lat - ring2[i].lat);
            const lngDiff = Math.abs(ring1[i].lng - ring2[i].lng);
            if (latDiff > tolerance || lngDiff > tolerance) {
              matchForward = false;
              break;
            }
          }
          if (matchForward) return true;
          
          // Try matching in reverse order (rings might be reversed)
          let matchReverse = true;
          for (let i = 0; i < ring1.length; i++) {
            const j = ring2.length - 1 - i;
            const latDiff = Math.abs(ring1[i].lat - ring2[j].lat);
            const lngDiff = Math.abs(ring1[i].lng - ring2[j].lng);
            if (latDiff > tolerance || lngDiff > tolerance) {
              matchReverse = false;
              break;
            }
          }
          if (matchReverse) return true;
          
          // Try matching with offset (rings might start at different points)
          for (let offset = 1; offset < ring1.length; offset++) {
            let matchOffset = true;
            for (let i = 0; i < ring1.length; i++) {
              const j = (i + offset) % ring2.length;
              const latDiff = Math.abs(ring1[i].lat - ring2[j].lat);
              const lngDiff = Math.abs(ring1[i].lng - ring2[j].lng);
              if (latDiff > tolerance || lngDiff > tolerance) {
                matchOffset = false;
                break;
              }
            }
            if (matchOffset) return true;
          }
          
          return false;
        };

        const nriPopupEntries: Array<{
          polygon: L.Polygon;
          title: string;
          icon: string;
          color: string;
          feature: any;
          originalRing: Array<{ lat: number; lng: number }>;
        }> = [];

        const nriLayers = [
          {
            key: 'nri_hurricane_annualized_frequency_county_all',
            title: 'NRI Hurricane Annualized Frequency (County)',
            icon: '🌀',
            color: '#2563eb',
            legendKey: 'nri_hurricane_annualized_frequency_county',
          },
          {
            key: 'nri_hurricane_annualized_frequency_census_tract_all',
            title: 'NRI Hurricane Annualized Frequency (Census Tract)',
            icon: '🌀',
            color: '#1d4ed8',
            legendKey: 'nri_hurricane_annualized_frequency_census_tract',
          },
          {
            key: 'nri_hail_annualized_frequency_county_all',
            title: 'NRI Hail Annualized Frequency (County)',
            icon: '🌨️',
            color: '#0ea5e9',
            legendKey: 'nri_hail_annualized_frequency_county',
          },
          {
            key: 'nri_hail_annualized_frequency_census_tract_all',
            title: 'NRI Hail Annualized Frequency (Census Tract)',
            icon: '🌨️',
            color: '#0284c7',
            legendKey: 'nri_hail_annualized_frequency_census_tract',
          },
          {
            key: 'nri_tornado_annualized_frequency_county_all',
            title: 'NRI Tornado Annualized Frequency (County)',
            icon: '🌪️',
            color: '#7c3aed',
            legendKey: 'nri_tornado_annualized_frequency_county',
          },
          {
            key: 'nri_tornado_annualized_frequency_census_tract_all',
            title: 'NRI Tornado Annualized Frequency (Census Tract)',
            icon: '🌪️',
            color: '#6d28d9',
            legendKey: 'nri_tornado_annualized_frequency_census_tract',
          },
          {
            key: 'nri_earthquake_annualized_frequency_county_all',
            title: 'NRI Earthquake Annualized Frequency (County)',
            icon: '🌎',
            color: '#b45309',
            legendKey: 'nri_earthquake_annualized_frequency_county',
          },
          {
            key: 'nri_earthquake_annualized_frequency_census_tract_all',
            title: 'NRI Earthquake Annualized Frequency (Census Tract)',
            icon: '🌎',
            color: '#92400e',
            legendKey: 'nri_earthquake_annualized_frequency_census_tract',
          },
          {
            key: 'nri_drought_annualized_frequency_county_all',
            title: 'NRI Drought Annualized Frequency (County)',
            icon: '☀️',
            color: '#ca8a04',
            legendKey: 'nri_drought_annualized_frequency_county',
          },
          {
            key: 'nri_drought_annualized_frequency_census_tract_all',
            title: 'NRI Drought Annualized Frequency (Census Tract)',
            icon: '☀️',
            color: '#a16207',
            legendKey: 'nri_drought_annualized_frequency_census_tract',
          },
          {
            key: 'nri_wildfire_annualized_frequency_county_all',
            title: 'NRI Wildfire Annualized Frequency (County)',
            icon: '🔥',
            color: '#dc2626',
            legendKey: 'nri_wildfire_annualized_frequency_county',
          },
          {
            key: 'nri_wildfire_annualized_frequency_census_tract_all',
            title: 'NRI Wildfire Annualized Frequency (Census Tract)',
            icon: '🔥',
            color: '#b91c1c',
            legendKey: 'nri_wildfire_annualized_frequency_census_tract',
          },
          {
            key: 'nri_lightning_annualized_frequency_county_all',
            title: 'NRI Lightning Annualized Frequency (County)',
            icon: '⚡',
            color: '#fbbf24',
            legendKey: 'nri_lightning_annualized_frequency_county',
          },
          {
            key: 'nri_lightning_annualized_frequency_census_tract_all',
            title: 'NRI Lightning Annualized Frequency (Census Tract)',
            icon: '⚡',
            color: '#f59e0b',
            legendKey: 'nri_lightning_annualized_frequency_census_tract',
          },
          {
            key: 'nri_ice_storm_annualized_frequency_county_all',
            title: 'NRI Ice Storm Annualized Frequency (County)',
            icon: '🧊',
            color: '#60a5fa',
            legendKey: 'nri_ice_storm_annualized_frequency_county',
          },
          {
            key: 'nri_ice_storm_annualized_frequency_census_tract_all',
            title: 'NRI Ice Storm Annualized Frequency (Census Tract)',
            icon: '🧊',
            color: '#3b82f6',
            legendKey: 'nri_ice_storm_annualized_frequency_census_tract',
          },
          {
            key: 'nri_coastal_flooding_annualized_frequency_county_all',
            title: 'NRI Coastal Flooding Annualized Frequency (County)',
            icon: '🌊',
            color: '#06b6d4',
            legendKey: 'nri_coastal_flooding_annualized_frequency_county',
          },
          {
            key: 'nri_coastal_flooding_annualized_frequency_census_tract_all',
            title: 'NRI Coastal Flooding Annualized Frequency (Census Tract)',
            icon: '🌊',
            color: '#0891b2',
            legendKey: 'nri_coastal_flooding_annualized_frequency_census_tract',
          },
          {
            key: 'nri_riverine_flooding_annualized_frequency_county_all',
            title: 'NRI Riverine Flooding Annualized Frequency (County)',
            icon: '💧',
            color: '#0ea5e9',
            legendKey: 'nri_riverine_flooding_annualized_frequency_county',
          },
          {
            key: 'nri_riverine_flooding_annualized_frequency_census_tract_all',
            title: 'NRI Riverine Flooding Annualized Frequency (Census Tract)',
            icon: '💧',
            color: '#0284c7',
            legendKey: 'nri_riverine_flooding_annualized_frequency_census_tract',
          },
          {
            key: 'nri_landslide_annualized_frequency_county_all',
            title: 'NRI Landslide Annualized Frequency (County)',
            icon: '⛰️',
            color: '#78716c',
            legendKey: 'nri_landslide_annualized_frequency_county',
          },
          {
            key: 'nri_landslide_annualized_frequency_census_tract_all',
            title: 'NRI Landslide Annualized Frequency (Census Tract)',
            icon: '⛰️',
            color: '#57534e',
            legendKey: 'nri_landslide_annualized_frequency_census_tract',
          },
          {
            key: 'nri_strong_wind_annualized_frequency_county_all',
            title: 'NRI Strong Wind Annualized Frequency (County)',
            icon: '💨',
            color: '#a3a3a3',
            legendKey: 'nri_strong_wind_annualized_frequency_county',
          },
          {
            key: 'nri_strong_wind_annualized_frequency_census_tract_all',
            title: 'NRI Strong Wind Annualized Frequency (Census Tract)',
            icon: '💨',
            color: '#737373',
            legendKey: 'nri_strong_wind_annualized_frequency_census_tract',
          },
          {
            key: 'nri_winter_weather_annualized_frequency_county_all',
            title: 'NRI Winter Weather Annualized Frequency (County)',
            icon: '❄️',
            color: '#e0e7ff',
            legendKey: 'nri_winter_weather_annualized_frequency_county',
          },
          {
            key: 'nri_winter_weather_annualized_frequency_census_tract_all',
            title: 'NRI Winter Weather Annualized Frequency (Census Tract)',
            icon: '❄️',
            color: '#c7d2fe',
            legendKey: 'nri_winter_weather_annualized_frequency_census_tract',
          },
          {
            key: 'nri_cold_wave_annualized_frequency_county_all',
            title: 'NRI Cold Wave Annualized Frequency (County)',
            icon: '🧊',
            color: '#bfdbfe',
            legendKey: 'nri_cold_wave_annualized_frequency_county',
          },
          {
            key: 'nri_cold_wave_annualized_frequency_census_tract_all',
            title: 'NRI Cold Wave Annualized Frequency (Census Tract)',
            icon: '🧊',
            color: '#93c5fd',
            legendKey: 'nri_cold_wave_annualized_frequency_census_tract',
          },
          {
            key: 'nri_heat_wave_annualized_frequency_county_all',
            title: 'NRI Heat Wave Annualized Frequency (County)',
            icon: '🌡️',
            color: '#f87171',
            legendKey: 'nri_heat_wave_annualized_frequency_county',
          },
          {
            key: 'nri_heat_wave_annualized_frequency_census_tract_all',
            title: 'NRI Heat Wave Annualized Frequency (Census Tract)',
            icon: '🌡️',
            color: '#ef4444',
            legendKey: 'nri_heat_wave_annualized_frequency_census_tract',
          },
          {
            key: 'nri_avalanche_annualized_frequency_county_all',
            title: 'NRI Avalanche Annualized Frequency (County)',
            icon: '🏔️',
            color: '#cbd5e1',
            legendKey: 'nri_avalanche_annualized_frequency_county',
          },
          {
            key: 'nri_avalanche_annualized_frequency_census_tract_all',
            title: 'NRI Avalanche Annualized Frequency (Census Tract)',
            icon: '🏔️',
            color: '#94a3b8',
            legendKey: 'nri_avalanche_annualized_frequency_census_tract',
          },
          {
            key: 'nri_tsunami_annualized_frequency_county_all',
            title: 'NRI Tsunami Annualized Frequency (County)',
            icon: '🌊',
            color: '#0d9488',
            legendKey: 'nri_tsunami_annualized_frequency_county',
          },
          {
            key: 'nri_tsunami_annualized_frequency_census_tract_all',
            title: 'NRI Tsunami Annualized Frequency (Census Tract)',
            icon: '🌊',
            color: '#0f766e',
            legendKey: 'nri_tsunami_annualized_frequency_census_tract',
          },
          {
            key: 'nri_volcanic_activity_annualized_frequency_county_all',
            title: 'NRI Volcanic Activity Annualized Frequency (County)',
            icon: '🌋',
            color: '#7c2d12',
            legendKey: 'nri_volcanic_activity_annualized_frequency_county',
          },
          {
            key: 'nri_volcanic_activity_annualized_frequency_census_tract_all',
            title: 'NRI Volcanic Activity Annualized Frequency (Census Tract)',
            icon: '🌋',
            color: '#9a3412',
            legendKey: 'nri_volcanic_activity_annualized_frequency_census_tract',
          },
          {
            key: 'nri_avalanche_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Avalanche Hazard Type Risk Index Rating (Census Tract)',
            icon: '🏔️',
            color: '#64748b',
            legendKey: 'nri_avalanche_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_coastal_flooding_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Coastal Flooding Expected Annual Loss Rating (Census Tract)',
            icon: '🌊',
            color: '#0891b2',
            legendKey: 'nri_coastal_flooding_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_coastal_flooding_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Coastal Flooding Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌊',
            color: '#0e7490',
            legendKey: 'nri_coastal_flooding_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_cold_wave_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Cold Wave Expected Annual Loss Rating (Census Tract)',
            icon: '🧊',
            color: '#93c5fd',
            legendKey: 'nri_cold_wave_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_cold_wave_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Cold Wave Hazard Type Risk Index Rating (Census Tract)',
            icon: '🧊',
            color: '#60a5fa',
            legendKey: 'nri_cold_wave_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_drought_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Drought Expected Annual Loss Rating (Census Tract)',
            icon: '☀️',
            color: '#fbbf24',
            legendKey: 'nri_drought_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_drought_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Drought Hazard Type Risk Index Rating (Census Tract)',
            icon: '☀️',
            color: '#f59e0b',
            legendKey: 'nri_drought_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_earthquake_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Earthquake Expected Annual Loss Rating (Census Tract)',
            icon: '🌍',
            color: '#f97316',
            legendKey: 'nri_earthquake_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_earthquake_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Earthquake Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌍',
            color: '#ea580c',
            legendKey: 'nri_earthquake_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_expected_annual_loss_rating_composite_census_tract_all',
            title: 'NRI Expected Annual Loss Rating Composite (Census Tract)',
            icon: '📊',
            color: '#6366f1',
            legendKey: 'nri_expected_annual_loss_rating_composite_census_tract',
          },
          {
            key: 'nri_hail_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Hail Expected Annual Loss Rating (Census Tract)',
            icon: '🌨️',
            color: '#0284c7',
            legendKey: 'nri_hail_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_hail_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Hail Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌨️',
            color: '#0369a1',
            legendKey: 'nri_hail_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_heat_wave_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Heat Wave Expected Annual Loss Rating (Census Tract)',
            icon: '🌡️',
            color: '#ef4444',
            legendKey: 'nri_heat_wave_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_heat_wave_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Heat Wave Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌡️',
            color: '#dc2626',
            legendKey: 'nri_heat_wave_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_ice_storm_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Ice Storm Expected Annual Loss Rating (Census Tract)',
            icon: '🧊',
            color: '#3b82f6',
            legendKey: 'nri_ice_storm_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_ice_storm_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Ice Storm Hazard Type Risk Index Rating (Census Tract)',
            icon: '🧊',
            color: '#2563eb',
            legendKey: 'nri_ice_storm_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_inland_flooding_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Inland Flooding Expected Annual Loss Rating (Census Tract)',
            icon: '💧',
            color: '#0284c7',
            legendKey: 'nri_inland_flooding_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_inland_flooding_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Inland Flooding Hazard Type Risk Index Rating (Census Tract)',
            icon: '💧',
            color: '#0369a1',
            legendKey: 'nri_inland_flooding_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_landslide_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Landslide Expected Annual Loss Rating (Census Tract)',
            icon: '⛰️',
            color: '#57534e',
            legendKey: 'nri_landslide_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_landslide_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Landslide Hazard Type Risk Index Rating (Census Tract)',
            icon: '⛰️',
            color: '#44403c',
            legendKey: 'nri_landslide_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_lightning_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Lightning Expected Annual Loss Rating (Census Tract)',
            icon: '⚡',
            color: '#f59e0b',
            legendKey: 'nri_lightning_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_lightning_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Lightning Hazard Type Risk Index Rating (Census Tract)',
            icon: '⚡',
            color: '#d97706',
            legendKey: 'nri_lightning_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_social_vulnerability_rating_census_tract_all',
            title: 'NRI Social Vulnerability Rating (Census Tract)',
            icon: '👥',
            color: '#8b5cf6',
            legendKey: 'nri_social_vulnerability_rating_census_tract',
          },
          {
            key: 'nri_strong_wind_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Strong Wind Expected Annual Loss Rating (Census Tract)',
            icon: '💨',
            color: '#737373',
            legendKey: 'nri_strong_wind_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_strong_wind_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Strong Wind Hazard Type Risk Index Rating (Census Tract)',
            icon: '💨',
            color: '#525252',
            legendKey: 'nri_strong_wind_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_tornado_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Tornado Expected Annual Loss Rating (Census Tract)',
            icon: '🌪️',
            color: '#7c3aed',
            legendKey: 'nri_tornado_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_tornado_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Tornado Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌪️',
            color: '#6d28d9',
            legendKey: 'nri_tornado_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_tsunami_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Tsunami Expected Annual Loss Rating (Census Tract)',
            icon: '🌊',
            color: '#0f766e',
            legendKey: 'nri_tsunami_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_tsunami_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Tsunami Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌊',
            color: '#0d9488',
            legendKey: 'nri_tsunami_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_volcanic_activity_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Volcanic Activity Expected Annual Loss Rating (Census Tract)',
            icon: '🌋',
            color: '#9a3412',
            legendKey: 'nri_volcanic_activity_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_volcanic_activity_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Volcanic Activity Hazard Type Risk Index Rating (Census Tract)',
            icon: '🌋',
            color: '#7c2d12',
            legendKey: 'nri_volcanic_activity_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_wildfire_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Wildfire Expected Annual Loss Rating (Census Tract)',
            icon: '🔥',
            color: '#b91c1c',
            legendKey: 'nri_wildfire_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_wildfire_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Wildfire Hazard Type Risk Index Rating (Census Tract)',
            icon: '🔥',
            color: '#991b1b',
            legendKey: 'nri_wildfire_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_winter_weather_expected_annual_loss_rating_census_tract_all',
            title: 'NRI Winter Weather Expected Annual Loss Rating (Census Tract)',
            icon: '❄️',
            color: '#c7d2fe',
            legendKey: 'nri_winter_weather_expected_annual_loss_rating_census_tract',
          },
          {
            key: 'nri_winter_weather_hazard_type_risk_index_rating_census_tract_all',
            title: 'NRI Winter Weather Hazard Type Risk Index Rating (Census Tract)',
            icon: '❄️',
            color: '#a5b4fc',
            legendKey: 'nri_winter_weather_hazard_type_risk_index_rating_census_tract',
          },
          {
            key: 'nri_avalanche_expected_annual_loss_rating_county_all',
            title: 'NRI Avalanche Expected Annual Loss Rating (County)',
            icon: '🏔️',
            color: '#475569',
            legendKey: 'nri_avalanche_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_avalanche_hazard_type_risk_index_rating_county_all',
            title: 'NRI Avalanche Hazard Type Risk Index Rating (County)',
            icon: '🏔️',
            color: '#334155',
            legendKey: 'nri_avalanche_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_coastal_flooding_expected_annual_loss_rating_county_all',
            title: 'NRI Coastal Flooding Expected Annual Loss Rating (County)',
            icon: '🌊',
            color: '#0e7490',
            legendKey: 'nri_coastal_flooding_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_coastal_flooding_hazard_type_risk_index_rating_county_all',
            title: 'NRI Coastal Flooding Hazard Type Risk Index Rating (County)',
            icon: '🌊',
            color: '#155e75',
            legendKey: 'nri_coastal_flooding_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_cold_wave_expected_annual_loss_rating_county_all',
            title: 'NRI Cold Wave Expected Annual Loss Rating (County)',
            icon: '🧊',
            color: '#60a5fa',
            legendKey: 'nri_cold_wave_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_cold_wave_hazard_type_risk_index_rating_county_all',
            title: 'NRI Cold Wave Hazard Type Risk Index Rating (County)',
            icon: '🧊',
            color: '#3b82f6',
            legendKey: 'nri_cold_wave_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_community_resilience_rating_county_all',
            title: 'NRI Community Resilience Rating (County)',
            icon: '🏘️',
            color: '#10b981',
            legendKey: 'nri_community_resilience_rating_county',
          },
          {
            key: 'nri_drought_expected_annual_loss_rating_county_all',
            title: 'NRI Drought Expected Annual Loss Rating (County)',
            icon: '☀️',
            color: '#f59e0b',
            legendKey: 'nri_drought_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_drought_hazard_type_risk_index_rating_county_all',
            title: 'NRI Drought Hazard Type Risk Index Rating (County)',
            icon: '☀️',
            color: '#d97706',
            legendKey: 'nri_drought_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_earthquake_expected_annual_loss_rating_county_all',
            title: 'NRI Earthquake Expected Annual Loss Rating (County)',
            icon: '🌍',
            color: '#ea580c',
            legendKey: 'nri_earthquake_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_earthquake_hazard_type_risk_index_rating_county_all',
            title: 'NRI Earthquake Hazard Type Risk Index Rating (County)',
            icon: '🌍',
            color: '#c2410c',
            legendKey: 'nri_earthquake_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_hail_expected_annual_loss_rating_county_all',
            title: 'NRI Hail Expected Annual Loss Rating (County)',
            icon: '🌨️',
            color: '#0369a1',
            legendKey: 'nri_hail_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_hail_hazard_type_risk_index_rating_county_all',
            title: 'NRI Hail Hazard Type Risk Index Rating (County)',
            icon: '🌨️',
            color: '#075985',
            legendKey: 'nri_hail_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_heat_wave_expected_annual_loss_rating_county_all',
            title: 'NRI Heat Wave Expected Annual Loss Rating (County)',
            icon: '🌡️',
            color: '#dc2626',
            legendKey: 'nri_heat_wave_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_heat_wave_hazard_type_risk_index_rating_county_all',
            title: 'NRI Heat Wave Hazard Type Risk Index Rating (County)',
            icon: '🌡️',
            color: '#b91c1c',
            legendKey: 'nri_heat_wave_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_hurricane_expected_annual_loss_rating_county_all',
            title: 'NRI Hurricane Expected Annual Loss Rating (County)',
            icon: '🌀',
            color: '#1d4ed8',
            legendKey: 'nri_hurricane_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_hurricane_hazard_type_risk_index_rating_county_all',
            title: 'NRI Hurricane Hazard Type Risk Index Rating (County)',
            icon: '🌀',
            color: '#1e40af',
            legendKey: 'nri_hurricane_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_ice_storm_expected_annual_loss_rating_county_all',
            title: 'NRI Ice Storm Expected Annual Loss Rating (County)',
            icon: '🧊',
            color: '#2563eb',
            legendKey: 'nri_ice_storm_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_ice_storm_hazard_type_risk_index_rating_county_all',
            title: 'NRI Ice Storm Hazard Type Risk Index Rating (County)',
            icon: '🧊',
            color: '#1e3a8a',
            legendKey: 'nri_ice_storm_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_inland_flooding_expected_annual_loss_rating_county_all',
            title: 'NRI Inland Flooding Expected Annual Loss Rating (County)',
            icon: '💧',
            color: '#0369a1',
            legendKey: 'nri_inland_flooding_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_inland_flooding_hazard_type_risk_index_rating_county_all',
            title: 'NRI Inland Flooding Hazard Type Risk Index Rating (County)',
            icon: '💧',
            color: '#075985',
            legendKey: 'nri_inland_flooding_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_landslide_expected_annual_loss_rating_county_all',
            title: 'NRI Landslide Expected Annual Loss Rating (County)',
            icon: '⛰️',
            color: '#44403c',
            legendKey: 'nri_landslide_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_landslide_hazard_type_risk_index_rating_county_all',
            title: 'NRI Landslide Hazard Type Risk Index Rating (County)',
            icon: '⛰️',
            color: '#292524',
            legendKey: 'nri_landslide_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_lightning_expected_annual_loss_rating_county_all',
            title: 'NRI Lightning Expected Annual Loss Rating (County)',
            icon: '⚡',
            color: '#d97706',
            legendKey: 'nri_lightning_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_national_risk_index_rating_composite_county_all',
            title: 'NRI National Risk Index Rating Composite (County)',
            icon: '📊',
            color: '#6366f1',
            legendKey: 'nri_national_risk_index_rating_composite_county',
          },
          {
            key: 'nri_strong_wind_expected_annual_loss_rating_county_all',
            title: 'NRI Strong Wind Expected Annual Loss Rating (County)',
            icon: '💨',
            color: '#525252',
            legendKey: 'nri_strong_wind_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_strong_wind_hazard_type_risk_index_rating_county_all',
            title: 'NRI Strong Wind Hazard Type Risk Index Rating (County)',
            icon: '💨',
            color: '#404040',
            legendKey: 'nri_strong_wind_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_tornado_expected_annual_loss_rating_county_all',
            title: 'NRI Tornado Expected Annual Loss Rating (County)',
            icon: '🌪️',
            color: '#6d28d9',
            legendKey: 'nri_tornado_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_tornado_hazard_type_risk_index_rating_county_all',
            title: 'NRI Tornado Hazard Type Risk Index Rating (County)',
            icon: '🌪️',
            color: '#5b21b6',
            legendKey: 'nri_tornado_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_tsunami_expected_annual_loss_rating_county_all',
            title: 'NRI Tsunami Expected Annual Loss Rating (County)',
            icon: '🌊',
            color: '#0d9488',
            legendKey: 'nri_tsunami_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_tsunami_hazard_type_risk_index_rating_county_all',
            title: 'NRI Tsunami Hazard Type Risk Index Rating (County)',
            icon: '🌊',
            color: '#0f766e',
            legendKey: 'nri_tsunami_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_volcanic_activity_expected_annual_loss_rating_county_all',
            title: 'NRI Volcanic Activity Expected Annual Loss Rating (County)',
            icon: '🌋',
            color: '#7c2d12',
            legendKey: 'nri_volcanic_activity_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_volcanic_activity_hazard_type_risk_index_rating_county_all',
            title: 'NRI Volcanic Activity Hazard Type Risk Index Rating (County)',
            icon: '🌋',
            color: '#7c2d12',
            legendKey: 'nri_volcanic_activity_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_wildfire_expected_annual_loss_rating_county_all',
            title: 'NRI Wildfire Expected Annual Loss Rating (County)',
            icon: '🔥',
            color: '#991b1b',
            legendKey: 'nri_wildfire_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_wildfire_hazard_type_risk_index_rating_county_all',
            title: 'NRI Wildfire Hazard Type Risk Index Rating (County)',
            icon: '🔥',
            color: '#7f1d1d',
            legendKey: 'nri_wildfire_hazard_type_risk_index_rating_county',
          },
          {
            key: 'nri_winter_weather_expected_annual_loss_rating_county_all',
            title: 'NRI Winter Weather Expected Annual Loss Rating (County)',
            icon: '❄️',
            color: '#a5b4fc',
            legendKey: 'nri_winter_weather_expected_annual_loss_rating_county',
          },
          {
            key: 'nri_winter_weather_hazard_type_risk_index_rating_county_all',
            title: 'NRI Winter Weather Hazard Type Risk Index Rating (County)',
            icon: '❄️',
            color: '#818cf8',
            legendKey: 'nri_winter_weather_hazard_type_risk_index_rating_county',
          },
        ];

        nriLayers.forEach(({ key, title, icon, color, legendKey }) => {
          if (!enrichments[key] || !Array.isArray(enrichments[key])) return;

          let count = 0;
          (enrichments[key] as any[]).forEach((feature: any) => {
            const geometry = feature?.geometry || feature?.__geometry;
            if (!geometry || !Array.isArray(geometry.rings)) return;

            try {
              geometry.rings.forEach((ring: number[][]) => {
                if (!Array.isArray(ring) || ring.length < 3) return;
                const latlngs = ring
                  .filter((coord: any) => Array.isArray(coord) && coord.length >= 2)
                  .map((coord: number[]) => [coord[1], coord[0]] as [number, number]);
                if (latlngs.length < 3) return;

                count++;
                const polygon = L.polygon(latlngs, {
                  color,
                  weight: 2,
                  opacity: 0.9,
                  fillColor: color,
                  fillOpacity: 0.15,
                });

                const attrs = feature?.attributes || {};
                const distance = feature?.distance_miles;
                // Store the original latlngs array for reliable geometry comparison
                const originalLatLngs = latlngs.map(ll => ({ lat: ll[0], lng: ll[1] }));
                
                // Store metadata for tabbed popup system (so it can distinguish between different NRI layers)
                (polygon as any).__layerType = 'nri_annualized_frequency';
                (polygon as any).__layerTitle = title;
                
                nriPopupEntries.push({ 
                  polygon, 
                  title, 
                  icon, 
                  color, 
                  feature: { ...feature, attributes: attrs, distance_miles: distance },
                  originalRing: originalLatLngs // Store original ring for comparison
                });

                // Fallback single-feature popup (so clicking still works even if overlap logic fails)
                const singlePopupContent = `
                  <div style="max-width: 360px;">
                    <div style="font-weight: 700; margin-bottom: 6px;">${icon} ${title}</div>
                    ${distance !== undefined && distance !== null ? `<div><strong>Distance:</strong> ${Number(distance).toFixed(2)} miles</div>` : ''}
                    <details style="margin-top: 6px;">
                      <summary style="cursor: pointer; color: #111827;">Attributes</summary>
                      <pre style="white-space: pre-wrap; word-break: break-word; margin: 6px 0 0 0; font-size: 12px; color: #374151;">${JSON.stringify(attrs, null, 2)}</pre>
                    </details>
                  </div>
                `;
                polygon.bindPopup(singlePopupContent, { maxWidth: 420 });

                polygon.on('click', (e: any) => {
                  const clickPoint: L.LatLng = e.latlng;
                  const leafletMap = mapInstanceRef.current;
                  if (!leafletMap) {
                    // If map isn't available for some reason, fall back to the bound popup
                    polygon.openPopup();
                    return;
                  }

                  const tabGroupId = `nri-tabs-${Date.now()}-${Math.random().toString(16).slice(2)}`;

                  // Step 1: Find all entries whose bounds contain the click point
                  const candidatesWithClickPoint: typeof nriPopupEntries = [];
                  nriPopupEntries.forEach((entry) => {
                    if (entry.polygon.getBounds().contains(clickPoint)) {
                      candidatesWithClickPoint.push(entry);
                    }
                  });

                  // Step 2: For each candidate, find ALL entries that have the same geometry
                  // This ensures we catch all layers (Hail, Wildfire, etc.) that share the same county geometry
                  const allMatches = new Set<typeof nriPopupEntries[0]>();
                  
                  candidatesWithClickPoint.forEach((candidate) => {
                    // Add the candidate itself
                    allMatches.add(candidate);
                    
                    // Find all other entries with the same geometry
                    const candidateRing = candidate.originalRing;
                    nriPopupEntries.forEach((entry) => {
                      if (allMatches.has(entry)) return; // Already included
                      if (entry.originalRing.length !== candidateRing.length) return;
                      
                      // Compare geometries
                      if (polygonsHaveSameGeometry(entry.originalRing, candidateRing)) {
                        allMatches.add(entry);
                      }
                    });
                  });

                  // Step 3: If no matches found via geometry comparison, fall back to point-in-polygon
                  if (allMatches.size === 0) {
                    nriPopupEntries.forEach((entry) => {
                      if (!entry.polygon.getBounds().contains(clickPoint)) return;
                      const ringLatLngs = entry.originalRing.map(ll => new L.LatLng(ll.lat, ll.lng));
                      if (!ringLatLngs || ringLatLngs.length < 3) return;
                      if (pointInPolygon(clickPoint, ringLatLngs)) {
                        allMatches.add(entry);
                      }
                    });
                  }

                  const matches = Array.from(allMatches)
                    .map((entry, idx) => {
                      const dist = entry.feature?.distance_miles;
                      const attrs2 = entry.feature?.attributes || {};
                      const tabId = `${tabGroupId}-tab-${idx}`;
                      const radioId = `${tabGroupId}-radio-${idx}`;
                      const checked = idx === 0 ? 'checked' : '';
                      return {
                        tabId,
                        radioId,
                        checked,
                        title: `${entry.icon} ${entry.title}`,
                        color: entry.color,
                        dist,
                        attrs: attrs2,
                      };
                    });

                  const content = matches.length
                    ? (() => {
                        const tabsCss = `
                          <style>
                            .nri-tabs { max-width: 460px; }
                            .nri-tab-labels { display:flex; flex-wrap:wrap; gap:6px; margin: 8px 0; }
                            .nri-tab-label { padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; cursor:pointer; font-size:12px; background:#fff; }
                            .nri-tab-label:hover { background:#f9fafb; }
                            .nri-tab-panel { display:none; border-top:1px solid #e5e7eb; padding-top:8px; margin-top:8px; }
                            .nri-tab-radio { display:none; }
                            .nri-tab-radio:checked + label { border-color:#111827; box-shadow: 0 0 0 2px rgba(17,24,39,0.12); }
                          </style>
                        `;

                        const labels = matches.map((m) => `
                          <input class="nri-tab-radio" type="radio" name="${tabGroupId}" id="${m.radioId}" ${m.checked}/>
                          <label class="nri-tab-label" for="${m.radioId}" style="border-left:4px solid ${m.color};">
                            ${m.title}
                          </label>
                        `).join('');

                        const panels = matches.map((m) => `
                          <div class="nri-tab-panel" id="${m.tabId}">
                            <div style="font-weight:700; margin-bottom:6px;">${m.title}</div>
                            ${m.dist !== undefined && m.dist !== null ? `<div><strong>Distance:</strong> ${Number(m.dist).toFixed(2)} miles</div>` : ''}
                            <details style="margin-top: 6px;">
                              <summary style="cursor:pointer; color:#111827;">Attributes</summary>
                              <pre style="white-space: pre-wrap; word-break: break-word; margin: 6px 0 0 0; font-size: 12px; color: #374151;">${JSON.stringify(m.attrs, null, 2)}</pre>
                            </details>
                          </div>
                        `).join('');

                        // Simple JS-less panel toggle using :checked isn't possible without heavier CSS selectors inside Leaflet popup.
                        // Instead, we render all panels and hide/show via a tiny inline onChange handler.
                        const script = `
                          <script>
                            (function() {
                              const radios = document.querySelectorAll('input[name="${tabGroupId}"]');
                              const panels = ${JSON.stringify(matches.map(m => m.tabId))}.map(id => document.getElementById(id));
                              function sync() {
                                radios.forEach((r, i) => {
                                  if (panels[i]) panels[i].style.display = r.checked ? 'block' : 'none';
                                });
                              }
                              radios.forEach(r => r.addEventListener('change', sync));
                              sync();
                            })();
                          </script>
                        `;

                        return `<div class="nri-tabs"><div style="font-weight:700;">Overlapping NRI layers (${matches.length})</div>${tabsCss}<div class="nri-tab-labels">${labels}</div>${panels}${script}</div>`;
                      })()
                    : `<div style="max-width: 320px;">No NRI features at this point.</div>`;

                  L.popup({ maxWidth: 450 })
                    .setLatLng(clickPoint)
                    .setContent(content)
                    .openOn(leafletMap);
                });

                polygon.addTo(primary);
                bounds.extend(polygon.getBounds());
              });
            } catch (e) {
              console.error('Error drawing NRI polygon:', e);
            }
          });

          if (!legendAccumulator[legendKey]) {
            legendAccumulator[legendKey] = {
              icon,
              color,
              title,
              count: 0,
            };
          }
          legendAccumulator[legendKey].count += count;
        });
      } catch (error) {
        console.error('Error processing NRI Hurricane layers:', error);
      }

      // Draw Boston Open Data layers
      const bostonLayers = [
        { key: 'boston_approved_building_permits_all', icon: '🏗️', color: '#dc2626', title: 'Boston Approved Building Permits', isPoint: true },
        { key: 'boston_isd_inspector_districts_all', icon: '🏛️', color: '#7c3aed', title: 'Boston ISD Inspector Districts', isPolygon: true },
        { key: 'boston_parcels_2023_all', icon: '🏘️', color: '#f97316', title: 'Boston Parcels 2023', isPolygon: true },
        { key: 'boston_charging_stations_all', icon: '🔌', color: '#16a34a', title: 'Boston Charging Stations', isPoint: true },
        { key: 'boston_blue_bike_stations_all', icon: '🚴', color: '#2563eb', title: 'Boston Blue Bike Stations', isPoint: true },
        { key: 'boston_mbta_stops_all', icon: '🚇', color: '#dc2626', title: 'MBTA Stops', isPoint: true },
        { key: 'boston_bicycle_network_2023_all', icon: '🚴', color: '#059669', title: 'Boston Bicycle Network 2023', isPolyline: true },
        { key: 'boston_managed_streets_all', icon: '🛣️', color: '#7c3aed', title: 'City of Boston Managed Streets', isPolyline: true },
        { key: 'boston_public_open_space_all', icon: '🌳', color: '#16a34a', title: 'Boston Public Open Space', isPolygon: true },
        { key: 'boston_park_features_all', icon: '🌳', color: '#22c55e', title: 'Boston Park Features', isPoint: true },
        { key: 'boston_school_zones_all', icon: '🏫', color: '#f59e0b', title: 'Boston School Zones', isPolygon: true },
        { key: 'boston_crosswalks_all', icon: '🚶', color: '#3b82f6', title: 'Boston Crosswalks', isPoint: true },
        { key: 'boston_yellow_centerlines_all', icon: '🟡', color: '#fbbf24', title: 'Boston Yellow Centerlines', isPolyline: true },
        { key: 'boston_parcels_2025_all', icon: '🏘️', color: '#ec4899', title: 'Boston Parcels 2025', isPolygon: true },
        { key: 'boston_planning_main_street_districts_all', icon: '🏪', color: '#8b5cf6', title: 'Boston Planning - Main Street Districts', isPolygon: true },
        { key: 'boston_planning_zip_codes_all', icon: '📮', color: '#06b6d4', title: 'Boston Planning - ZIP Codes', isPolygon: true },
        { key: 'boston_planning_public_works_districts_all', icon: '🔧', color: '#f59e0b', title: 'Boston Planning - Public Works Districts', isPolygon: true },
        { key: 'boston_planning_parcels_2015_all', icon: '🏘️', color: '#ef4444', title: 'Boston Planning - Parcels 2015', isPolygon: true },
        { key: 'boston_planning_city_council_districts_all', icon: '🏛️', color: '#3b82f6', title: 'Boston Planning - City Council Districts', isPolygon: true },
        { key: 'boston_planning_btd_districts_all', icon: '🚌', color: '#10b981', title: 'Boston Planning - BTD Districts', isPolygon: true },
        { key: 'boston_planning_article80_projects_active_all', icon: '🏗️', color: '#f97316', title: 'Boston Planning - Article80 Projects Active', isPolygon: true },
        { key: 'boston_planning_precincts_all', icon: '👮', color: '#6366f1', title: 'Boston Planning - Precincts', isPolygon: true },
        { key: 'boston_planning_wards_all', icon: '🗳️', color: '#ec4899', title: 'Boston Planning - Wards', isPolygon: true },
        { key: 'boston_planning_boston_boundary_all', icon: '📍', color: '#14b8a6', title: 'Boston Planning - Boston Boundary', isPolygon: true },
        { key: 'boston_public_safety_fire_hydrants_all', icon: '🚒', color: '#ef4444', title: 'Boston Public Safety - Fire Hydrants', isPoint: true },
        { key: 'boston_public_safety_fire_boxes_all', icon: '📞', color: '#dc2626', title: 'Boston Public Safety - Fire Boxes', isPoint: true },
        { key: 'boston_public_safety_fire_departments_all', icon: '🏢', color: '#b91c1c', title: 'Boston Public Safety - Fire Departments', isPoint: true },
        { key: 'boston_public_safety_fire_districts_all', icon: '🔥', color: '#991b1b', title: 'Boston Public Safety - Fire Districts', isPolygon: true },
        { key: 'boston_public_safety_fire_subdistricts_all', icon: '🛡️', color: '#7f1d1d', title: 'Boston Public Safety - Fire Subdistricts', isPolygon: true },
        { key: 'boston_public_safety_police_districts_all', icon: '👮', color: '#1e40af', title: 'Boston Public Safety - Police Districts', isPolygon: true },
        { key: 'boston_public_safety_police_departments_all', icon: '🚔', color: '#1e3a8a', title: 'Boston Public Safety - Police Departments', isPoint: true },
        { key: 'boston_pwd_cartegraph_street_lights_all', icon: '💡', color: '#fbbf24', title: 'Boston PWD Cartegraph - Street Lights', isPoint: true },
        { key: 'boston_pwd_cartegraph_bus_shelters_all', icon: '🚏', color: '#3b82f6', title: 'Boston PWD Cartegraph - Bus Shelters', isPoint: true },
        { key: 'boston_pwd_cartegraph_hydrants_all', icon: '🚰', color: '#ef4444', title: 'Boston PWD Cartegraph - Hydrants', isPoint: true },
        { key: 'boston_pwd_cartegraph_waste_receptacles_all', icon: '🗑️', color: '#6b7280', title: 'Boston PWD Cartegraph - Waste Receptacles', isPoint: true },
        { key: 'boston_pwd_cartegraph_street_light_cabinets_all', icon: '📦', color: '#f59e0b', title: 'Boston PWD Cartegraph - Street Light Cabinets', isPoint: true },
        { key: 'boston_pwd_cartegraph_access_point_all', icon: '📍', color: '#6366f1', title: 'Boston PWD Cartegraph - Access Point', isPoint: true },
        { key: 'boston_pwd_cartegraph_street_light_control_box_all', icon: '⚡', color: '#f97316', title: 'Boston PWD Cartegraph - Street Light Control Box', isPoint: true },
        { key: 'boston_pwd_cartegraph_fire_alarm_light_all', icon: '🚨', color: '#dc2626', title: 'Boston PWD Cartegraph - Fire Alarm Light', isPoint: true },
        { key: 'boston_pwd_pavement_sidewalk_condition_ramp_condition_all', icon: '♿', color: '#059669', title: 'Boston PWD - Ramp Condition', isPoint: true },
        { key: 'boston_pwd_pavement_sidewalk_condition_intersection_condition_all', icon: '🚦', color: '#3b82f6', title: 'Boston PWD - Intersection Condition', isPoint: true },
        { key: 'boston_pwd_pavement_sidewalk_condition_sidewalk_condition_all', icon: '🚶', color: '#10b981', title: 'Boston PWD - Sidewalk Condition', isPolygon: true },
        { key: 'boston_pwd_pavement_sidewalk_condition_pavement_condition_all', icon: '🛣️', color: '#f59e0b', title: 'Boston PWD - Pavement Condition', isPolyline: true },
        { key: 'boston_cooling_centers_all', icon: '❄️', color: '#0ea5e9', title: 'Boston Cooling Centers', isPoint: true },
        { key: 'boston_bprd_sporting_activity_locations_all', icon: '⚽', color: '#10b981', title: 'Boston BPRD Sporting Activity Locations', isPoint: true },
        { key: 'boston_doit_buildings_all', icon: '🏢', color: '#6366f1', title: 'Boston DOIT Buildings', isPolygon: true },
        { key: 'boston_doit_hydro_all', icon: '💧', color: '#06b6d4', title: 'Boston DOIT Hydro', isPolyline: true },
        { key: 'boston_doit_mbta_rapid_transit_all', icon: '🚇', color: '#f59e0b', title: 'Boston DOIT MBTA Rapid Transit', isPolyline: true },
        { key: 'boston_doit_rail_all', icon: '🚂', color: '#8b5cf6', title: 'Boston DOIT Rail', isPolyline: true },
        { key: 'alaska_dnr_trans_alaska_pipeline_all', icon: '🛢️', color: '#dc2626', title: 'Alaska DNR - Trans Alaska Pipeline System', isPolyline: true },
        { key: 'alaska_dnr_well_sites_all', icon: '⛽', color: '#f59e0b', title: 'Alaska DNR - Well Sites', isPoint: true },
        { key: 'alaska_dnr_oil_gas_lease_sale_tract_all', icon: '🛢️', color: '#7c3aed', title: 'Alaska DNR - Oil and Gas Lease Sale Tract', isPolygon: true },
        { key: 'alaska_dnr_state_park_roads_all', icon: '🛣️', color: '#059669', title: 'Alaska DNR - State Park Roads', isPolyline: true },
        { key: 'alaska_dnr_state_park_trails_all', icon: '🥾', color: '#10b981', title: 'Alaska DNR - State Park Trails', isPolyline: true },
        { key: 'alaska_dnr_state_park_boundaries_all', icon: '🏞️', color: '#059669', title: 'Alaska DNR - State Park Boundaries', isPolygon: true },
        { key: 'alaska_dnr_state_park_facilities_all', icon: '🏕️', color: '#10b981', title: 'Alaska DNR - State Park Facilities', isPoint: true },
        { key: 'alaska_dnr_controlled_livestock_districts_all', icon: '🐄', color: '#f59e0b', title: 'Alaska DNR - Controlled Livestock Districts', isPolygon: true },
        { key: 'alaska_dnr_land_capacity_classification_all', icon: '🌾', color: '#84cc16', title: 'Alaska DNR - Land Capacity Classification', isPolygon: true },
        { key: 'alaska_dnr_shore_fishery_leases_all', icon: '🐟', color: '#06b6d4', title: 'Alaska DNR - Shore Fishery Leases', isPolygon: true },
        { key: 'alaska_dnr_aquatic_farm_leases_all', icon: '🌊', color: '#3b82f6', title: 'Alaska DNR - Aquatic Farm Leases', isPolygon: true },
        { key: 'alaska_dnr_welts_all', icon: '💧', color: '#0ea5e9', title: 'Alaska DNR - WELTS (Well Log Tracking System)', isPoint: true },
        { key: 'alaska_dnr_plss_section_all', icon: '🗺️', color: '#6366f1', title: 'Alaska DNR - PLSS Section', isPolygon: true },
        { key: 'alaska_dnr_plss_township_all', icon: '🗺️', color: '#8b5cf6', title: 'Alaska DNR - PLSS Township', isPolygon: true },
        { key: 'alaska_dnr_surface_water_right_location_all', icon: '💧', color: '#06b6d4', title: 'Alaska DNR - Surface Water Right Location', isPoint: true },
        { key: 'alaska_dnr_subsurface_water_right_location_all', icon: '💧', color: '#0891b2', title: 'Alaska DNR - SubSurface Water Right Location', isPoint: true },
        { key: 'alaska_dnr_surface_water_rights_all', icon: '🌊', color: '#0ea5e9', title: 'Alaska DNR - Surface Water Rights', isPolygon: true },
        { key: 'alaska_dnr_subsurface_water_rights_all', icon: '🌊', color: '#0284c7', title: 'Alaska DNR - SubSurface Water Rights', isPolygon: true },
        { key: 'alaska_dnr_instream_flow_water_reservations_point_all', icon: '💧', color: '#14b8a6', title: 'Alaska DNR - Instream Flow Water Reservations (Point)', isPoint: true },
        { key: 'alaska_dnr_instream_flow_water_reservations_line_all', icon: '🌊', color: '#0d9488', title: 'Alaska DNR - Instream Flow Water Reservations (Line)', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_agreement_settlement_recon_point_all', icon: '📋', color: '#64748b', title: 'Alaska DNR - Mineral Estate Agreement Settlement Recon Point', isPoint: true },
        { key: 'alaska_dnr_mineral_estate_agreement_settlement_recon_line_all', icon: '📏', color: '#64748b', title: 'Alaska DNR - Mineral Estate Agreement Settlement Recon Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_agreement_settlement_recon_poly_all', icon: '📋', color: '#64748b', title: 'Alaska DNR - Mineral Estate Agreement Settlement Recon Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_federal_action_line_all', icon: '🏛️', color: '#3b82f6', title: 'Alaska DNR - Mineral Estate Federal Action Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_federal_action_poly_all', icon: '🏛️', color: '#3b82f6', title: 'Alaska DNR - Mineral Estate Federal Action Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_leasehold_location_line_all', icon: '📍', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate Leasehold Location Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_leasehold_location_poly_all', icon: '📍', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate Leasehold Location Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_management_agreement_line_all', icon: '📄', color: '#10b981', title: 'Alaska DNR - Mineral Estate Management Agreement Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_management_agreement_poly_all', icon: '📄', color: '#10b981', title: 'Alaska DNR - Mineral Estate Management Agreement Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_mental_health_trust_land_poly_all', icon: '🏥', color: '#ec4899', title: 'Alaska DNR - Mineral Estate Mental Health Trust Land Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_mineral_order_line_all', icon: '⛏️', color: '#8b5cf6', title: 'Alaska DNR - Mineral Estate Mineral Order Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_mineral_order_poly_all', icon: '⛏️', color: '#8b5cf6', title: 'Alaska DNR - Mineral Estate Mineral Order Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_interest_native_allotment_poly_all', icon: '🏛️', color: '#dc2626', title: 'Alaska DNR - Mineral Estate State Interest Native Allotment Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_oil_gas_lease_sale_tract_current_all', icon: '🛢️', color: '#7c3aed', title: 'Alaska DNR - Mineral Estate Oil and Gas Lease Sale Tract Current', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_other_state_acquired_me_line_all', icon: '📍', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate Other State Acquired ME Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_other_state_acquired_me_poly_all', icon: '📍', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate Other State Acquired ME Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_permit_lease_me_poly_all', icon: '📄', color: '#10b981', title: 'Alaska DNR - Mineral Estate Permit Lease ME Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_mining_claim_poly_all', icon: '⛏️', color: '#8b5cf6', title: 'Alaska DNR - Mineral Estate State Mining Claim Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_mining_claim_pending_poly_all', icon: '⏳', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate State Mining Claim Pending Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_mining_claim_closed_poly_all', icon: '🔒', color: '#6b7280', title: 'Alaska DNR - Mineral Estate State Mining Claim Closed Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_prospecting_site_poly_all', icon: '🔍', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate State Prospecting Site Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_municipal_entitlement_poly_all', icon: '🏙️', color: '#3b82f6', title: 'Alaska DNR - Mineral Estate Municipal Entitlement Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_selected_land_me_line_all', icon: '🗺️', color: '#6366f1', title: 'Alaska DNR - Mineral Estate State Selected Land ME Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_state_selected_or_anilca_topfiled_land_me_poly_all', icon: '🗺️', color: '#6366f1', title: 'Alaska DNR - Mineral Estate State Selected or ANILCA Topfiled Land ME Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_state_ta_patented_me_line_all', icon: '📜', color: '#a855f7', title: 'Alaska DNR - Mineral Estate State TA Patented ME Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_state_ta_patented_me_poly_all', icon: '📜', color: '#a855f7', title: 'Alaska DNR - Mineral Estate State TA Patented ME Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_survey_boundary_pt_all', icon: '📍', color: '#06b6d4', title: 'Alaska DNR - Mineral Estate Survey Boundary Pt', isPoint: true },
        { key: 'alaska_dnr_mineral_estate_survey_boundary_line_all', icon: '📏', color: '#06b6d4', title: 'Alaska DNR - Mineral Estate Survey Boundary Line', isPolyline: true },
        { key: 'alaska_dnr_mineral_estate_survey_boundary_poly_all', icon: '🗺️', color: '#06b6d4', title: 'Alaska DNR - Mineral Estate Survey Boundary Poly', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_recording_district_boundary_all', icon: '🏛️', color: '#3b82f6', title: 'Alaska DNR - Mineral Estate Recording District Boundary', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_well_site_point_all', icon: '⛽', color: '#f59e0b', title: 'Alaska DNR - Mineral Estate Well Site Point', isPoint: true },
        { key: 'alaska_dnr_mineral_estate_dcced_cra_borough_boundary_all', icon: '🏛️', color: '#3b82f6', title: 'Alaska DNR - Mineral Estate DCCED CRA Borough Boundary', isPolygon: true },
        { key: 'alaska_dnr_mineral_estate_township_all', icon: '🏘️', color: '#10b981', title: 'Alaska DNR - Mineral Estate Township', isPolygon: true },
        { key: 'alaska_dnr_mht_trust_land_survey_all', icon: '🗺️', color: '#8b5cf6', title: 'Alaska DNR - MHT Trust Land Survey (TLS)', isPolygon: true },
        { key: 'alaska_dnr_mht_other_activity_all', icon: '📋', color: '#6366f1', title: 'Alaska DNR - MHT Other Activity', isPolygon: true },
        { key: 'alaska_dnr_mht_trespass_point_all', icon: '📍', color: '#ef4444', title: 'Alaska DNR - MHT Trespass Point', isPoint: true },
        { key: 'alaska_dnr_mht_trespass_line_all', icon: '📏', color: '#f97316', title: 'Alaska DNR - MHT Trespass Line', isPolyline: true },
        { key: 'alaska_dnr_mht_trespass_area_all', icon: '🚫', color: '#dc2626', title: 'Alaska DNR - MHT Trespass Area', isPolygon: true },
        { key: 'alaska_dnr_mht_easements_all', icon: '🛤️', color: '#7c3aed', title: 'Alaska DNR - MHT Easements', isPolygon: true },
        { key: 'alaska_dnr_mht_easement_point_all', icon: '📍', color: '#9333ea', title: 'Alaska DNR - MHT Easement Point', isPoint: true },
        { key: 'alaska_dnr_mht_easement_line_all', icon: '📏', color: '#a855f7', title: 'Alaska DNR - MHT Easement Line', isPolyline: true },
        { key: 'alaska_dnr_mht_easement_area_all', icon: '🛤️', color: '#c084fc', title: 'Alaska DNR - MHT Easement Area', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sales_all', icon: '🏠', color: '#059669', title: 'Alaska DNR - MHT Land Sales', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_conveyed_all', icon: '✅', color: '#10b981', title: 'Alaska DNR - MHT Land Sale, Conveyed', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_contract_all', icon: '📝', color: '#34d399', title: 'Alaska DNR - MHT Land Sale, Contract', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_available_otc_all', icon: '🛒', color: '#6ee7b7', title: 'Alaska DNR - MHT Land Sale, Available OTC', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_pending_interest_all', icon: '⏳', color: '#a7f3d0', title: 'Alaska DNR - MHT Land Sale, Pending Interest', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_potential_reoffer_all', icon: '🔄', color: '#d1fae5', title: 'Alaska DNR - MHT Land Sale, Potential Reoffer', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_new_inventory_all', icon: '🆕', color: '#ecfdf5', title: 'Alaska DNR - MHT Land Sale, New Inventory', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_predisposal_all', icon: '📦', color: '#f0fdf4', title: 'Alaska DNR - MHT Land Sale, Predisposal', isPolygon: true },
        { key: 'alaska_dnr_mht_land_sale_all_all', icon: '🏘️', color: '#065f46', title: 'Alaska DNR - MHT Land Sale, All', isPolygon: true },
        { key: 'alaska_dnr_mht_resource_sales_all', icon: '💰', color: '#047857', title: 'Alaska DNR - MHT Resource Sales', isPolygon: true },
        { key: 'alaska_dnr_mht_material_sale_all', icon: '⛏️', color: '#059669', title: 'Alaska DNR - MHT Material Sale', isPolygon: true },
        { key: 'alaska_dnr_mht_timber_sale_all', icon: '🌲', color: '#10b981', title: 'Alaska DNR - MHT Timber Sale', isPolygon: true },
        { key: 'alaska_dnr_mht_land_leases_licenses_all', icon: '📄', color: '#34d399', title: 'Alaska DNR - MHT Land Leases & Licenses', isPolygon: true },
        { key: 'alaska_dnr_mht_land_use_license_line_all', icon: '📏', color: '#6ee7b7', title: 'Alaska DNR - MHT Land Use License Line', isPolyline: true },
        { key: 'alaska_dnr_mht_land_use_license_area_all', icon: '📋', color: '#a7f3d0', title: 'Alaska DNR - MHT Land Use License Area', isPolygon: true },
        { key: 'alaska_dnr_mht_land_lease_all', icon: '🏢', color: '#d1fae5', title: 'Alaska DNR - MHT Land Lease', isPolygon: true },
        { key: 'alaska_dnr_mht_mineral_leases_licenses_all', icon: '💎', color: '#0c4a6e', title: 'Alaska DNR - MHT Mineral Leases & Licenses', isPolygon: true },
        { key: 'alaska_dnr_mht_mineral_lease_all', icon: '⛏️', color: '#075985', title: 'Alaska DNR - MHT Mineral Lease', isPolygon: true },
        { key: 'alaska_dnr_mht_oil_gas_lease_all', icon: '🛢️', color: '#0e7490', title: 'Alaska DNR - MHT Oil & Gas Lease', isPolygon: true },
        { key: 'alaska_dnr_mht_coal_lease_all', icon: '⚫', color: '#155e75', title: 'Alaska DNR - MHT Coal Lease', isPolygon: true },
        { key: 'alaska_dnr_mht_mineral_exploration_license_all', icon: '🔍', color: '#164e63', title: 'Alaska DNR - MHT Mineral Exploration License', isPolygon: true },
        { key: 'alaska_dnr_mht_oil_gas_exploration_license_all', icon: '🔎', color: '#155e75', title: 'Alaska DNR - MHT Oil & Gas Exploration License', isPolygon: true },
        { key: 'alaska_dnr_mht_coal_exploration_license_all', icon: '🔬', color: '#0e7490', title: 'Alaska DNR - MHT Coal Exploration License', isPolygon: true },
        { key: 'alaska_dnr_mht_other_exploration_license_all', icon: '🔭', color: '#075985', title: 'Alaska DNR - MHT Other Exploration License', isPolygon: true },
        { key: 'alaska_dnr_tundra_area_stations_all', icon: '📍', color: '#059669', title: 'Alaska DNR - Tundra Area Stations', isPoint: true },
        { key: 'alaska_dnr_tundra_area_dalton_highway_all', icon: '🛣️', color: '#dc2626', title: 'Alaska DNR - Tundra Area Dalton Highway', isPolyline: true },
        { key: 'alaska_dnr_tundra_area_tundra_regions_all', icon: '🏔️', color: '#7c3aed', title: 'Alaska DNR - Tundra Area Tundra Regions', isPolygon: true },
        { key: 'alaska_dnr_soil_water_conservation_districts_all', icon: '💧', color: '#0891b2', title: 'Alaska DNR - Soil and Water Conservation Districts', isPolygon: true },
        { key: 'alaska_dnr_astar_public_airports_0_all', icon: '✈️', color: '#3b82f6', title: 'Alaska DNR - ASTAR Public Airports', isPoint: true },
        { key: 'alaska_dnr_astar_alaska_ports_harbors_all', icon: '⚓', color: '#0ea5e9', title: 'Alaska DNR - ASTAR Alaska Ports Harbors (DOT)', isPoint: true },
        { key: 'alaska_dnr_astar_public_airports_2_all', icon: '🛫', color: '#60a5fa', title: 'Alaska DNR - ASTAR Public Airports (2)', isPoint: true },
        { key: 'alaska_dnr_astar_dew_line_sites_all', icon: '📡', color: '#7c3aed', title: 'Alaska DNR - ASTAR DEW Line Sites', isPoint: true },
        { key: 'alaska_dnr_astar_roads_dot_all', icon: '🛣️', color: '#dc2626', title: 'Alaska DNR - ASTAR Roads (DOT)', isPolyline: true },
        { key: 'alaska_dnr_astar_all_roads_nssi_all', icon: '🛣️', color: '#ea580c', title: 'Alaska DNR - ASTAR All Roads (NSSI)', isPolyline: true },
        { key: 'alaska_dnr_astar_village_roads_nsb_all', icon: '🛣️', color: '#f97316', title: 'Alaska DNR - ASTAR Village Roads (NSB)', isPolyline: true },
        { key: 'alaska_dnr_astar_trails_state_of_alaska_all', icon: '🥾', color: '#059669', title: 'Alaska DNR - ASTAR Trails (State of Alaska)', isPolyline: true },
        { key: 'alaska_dnr_astar_airport_runway_usgs_all', icon: '🛬', color: '#0284c7', title: 'Alaska DNR - ASTAR Airport Runway (USGS)', isPolyline: true },
        { key: 'alaska_dnr_astar_easements_nsb_all', icon: '🛤️', color: '#6366f1', title: 'Alaska DNR - ASTAR Easements (NSB)', isPolygon: true },
        { key: 'alaska_dnr_astar_parcels_nsb_all', icon: '🏘️', color: '#8b5cf6', title: 'Alaska DNR - ASTAR Parcels (NSB)', isPolygon: true },
        { key: 'alaska_dnr_mht_tlo_land_exchange_all', icon: '🔄', color: '#0369a1', title: 'Alaska DNR - MHT TLO Land Exchange', isPolygon: true },
        { key: 'alaska_dnr_mht_tlo_agreement_all', icon: '📜', color: '#0284c7', title: 'Alaska DNR - MHT TLO Agreement', isPolygon: true },
        { key: 'alaska_dnr_mht_title_all', icon: '📑', color: '#0ea5e9', title: 'Alaska DNR - MHT Title', isPolygon: true },
        { key: 'alaska_dnr_mht_mental_health_parcel_all', icon: '🏥', color: '#38bdf8', title: 'Alaska DNR - MHT Mental Health Parcel', isPolygon: true },
        { key: 'alaska_dnr_mht_mental_health_land_qcd_all', icon: '🏥', color: '#60a5fa', title: 'Alaska DNR - MHT Mental Health Land (QCD)', isPolygon: true },
        { key: 'alaska_dnr_instream_flow_water_reservations_polygon_all', icon: '🌊', color: '#0f766e', title: 'Alaska DNR - Instream Flow Water Reservations (Polygon)', isPolygon: true },
        { key: 'alaska_dnr_shore_fishery_leases_line_all', icon: '🐟', color: '#06b6d4', title: 'Alaska DNR - Shore Fishery Leases (Line)', isPolyline: true },
        { key: 'alaska_dnr_shore_fishery_leases_polygon_waterestate_all', icon: '🐟', color: '#0891b2', title: 'Alaska DNR - Shore Fishery Leases (Polygon)', isPolygon: true },
        { key: 'alaska_dnr_aquatic_farm_leases_waterestate_all', icon: '🌊', color: '#0ea5e9', title: 'Alaska DNR - Aquatic Farm Leases (WaterEstate)', isPolygon: true },
        { key: 'alaska_dnr_lease_line_all', icon: '📏', color: '#64748b', title: 'Alaska DNR - Lease Line', isPolyline: true },
        { key: 'alaska_dnr_lease_area_all', icon: '📐', color: '#475569', title: 'Alaska DNR - Lease Area', isPolygon: true },
        { key: 'alaska_dnr_hatchers_pass_plan_boundary_all', icon: '🏔️', color: '#059669', title: "Alaska DNR - Hatcher's Pass Plan Boundary", isPolygon: true },
        { key: 'alaska_dnr_hatchers_pass_non_motorized_summer_all', icon: '🚫', color: '#dc2626', title: "Alaska DNR - Hatcher's Pass Non-motorized Summer", isPolygon: true },
        { key: 'alaska_dnr_hatchers_pass_non_motorized_year_round_all', icon: '🚫', color: '#991b1b', title: "Alaska DNR - Hatcher's Pass Non-motorized Year-round", isPolygon: true },
        // Alaska DNR Mapper Base Layers - Point layers
        { key: 'alaska_dnr_national_geodetic_survey_pt_all', icon: '📍', color: '#3b82f6', title: 'Alaska DNR - National Geodetic Survey Pt', isPoint: true },
        { key: 'alaska_dnr_state_control_monuments_all', icon: '🗿', color: '#6366f1', title: 'Alaska DNR - State Control Monuments', isPoint: true },
        { key: 'alaska_dnr_blm_monuments_gcdb_all', icon: '🗿', color: '#8b5cf6', title: 'Alaska DNR - BLM Monuments GCDB', isPoint: true },
        { key: 'alaska_dnr_blm_monuments_sdms_all', icon: '🗿', color: '#a855f7', title: 'Alaska DNR - BLM Monuments SDMS', isPoint: true },
        { key: 'alaska_dnr_survey_boundary_pt_all', icon: '📍', color: '#c084fc', title: 'Alaska DNR - Survey Boundary Pt', isPoint: true },
        // Alaska DNR Mapper Base Layers - Polyline layers
        { key: 'alaska_dnr_simple_coastline_all', icon: '🌊', color: '#06b6d4', title: 'Alaska DNR - Simple Coastline', isPolyline: true },
        { key: 'alaska_dnr_survey_tract_line_all', icon: '📏', color: '#0891b2', title: 'Alaska DNR - Survey Tract Line', isPolyline: true },
        { key: 'alaska_dnr_survey_block_line_all', icon: '📐', color: '#0e7490', title: 'Alaska DNR - Survey Block Line', isPolyline: true },
        { key: 'alaska_dnr_survey_boundary_line_all', icon: '📏', color: '#155e75', title: 'Alaska DNR - Survey Boundary Line', isPolyline: true },
        // Alaska DNR Mapper Base Layers - Polygon layers
        { key: 'alaska_dnr_section_all', icon: '🗺️', color: '#6b7280', title: 'Alaska DNR - Section', isPolygon: true },
        { key: 'alaska_dnr_survey_lot_poly_all', icon: '📋', color: '#9ca3af', title: 'Alaska DNR - Survey Lot Poly', isPolygon: true },
        { key: 'alaska_dnr_survey_tract_poly_all', icon: '📋', color: '#d1d5db', title: 'Alaska DNR - Survey Tract Poly', isPolygon: true },
        { key: 'alaska_dnr_survey_block_poly_all', icon: '📋', color: '#e5e7eb', title: 'Alaska DNR - Survey Block Poly', isPolygon: true },
        { key: 'alaska_dnr_survey_boundary_poly_all', icon: '📋', color: '#f3f4f6', title: 'Alaska DNR - Survey Boundary Poly', isPolygon: true },
        { key: 'alaska_dnr_township_all', icon: '🏘️', color: '#4b5563', title: 'Alaska DNR - Township', isPolygon: true },
        { key: 'alaska_dnr_incorporated_city_boundary_all', icon: '🏙️', color: '#374151', title: 'Alaska DNR - Incorporated City Boundary', isPolygon: true },
        { key: 'alaska_dnr_recording_district_boundary_all', icon: '🏛️', color: '#1f2937', title: 'Alaska DNR - Recording District Boundary', isPolygon: true },
        { key: 'alaska_dnr_dcced_cra_borough_boundary_all', icon: '🏛️', color: '#111827', title: 'Alaska DNR - DCCED CRA Borough Boundary', isPolygon: true },
        // Alaska DNR Mapper Land Estate Layers - Point layers
        { key: 'alaska_dnr_agreement_settlement_reconvey_pt_all', icon: '📍', color: '#3b82f6', title: 'Alaska DNR - Agreement Settlement Reconvey Pt', isPoint: true },
        { key: 'alaska_dnr_restricted_use_authorization_pt_all', icon: '🚫', color: '#ef4444', title: 'Alaska DNR - Restricted Use Authorization Pt', isPoint: true },
        { key: 'alaska_dnr_potential_hazardous_sites_pt_all', icon: '⚠️', color: '#f59e0b', title: 'Alaska DNR - Potential Hazardous Sites Pt', isPoint: true },
        { key: 'alaska_dnr_trespass_pt_all', icon: '🚧', color: '#dc2626', title: 'Alaska DNR - Trespass Pt', isPoint: true },
        { key: 'alaska_dnr_permit_lease_le_pt_all', icon: '📄', color: '#6366f1', title: 'Alaska DNR - Permit Lease LE Pt', isPoint: true },
        { key: 'alaska_dnr_easement_pt_all', icon: '🛤️', color: '#8b5cf6', title: 'Alaska DNR - Easement Pt', isPoint: true },
        { key: 'alaska_dnr_land_disposal_other_pt_all', icon: '🏘️', color: '#a855f7', title: 'Alaska DNR - Land Disposal Other Pt', isPoint: true },
        { key: 'alaska_dnr_land_estate_survey_boundary_pt_all', icon: '📍', color: '#c084fc', title: 'Alaska DNR - Survey Boundary Pt (Land Estate)', isPoint: true },
        // Alaska DNR Mapper Land Estate Layers - Polyline layers
        { key: 'alaska_dnr_land_estate_simple_coastline_all', icon: '🌊', color: '#06b6d4', title: 'Alaska DNR - Simple Coastline (Land Estate)', isPolyline: true },
        { key: 'alaska_dnr_agreement_settlement_reconvey_line_all', icon: '📏', color: '#0891b2', title: 'Alaska DNR - Agreement Settlement Reconvey Line', isPolyline: true },
        { key: 'alaska_dnr_restricted_use_authorization_line_all', icon: '🚫', color: '#0e7490', title: 'Alaska DNR - Restricted Use Authorization Line', isPolyline: true },
        { key: 'alaska_dnr_potential_hazardous_sites_line_all', icon: '⚠️', color: '#155e75', title: 'Alaska DNR - Potential Hazardous Sites Line', isPolyline: true },
        { key: 'alaska_dnr_trespass_line_all', icon: '🚧', color: '#1e40af', title: 'Alaska DNR - Trespass Line', isPolyline: true },
        { key: 'alaska_dnr_permit_lease_le_line_all', icon: '📄', color: '#1e3a8a', title: 'Alaska DNR - Permit Lease LE Line', isPolyline: true },
        { key: 'alaska_dnr_easement_line_all', icon: '🛤️', color: '#1e293b', title: 'Alaska DNR - Easement Line', isPolyline: true },
        { key: 'alaska_dnr_resource_sale_line_all', icon: '💰', color: '#10b981', title: 'Alaska DNR - Resource Sale Line', isPolyline: true },
        { key: 'alaska_dnr_federal_action_line_all', icon: '🏛️', color: '#059669', title: 'Alaska DNR - Federal Action Line', isPolyline: true },
        { key: 'alaska_dnr_land_disposal_available_line_all', icon: '🏘️', color: '#047857', title: 'Alaska DNR - Land Disposal Available Line', isPolyline: true },
        { key: 'alaska_dnr_land_disposal_conveyed_line_all', icon: '📋', color: '#065f46', title: 'Alaska DNR - Land Disposal Conveyed Line', isPolyline: true },
        { key: 'alaska_dnr_land_disposal_other_line_all', icon: '📝', color: '#064e3b', title: 'Alaska DNR - Land Disposal Other Line', isPolyline: true },
        { key: 'alaska_dnr_management_agreement_line_all', icon: '🤝', color: '#022c22', title: 'Alaska DNR - Management Agreement Line', isPolyline: true },
        { key: 'alaska_dnr_other_state_acquired_le_line_all', icon: '🏛️', color: '#6b7280', title: 'Alaska DNR - Other State Acquired LE Line', isPolyline: true },
        { key: 'alaska_dnr_rs2477_line_all', icon: '🛣️', color: '#9ca3af', title: 'Alaska DNR - RS2477 - Line', isPolyline: true },
        { key: 'alaska_dnr_state_selected_land_le_line_all', icon: '🗺️', color: '#d1d5db', title: 'Alaska DNR - State Selected Land LE Line', isPolyline: true },
        { key: 'alaska_dnr_state_ta_patented_le_line_all', icon: '📜', color: '#e5e7eb', title: 'Alaska DNR - State TA Patented LE Line', isPolyline: true },
        { key: 'alaska_dnr_land_estate_survey_boundary_line_all', icon: '📏', color: '#f3f4f6', title: 'Alaska DNR - Survey Boundary Line (Land Estate)', isPolyline: true },
        // Alaska DNR Mapper Land Estate Layers - Polygon layers
        { key: 'alaska_dnr_land_estate_section_all', icon: '🗺️', color: '#4b5563', title: 'Alaska DNR - Section (Land Estate)', isPolygon: true },
        { key: 'alaska_dnr_agreement_settlement_recon_poly_all', icon: '📋', color: '#374151', title: 'Alaska DNR - Agreement Settlement Recon Poly', isPolygon: true },
        { key: 'alaska_dnr_restricted_use_authorization_poly_all', icon: '🚫', color: '#1f2937', title: 'Alaska DNR - Restricted Use Authorization Poly', isPolygon: true },
        { key: 'alaska_dnr_potential_hazardous_sites_poly_all', icon: '⚠️', color: '#111827', title: 'Alaska DNR - Potential Hazardous Sites Poly', isPolygon: true },
        { key: 'alaska_dnr_trespass_poly_all', icon: '🚧', color: '#3b82f6', title: 'Alaska DNR - Trespass Poly', isPolygon: true },
        { key: 'alaska_dnr_permit_lease_le_poly_all', icon: '📄', color: '#6366f1', title: 'Alaska DNR - Permit Lease LE Poly', isPolygon: true },
        { key: 'alaska_dnr_easement_poly_all', icon: '🛤️', color: '#8b5cf6', title: 'Alaska DNR - Easement Poly', isPolygon: true },
        { key: 'alaska_dnr_resource_sale_poly_all', icon: '💰', color: '#a855f7', title: 'Alaska DNR - Resource Sale Poly', isPolygon: true },
        { key: 'alaska_dnr_federal_action_poly_all', icon: '🏛️', color: '#c084fc', title: 'Alaska DNR - Federal Action Poly', isPolygon: true },
        { key: 'alaska_dnr_land_disposal_available_poly_all', icon: '🏘️', color: '#d946ef', title: 'Alaska DNR - Land Disposal Available Poly', isPolygon: true },
        { key: 'alaska_dnr_land_disposal_conveyed_poly_all', icon: '📋', color: '#ec4899', title: 'Alaska DNR - Land Disposal Conveyed Poly', isPolygon: true },
        { key: 'alaska_dnr_land_disposal_other_poly_all', icon: '📝', color: '#f43f5e', title: 'Alaska DNR - Land Disposal Other Poly', isPolygon: true },
        { key: 'alaska_dnr_management_agreement_poly_all', icon: '🤝', color: '#ef4444', title: 'Alaska DNR - Management Agreement Poly', isPolygon: true },
        { key: 'alaska_dnr_mental_health_trust_land_poly_all', icon: '🏥', color: '#dc2626', title: 'Alaska DNR - Mental Health Trust Land Poly', isPolygon: true },
        { key: 'alaska_dnr_municipal_entitlement_poly_all', icon: '🏙️', color: '#b91c1c', title: 'Alaska DNR - Municipal Entitlement Poly', isPolygon: true },
        { key: 'alaska_dnr_municipal_tideland_poly_all', icon: '🌊', color: '#991b1b', title: 'Alaska DNR - Municipal Tideland Poly', isPolygon: true },
        { key: 'alaska_dnr_state_interest_native_allotment_poly_all', icon: '🏘️', color: '#7f1d1d', title: 'Alaska DNR - State Interest Native Allotment Poly', isPolygon: true },
        { key: 'alaska_dnr_other_state_acquired_le_poly_all', icon: '🏛️', color: '#450a0a', title: 'Alaska DNR - Other State Acquired LE Poly', isPolygon: true },
        { key: 'alaska_dnr_state_selected_or_anilca_topfiled_land_le_poly_all', icon: '🗺️', color: '#0ea5e9', title: 'Alaska DNR - State Selected or ANILCA Topfiled Land LE Poly', isPolygon: true },
        { key: 'alaska_dnr_state_ta_patented_le_poly_all', icon: '📜', color: '#0284c7', title: 'Alaska DNR - State TA, Patented, LE Poly', isPolygon: true },
        { key: 'alaska_dnr_land_estate_survey_boundary_poly_all', icon: '📋', color: '#0369a1', title: 'Alaska DNR - Survey Boundary Poly (Land Estate)', isPolygon: true },
        { key: 'alaska_dnr_land_estate_recording_district_boundary_all', icon: '🏛️', color: '#075985', title: 'Alaska DNR - Recording District Boundary (Land Estate)', isPolygon: true },
        { key: 'alaska_dnr_land_estate_township_all', icon: '🏘️', color: '#0c4a6e', title: 'Alaska DNR - Township (Land Estate)', isPolygon: true },
        { key: 'boston_population_estimates_2025_all', icon: '📊', color: '#8b5cf6', title: 'Boston Population Estimates 2025 Census Tracts', isPolygon: true },
        { key: 'boston_population_estimates_2025_neighborhoods_all', icon: '🏘️', color: '#a855f7', title: 'Boston Population Estimates 2025 Neighborhoods', isPolygon: true },
        { key: 'boston_population_estimates_2025_city_all', icon: '🏙️', color: '#9333ea', title: 'Boston Population Estimates 2025 City', isPolygon: true },
        { key: 'boston_pwd_districts_all', icon: '🏛️', color: '#0ea5e9', title: 'Boston PWD Districts', isPolygon: true },
        { key: 'boston_snow_districts_all', icon: '❄️', color: '#06b6d4', title: 'Boston Snow Districts', isPolygon: true },
        { key: 'boston_wifi_locations_all', icon: '📶', color: '#8b5cf6', title: 'Boston WiFi Locations', isPoint: true },
        { key: 'boston_wifi_collector_all', icon: '📡', color: '#a855f7', title: 'Boston WiFi Collector', isPoint: true },
        { key: 'boston_budget_facilities_all', icon: '💰', color: '#10b981', title: 'Boston Budget Facilities', isPoint: true },
        { key: 'boston_hubway_stations_all', icon: '🚴', color: '#f59e0b', title: 'Boston Hubway Stations', isPoint: true },
        { key: 'boston_polling_locations_all', icon: '🗳️', color: '#3b82f6', title: 'Boston Polling Locations', isPoint: true },
        { key: 'boston_public_libraries_all', icon: '📚', color: '#ef4444', title: 'Boston Public Libraries', isPoint: true },
        { key: 'boston_bike_network_existing_facility_all', icon: '🚴', color: '#22c55e', title: 'Boston Bike Network Existing Facility', isPolyline: true },
        { key: 'boston_bike_network_5yr_plan_all', icon: '🚴', color: '#3b82f6', title: 'Boston Bike Network 5YR Plan', isPolyline: true },
        { key: 'boston_bike_network_30yr_plan_all', icon: '🚴', color: '#8b5cf6', title: 'Boston Bike Network 30YR Plan', isPolyline: true },
        { key: 'boston_311_addresses_all', icon: '📞', color: '#ec4899', title: 'Boston 311 Bulk Item PickUp Locations', isPoint: true },
        { key: 'boston_public_schools_all', icon: '🏫', color: '#3b82f6', title: 'Boston Public Schools', isPoint: true },
        { key: 'boston_non_public_schools_all', icon: '🏫', color: '#8b5cf6', title: 'Boston Non Public Schools', isPoint: true },
        { key: 'boston_colleges_universities_all', icon: '🎓', color: '#10b981', title: 'Boston Colleges/Universities', isPoint: true },
        { key: 'boston_historic_districts_all', icon: '🏛️', color: '#f59e0b', title: 'Boston Historic Districts and Protection Areas', isPolygon: true },
        { key: 'boston_impervious_other_all', icon: '🏗️', color: '#64748b', title: 'Boston Impervious Other', isPolygon: true },
        { key: 'boston_municipal_building_energy_reporting_all', icon: '⚡', color: '#fbbf24', title: 'Boston Municipal Building Energy Reporting', isPolygon: true },
        { key: 'boston_historic_districts_environment_energy_all', icon: '🏛️', color: '#f97316', title: 'Boston Historic Districts (EnvironmentEnergy)', isPolygon: true },
        { key: 'boston_hydrography_poly_all', icon: '💧', color: '#06b6d4', title: 'Boston Hydrography (poly)', isPolygon: true },
        { key: 'boston_open_space_environment_energy_all', icon: '🌳', color: '#22c55e', title: 'Boston Open Space (EnvironmentEnergy)', isPolygon: true },
        { key: 'boston_open_space_planning_neighborhoods_all', icon: '🌳', color: '#16a34a', title: 'Boston Open Space Planning Neighborhoods', isPolygon: true },
        { key: 'boston_green_links_existing_lines_all', icon: '🟢', color: '#22c55e', title: 'Boston Green Links Existing Lines', isPolyline: true },
        { key: 'boston_green_links_in_progress_lines_all', icon: '🟡', color: '#facc15', title: 'Boston Green Links In Progress Lines', isPolyline: true },
        { key: 'boston_green_links_proposed_lines_all', icon: '🔵', color: '#3b82f6', title: 'Boston Green Links Proposed Lines', isPolyline: true },
        { key: 'boston_green_links_crossings_all', icon: '🚶', color: '#8b5cf6', title: 'Boston Green Links Crossings', isPoint: true },
        { key: 'boston_green_links_greenway_all', icon: '🌿', color: '#10b981', title: 'Boston Green Links Greenway', isPolygon: true },
        { key: 'boston_fiber_sites_all', icon: '📡', color: '#3b82f6', title: 'Boston Fiber Sites', isPoint: true },
        { key: 'boston_fiber_segments_all', icon: '🔌', color: '#8b5cf6', title: 'Boston Fiber Segments', isPolyline: true },
        { key: 'boston_fiber_other_assets_all', icon: '🔧', color: '#f59e0b', title: 'Boston Fiber Other Assets', isPolyline: true },
        { key: 'boston_fiber_pic_conduit_all', icon: '🔌', color: '#10b981', title: 'Boston Fiber PIC Conduit', isPolyline: true },
        { key: 'boston_fiber_rcn_fiber_all', icon: '🔌', color: '#06b6d4', title: 'Boston Fiber RCN Fiber', isPolyline: true },
        { key: 'boston_fiber_nstar_conduit_all', icon: '🔌', color: '#6366f1', title: 'Boston Fiber NSTAR Conduit', isPolyline: true },
        { key: 'boston_fiber_btd_all', icon: '🚗', color: '#ef4444', title: 'Boston Fiber BTD', isPolyline: true },
        { key: 'boston_fiber_lit_fiber_all', icon: '💡', color: '#facc15', title: 'Boston Fiber Lit Fiber', isPolyline: true },
        { key: 'boston_fiber_core_fiber_all', icon: '🔷', color: '#3b82f6', title: 'Boston Fiber Core Fiber', isPolyline: true },
        { key: 'boston_fiber_wireless_all', icon: '📶', color: '#a855f7', title: 'Boston Fiber Wireless', isPoint: true },
        { key: 'boston_fiber_planning_areas_all', icon: '🗺️', color: '#16a34a', title: 'Boston Fiber Planning Areas', isPolygon: true },
        { key: 'boston_infrastructure_sidewalk_inventory_all', icon: '🚶', color: '#8b5cf6', title: 'Boston Sidewalk Inventory', isPolygon: true },
        { key: 'boston_infrastructure_mbta_stops_all', icon: '🚇', color: '#3b82f6', title: 'Boston MBTA Stops (Infrastructure)', isPoint: true },
        { key: 'boston_infrastructure_hospitals_all', icon: '🏥', color: '#ef4444', title: 'Boston Hospitals', isPoint: true },
        { key: 'boston_infrastructure_ramp_inventory_all', icon: '♿', color: '#10b981', title: 'Boston Ramp Inventory', isPolygon: true },
        { key: 'boston_infrastructure_mbta_bus_stops_all', icon: '🚌', color: '#f59e0b', title: 'Boston MBTA Bus Stops', isPoint: true },
        { key: 'boston_infrastructure_sidewalk_centerline_all', icon: '🚶', color: '#a855f7', title: 'Boston Sidewalk Centerline', isPolyline: true },
        { key: 'boston_infrastructure_curbs_all', icon: '🛣️', color: '#6366f1', title: 'Boston Curbs', isPolyline: true },
        { key: 'boston_infrastructure_snow_emergency_routes_all', icon: '❄️', color: '#3b88c4', title: 'Boston Snow Emergency Routes', isPolyline: true },
        { key: 'boston_infrastructure_segments_all', icon: '🛣️', color: '#8b5cf6', title: 'Boston Segments', isPolyline: true },
        { key: 'boston_infrastructure_parking_meters_all', icon: '🅿️', color: '#facc15', title: 'Boston Parking Meters', isPoint: true },
        { key: 'boston_infrastructure_trash_collection_days_all', icon: '🗑️', color: '#65a30d', title: 'Boston Trash Collection Days', isPolygon: true },
        { key: 'boston_infrastructure_street_lights_all', icon: '💡', color: '#facc15', title: 'Boston Street Lights', isPoint: true },
        { key: 'boston_infrastructure_traffic_signals_all', icon: '🚦', color: '#ef4444', title: 'Boston Traffic Signals', isPoint: true },
        { key: 'boston_infrastructure_curbs2_all', icon: '🛣️', color: '#6366f1', title: 'Boston Curbs (Layer 13)', isPolyline: true },
        { key: 'boston_infrastructure_massdot_road_inventory_all', icon: '🛣️', color: '#3b82f6', title: 'Boston MassDOT Road Inventory', isPolyline: true },
        { key: 'boston_infrastructure_mbta_bus_routes_all', icon: '🚌', color: '#06b6d4', title: 'Boston MBTA Bus Routes', isPolyline: true },
        { key: 'boston_infrastructure_mbcr_train_routes_all', icon: '🚂', color: '#8b5cf6', title: 'Boston MBCR Train Routes', isPolyline: true },
        { key: 'boston_infrastructure_mbcr_train_stations_all', icon: '🚉', color: '#3b82f6', title: 'Boston MBCR Train Stations', isPoint: true }
      ];

      bostonLayers.forEach((layerConfig) => {
        if (enrichments[layerConfig.key] && Array.isArray(enrichments[layerConfig.key])) {
          try {
            console.log(`🏙️ Drawing ${enrichments[layerConfig.key].length} ${layerConfig.title} features`);
            let featureCount = 0;
            enrichments[layerConfig.key].forEach((feature: any) => {
              const geometry = feature.geometry;
              if (!geometry) {
                console.warn(`⚠️ ${layerConfig.title}: Feature missing geometry`, feature);
                return;
              }

              try {
                // Check if this is actually a point geometry (x, y) even if marked as polyline
                // Some layers might return point geometry even if they're supposed to be polylines
                // Also handle crosswalks and yellow centerlines that might be points
                const isPointGeometry = geometry.x !== undefined && geometry.y !== undefined && 
                                      (!geometry.paths || geometry.paths.length === 0) && 
                                      (!geometry.rings || geometry.rings.length === 0);
                
                if (layerConfig.isPoint || isPointGeometry) {
                  // Point geometry
                  let pointLat: number | null = null;
                  let pointLon: number | null = null;

                  // Try to get coordinates from geometry first, then attributes
                  if (geometry.x !== undefined && geometry.y !== undefined) {
                    pointLat = geometry.y;
                    pointLon = geometry.x;
                  } else if (geometry.coordinates && geometry.coordinates.length >= 2) {
                    pointLon = geometry.coordinates[0];
                    pointLat = geometry.coordinates[1];
                  } else if (feature.Latitude && feature.Longitude) {
                    pointLat = feature.Latitude;
                    pointLon = feature.Longitude;
                  }

                  if (pointLat === null || pointLon === null) {
                    console.warn(`⚠️ ${layerConfig.title}: Could not extract point coordinates from geometry`, {
                      hasX: geometry.x !== undefined,
                      hasY: geometry.y !== undefined,
                      hasCoordinates: !!geometry.coordinates,
                      hasLatLon: !!(feature.Latitude && feature.Longitude)
                    });
                    return;
                  }

                  const icon = createPOIIcon(layerConfig.icon, layerConfig.color);
                  const marker = L.marker([pointLat, pointLon], { icon });

                  // Handle charging stations, blue bike stations, park features, and MBTA stops
                  const stationName = feature.Station_Name || feature.station_name || feature.STATION_NAME || 
                    feature.STATION || feature.station || feature.Station ||
                    feature.Name || feature.name || feature.NAME || 
                    feature.Park_Name || feature.park_name || feature.PARK_NAME || 
                    feature.Play_Name || feature.play_name || feature.PLAY_NAME || 'Unknown';
                  const streetAddress = feature.Street_Address || feature.street_address || feature.STREET_ADDRESS || feature.address || '';
                  const city = feature.City || feature.city || feature.CITY || feature.District || feature.district || feature.Neighbor || feature.neighbor || feature.NEIGHBOR || 'Boston';
                  const evLevel2 = feature.EV_Level2_EVSE_Num || feature.ev_level2_evse_num || 0;
                  const evConnectorTypes = feature.EV_Connector_Types || feature.ev_connector_types || '';
                  const totalDocks = feature.Total_docks || feature.total_docks || feature.Total_Docks || '';
                  const district = feature.District || feature.district || '';
                  const neighbor = feature.Neighbor || feature.neighbor || feature.NEIGHBOR || feature.Neighbor_ || '';
                  const asset = feature.Asset || feature.asset || feature.ASSET || feature.Asset_ || '';
                  const assetDetail = feature.asset_deta || feature.asset_deta_ || feature.ASSET_DETA || '';
                  const publicAccess = feature.Public_ || feature.public_ || feature.PUBLIC_ || '';
                  // MBTA stops fields
                  const mbtaLine = feature.LINE || feature.line || feature.Line || '';
                  const mbtaTerminus = feature.TERMINUS || feature.terminus || feature.Terminus || '';
                  const mbtaRoute = feature.ROUTE || feature.route || feature.Route || '';
                  const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';
                  
                  // For crosswalks and yellow centerlines, use different field names
                  const crosswalkId = feature.Crosswalk_ID || feature.crosswalk_id || feature.CROSSWALK_ID || '';
                  const lineId = feature.Line_ID || feature.line_id || feature.LINE_ID || '';
                  const segmentId = feature.Segment_ID || feature.segment_id || feature.SEGMENT_ID || '';

                  let popupContent = `
                    <div style="min-width: 250px; max-width: 400px;">
                      <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                        ${layerConfig.icon} ${stationName || crosswalkId || lineId || segmentId || 'Unknown'}
                      </h3>
                      <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                        ${streetAddress ? `<div><strong>Address:</strong> ${streetAddress}, ${city}</div>` : neighbor ? `<div><strong>Neighborhood:</strong> ${neighbor}</div>` : district ? `<div><strong>District:</strong> ${district}</div>` : ''}
                        ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                        ${mbtaLine ? `<div><strong>Line:</strong> ${mbtaLine}</div>` : ''}
                        ${mbtaRoute ? `<div><strong>Route:</strong> ${mbtaRoute}</div>` : ''}
                        ${mbtaTerminus ? `<div><strong>Terminus:</strong> ${mbtaTerminus === 'Y' ? 'Yes' : mbtaTerminus === 'N' ? 'No' : mbtaTerminus}</div>` : ''}
                        ${crosswalkId ? `<div><strong>Crosswalk ID:</strong> ${crosswalkId}</div>` : ''}
                        ${lineId ? `<div><strong>Line ID:</strong> ${lineId}</div>` : ''}
                        ${segmentId ? `<div><strong>Segment ID:</strong> ${segmentId}</div>` : ''}
                        ${totalDocks ? `<div><strong>Total Docks:</strong> ${totalDocks}</div>` : ''}
                        ${evLevel2 ? `<div><strong>Level 2 EVSE:</strong> ${evLevel2}</div>` : ''}
                        ${evConnectorTypes ? `<div><strong>Connector Types:</strong> ${evConnectorTypes}</div>` : ''}
                        ${asset ? `<div><strong>Asset:</strong> ${asset}</div>` : ''}
                        ${assetDetail ? `<div><strong>Asset Detail:</strong> ${assetDetail}</div>` : ''}
                        ${publicAccess ? `<div><strong>Public Access:</strong> ${publicAccess}</div>` : ''}
                      </div>
                      <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                  `;

                  const excludeFields = ['Station_Name', 'station_name', 'STATION_NAME', 'STATION', 'station', 'Station', 'Name', 'name', 'NAME', 'Park_Name', 'park_name', 'PARK_NAME', 'Play_Name', 'play_name', 'PLAY_NAME', 'Street_Address', 'street_address', 'STREET_ADDRESS', 'address', 'City', 'city', 'CITY', 'District', 'district', 'Neighbor', 'neighbor', 'NEIGHBOR', 'Neighbor_', 'Asset', 'asset', 'ASSET', 'Asset_', 'asset_deta', 'asset_deta_', 'ASSET_DETA', 'Total_docks', 'total_docks', 'Total_Docks', 'Public_', 'public_', 'PUBLIC_', 'EV_Level2_EVSE_Num', 'ev_level2_evse_num', 'EV_Connector_Types', 'ev_connector_types', 'LINE', 'line', 'Line', 'ROUTE', 'route', 'Route', 'TERMINUS', 'terminus', 'Terminus', 'Crosswalk_ID', 'crosswalk_id', 'CROSSWALK_ID', 'Line_ID', 'line_id', 'LINE_ID', 'Segment_ID', 'segment_id', 'SEGMENT_ID', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'ObjectId', 'layerId', 'layerName', 'Latitude', 'Longitude', 'latitude', 'longitude'];
                  Object.entries(feature).forEach(([key, value]) => {
                    if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                      if (typeof value === 'object' && !Array.isArray(value)) return;
                      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                      popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                    }
                  });

                  popupContent += `</div></div>`;
                  marker.bindPopup(popupContent, { maxWidth: 400 });
                  marker.addTo(primary);
                  bounds.extend([pointLat, pointLon]);
                  featureCount++;
                } else if (layerConfig.isPolyline) {
                  // Polyline geometry (bicycle network, managed streets, crosswalks, yellow centerlines)
                  let paths: number[][][] = [];
                  
                  // Check for paths first (most common for polylines)
                  if (geometry.paths && Array.isArray(geometry.paths) && geometry.paths.length > 0) {
                    paths = geometry.paths;
                  } 
                  // Check for rings (some polylines stored as rings)
                  else if (geometry.rings && Array.isArray(geometry.rings) && geometry.rings.length > 0) {
                    paths = geometry.rings;
                  }
                  // Debug: log geometry structure if neither paths nor rings found
                  else {
                    console.warn(`⚠️ ${layerConfig.title}: Feature has geometry but no paths or rings`, {
                      geometryType: geometry.type,
                      geometryKeys: Object.keys(geometry),
                      hasPaths: !!geometry.paths,
                      hasRings: !!geometry.rings,
                      featureKeys: Object.keys(feature).slice(0, 20)
                    });
                  }

                  if (paths.length > 0) {
                    paths.forEach((path: number[][]) => {
                      if (path && Array.isArray(path) && path.length >= 2) {
                        const latlngs = path
                          .map((coord: number[]) => {
                            // Handle both [lon, lat] and [x, y] coordinate formats
                            if (Array.isArray(coord) && coord.length >= 2) {
                              // ESRI geometry coordinates are [x, y] which is [lon, lat] in WGS84
                              // Convert [lon, lat] to [lat, lon] for Leaflet
                              return [coord[1], coord[0]] as [number, number];
                            }
                            return null;
                          })
                          .filter((coord): coord is [number, number] => coord !== null && coord[0] !== null && coord[1] !== null);

                        if (latlngs.length < 2) {
                          console.warn(`⚠️ ${layerConfig.title}: Skipping polyline with less than 2 valid coordinates (got ${latlngs.length} from ${path.length} coords)`);
                          return;
                        }

                        const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : '';
                        const streetName = feature.STREET_NAM || feature.street_nam || feature.STREET_NAME || feature.street_name || 
                          feature.STREETNAME || feature.streetname ||
                          feature.Crosswalk_ID || feature.crosswalk_id || feature.CROSSWALK_ID ||
                          feature.Segment_ID || feature.segment_id || feature.SEGMENT_ID ||
                          feature.Line_ID || feature.line_id || feature.LINE_ID || 'Unknown';
                        const existingFacility = feature.ExisFacil || feature.exis_facil || feature.EXIS_FACIL || '';
                        const installDate = feature.InstallDat || feature.install_dat || feature.INSTALL_DAT || '';
                        const km = feature.Km || feature.km || feature.KM || '';
                        const lengthMi = feature.LENGTH_MI || feature.length_mi || feature.Length_Mi || feature.Length || feature.length || '';
                        const speedLimit = feature.SPEED_LIM || feature.speed_lim || feature.Speed_Lim || '';
                        const crosswalkId = feature.Crosswalk_ID || feature.crosswalk_id || feature.CROSSWALK_ID || '';
                        const segmentId = feature.Segment_ID || feature.segment_id || feature.SEGMENT_ID || '';
                        const lineId = feature.Line_ID || feature.line_id || feature.LINE_ID || '';
                        const numLanes = feature.NUM_LANES || feature.num_lanes || feature.Num_Lanes || '';
                        const fromStreet = feature.FM_ST_NAME || feature.fm_st_name || feature.FM_STREET_NAME || '';
                        const toStreet = feature.TO_ST_NAME || feature.to_st_name || feature.TO_STREET_NAME || '';

                        const polyline = L.polyline(latlngs, {
                          color: layerConfig.color,
                          weight: 3,
                          opacity: 0.8
                        });

                        let popupContent = `
                          <div style="min-width: 250px; max-width: 400px;">
                            <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                              ${layerConfig.icon} ${streetName}
                            </h3>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                              ${distance ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                              ${crosswalkId ? `<div><strong>Crosswalk ID:</strong> ${crosswalkId}</div>` : ''}
                              ${segmentId ? `<div><strong>Segment ID:</strong> ${segmentId}</div>` : ''}
                              ${lineId ? `<div><strong>Line ID:</strong> ${lineId}</div>` : ''}
                              ${fromStreet && toStreet ? `<div><strong>From:</strong> ${fromStreet} <strong>To:</strong> ${toStreet}</div>` : ''}
                              ${lengthMi ? `<div><strong>Length:</strong> ${lengthMi} miles</div>` : km ? `<div><strong>Length:</strong> ${km} km</div>` : ''}
                              ${speedLimit ? `<div><strong>Speed Limit:</strong> ${speedLimit} mph</div>` : ''}
                              ${numLanes ? `<div><strong>Number of Lanes:</strong> ${numLanes}</div>` : ''}
                              ${existingFacility ? `<div><strong>Facility Type:</strong> ${existingFacility}</div>` : ''}
                              ${installDate ? `<div><strong>Installation Date:</strong> ${installDate}</div>` : ''}
                            </div>
                            <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                        `;

                        const excludeFields = ['STREET_NAM', 'street_nam', 'STREET_NAME', 'street_name', 'STREETNAME', 'streetname', 'Crosswalk_ID', 'crosswalk_id', 'CROSSWALK_ID', 'Segment_ID', 'segment_id', 'SEGMENT_ID', 'Line_ID', 'line_id', 'LINE_ID', 'FM_ST_NAME', 'fm_st_name', 'FM_STREET_NAME', 'TO_ST_NAME', 'to_st_name', 'TO_STREET_NAME', 'LENGTH_MI', 'length_mi', 'Length_Mi', 'Length', 'length', 'SPEED_LIM', 'speed_lim', 'Speed_Lim', 'NUM_LANES', 'num_lanes', 'Num_Lanes', 'ExisFacil', 'exis_facil', 'EXIS_FACIL', 'InstallDat', 'install_dat', 'INSTALL_DAT', 'Km', 'km', 'KM', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'ObjectId', 'FID', 'fid', 'layerId', 'layerName'];
                        Object.entries(feature).forEach(([key, value]) => {
                          if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                            if (typeof value === 'object' && !Array.isArray(value)) return;
                            const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                            popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                          }
                        });

                        popupContent += `</div></div>`;
                        polyline.bindPopup(popupContent, { maxWidth: 400 });
                        polyline.addTo(primary);
                        bounds.extend(polyline.getBounds());
                        featureCount++;
                      }
                    });
                  } else {
                    // Debug: Log when geometry exists but no paths/rings found
                    console.warn(`⚠️ ${layerConfig.title}: Feature has geometry but no paths or rings found`, {
                      hasPaths: !!geometry.paths,
                      pathsLength: geometry.paths?.length || 0,
                      hasRings: !!geometry.rings,
                      ringsLength: geometry.rings?.length || 0,
                      geometryKeys: Object.keys(geometry)
                    });
                  }
                } else if (layerConfig.isPolygon) {
                  // Polygon geometry (public open space, school zones, parcels)
                  if (geometry.rings && geometry.rings.length > 0) {
                    const rings = geometry.rings;
                    if (rings && rings.length > 0) {
                      const outerRing = rings[0];
                      if (outerRing && outerRing.length >= 3) {
                        const latlngs = outerRing.map((coord: number[]) => {
                          return [coord[1], coord[0]] as [number, number];
                        });

                        const isContaining = feature.isContaining || feature.distance_miles === 0;
                        const distance = feature.distance_miles !== undefined ? feature.distance_miles.toFixed(2) : (isContaining ? '0.00' : '');
                        const siteName = feature.SITE_NAME || feature.site_name || feature.SITE_NAME_ || 
                          feature.School_Name || feature.school_name || feature.SCHOOL_NAME || 
                          feature.School_Zone_ID || feature.school_zone_id || feature.SCHOOL_ZONE_ID ||
                          feature.MAP_PAR_ID || feature.map_par_id || feature.MAP_PAR_ID_ || 
                          feature.Tract || feature.tract || feature.TRACT || 
                          feature.GEOID || feature.geoid || feature.GEOID10 || feature.geoid10 || 
                          feature.NAME || feature.name || feature.NAME10 || feature.name10 ||
                          feature.Neighborhood || feature.neighborhood || feature.NEIGHBORHOOD ||
                          feature.City || feature.city || feature.CITY ||
                          feature.District || feature.district || feature.DISTRICT ||
                          feature.DISTRICT_NAME || feature.district_name || feature.District_Name ||
                          feature.PWD_DISTRICT || feature.pwd_district || feature.PWD_District ||
                          feature.SNOW_DISTRICT || feature.snow_district || feature.Snow_District || 'Unknown';
                        const ownership = feature.OWNERSHIP || feature.ownership || feature.OWNERSHIP_ || '';
                        const protection = feature.PROTECTION || feature.protection || feature.PROTECTION_ || '';
                        const acres = feature.ACRES || feature.acres || feature.ACRES_ || '';
                        const address = feature.ADDRESS || feature.address || feature.ADDRESS_ || '';
                        const district = feature.DISTRICT || feature.district || feature.DISTRICT_ || '';
                        const schoolId = feature.School_ID || feature.school_id || feature.SCHOOL_ID || '';
                        const mapParId = feature.MAP_PAR_ID || feature.map_par_id || feature.MAP_PAR_ID_ || '';
                        const locId = feature.LOC_ID || feature.loc_id || feature.LOC_ID_ || '';
                        const polyType = feature.POLY_TYPE || feature.poly_type || feature.POLY_TYPE_ || '';
                        const mapNo = feature.MAP_NO || feature.map_no || feature.MAP_NO_ || '';
                        // Census tract, neighborhood, city, and district fields
                        const tract = feature.Tract || feature.tract || feature.TRACT || '';
                        const geoid = feature.GEOID || feature.geoid || feature.GEOID10 || feature.geoid10 || '';
                        const tractName = feature.NAME || feature.name || feature.NAME10 || feature.name10 || '';
                        const neighborhood = feature.Neighborhood || feature.neighborhood || feature.NEIGHBORHOOD || '';
                        const city = feature.City || feature.city || feature.CITY || '';
                        const districtName = feature.DISTRICT_NAME || feature.district_name || feature.District_Name || feature.District || feature.district || feature.DISTRICT || '';
                        const pwdDistrict = feature.PWD_DISTRICT || feature.pwd_district || feature.PWD_District || '';
                        const snowDistrict = feature.SNOW_DISTRICT || feature.snow_district || feature.Snow_District || '';
                        const population = feature.Population || feature.population || feature.POPULATION || feature.POP2025 || feature.pop2025 || '';
                        const households = feature.Households || feature.households || feature.HOUSEHOLDS || feature.HH2025 || feature.hh2025 || '';
                        const housingUnits = feature.Housing_Units || feature.housing_units || feature.HOUSING_UNITS || feature.HU2025 || feature.hu2025 || '';

                        // Get unique color for this polygon layer to ensure distinct colors across layers
                        const polygonColor = getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color);
                        
                        const polygon = L.polygon(latlngs, {
                          color: polygonColor,
                          weight: isContaining ? 3 : 2,
                          opacity: 0.8,
                          fillColor: polygonColor,
                          fillOpacity: isContaining ? 0.4 : 0.2
                        });

                        let popupContent = `
                          <div style="min-width: 250px; max-width: 400px;">
                            <h3 style="margin: 0 0 8px 0; color: #1f2937; font-weight: 600; font-size: 14px;">
                              ${layerConfig.icon} ${siteName}${isContaining ? ' <span style="color: #16a34a;">(Contains Point)</span>' : ''}
                            </h3>
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">
                              ${districtName ? `<div><strong>District Name:</strong> ${districtName}</div>` : ''}
                              ${pwdDistrict ? `<div><strong>PWD District:</strong> ${pwdDistrict}</div>` : ''}
                              ${snowDistrict ? `<div><strong>Snow District:</strong> ${snowDistrict}</div>` : ''}
                              ${neighborhood ? `<div><strong>Neighborhood:</strong> ${neighborhood}</div>` : ''}
                              ${city ? `<div><strong>City:</strong> ${city}</div>` : ''}
                              ${tract ? `<div><strong>Census Tract:</strong> ${tract}</div>` : ''}
                              ${geoid ? `<div><strong>GEOID:</strong> ${geoid}</div>` : ''}
                              ${tractName ? `<div><strong>Tract Name:</strong> ${tractName}</div>` : ''}
                              ${population ? `<div><strong>Population (2025):</strong> ${typeof population === 'number' ? population.toLocaleString() : population}</div>` : ''}
                              ${households ? `<div><strong>Households (2025):</strong> ${typeof households === 'number' ? households.toLocaleString() : households}</div>` : ''}
                              ${housingUnits ? `<div><strong>Housing Units (2025):</strong> ${typeof housingUnits === 'number' ? housingUnits.toLocaleString() : housingUnits}</div>` : ''}
                              ${address ? `<div><strong>Address:</strong> ${address}</div>` : ''}
                              ${district ? `<div><strong>District:</strong> ${district}</div>` : ''}
                              ${schoolId ? `<div><strong>School ID:</strong> ${schoolId}</div>` : ''}
                              ${mapParId ? `<div><strong>Map Parcel ID:</strong> ${mapParId}</div>` : ''}
                              ${locId ? `<div><strong>Location ID:</strong> ${locId}</div>` : ''}
                              ${polyType ? `<div><strong>Polygon Type:</strong> ${polyType}</div>` : ''}
                              ${mapNo ? `<div><strong>Map Number:</strong> ${mapNo}</div>` : ''}
                              ${distance !== undefined && distance !== '' ? `<div style="color: #d97706; font-weight: 600;">📍 Distance: ${distance} miles</div>` : ''}
                              ${isContaining ? `<div style="color: #16a34a; font-weight: 600;">✓ Point is within this area</div>` : ''}
                              ${acres ? `<div><strong>Acres:</strong> ${acres}</div>` : ''}
                              ${ownership ? `<div><strong>Ownership:</strong> ${ownership}</div>` : ''}
                              ${protection ? `<div><strong>Protection:</strong> ${protection}</div>` : ''}
                            </div>
                            <div style="font-size: 12px; color: #6b7280; max-height: 300px; overflow-y: auto; border-top: 1px solid #e5e7eb; padding-top: 8px;">
                        `;

                        const excludeFields = ['SITE_NAME', 'site_name', 'SITE_NAME_', 'School_Name', 'school_name', 'SCHOOL_NAME', 'School_Zone_ID', 'school_zone_id', 'SCHOOL_ZONE_ID', 'School_ID', 'school_id', 'SCHOOL_ID', 'MAP_PAR_ID', 'map_par_id', 'MAP_PAR_ID_', 'LOC_ID', 'loc_id', 'LOC_ID_', 'POLY_TYPE', 'poly_type', 'POLY_TYPE_', 'MAP_NO', 'map_no', 'MAP_NO_', 'OWNERSHIP', 'ownership', 'OWNERSHIP_', 'PROTECTION', 'protection', 'PROTECTION_', 'ACRES', 'acres', 'ACRES_', 'ADDRESS', 'address', 'ADDRESS_', 'DISTRICT', 'district', 'DISTRICT_', 'DISTRICT_NAME', 'district_name', 'District_Name', 'PWD_DISTRICT', 'pwd_district', 'PWD_District', 'SNOW_DISTRICT', 'snow_district', 'Snow_District', 'Tract', 'tract', 'TRACT', 'GEOID', 'geoid', 'GEOID10', 'geoid10', 'NAME', 'name', 'NAME10', 'name10', 'Neighborhood', 'neighborhood', 'NEIGHBORHOOD', 'City', 'city', 'CITY', 'Population', 'population', 'POPULATION', 'POP2025', 'pop2025', 'Households', 'households', 'HOUSEHOLDS', 'HH2025', 'hh2025', 'Housing_Units', 'housing_units', 'HOUSING_UNITS', 'HU2025', 'hu2025', 'geometry', 'distance_miles', 'objectid', 'OBJECTID', 'ObjectId', 'OBJECTID_', 'FID', 'fid', 'layerId', 'layerName', 'isContaining'];
                        Object.entries(feature).forEach(([key, value]) => {
                          if (!excludeFields.includes(key) && value !== null && value !== undefined && value !== '') {
                            if (typeof value === 'object' && !Array.isArray(value)) return;
                            const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
                            popupContent += `<div><strong>${formattedKey}:</strong> ${value}</div>`;
                          }
                        });

                        popupContent += `</div></div>`;
                        polygon.bindPopup(popupContent, { maxWidth: 400 });
                        polygon.addTo(primary);
                        bounds.extend(polygon.getBounds());
                        featureCount++;
                      }
                    }
                  }
                }
              } catch (error) {
                console.error(`Error drawing ${layerConfig.title} feature:`, error);
              }
            });

            if (featureCount > 0) {
              const legendKey = layerConfig.key.replace('_all', '');
              const radius = getRadiusForLegendKey(legendKey);
              const radiusDisplay = formatRadiusDisplay(legendKey, radius);
              
              // Get unique color for polygon layers to ensure distinct colors
              const uniqueColor = layerConfig.isPolygon 
                ? getUniqueColorForPolygonLayer(layerConfig.key, layerConfig.color)
                : layerConfig.color;
              
              if (!legendAccumulator[legendKey]) {
                legendAccumulator[legendKey] = {
                  icon: layerConfig.icon,
                  color: uniqueColor,
                  title: layerConfig.title,
                  count: 0,
                  radius: radius,
                  radiusDisplay: radiusDisplay,
                };
              } else {
                // Update color to ensure it matches the rendered polygons
                legendAccumulator[legendKey].color = uniqueColor;
              }
              legendAccumulator[legendKey].count += featureCount;
              // Always update radius info (in case poiRadii was updated or we want to ensure it's set)
              if (radius !== undefined) {
                legendAccumulator[legendKey].radius = radius;
                legendAccumulator[legendKey].radiusDisplay = radiusDisplay;
              }
            }
          } catch (error) {
            console.error(`Error processing ${layerConfig.title}:`, error);
          }
        }
      });

      // All enrichment features are drawn here (map already zoomed in STEP 1 above)
      Object.entries(enrichments).forEach(([key, value]) => {
        if (!Array.isArray(value)) {
          return;
        }

        if (!/_detailed$|_elements$|_features$|_facilities$|_all_pois$|_all$/i.test(key)) {
          return;
        }

        // Skip TIGER Places and County Subdivisions _all arrays - handled separately with polygon geometry drawing
        if (key.startsWith('tiger_places_') && key.endsWith('_all')) {
          return;
        }

        // CRITICAL: Skip Australia mine arrays - they're drawn above with correct icons
        if (key === 'australia_operating_mines_all_pois' ||
            key === 'australia_developing_mines_all_pois' ||
            key === 'australia_care_maintenance_mines_all_pois' ||
            key === 'australia_npi_facilities_all_pois') {
          console.log(`⛏️ EXCLUDING ${key} from generic handler - already drawn above`);
          return;
        }

        // Skip PAD-US features arrays - they're handled separately with geometry drawing
        if (key.includes('padus_public_access_nearby_features') || key.includes('padus_protection_status_nearby_features')) {
          return;
        }

        // Skip TIGER CBSA nearby_features arrays - they're handled separately with geometry drawing
        if (key.includes('tiger_cbsa_') && key.includes('_nearby_features')) {
          return;
        }
        if (key.includes('tiger_bas2025_cbsa_') && key.includes('_nearby_features')) {
          return;
        }
        if (key.includes('tiger_acs2024_cbsa_') && key.includes('_nearby_features')) {
          return;
        }
        if (key.includes('tiger_census2020_cbsa_') && key.includes('_nearby_features')) {
          return;
        }

        // Skip Orlando Christmas Lights - handled separately with custom icons
        if (key === 'orlando_christmas_lights_all') {
          return;
        }

        // Skip US Drilling Platforms - handled separately with custom icons
        if (key === 'us_drilling_platforms_all') {
          return;
        }

        // Skip SC Scenic Rivers - handled separately with custom polylines
        if (key === 'sc_scenic_rivers_all') {
          return;
        }

        // Skip FLDOT Number of Lanes - handled separately with custom polylines (color-coded by lane count)
        if (key === 'fldot_number_of_lanes_all') {
          return;
        }

        // Skip FLDOT Functional Classification - handled separately with custom polylines (color-coded by FUNCLASS)
        if (key === 'fldot_functional_classification_all') {
          return;
        }

        // Skip FLDOT Rest Areas - handled separately with custom point markers (color-coded by type)
        if (key === 'fldot_rest_areas_all') {
          return;
        }

        // Skip WY Bighorn Sheep Crucial Range - handled separately with polygon geometry drawing
        if (key === 'wy_bighorn_sheep_crucial_range_all') {
          return;
        }

        // Skip DC Urban Tree Canopy layers - handled separately with geometry drawing
        if (key.startsWith('dc_utc_') && key.endsWith('_all')) {
          return;
        }

        // Skip DC Bike Trails layers - handled separately with geometry drawing
        if (key.startsWith('dc_bike_') && key.endsWith('_all')) {
          return;
        }

        // Skip Ireland arrays - they're handled separately with geometry drawing
        if (key.includes('ireland_electoral_divisions_containing') || 
            key.includes('ireland_electoral_divisions_nearby_features') || 
            key.includes('ireland_electoral_divisions_all') ||
            key.includes('ireland_nuts3_boundaries_containing') ||
            key.includes('ireland_nuts3_boundaries_nearby_features') ||
            key.includes('ireland_nuts3_boundaries_all') ||
            key.includes('ireland_civil_parishes_containing') ||
            key.includes('ireland_civil_parishes_nearby_features') ||
            key.includes('ireland_civil_parishes_all') ||
            key.includes('ireland_buildings_residential_containing') ||
            key.includes('ireland_buildings_residential_nearby_features') ||
            key.includes('ireland_buildings_residential_all') ||
            key.includes('ireland_buildings_residential_commercial_containing') ||
            key.includes('ireland_buildings_residential_commercial_nearby_features') ||
            key.includes('ireland_buildings_residential_commercial_all') ||
            key.includes('ireland_buildings_commercial_containing') ||
            key.includes('ireland_buildings_commercial_nearby_features') ||
            key.includes('ireland_buildings_commercial_all') ||
            key.includes('ireland_mountains_all') ||
            key.includes('ireland_centres_of_population_all') ||
            key.includes('ireland_high_water_marks_all') ||
            key.includes('ireland_pois_all') ||
            key.includes('australia_railways_all') ||
            key.includes('australia_railways_detailed') ||
            key.includes('australia_trams_all') ||
            key.includes('australia_trams_detailed') ||
            key.includes('australia_national_roads_all') ||
            key.includes('australia_national_roads_detailed') ||
            key.includes('australia_major_roads_all') ||
            key.includes('australia_major_roads_detailed') ||
            key.includes('australia_bushfires_containing') ||
            key.includes('australia_bushfires_nearby_features') ||
            key.includes('australia_bushfires_all') ||
            key.includes('australia_built_up_areas_all') ||
            key.includes('australia_built_up_areas_containing') ||
            key.includes('australia_built_up_areas_nearby_features') ||
            key.includes('australia_operating_mines_all_pois') ||
            key.includes('australia_developing_mines_all_pois') ||
            key.includes('australia_care_maintenance_mines_all_pois') ||
            key.includes('australia_npi_facilities_all_pois') ||
            key.includes('ireland_vegetation_areas_containing') ||
            key.includes('ireland_vegetation_areas_nearby_features') ||
            key.includes('ireland_vegetation_areas_all') ||
            key.includes('ireland_small_areas_containing') ||
            key.includes('ireland_small_areas_nearby_features') ||
            key.includes('ireland_small_areas_all') ||
            key.includes('ireland_built_up_areas_containing') ||
            key.includes('ireland_built_up_areas_nearby_features') ||
            key.includes('ireland_built_up_areas_all') ||
            key.includes('ireland_provinces_containing') ||
            key.includes('ireland_provinces_nearby_features') ||
            key.includes('ireland_provinces_all')) {
          return;
        }

        // Skip Boston layers - they're handled separately with geometry drawing in bostonLayers.forEach above
        if (key.startsWith('boston_') && key.endsWith('_all')) {
          return;
        }

        // Skip Alaska DNR layers - they're handled separately with mapLayerConfig
        if (key.startsWith('alaska_dnr_') && key.endsWith('_all')) {
          return;
        }

        const baseKey = key.replace(/_(detailed|elements|features|facilities|all_pois|all)$/i, '');

        // Skip NH and USVI layers that are explicitly drawn above with custom popups
        if (baseKey === 'nh_fire_stations' || 
            baseKey === 'nh_ems' || 
            baseKey === 'nh_nursing_homes' ||
            baseKey === 'usvi_fire_stations' ||
            baseKey === 'usvi_police_stations') {
          return;
        }

        // Tornado tracks are polylines; never render them as generic point markers.
        if (baseKey === 'tornado_tracks_1950_2017') {
          return;
        }

        // NRI annualized frequency layers are polygons; never render them as generic point markers.
        if (
          baseKey === 'nri_hurricane_annualized_frequency_county' ||
          baseKey === 'nri_hurricane_annualized_frequency_census_tract' ||
          baseKey === 'nri_hail_annualized_frequency_county' ||
          baseKey === 'nri_hail_annualized_frequency_census_tract' ||
          baseKey === 'nri_tornado_annualized_frequency_county' ||
          baseKey === 'nri_tornado_annualized_frequency_census_tract' ||
          baseKey === 'nri_earthquake_annualized_frequency_county' ||
          baseKey === 'nri_earthquake_annualized_frequency_census_tract' ||
          baseKey === 'nri_drought_annualized_frequency_county' ||
          baseKey === 'nri_drought_annualized_frequency_census_tract' ||
          baseKey === 'nri_wildfire_annualized_frequency_county' ||
          baseKey === 'nri_wildfire_annualized_frequency_census_tract' ||
          baseKey === 'nri_lightning_annualized_frequency_county' ||
          baseKey === 'nri_lightning_annualized_frequency_census_tract' ||
          baseKey === 'nri_ice_storm_annualized_frequency_county' ||
          baseKey === 'nri_ice_storm_annualized_frequency_census_tract' ||
          baseKey === 'nri_coastal_flooding_annualized_frequency_county' ||
          baseKey === 'nri_coastal_flooding_annualized_frequency_census_tract' ||
          baseKey === 'nri_riverine_flooding_annualized_frequency_county' ||
          baseKey === 'nri_riverine_flooding_annualized_frequency_census_tract' ||
          baseKey === 'nri_landslide_annualized_frequency_county' ||
          baseKey === 'nri_landslide_annualized_frequency_census_tract' ||
          baseKey === 'nri_strong_wind_annualized_frequency_county' ||
          baseKey === 'nri_strong_wind_annualized_frequency_census_tract' ||
          baseKey === 'nri_winter_weather_annualized_frequency_county' ||
          baseKey === 'nri_winter_weather_annualized_frequency_census_tract' ||
          baseKey === 'nri_cold_wave_annualized_frequency_county' ||
          baseKey === 'nri_cold_wave_annualized_frequency_census_tract' ||
          baseKey === 'nri_heat_wave_annualized_frequency_county' ||
          baseKey === 'nri_heat_wave_annualized_frequency_census_tract' ||
          baseKey === 'nri_avalanche_annualized_frequency_county' ||
          baseKey === 'nri_avalanche_annualized_frequency_census_tract' ||
          baseKey === 'nri_tsunami_annualized_frequency_county' ||
          baseKey === 'nri_tsunami_annualized_frequency_census_tract' ||
          baseKey === 'nri_volcanic_activity_annualized_frequency_county' ||
          baseKey === 'nri_volcanic_activity_annualized_frequency_census_tract' ||
          baseKey === 'nri_avalanche_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_coastal_flooding_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_coastal_flooding_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_cold_wave_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_cold_wave_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_drought_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_drought_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_earthquake_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_earthquake_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_expected_annual_loss_rating_composite_census_tract' ||
          baseKey === 'nri_hail_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_hail_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_heat_wave_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_heat_wave_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_ice_storm_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_ice_storm_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_inland_flooding_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_inland_flooding_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_landslide_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_landslide_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_lightning_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_lightning_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_social_vulnerability_rating_census_tract' ||
          baseKey === 'nri_strong_wind_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_strong_wind_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_tornado_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_tornado_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_tsunami_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_tsunami_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_volcanic_activity_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_volcanic_activity_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_wildfire_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_wildfire_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_winter_weather_expected_annual_loss_rating_census_tract' ||
          baseKey === 'nri_winter_weather_hazard_type_risk_index_rating_census_tract' ||
          baseKey === 'nri_avalanche_expected_annual_loss_rating_county' ||
          baseKey === 'nri_avalanche_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_coastal_flooding_expected_annual_loss_rating_county' ||
          baseKey === 'nri_coastal_flooding_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_cold_wave_expected_annual_loss_rating_county' ||
          baseKey === 'nri_cold_wave_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_community_resilience_rating_county' ||
          baseKey === 'nri_drought_expected_annual_loss_rating_county' ||
          baseKey === 'nri_drought_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_earthquake_expected_annual_loss_rating_county' ||
          baseKey === 'nri_earthquake_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_hail_expected_annual_loss_rating_county' ||
          baseKey === 'nri_hail_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_heat_wave_expected_annual_loss_rating_county' ||
          baseKey === 'nri_heat_wave_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_hurricane_expected_annual_loss_rating_county' ||
          baseKey === 'nri_hurricane_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_ice_storm_expected_annual_loss_rating_county' ||
          baseKey === 'nri_ice_storm_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_inland_flooding_expected_annual_loss_rating_county' ||
          baseKey === 'nri_inland_flooding_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_landslide_expected_annual_loss_rating_county' ||
          baseKey === 'nri_landslide_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_lightning_expected_annual_loss_rating_county' ||
          baseKey === 'nri_national_risk_index_rating_composite_county' ||
          baseKey === 'nri_strong_wind_expected_annual_loss_rating_county' ||
          baseKey === 'nri_strong_wind_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_tornado_expected_annual_loss_rating_county' ||
          baseKey === 'nri_tornado_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_tsunami_expected_annual_loss_rating_county' ||
          baseKey === 'nri_tsunami_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_volcanic_activity_expected_annual_loss_rating_county' ||
          baseKey === 'nri_volcanic_activity_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_wildfire_expected_annual_loss_rating_county' ||
          baseKey === 'nri_wildfire_hazard_type_risk_index_rating_county' ||
          baseKey === 'nri_winter_weather_expected_annual_loss_rating_county' ||
          baseKey === 'nri_winter_weather_hazard_type_risk_index_rating_county'
        ) {
          return;
        }

        // Explicitly skip POI marker rendering for ice layers to avoid points while keeping proximity support
        if (baseKey.startsWith('nws_ndfd_ice_')) {
          console.warn(`🥶 Skipping POI marker rendering for ice layer ${baseKey} (polygon-only)`);
          return;
        }
        // Skip POI marker rendering for Stream Gauges (handled in NWS renderer)
        if (baseKey === 'nws_stream_gauges_live') {
          console.warn(`💧 Skipping POI marker rendering for ${baseKey} (handled as NWS layer)`);
          return;
        }
        
        // ABSOLUTE CHECK: If this is a mine array, skip it completely
        if (baseKey.includes('australia_operating_mines') || 
            baseKey.includes('australia_developing_mines') || 
            baseKey.includes('australia_care_maintenance_mines') ||
            key.includes('australia_operating_mines') ||
            key.includes('australia_developing_mines') ||
            key.includes('australia_care_maintenance_mines')) {
          console.log(`🚫 BLOCKING ${key} from generic handler`);
          return;
        }
        
        const poiInfo = POI_ICONS[baseKey] || POI_ICONS['default'];
        const poiMeta = poiConfigManager.getPOIType(baseKey);
        const iconEmoji = poiInfo.icon || '📍';
        const defaultColor = poiInfo.color || '#2563eb';
        // Ensure unique color for point features
        const iconColor = getUniqueColorForPointFeature(baseKey, defaultColor);
        const legendTitle = poiMeta?.label || poiInfo.title || formatPopupFieldName(baseKey);
        
        // Get radius info if available
        const radius = getRadiusForLegendKey(baseKey);
        const radiusDisplay = formatRadiusDisplay(baseKey, radius);

        if (!legendAccumulator[baseKey]) {
          legendAccumulator[baseKey] = {
            icon: iconEmoji,
            color: iconColor,
            title: legendTitle,
            count: 0,
            radius: radius,
            radiusDisplay: radiusDisplay,
          };
        } else {
          // Update color to ensure uniqueness even if entry exists
          legendAccumulator[baseKey].color = iconColor;
          // Update radius info if not already set
          if (radius !== undefined && !legendAccumulator[baseKey].radius) {
            legendAccumulator[baseKey].radius = radius;
            legendAccumulator[baseKey].radiusDisplay = radiusDisplay;
          }
        }

        const itemsArray = value as Array<any>;
        
        // Debug logging for mail shipping
        if (baseKey === 'poi_mail_shipping') {
          console.log(`🗺️ Mail & Shipping: Processing ${itemsArray.length} items for map display`);
        }
        
        // Add to legend count - use full array length for accurate count (shows total available)
        legendAccumulator[baseKey].count += itemsArray.length;

        const leafletIcon = createPOIIcon(iconEmoji, iconColor);

        // Map all POIs - they are already limited by proximity/radius in the query
        // No need for additional limiting here - map ALL items
        let mappedCount = 0;
        itemsArray.forEach((item) => {
          // Skip items with polygon geometry (rings) - these should be drawn as polygons, not points
          if (item.geometry && item.geometry.rings && Array.isArray(item.geometry.rings) && item.geometry.rings.length > 0) {
            return; // Skip polygon features - they're handled separately
          }

          const poiLat =
            item.lat ??
            item.latitude ??
            item.LATITUDE ??
            item.location?.lat ??
            item.center?.lat ??
            item.geometry?.coordinates?.[1];
          const poiLon =
            item.lon ??
            item.longitude ??
            item.LONGITUDE ??
            item.location?.lon ??
            item.center?.lon ??
            item.geometry?.coordinates?.[0];

          if (typeof poiLat !== 'number' || typeof poiLon !== 'number') {
            // Debug logging for items that can't be mapped
            if (baseKey.includes('tri_') || baseKey.includes('epa_')) {
              console.warn(`⚠️ ${baseKey}: Skipping item with invalid coordinates:`, {
                hasLat: !!item.lat || !!item.latitude || !!item.LATITUDE,
                hasLon: !!item.lon || !!item.longitude || !!item.LONGITUDE,
                itemKeys: Object.keys(item)
              });
            }
            return;
          }

          // CRITICAL: Check if a mine marker already exists at this location
          let mineMarkerExists = false;
          poi.eachLayer((layer: any) => {
            if (layer instanceof L.Marker && (layer as any).__isMineMarker) {
              const layerLat = (layer as any).getLatLng().lat;
              const layerLon = (layer as any).getLatLng().lon;
              // Check if coordinates are very close (within 0.0001 degrees, ~11 meters)
              if (Math.abs(layerLat - poiLat) < 0.0001 && Math.abs(layerLon - poiLon) < 0.0001) {
                mineMarkerExists = true;
              }
            }
          });
          
          if (mineMarkerExists) {
            // Skip creating generic marker - mine marker already exists
            return;
          }

          const poiMarker = L.marker([poiLat, poiLon], { icon: leafletIcon });
          // Store metadata for tabbed popup functionality
          (poiMarker as any).__layerType = baseKey;
          (poiMarker as any).__layerTitle = legendTitle;
          poiMarker.bindPopup(createPOIPopupContent(item, legendTitle, baseKey), { maxWidth: 360 });
          poiMarker.addTo(poi);
          mappedCount++;
        });
        
        // Debug logging for mail shipping
        if (baseKey === 'poi_mail_shipping') {
          console.log(`🗺️ Mail & Shipping: Mapped ${mappedCount} markers out of ${itemsArray.length} items`);
        }
      });
    }); // Close results.forEach

        // Set Miami schools and businesses legend items AFTER all results are processed, using total unique counts
        if (totalPublicSchoolCount > 0) {
          legendAccumulator['miami_public_schools'] = {
            icon: '🎓',
            color: '#8b5cf6',
            title: 'Miami Public Schools',
            count: totalPublicSchoolCount
          };
        }
        if (totalPrivateSchoolCount > 0) {
          legendAccumulator['miami_private_schools'] = {
            icon: '🏫',
            color: '#a855f7',
            title: 'Miami Private Schools',
            count: totalPrivateSchoolCount
          };
        }
        if (totalBusinessCount > 0) {
          legendAccumulator['miami_business_fd_inspected'] = {
            icon: '🏢',
            color: '#3b82f6',
            title: 'Miami Business Locations (FD Inspected)',
            count: totalBusinessCount
          };
        }
        if (totalBikeRouteCount > 0) {
          legendAccumulator['fldot_bike_routes'] = {
            icon: '🚴',
            color: '#10b981',
            title: 'FLDOT Bike Routes',
            count: totalBikeRouteCount
          };
        }
        if (totalTrafficPointCount > 0) {
          legendAccumulator['fldot_real_time_traffic'] = {
            icon: '🚦',
            color: '#ef4444',
            title: 'FLDOT Real-Time Traffic',
            count: totalTrafficPointCount
          };
        }

        if (totalFacilityPointCount > 0) {
          legendAccumulator['fldot_facilities'] = {
            icon: '🏢',
            color: '#10b981',
            title: 'FLDOT Facilities',
            count: totalFacilityPointCount
          };
        }

        if (totalBikeSlotCount > 0) {
          legendAccumulator['fldot_bike_slots'] = {
            icon: '🚴',
            color: '#8b5cf6',
            title: 'FLDOT Bike Slots',
            count: totalBikeSlotCount
          };
        }

        if (totalBikeLaneCount > 0) {
          legendAccumulator['fldot_bike_lanes'] = {
            icon: '🚴',
            color: '#3b82f6',
            title: 'FLDOT Bike Lanes',
            count: totalBikeLaneCount
          };
        }

        if (totalRailroadCrossingCount > 0) {
          legendAccumulator['fldot_railroad_crossings'] = {
            icon: '🚂',
            color: '#f59e0b',
            title: 'FLDOT Railroad Crossings',
            count: totalRailroadCrossingCount
          };
        }

        if (totalNumberOfLanesCount > 0) {
          // Number of lanes uses polylines with color coding - show as line with ranges
          // Count lanes by lane count using the stats we collected
          const laneCountRanges = [
            { label: '1 lane', color: '#ef4444', count: laneCountStats[1] || 0 },
            { label: '2 lanes', color: '#f59e0b', count: laneCountStats[2] || 0 },
            { label: '3 lanes', color: '#10b981', count: laneCountStats[3] || 0 },
            { label: '4 lanes', color: '#3b82f6', count: laneCountStats[4] || 0 },
            { label: '5+ lanes', color: '#8b5cf6', count: Object.keys(laneCountStats).filter(k => parseInt(k) >= 5).reduce((sum, k) => sum + (laneCountStats[parseInt(k)] || 0), 0) },
            { label: 'Unknown', color: '#6366f1', count: laneCountStats[0] || 0 }
          ];
          
          // Filter out ranges with zero count
          const activeRanges = laneCountRanges.filter(range => range.count > 0);
          
          // Use most common color as primary, or default to indigo
          const mostCommonRange = activeRanges.length > 0 
            ? activeRanges.reduce((max, range) => range.count > max.count ? range : max)
            : { color: '#6366f1', count: 0 };
          
          legendAccumulator['fldot_number_of_lanes'] = {
            icon: '', // Empty icon for polylines - will render as line
            color: mostCommonRange.color, // Use most common color as primary
            title: 'FLDOT Number of Lanes',
            count: totalNumberOfLanesCount,
            ranges: activeRanges.length > 0 ? activeRanges : laneCountRanges // Show active ranges, or all if none
          };
        }

        if (totalFunctionalClassificationCount > 0) {
          // Functional Classification uses polylines with color coding by FUNCLASS
          const funclassRanges = [
            { label: 'Principal Arterial (01-07)', color: '#ef4444', count: Object.entries(funclassStats).filter(([k]) => { const n = parseInt(k); return n >= 1 && n <= 7; }).reduce((sum, [, c]) => sum + (c || 0), 0) },
            { label: 'Minor Arterial (08-12)', color: '#f59e0b', count: Object.entries(funclassStats).filter(([k]) => { const n = parseInt(k); return n >= 8 && n <= 12; }).reduce((sum, [, c]) => sum + (c || 0), 0) },
            { label: 'Collector (13-16)', color: '#10b981', count: Object.entries(funclassStats).filter(([k]) => { const n = parseInt(k); return n >= 13 && n <= 16; }).reduce((sum, [, c]) => sum + (c || 0), 0) },
            { label: 'Local (17-19)', color: '#3b82f6', count: Object.entries(funclassStats).filter(([k]) => { const n = parseInt(k); return n >= 17 && n <= 19; }).reduce((sum, [, c]) => sum + (c || 0), 0) }
          ];

          const activeRanges = funclassRanges.filter(range => range.count > 0);
          const mostCommonRange = activeRanges.length > 0
            ? activeRanges.reduce((max, range) => range.count > max.count ? range : max)
            : { color: '#6366f1', count: 0 };

          const radius = getRadiusForLegendKey('fldot_functional_classification');
          const radiusDisplay = formatRadiusDisplay('fldot_functional_classification', radius);

          legendAccumulator['fldot_functional_classification'] = {
            icon: '', // Empty icon for polylines - will render as line
            color: mostCommonRange.color, // Use most common color as primary
            title: 'FLDOT Functional Classification',
            count: totalFunctionalClassificationCount,
            radius: radius,
            radiusDisplay: radiusDisplay,
            ranges: activeRanges.length > 0 ? activeRanges : funclassRanges // Show active ranges, or all if none
          };
        }

        if (totalRestAreaCount > 0) {
          legendAccumulator['fldot_rest_areas'] = {
            icon: '🚻',
            color: '#3b82f6',
            title: 'FLDOT Rest Areas & Welcome Centers',
            count: totalRestAreaCount
          };
        }

        console.log('🗺️ STEP 2: Finished drawing all features, setting legend items');
        
        // Debug: Log poiRadii to help diagnose
        if (Object.keys(poiRadii).length > 0) {
          console.log('🗺️ poiRadii available:', Object.keys(poiRadii).slice(0, 10), '... (showing first 10 keys)');
        } else {
          console.log('🗺️ poiRadii is empty - no proximity values available');
        }
        
        // Ensure ALL legend items (points, polylines, AND polygons) have radius info if available
        // This is critical for showing proximity values in the legend for all layer types
        Object.keys(legendAccumulator).forEach(legendKey => {
          const item = legendAccumulator[legendKey];
          if (item) {
            // Always try to get radius - this works for all geometry types (points, polylines, polygons)
            // Priority: poiRadii (user-selected) > POI config defaultRadius
            const radius = getRadiusForLegendKey(legendKey);
            if (radius !== undefined) {
              // Always set radius and radiusDisplay for all legend items
              item.radius = radius;
              item.radiusDisplay = formatRadiusDisplay(legendKey, radius);
              // Check if this came from poiRadii or default
              const fromPoiRadii = poiRadii[legendKey] !== undefined || 
                                   poiRadii[`${legendKey}_all`] !== undefined ||
                                   (legendKey.endsWith('_all') && poiRadii[legendKey.replace(/_all$/, '')] !== undefined);
              const source = fromPoiRadii ? 'poiRadii' : 'POI config default';
              console.log(`✅ Found radius for ${legendKey}: ${radius} -> ${item.radiusDisplay} (from ${source})`);
            } else {
              // Debug: Log when radius is not found (but don't set undefined - keep existing value if any)
              if (!item.radius) {
                console.log(`❌ No radius found for legend key: ${legendKey} (tried variations and POI config)`);
              }
            }
          }
        });
        
        const finalLegendItems = Object.values(legendAccumulator)
          .filter(item => item.count > 0) // Filter out items with zero count
          .sort((a, b) => b.count - a.count);
        
        // Debug logging to help diagnose radius display issues
        if (finalLegendItems.length > 0) {
          console.log('🗺️ Legend items with radius info:', finalLegendItems.map(item => ({
            title: item.title,
            count: item.count,
            radius: item.radius,
            radiusDisplay: item.radiusDisplay,
            hasRadius: !!item.radius,
            hasRadiusDisplay: !!item.radiusDisplay
          })));
        }
        
        setLegendItems(finalLegendItems);
        setShowBatchSuccess(results.length > 1);
        
        // Features drawn - smoothly animate to geocoded location if needed
        // Wait for map to be fully ready before animating
        if (mapInstanceRef.current && isMapReady && results && results.length > 0 && results[0]?.location) {
          const targetLat = results[0].location.lat;
          const targetLon = results[0].location.lon;
          const currentCenter = mapInstanceRef.current.getCenter();
          const currentZoom = mapInstanceRef.current.getZoom();
          
          // Calculate distance between current center and target
          const distance = mapInstanceRef.current.distance(currentCenter, L.latLng(targetLat, targetLon));
          
          // Only animate if we're significantly away from the target (more than 100 meters)
          // or if zoom level is not appropriate
          // Check if any Boston Open Data layers are present - use closer zoom for Boston
          const hasBostonLayers = results.some(result => {
            if (!result.enrichments) return false;
            return Object.keys(result.enrichments).some(key => 
              key.startsWith('boston_') && key.endsWith('_all')
            );
          });
          
          // Use closer zoom (16) for Boston layers, otherwise use standard zoom
          const targetZoom = hasBostonLayers 
            ? (results.length === 1 ? 16 : 14)  // Closer zoom for Boston
            : (results.length === 1 ? 15 : 12);  // Standard zoom for other layers
          const shouldAnimate = distance > 100 || Math.abs(currentZoom - targetZoom) > 2;
          
          if (shouldAnimate) {
            // Smoothly fly to the geocoded location
            // Use a longer delay to ensure map tiles are loaded and map is stable
            setTimeout(() => {
              if (mapInstanceRef.current) {
                try {
                  mapInstanceRef.current.flyTo(
                    [targetLat, targetLon],
                    targetZoom,
                    {
                      duration: 1.2, // Smooth 1.2 second animation
                      easeLinearity: 0.25
                    }
                  );
                } catch (error) {
                  // Fallback to setView if flyTo fails
                  console.warn('flyTo failed, using setView instead:', error);
                  mapInstanceRef.current.setView([targetLat, targetLon], targetZoom, { animate: true });
                }
              }
            }, 400); // Longer delay to ensure map is fully ready
          } else {
            // Just ensure we're at the right location without animation
            mapInstanceRef.current.setView([targetLat, targetLon], targetZoom, { animate: false });
          }
        }
        
        console.log('🗺️ All features drawn');
        
        // Bring location marker to front to ensure it's always visible on top of all features
        if (results[0]?.location && mapInstanceRef.current) {
          try {
            primary.eachLayer((layer: any) => {
              if (layer.__isLocationMarker && typeof layer.bringToFront === 'function') {
                layer.bringToFront();
              }
            });
          } catch (error) {
            console.warn('Error bringing location marker to front:', error);
          }
        }
        
        // Add map click handler for tabbed popup functionality
        // Use requestAnimationFrame to ensure all features are fully added to layer groups
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            setupTabbedPopupHandler();
          });
        });
      });
    }
  }, [results]);


  // Setup tabbed popup handler for overlapping features
  const setupTabbedPopupHandler = () => {
    console.log('🔍 [TABBED POPUP] Setting up handler...');
    if (!mapInstanceRef.current || !layerGroupsRef.current) {
      console.error('❌ [TABBED POPUP] Map or layer groups not ready');
      return;
    }
    
    const map = mapInstanceRef.current;
    const { primary, poi } = layerGroupsRef.current;
    console.log('🔍 [TABBED POPUP] Map instance found:', !!map);
    console.log('🔍 [TABBED POPUP] Primary layer group:', primary);
    console.log('🔍 [TABBED POPUP] POI layer group:', poi);
    
    // Check how many layers are actually in the groups
    const primaryLayerCount = primary.getLayers().length;
    const poiLayerCount = poi.getLayers().length;
    console.log('🔍 [TABBED POPUP] Primary layers count:', primaryLayerCount);
    console.log('🔍 [TABBED POPUP] POI layers count:', poiLayerCount);
    
    if (primaryLayerCount === 0 && poiLayerCount === 0) {
      console.warn('⚠️ [TABBED POPUP] No features found in layer groups yet, retrying in 200ms...');
      setTimeout(() => {
        setupTabbedPopupHandler();
      }, 200);
      return;
    }
    
    // Remove existing click handlers
    map.off('click', handleMapClick);
    
    // Add map click handler (for clicks on empty areas)
    map.on('click', handleMapClick);
    
    // Also intercept clicks on features - prevent default popup and check for overlaps
    let featureHandlerCount = 0;
    
    // Set up handlers for primary group
    primary.eachLayer((layer: L.Layer) => {
      // Skip location marker
      if (layer instanceof L.Marker && (layer as any).options?.title === results[0]?.location?.name) {
        return;
      }
      
      // Remove existing click handlers
      layer.off('click', handleFeatureClick);
      
      // Store original popup content before unbinding (we'll use it in our handler)
      let originalPopupContent = '';
      if (layer instanceof L.Marker || layer instanceof L.Polygon || layer instanceof L.Polyline) {
        const popup = (layer as any).getPopup();
        if (popup) {
          originalPopupContent = popup.getContent() as string;
        }
        // Unbind default popup to prevent it from opening automatically
        (layer as any).unbindPopup();
        // Re-bind popup but don't auto-open it
        if (originalPopupContent) {
          (layer as any).bindPopup(originalPopupContent, { 
            autoOpen: false,  // Don't auto-open on click
            closeOnClick: false 
          });
        }
      }
      
      // Add click handler that checks for overlapping features (with higher priority)
      layer.on('click', handleFeatureClick);
      featureHandlerCount++;
    });
    
    // Set up handlers for poi group as well
    poi.eachLayer((layer: L.Layer) => {
      // Skip location marker
      if (layer instanceof L.Marker && (layer as any).options?.title === results[0]?.location?.name) {
        return;
      }
      
      // Remove existing click handlers
      layer.off('click', handleFeatureClick);
      
      // Store original popup content before unbinding
      let originalPopupContent = '';
      if (layer instanceof L.Marker || layer instanceof L.Polygon || layer instanceof L.Polyline) {
        const popup = (layer as any).getPopup();
        if (popup) {
          originalPopupContent = popup.getContent() as string;
        }
        // Unbind default popup to prevent it from opening automatically
        (layer as any).unbindPopup();
        // Re-bind popup but don't auto-open it
        if (originalPopupContent) {
          (layer as any).bindPopup(originalPopupContent, { 
            autoOpen: false,
            closeOnClick: false 
          });
        }
      }
      
      // Add click handler that checks for overlapping features
      layer.on('click', handleFeatureClick);
      featureHandlerCount++;
    });
    
    console.log('✅ [TABBED POPUP] Handler set up successfully');
    console.log('🔍 [TABBED POPUP] Attached handlers to', featureHandlerCount, 'features');
  };
  
  // Handle feature click to check for overlapping features
  const handleFeatureClick = (e: L.LeafletMouseEvent) => {
    console.log('🔍 [TABBED POPUP] ========== FEATURE CLICK DETECTED ==========');
    console.log('🔍 [TABBED POPUP] Feature click event:', e);
    console.log('🔍 [TABBED POPUP] Clicked layer:', e.target);
    console.log('🔍 [TABBED POPUP] Event type:', e.type);
    
    // Stop event propagation to prevent default popup - do this FIRST
    if (e.originalEvent) {
      e.originalEvent.stopImmediatePropagation();
      e.originalEvent.preventDefault();
      e.originalEvent.stopPropagation();
    }
    
    // Also stop Leaflet's event propagation
    if (e.type) {
      L.DomEvent.stop(e);
    }
    
    // Close any existing popups immediately (including the layer's own popup)
    if (mapInstanceRef.current) {
      mapInstanceRef.current.closePopup();
    }
    
    // Also close the clicked layer's popup if it exists
    const clickedLayer = e.target as L.Layer;
    if (clickedLayer) {
      const layerPopup = (clickedLayer as any).getPopup?.();
      if (layerPopup) {
        layerPopup.close();
      }
    }
    
    // Get the click point from the event
    let clickPoint = e.latlng;
    if (e.target instanceof L.Marker) {
      clickPoint = (e.target as L.Marker).getLatLng();
    } else if (e.target instanceof L.Polygon || e.target instanceof L.Polyline) {
      // For polygons/polylines, use the click latlng from the event
      clickPoint = e.latlng;
    }
    console.log('🔍 [TABBED POPUP] Click point from feature:', clickPoint);
    
    // Create a synthetic map click event to use the same handler
    const syntheticEvent = {
      ...e,
      latlng: clickPoint
    } as L.LeafletMouseEvent;
    
    // Use the same logic as map click to find all features at this point
    // Small delay to ensure popup is closed
    setTimeout(() => {
      handleMapClick(syntheticEvent);
    }, 50);
  };

  // Handle map click to show tabbed popup for overlapping features
  const handleMapClick = (e: L.LeafletMouseEvent) => {
    console.log('🔍 [TABBED POPUP] ========== MAP CLICK DETECTED ==========');
    console.log('🔍 [TABBED POPUP] Click event:', e);
    
    if (!mapInstanceRef.current || !layerGroupsRef.current) {
      console.error('❌ [TABBED POPUP] Map or layer groups not ready');
      console.log('🔍 [TABBED POPUP] mapInstanceRef.current:', !!mapInstanceRef.current);
      console.log('🔍 [TABBED POPUP] layerGroupsRef.current:', !!layerGroupsRef.current);
      return;
    }
    
    const clickPoint = e.latlng;
    const { primary, poi } = layerGroupsRef.current;
    
    console.log('🔍 [TABBED POPUP] Click point:', clickPoint);
    console.log('🔍 [TABBED POPUP] Primary layer group:', primary);
    console.log('🔍 [TABBED POPUP] POI layer group:', poi);
    
    // Close any existing popups first
    mapInstanceRef.current.closePopup();
    
    // Collect all features at click point
    const featuresAtPoint: Array<{
      layer: L.Layer;
      layerType: string;
      layerTitle: string;
      popupContent: string;
    }> = [];
    
    // Track layers we've already processed to prevent duplicates
    const processedLayers = new Set<L.Layer>();
    // Track unique feature signatures (coordinates + layer type) to prevent duplicates
    const seenFeatureSignatures = new Set<string>();
    
    let layerCount = 0;
    let markerCount = 0;
    let polygonCount = 0;
    let polylineCount = 0;
    
    console.log('🔍 [TABBED POPUP] Starting to check layers...');
    
    // Helper function to check layers in a group
    const checkLayerGroup = (layerGroup: L.LayerGroup) => {
      layerGroup.eachLayer((layer: L.Layer) => {
      // Skip if we've already processed this layer
      if (processedLayers.has(layer)) {
        console.log('🔍 [TABBED POPUP] Skipping duplicate layer');
        return;
      }
      
      layerCount++;
      // Skip location marker
      if (layer instanceof L.Marker && (layer as any).options?.title === results[0]?.location?.name) {
        console.log('🔍 [TABBED POPUP] Skipping location marker');
        return;
      }
      
      let intersects = false;
      let layerType = 'unknown';
      let layerTitle = 'Unknown Layer';
      let popupContent = '';
      
      // Check for stored metadata first
      const storedType = (layer as any).__layerType;
      const storedTitle = (layer as any).__layerTitle;
      console.log(`🔍 [TABBED POPUP] Layer ${layerCount}:`, {
        type: layer instanceof L.Marker ? 'Marker' : layer instanceof L.Polygon ? 'Polygon' : layer instanceof L.Polyline ? 'Polyline' : 'Unknown',
        storedType,
        storedTitle
      });
      
      // Check if click point intersects with this layer
      if (layer instanceof L.Marker) {
        markerCount++;
        // Point feature - check distance (within 15 pixels)
        const markerLatLng = (layer as L.Marker).getLatLng();
        const containerPoint = mapInstanceRef.current!.latLngToContainerPoint(markerLatLng);
        const clickContainerPoint = mapInstanceRef.current!.latLngToContainerPoint(clickPoint);
        const pixelDistance = Math.sqrt(
          Math.pow(containerPoint.x - clickContainerPoint.x, 2) + 
          Math.pow(containerPoint.y - clickContainerPoint.y, 2)
        );
        intersects = pixelDistance <= 15; // 15 pixels tolerance
        
        if (intersects) {
          console.log(`🔍 [TABBED POPUP] Marker ${markerCount} intersects!`);
          const popup = (layer as L.Marker).getPopup();
          if (popup) {
            popupContent = popup.getContent() as string;
            console.log('🔍 [TABBED POPUP] Marker popup content length:', popupContent?.length || 0);
          } else {
            // Fallback to stored popup content
            popupContent = (layer as any).__popupContent || '';
            console.warn('⚠️ [TABBED POPUP] Marker has no popup, using stored content:', popupContent?.length || 0);
          }
          layerType = storedType || extractLayerTypeFromPopup(popupContent) || 'point';
          layerTitle = storedTitle || extractLayerTitleFromPopup(popupContent) || 'Point Feature';
          
          // Create a unique signature for this feature based on coordinates + layer type
          // Use 6 decimal places for lat/lng to catch markers at exact same location
          const featureSignature = `${markerLatLng.lat.toFixed(6)}_${markerLatLng.lng.toFixed(6)}_${layerType}`;
          
          console.log('🔍 [TABBED POPUP] Marker layer type:', layerType, 'title:', layerTitle);
          console.log('🔍 [TABBED POPUP] Marker coordinates:', markerLatLng.lat.toFixed(6), markerLatLng.lng.toFixed(6));
          console.log('🔍 [TABBED POPUP] Feature signature:', featureSignature);
          
          // Check if we've already seen this exact feature (same location + type)
          if (seenFeatureSignatures.has(featureSignature)) {
            console.log('⚠️ [TABBED POPUP] Skipping duplicate feature (same coordinates + type):', featureSignature);
            // Mark layer as processed and skip adding to featuresAtPoint
            processedLayers.add(layer);
            return;
          }
          
          // Mark signature as seen BEFORE adding to featuresAtPoint
          seenFeatureSignatures.add(featureSignature);
          processedLayers.add(layer);
        }
      } else if (layer instanceof L.Polygon) {
        polygonCount++;
        // Polygon feature - check if point is inside (supports multi-ring / multi-polygon)
        const bounds = (layer as L.Polygon).getBounds();
        if (bounds.contains(clickPoint)) {
          // Leaflet can return nested arrays for polygons with multiple rings / multipolygons.
          const rawLatLngs = (layer as L.Polygon).getLatLngs();
          const rings: L.LatLng[][] = [];

          const flattenRings = (arr: any) => {
            if (!Array.isArray(arr) || arr.length === 0) return;
            // If this level is an array of LatLngs, treat it as a ring
            if (arr[0] instanceof L.LatLng) {
              rings.push(arr as L.LatLng[]);
              return;
            }
            // Otherwise recurse into sub-arrays
            arr.forEach((sub: any) => flattenRings(sub));
          };

          flattenRings(rawLatLngs);

          if (rings.length > 0) {
            for (const ring of rings) {
              if (!Array.isArray(ring) || ring.length === 0) continue;
              if (isPointInPolygon(clickPoint, ring)) {
                intersects = true;
                break;
              }
            }
          }

          if (intersects) {
            console.log(`🔍 [TABBED POPUP] Polygon ${polygonCount} intersects! (multi-ring aware)`);
            const popup = (layer as L.Polygon).getPopup();
            if (popup) {
              popupContent = popup.getContent() as string;
              console.log('🔍 [TABBED POPUP] Polygon popup content length:', popupContent?.length || 0);
            } else {
              // Fallback to stored popup content
              popupContent = (layer as any).__popupContent || '';
              console.warn('⚠️ [TABBED POPUP] Polygon has no popup, using stored content:', popupContent?.length || 0);
            }
            layerType = storedType || extractLayerTypeFromPopup(popupContent) || 'polygon';
            layerTitle = storedTitle || extractLayerTitleFromPopup(popupContent) || 'Polygon Feature';
            console.log('🔍 [TABBED POPUP] Polygon layer type:', layerType, 'title:', layerTitle);
          }
        }
      } else if (layer instanceof L.Polyline) {
        polylineCount++;
        // Polyline feature - check distance to line (within 15 pixels)
        const latlngs = (layer as L.Polyline).getLatLngs() as L.LatLng[];
        if (Array.isArray(latlngs) && latlngs.length > 0) {
          let minPixelDistance = Infinity;
          for (let i = 0; i < latlngs.length; i++) {
            const point = latlngs[i];
            const containerPoint = mapInstanceRef.current!.latLngToContainerPoint(point);
            const clickContainerPoint = mapInstanceRef.current!.latLngToContainerPoint(clickPoint);
            const pixelDistance = Math.sqrt(
              Math.pow(containerPoint.x - clickContainerPoint.x, 2) + 
              Math.pow(containerPoint.y - clickContainerPoint.y, 2)
            );
            if (pixelDistance < minPixelDistance) {
              minPixelDistance = pixelDistance;
            }
          }
          intersects = minPixelDistance <= 15; // 15 pixels tolerance
          
          if (intersects) {
            console.log(`🔍 [TABBED POPUP] Polyline ${polylineCount} intersects!`);
            const popup = (layer as L.Polyline).getPopup();
            if (popup) {
              popupContent = popup.getContent() as string;
              console.log('🔍 [TABBED POPUP] Polyline popup content length:', popupContent?.length || 0);
            } else {
              // Fallback to stored popup content
              popupContent = (layer as any).__popupContent || '';
              console.warn('⚠️ [TABBED POPUP] Polyline has no popup, using stored content:', popupContent?.length || 0);
            }
            layerType = storedType || extractLayerTypeFromPopup(popupContent) || 'polyline';
            layerTitle = storedTitle || extractLayerTitleFromPopup(popupContent) || 'Line Feature';
            console.log('🔍 [TABBED POPUP] Polyline layer type:', layerType, 'title:', layerTitle);
          }
        }
      }
      
      if (intersects && popupContent) {
        // For markers, deduplication was already done above and layer was marked as processed
        // For polygons/polylines, create a signature and check for duplicates
        if (!(layer instanceof L.Marker)) {
          let featureSignature = '';
          if (layer instanceof L.Polygon) {
            const bounds = (layer as L.Polygon).getBounds();
            const center = bounds.getCenter();
            // Include layer title in signature to allow multiple NRI layers with same geometry (Hail, Wildfire, etc.)
            // This prevents deduplication of different layers that happen to share the same county/census tract geometry
            const titlePart = layerTitle && layerTitle !== 'Polygon Feature' ? `_${layerTitle.replace(/\s+/g, '_')}` : '';
            featureSignature = `${center.lat.toFixed(6)}_${center.lng.toFixed(6)}_${layerType}${titlePart}`;
          } else if (layer instanceof L.Polyline) {
            const latlngs = (layer as L.Polyline).getLatLngs() as L.LatLng[];
            if (latlngs.length > 0) {
              const firstPoint = Array.isArray(latlngs[0]) ? latlngs[0][0] : latlngs[0];
              const titlePart = layerTitle && layerTitle !== 'Line Feature' ? `_${layerTitle.replace(/\s+/g, '_')}` : '';
              featureSignature = `${firstPoint.lat.toFixed(6)}_${firstPoint.lng.toFixed(6)}_${layerType}${titlePart}`;
            }
          }
          
          // Check for duplicates (for non-markers)
          if (featureSignature && seenFeatureSignatures.has(featureSignature)) {
            console.log('⚠️ [TABBED POPUP] Skipping duplicate feature (same location + type):', featureSignature);
            processedLayers.add(layer);
            return;
          }
          
          // Mark signature and layer as processed
          if (featureSignature) {
            seenFeatureSignatures.add(featureSignature);
          }
          processedLayers.add(layer);
        }
        
        console.log('✅ [TABBED POPUP] Found intersecting feature:', { 
          layerType, 
          layerTitle,
          hasPopup: !!popupContent,
          popupLength: popupContent.length,
          popupPreview: popupContent.substring(0, 100)
        });
        featuresAtPoint.push({
          layer,
          layerType,
          layerTitle,
          popupContent
        });
      } else if (intersects && !popupContent) {
          console.warn('⚠️ [TABBED POPUP] Feature intersects but has no popup content');
        }
      });
    };
    
    // Check both layer groups
    checkLayerGroup(primary);
    checkLayerGroup(poi);
    
    console.log('🔍 [TABBED POPUP] ========== LAYER CHECK COMPLETE ==========');
    console.log('🔍 [TABBED POPUP] Total layers checked:', layerCount);
    console.log('🔍 [TABBED POPUP] Markers:', markerCount, 'Polygons:', polygonCount, 'Polylines:', polylineCount);
    console.log('🔍 [TABBED POPUP] Features found at point:', featuresAtPoint.length);
    console.log('🔍 [TABBED POPUP] Features details:', featuresAtPoint.map(f => ({ type: f.layerType, title: f.layerTitle })));
    
    // If we found multiple features, show tabbed popup
    if (featuresAtPoint.length > 1) {
      console.log('🔍 [TABBED POPUP] ========== MULTIPLE FEATURES FOUND ==========');
      console.log('🔍 [TABBED POPUP] Features count:', featuresAtPoint.length);
      console.log('🔍 [TABBED POPUP] All features details:', featuresAtPoint.map((f, i) => ({
        index: i,
        layerType: f.layerType,
        layerTitle: f.layerTitle,
        hasPopup: !!f.popupContent,
        popupPreview: f.popupContent?.substring(0, 100)
      })));
      
      // Group by layer type
      const groupedFeatures = groupFeaturesByType(featuresAtPoint);
      console.log('🔍 [TABBED POPUP] Grouped features:', groupedFeatures);
      console.log('🔍 [TABBED POPUP] Layer types:', Object.keys(groupedFeatures));
      console.log('🔍 [TABBED POPUP] Features per type:', Object.entries(groupedFeatures).map(([type, features]) => ({
        type,
        count: features.length,
        titles: features.map(f => f.layerTitle)
      })));
      
      // Limit to max 10 tabs
      const layerTypes = Object.keys(groupedFeatures).slice(0, 10);
      console.log('🔍 [TABBED POPUP] Layer types (limited to 10):', layerTypes);
      
      console.log('🔍 [TABBED POPUP] Layer types count:', layerTypes.length);
      console.log('🔍 [TABBED POPUP] Features per type:', layerTypes.map(lt => ({ type: lt, count: groupedFeatures[lt].length })));
      
      // Show tabs if we have multiple layer types OR multiple features of the same type
      const totalFeatures = featuresAtPoint.length;
      const shouldShowTabs = layerTypes.length > 1 || (layerTypes.length === 1 && totalFeatures > 1);
      
      console.log('🔍 [TABBED POPUP] Should show tabs?', shouldShowTabs, '(layerTypes:', layerTypes.length, ', totalFeatures:', totalFeatures, ')');
      
      if (shouldShowTabs) {
        console.log('🔍 [TABBED POPUP] Creating popup with', layerTypes.length, 'tabs');
        const tabbedPopupContent = createTabbedPopupContent(groupedFeatures, layerTypes);
        console.log('🔍 [TABBED POPUP] Popup content length:', tabbedPopupContent.length);
        console.log('🔍 [TABBED POPUP] Popup content preview (first 500 chars):', tabbedPopupContent.substring(0, 500));
        
        // Use setTimeout to ensure popup opens after any default popups are closed
        setTimeout(() => {
          console.log('🔍 [TABBED POPUP] Opening popup...');
          const popup = L.popup({ 
            maxWidth: 500, 
            maxHeight: 500,
            className: 'tabbed-popup', 
            autoPan: true,
            autoClose: false,
            closeOnClick: false
          })
            .setLatLng(clickPoint)
            .setContent(tabbedPopupContent);
          popup.openOn(mapInstanceRef.current!);
          console.log('✅ [TABBED POPUP] Popup opened on map');
          
          // Attach event listeners after popup is added to DOM
          setTimeout(() => {
            console.log('🔍 [TABBED POPUP] Looking for popup element in DOM...');
            const popupElement = document.querySelector('.tabbed-popup .leaflet-popup-content-wrapper');
            console.log('🔍 [TABBED POPUP] Popup element found:', !!popupElement);
            if (popupElement) {
              console.log('🔍 [TABBED POPUP] Popup element HTML:', popupElement.innerHTML.substring(0, 200));
              const tabs = popupElement.querySelectorAll('.tabbed-popup-tab');
              console.log('🔍 [TABBED POPUP] Tabs found:', tabs.length);
              const contents = popupElement.querySelectorAll('.tabbed-popup-content');
              console.log('🔍 [TABBED POPUP] Content panels found:', contents.length);
              
              // Use event delegation for tab clicks
              popupElement.addEventListener('click', (e: Event) => {
                const target = e.target as HTMLElement;
                console.log('🔍 [TABBED POPUP] Click in popup:', target);
                if (target.classList.contains('tabbed-popup-tab') || target.closest('.tabbed-popup-tab')) {
                  const tab = target.classList.contains('tabbed-popup-tab') ? target : target.closest('.tabbed-popup-tab') as HTMLElement;
                  const tabIndex = tab.getAttribute('data-tab-index');
                  console.log('🔍 [TABBED POPUP] Tab clicked, index:', tabIndex);
                  if (tabIndex !== null) {
                    // Update all tabs
                    popupElement.querySelectorAll('.tabbed-popup-tab').forEach((t: Element) => {
                      const tabEl = t as HTMLElement;
                      tabEl.style.backgroundColor = 'transparent';
                      tabEl.style.color = '#6b7280';
                      tabEl.style.fontWeight = '400';
                      tabEl.style.borderBottomColor = 'transparent';
                      tabEl.classList.remove('active');
                    });
                    // Update all content panels
                    popupElement.querySelectorAll('.tabbed-popup-content').forEach((c: Element) => {
                      (c as HTMLElement).style.display = 'none';
                    });
                    // Activate clicked tab
                    tab.style.backgroundColor = '#3b82f6';
                    tab.style.color = 'white';
                    tab.style.fontWeight = '600';
                    tab.style.borderBottomColor = '#3b82f6';
                    tab.classList.add('active');
                    // Show corresponding content
                    const content = popupElement.querySelector(`#tab-content-${tabIndex}`) as HTMLElement;
                    if (content) {
                      content.style.display = 'block';
                      console.log('✅ [TABBED POPUP] Tab switched to index:', tabIndex);
                    } else {
                      console.error('❌ [TABBED POPUP] Content panel not found for index:', tabIndex);
                    }
                  }
                }
              });
              console.log('✅ [TABBED POPUP] Event listeners attached');
            } else {
              console.error('❌ [TABBED POPUP] Popup element not found in DOM');
            }
          }, 100);
          
          console.log('✅ [TABBED POPUP] Popup creation complete');
        }, 50);
      } else {
        console.log('⚠️ [TABBED POPUP] Not showing tabs. Layer types:', layerTypes.length, 'Total features:', totalFeatures);
        // If we have multiple features but only one type, still show them in a scrollable popup
        if (totalFeatures > 1) {
          console.log('🔍 [TABBED POPUP] Multiple features of same type, creating single-tab popup');
          const singleTabContent = createTabbedPopupContent(groupedFeatures, layerTypes);
          setTimeout(() => {
            const popup = L.popup({ 
              maxWidth: 500, 
              maxHeight: 500,
              className: 'tabbed-popup', 
              autoPan: true,
              autoClose: false,
              closeOnClick: false
            })
              .setLatLng(clickPoint)
              .setContent(singleTabContent);
            popup.openOn(mapInstanceRef.current!);
          }, 10);
        }
      }
    } else if (featuresAtPoint.length === 1) {
      // Single feature - open its popup manually since autoOpen is false
      console.log('🔍 [TABBED POPUP] Single feature found, opening popup manually');
      console.log('🔍 [TABBED POPUP] Features at point count:', featuresAtPoint.length);
      console.log('🔍 [TABBED POPUP] Popup content length:', featuresAtPoint[0].popupContent?.length || 0);
      console.log('🔍 [TABBED POPUP] Popup content preview (first 500 chars):', featuresAtPoint[0].popupContent?.substring(0, 500));
      
      const singleFeature = featuresAtPoint[0];
      
      // Ensure ALL popups are closed first to prevent duplicates
      if (mapInstanceRef.current) {
        mapInstanceRef.current.closePopup();
        // Also close any popups that might be attached to layers
        const allLayers: L.Layer[] = [];
        primary.eachLayer((l: L.Layer) => allLayers.push(l));
        poi.eachLayer((l: L.Layer) => allLayers.push(l));
        allLayers.forEach(layer => {
          const popup = (layer as any).getPopup?.();
          if (popup) {
            popup.close();
          }
        });
      }
      
      // Ensure the layer's popup is closed
      const layerPopup = singleFeature.layer.getPopup();
      if (layerPopup) {
        layerPopup.close();
      }
      
      if (singleFeature.popupContent) {
        // Deduplicate popup content before displaying
        const cleanedContent = deduplicatePopupContent(singleFeature.popupContent);
        console.log('🔍 [TABBED POPUP] Original content length:', singleFeature.popupContent.length);
        console.log('🔍 [TABBED POPUP] Cleaned content length:', cleanedContent.length);
        
        // Small delay to ensure any default popups are closed
        setTimeout(() => {
          // Double-check no popups are open
          if (mapInstanceRef.current) {
            mapInstanceRef.current.closePopup();
          }
          
          const popup = L.popup({ 
            maxWidth: 500, 
            maxHeight: 500,
            autoPan: true,
            autoClose: false,
            closeOnClick: false
          })
            .setLatLng(clickPoint)
            .setContent(cleanedContent);
          popup.openOn(mapInstanceRef.current!);
          console.log('✅ [TABBED POPUP] Single feature popup opened with cleaned content length:', cleanedContent.length);
        }, 100);
      } else {
        // Fallback: try to get popup from layer
        setTimeout(() => {
          if (mapInstanceRef.current) {
            mapInstanceRef.current.closePopup();
          }
          const fallbackPopup = singleFeature.layer.getPopup();
          if (fallbackPopup) {
            fallbackPopup.openOn(mapInstanceRef.current!);
            console.log('✅ [TABBED POPUP] Single feature popup opened from layer');
          } else {
            console.warn('⚠️ [TABBED POPUP] Single feature has no popup content');
          }
        }, 100);
      }
    } else {
      console.log('ℹ️ [TABBED POPUP] No features found at click point');
    }
    console.log('🔍 [TABBED POPUP] ========== HANDLER COMPLETE ==========');
  };

  // Helper function to check if point is in polygon
  const isPointInPolygon = (point: L.LatLng, polygon: L.LatLng[]): boolean => {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].lng, yi = polygon[i].lat;
      const xj = polygon[j].lng, yj = polygon[j].lat;
      const intersect = ((yi > point.lat) !== (yj > point.lat)) && 
                       (point.lng < (xj - xi) * (point.lat - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  };


  // Helper function to extract layer type from popup content
  const extractLayerTypeFromPopup = (popupContent: string): string | null => {
    if (!popupContent) return null;
    // Try to extract from popup content - look for common patterns
    const match = popupContent.match(/data-layer-type=["']([^"']+)["']/);
    if (match) return match[1];
    // Fallback: try to extract from title
    const titleMatch = popupContent.match(/<h3[^>]*>([^<]+)<\/h3>/);
    if (titleMatch) {
      const title = titleMatch[1].toLowerCase();
      // NYC layers
      if (title.includes('bike route')) return 'nyc_bike_routes';
      if (title.includes('neighborhood')) return 'nyc_neighborhoods';
      if (title.includes('tax lot') || title.includes('mappluto')) {
        if (title.includes('commercial') || title.includes('mixed use')) {
          return 'nyc_mappluto_commercial_mixed_use';
        }
        return 'nyc_mappluto';
      }
      // LA County layers
      if (title.includes('historic cultural monument')) return 'la_county_historic_cultural_monuments';
      if (title.includes('housing') && title.includes('lead')) return 'la_county_housing_lead_risk';
      if (title.includes('school district')) return 'la_county_school_district_boundaries';
      if (title.includes('metro line')) return 'la_county_metro_lines';
      if (title.includes('street inventory')) return 'la_county_street_inventory';
      if (title.includes('roads centerline') || title.includes('road centerline')) return 'houston_roads_centerline';
      // Chicago layers
      if (title.includes('311') || title.includes('service request')) return 'chicago_311';
      if (title.includes('building') && (title.includes('centroid') || title.includes('footprint'))) return 'chicago_building_footprints';
      if (title.includes('traffic crash')) return 'chicago_traffic_crashes';
      if (title.includes('speed camera')) return 'chicago_speed_cameras';
      if (title.includes('red light camera')) return 'chicago_red_light_cameras';
      // Generic patterns
      if (title.includes('parcel')) return 'parcels';
      if (title.includes('polygon')) return 'polygon';
      if (title.includes('line') || title.includes('route')) return 'polyline';
    }
    return null;
  };

  // Helper function to extract layer title from popup content
  const extractLayerTitleFromPopup = (popupContent: string): string | null => {
    if (!popupContent) return null;
    const titleMatch = popupContent.match(/<h3[^>]*>([^<]+)<\/h3>/);
    if (titleMatch) {
      // Remove emojis and clean up title
      let title = titleMatch[1].replace(/[🚴🏘️🏢🚑🚇🚆🚂💧🏛️🏠🌲🔥🌊⛰️🏔️🌋🌍🌎🌏🗺️📍]/g, '').trim();
      // Remove common prefixes like "Containing" or "Nearby"
      title = title.replace(/^(Containing|Nearby)\s+/i, '');
      return title || 'Feature';
    }
    return null;
  };

  // Helper function to remove duplicate sections from popup content
  const deduplicatePopupContent = (content: string): string => {
    if (!content) return content;
    
    // Try to detect if content contains duplicate sections
    // Look for repeated div blocks with the same content
    const divMatches = content.match(/<div[^>]*>[\s\S]*?<\/div>/g);
    if (divMatches && divMatches.length > 1) {
      const seenContent = new Set<string>();
      let deduplicated = content;
      let removedCount = 0;
      
      // Try to find and remove exact duplicate divs
      divMatches.forEach(div => {
        // Normalize whitespace for comparison
        const normalized = div.replace(/\s+/g, ' ').trim();
        if (seenContent.has(normalized)) {
          // Remove this duplicate div (only the first occurrence after the original)
          const index = deduplicated.indexOf(div, seenContent.size > 0 ? 1 : 0);
          if (index !== -1) {
            deduplicated = deduplicated.substring(0, index) + deduplicated.substring(index + div.length);
            removedCount++;
          }
        } else {
          seenContent.add(normalized);
        }
      });
      
      // If we removed duplicates, return cleaned content
      if (removedCount > 0) {
        console.log(`🔍 [TABBED POPUP] Removed ${removedCount} duplicate sections from popup content`);
        return deduplicated.trim();
      }
    }
    
    return content;
  };

  // Helper function to group features by layer type
  const groupFeaturesByType = (features: Array<{layerType: string; layerTitle: string; popupContent: string}>) => {
    const grouped: Record<string, Array<{layerTitle: string; popupContent: string}>> = {};
    console.log('🔍 [TABBED POPUP] Grouping', features.length, 'features...');
    features.forEach((feature, index) => {
      // Use layerTitle as the key if layerType is 'unknown' or not specific enough
      // This ensures different layers get separate tabs even if type detection fails
      const key = feature.layerType && feature.layerType !== 'unknown' 
        ? feature.layerType 
        : (feature.layerTitle || `feature_${index}`);
      
      console.log(`🔍 [TABBED POPUP] Feature ${index}: type="${feature.layerType}", title="${feature.layerTitle}", key="${key}"`);
      
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push({
        layerTitle: feature.layerTitle,
        popupContent: feature.popupContent
      });
    });
    console.log('🔍 [TABBED POPUP] Grouping result:', Object.keys(grouped).map(k => ({ key: k, count: grouped[k].length })));
    return grouped;
  };

  // Helper function to create tabbed popup content
  const createTabbedPopupContent = (
    groupedFeatures: Record<string, Array<{layerTitle: string; popupContent: string}>>,
    layerTypes: string[]
  ): string => {
    let html = `
      <div class="tabbed-popup-container" style="min-width: 300px; max-width: 500px;">
        <div class="tabbed-popup-tabs" style="display: flex; border-bottom: 2px solid #e5e7eb; margin-bottom: 12px; overflow-x: auto;">
    `;
    
    layerTypes.forEach((layerType, index) => {
      const features = groupedFeatures[layerType];
      const count = features.length;
      const title = features[0]?.layerTitle || layerType;
      const isActive = index === 0 ? 'active' : '';
      html += `
        <button 
          class="tabbed-popup-tab ${isActive}" 
          data-tab-index="${index}"
          style="
            padding: 8px 12px;
            border: none;
            background: ${index === 0 ? '#3b82f6' : 'transparent'};
            color: ${index === 0 ? 'white' : '#6b7280'};
            cursor: pointer;
            font-size: 12px;
            font-weight: ${index === 0 ? '600' : '400'};
            border-bottom: 2px solid ${index === 0 ? '#3b82f6' : 'transparent'};
            margin-bottom: -2px;
            white-space: nowrap;
            flex-shrink: 0;
          "
          onmouseover="this.style.backgroundColor='${index === 0 ? '#3b82f6' : '#f3f4f6'}'"
          onmouseout="this.style.backgroundColor='${index === 0 ? '#3b82f6' : 'transparent'}'"
        >
          ${title}${count > 1 ? ` (${count})` : ''}
        </button>
      `;
    });
    
    html += `
        </div>
        <div class="tabbed-popup-contents" style="max-height: 400px; overflow-y: auto; overflow-x: hidden;">
    `;
    
    layerTypes.forEach((layerType, index) => {
      const features = groupedFeatures[layerType];
      const isActive = index === 0 ? 'block' : 'none';
      html += `
        <div id="tab-content-${index}" class="tabbed-popup-content" style="display: ${isActive};">
      `;
      
      features.forEach((feature, featureIndex) => {
        if (features.length > 1) {
          html += `<div style="margin-bottom: ${featureIndex < features.length - 1 ? '16px' : '0'}; padding-bottom: ${featureIndex < features.length - 1 ? '16px' : '0'}; border-bottom: ${featureIndex < features.length - 1 ? '1px solid #e5e7eb' : 'none'};">
            ${feature.popupContent}
          </div>`;
        } else {
          html += feature.popupContent;
        }
      });
      
      html += `</div>`;
    });
    
    html += `
        </div>
      </div>
    `;
    
    return html;
  };

  // CSV export now handled by shared utility function

  // Mobile: Full screen map within container (no fixed positioning, works with MapPage wrapper)
  if (isMobile) {
    return (
      <div
        className="relative w-full h-full bg-gray-200 min-h-0"
        style={{ 
          height: '100%',
          width: '100%',
          position: 'relative',
          overflow: 'hidden',
          display: 'flex',
          flexDirection: 'column',
          flex: '1 1 auto'
        }}
      >
        {/* Map Container - Full Screen */}
        <div 
          ref={mapRef} 
          className="w-full h-full min-h-0 mobile-map-leaflet"
          style={{
            height: '100%',
            width: '100%',
            position: 'relative',
            zIndex: 10,
            margin: 0,
            padding: 0,
            backgroundColor: '#e5e7eb',
            touchAction: 'pan-x pan-y pinch-zoom'
          }}
        />
          
          {/* Back Button Overlay - Mobile full-screen map UX */}
          <button
            onClick={onBackToConfig}
            className="absolute z-[1200] bg-black/90 text-white rounded-full shadow-lg px-3 py-2 border-2 border-white/20 font-medium"
            style={{
              top: 'calc(env(safe-area-inset-top) + 8px)',
              left: '12px',
              zIndex: 1200,
            }}
            aria-label="Back"
            title="Back"
          >
            ← Back
          </button>

          {/* Download Button - Bottom Left (replaces legend on mobile) */}
          {results.length === 1 && (
            <button
              onClick={() => exportEnrichmentResultsToCSV(results)}
              className="absolute z-[1000] bg-blue-600 text-white rounded shadow-lg hover:bg-blue-700 transition-colors border border-white/20"
              style={{ 
                bottom: '12px',
                left: '12px',
                zIndex: 1000,
                padding: '8px 12px',
                fontSize: '14px',
                fontWeight: '500',
                display: 'flex',
                alignItems: 'center',
                gap: '6px',
                whiteSpace: 'nowrap'
              }}
              title="Download all proximity layers and distances for this location"
            >
              <span>⬇️</span>
              <span>Download</span>
            </button>
          )}
          
          {/* Batch Success Message - Mobile */}
          {showBatchSuccess && (
            <div className="absolute top-8 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-1.5 py-1 rounded shadow-md z-[1000]">
              <div className="flex items-center space-x-0.5">
                <span className="text-[10px]">✅</span>
                <span className="text-[9px] font-medium">Batch completed!</span>
              </div>
            </div>
          )}
      </div>
    );
  }

  // Desktop: Original layout with header
  return (
    <div
      className="h-screen flex flex-col bg-white"
    >
      {/* Results Header */}
      <div className="bg-white border-b border-gray-200 px-4 sm:px-6 py-4 flex items-center justify-between flex-shrink-0 relative z-20">
        <div className="flex items-center space-x-4 flex-shrink-0">
          <button
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              onBackToConfig();
            }}
            className="flex items-center space-x-2 text-gray-600 hover:text-gray-900 transition-colors cursor-pointer"
            type="button"
          >
            <span className="w-5 h-5">←</span>
            <span className="text-sm font-medium">Back to Configuration</span>
          </button>
        </div>
          
        {/* Centered Title */}
        <div className="flex-1 flex items-center justify-center">
          <h1 className="text-2xl sm:text-3xl font-bold text-gradient">
            KNOW YOUR LOCATION
          </h1>
        </div>
        
        <div className="flex items-center space-x-4 flex-shrink-0">
          <div className="text-right">
            <p className="text-sm text-gray-600">{results.length} location{results.length !== 1 ? 's' : ''} processed</p>
          </div>
          
          {/* Prominent Download Button for Single Lookup */}
          {results.length === 1 && (
            <button
              onClick={() => exportEnrichmentResultsToCSV(results)}
              className="btn btn-primary flex items-center space-x-2 px-4 py-2"
              title="Download all proximity layers and distances for this location"
            >
              <span className="w-4 h-4">⬇️</span>
              <span>Download Results</span>
            </button>
          )}
        </div>
      </div>

      {/* Map Container */}
      <div 
        className="flex-1 relative"
      >
        <div 
          ref={mapRef} 
          className="w-full h-full"
          style={{ 
            height: '100%', 
            width: '100%',
            // On mobile, never hide the map container behind an "isMapReady" fade gate.
            // With MapLibre basemaps, readiness can lag while WebGL initializes, but the user still needs
            // to pan/zoom and access controls immediately.
            opacity: isMobile ? 1 : (isMapReady ? 1 : 0),
            transition: 'opacity 0.3s ease-in-out'
          }}
        />
        
        {/* Basemap Dropdown and Weather Radar Toggle - Desktop only */}
        {!isMobile && (
          <div className="absolute top-4 left-20 bg-white rounded-lg shadow-lg p-3 z-10 space-y-3" style={{ minWidth: '280px', maxWidth: '320px' }}>
            <div>
              <div className="flex items-center justify-between mb-2 relative">
                <label className="block text-sm font-semibold text-black">
                  Available Basemap Themes
                </label>
                <div className="relative" ref={basemapInfoRef}>
                  <button
                    type="button"
                    onClick={() => setShowBasemapInfo(!showBasemapInfo)}
                    className="w-5 h-5 rounded-full bg-blue-100 hover:bg-blue-200 text-blue-600 flex items-center justify-center text-xs font-bold transition-colors"
                    title="How basemaps work"
                  >
                    i
                  </button>
                  {showBasemapInfo && (
                    <div className="absolute right-0 top-6 w-72 bg-gray-800 text-white text-xs rounded-lg shadow-xl p-4 z-50 pointer-events-auto">
                      <button
                        onClick={() => setShowBasemapInfo(false)}
                        className="absolute top-2 right-2 text-white hover:text-gray-300 text-lg leading-none"
                      >
                        ×
                      </button>
                      <div className="space-y-3">
                        <div>
                          <div className="font-bold text-sm mb-1">📌 BASE LAYER (Toggle On/Off)</div>
                          <ul className="list-disc list-inside space-y-1 text-gray-200">
                            <li>One basemap from "Basemaps" section can be shown (toggle enabled by default)</li>
                            <li>Use "Show Base Basemap" toggle to show/hide the base layer</li>
                            <li>Select any basemap to replace the current one</li>
                            <li>Examples: OpenFreeMap styles, USA Topo Maps, National Geographic</li>
                          </ul>
                        </div>
                        <div>
                          <div className="font-bold text-sm mb-1">🎨 THEMATIC OVERLAYS (Optional)</div>
                          <ul className="list-disc list-inside space-y-1 text-gray-200">
                            <li>Thematic basemaps draw on top of the base layer</li>
                            <li>Click to toggle on/off</li>
                            <li>Examples: USGS, USFS, FIA Forest Atlas</li>
                          </ul>
                        </div>
                        <div className="text-gray-200 italic border-t border-gray-600 pt-2">
                          💡 TIP: The base layer is always visible. Thematic layers are transparent overlays that enhance the base map.
                        </div>
                      </div>
                      <div className="absolute right-2 bottom-0 transform translate-y-1/2 rotate-45 w-2 h-2 bg-gray-800"></div>
                    </div>
                  )}
                </div>
              </div>
              <div className="border border-gray-300 rounded-md bg-white max-h-96 overflow-y-auto">
                {/* Thematic Basemap Themes - Collapsible */}
                <div className="border-b border-gray-200">
                  <button
                    onClick={() => setShowThematicThemes(!showThematicThemes)}
                    className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-gray-700 hover:bg-gray-50 transition-colors bg-gray-100"
                  >
                    <span>🎨 Basemap Themes</span>
                    <span className={`transform transition-transform ${showThematicThemes ? 'rotate-180' : ''}`}>
                      ▼
                    </span>
                  </button>
                  {showThematicThemes && (
                    <div className="bg-gray-50">
                      {/* USGS National Map basemaps */}
                      <div className="border-b border-gray-200">
                        <button
                          onClick={() => setExpandedBasemapSections(prev => ({ ...prev, 'USGS National Map': !prev['USGS National Map'] }))}
                          className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-white hover:opacity-90 transition-colors"
                          style={{ backgroundColor: '#2563eb' }}
                        >
                          <span>USGS National Map</span>
                          <span className={`transform transition-transform ${expandedBasemapSections['USGS National Map'] ? 'rotate-180' : ''}`}>
                            ▼
                          </span>
                        </button>
                        {expandedBasemapSections['USGS National Map'] && (
                          <div className="pb-1 bg-white">
                            {Object.entries(BASEMAP_CONFIGS)
                              .filter(([key]) => key.startsWith('usgs_'))
                              .map(([key, config]) => (
                                <button
                                  key={key}
                                  onClick={() => {
                                    // Toggle: if already selected, deselect it; otherwise select it
                                    setSelectedThematicBasemap(selectedThematicBasemap === key ? null : key);
                                  }}
                                  className={`w-full px-4 py-2 text-left text-sm hover:bg-blue-50 transition-colors ${
                                    selectedThematicBasemap === key ? 'bg-blue-100 text-blue-700 font-medium' : 'text-gray-700'
                                  }`}
                                >
                                  {config.name}
                                </button>
                              ))}
                          </div>
                        )}
                      </div>
                      
                      {/* NOAA basemaps */}
                      <div className="border-b border-gray-200">
                        <button
                          onClick={() => setExpandedBasemapSections(prev => ({ ...prev, 'NOAA': !prev['NOAA'] }))}
                          className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-white hover:opacity-90 transition-colors"
                          style={{ backgroundColor: '#0891b2' }}
                        >
                          <span>NOAA</span>
                          <span className={`transform transition-transform ${expandedBasemapSections['NOAA'] ? 'rotate-180' : ''}`}>
                            ▼
                          </span>
                        </button>
                        {expandedBasemapSections['NOAA'] && (
                          <div className="pb-1 bg-white">
                            {Object.entries(BASEMAP_CONFIGS)
                              .filter(([key]) => key.startsWith('noaa_'))
                              .map(([key, config]) => (
                                <button
                                  key={key}
                                  onClick={() => {
                                    // Toggle: if already selected, deselect it; otherwise select it
                                    setSelectedThematicBasemap(selectedThematicBasemap === key ? null : key);
                                  }}
                                  className={`w-full px-4 py-2 text-left text-sm hover:bg-blue-50 transition-colors ${
                                    selectedThematicBasemap === key ? 'bg-blue-100 text-blue-700 font-medium' : 'text-gray-700'
                                  }`}
                                >
                                  {config.name}
                                </button>
                              ))}
                          </div>
                        )}
                      </div>
                      
                      {/* USFS basemaps (includes FIA Forest Atlas) */}
                      <div className="border-b border-gray-200">
                        <button
                          onClick={() => setExpandedBasemapSections(prev => ({ ...prev, 'USFS': !prev['USFS'] }))}
                          className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-white hover:opacity-90 transition-colors"
                          style={{ backgroundColor: '#dc2626' }}
                        >
                          <span>USFS</span>
                          <span className={`transform transition-transform ${expandedBasemapSections['USFS'] ? 'rotate-180' : ''}`}>
                            ▼
                          </span>
                        </button>
                        {expandedBasemapSections['USFS'] && (
                          <div className="pb-1 bg-white">
                            {Object.entries(BASEMAP_CONFIGS)
                              .filter(([key]) => (key.startsWith('usfs_') && !key.startsWith('usfs_fia_')) || (key.startsWith('fia_') && key.endsWith('_basemap') && !key.includes('alaska')))
                              .map(([key, config]) => (
                                <button
                                  key={key}
                                  onClick={() => {
                                    // Toggle: if already selected, deselect it; otherwise select it
                                    setSelectedThematicBasemap(selectedThematicBasemap === key ? null : key);
                                  }}
                                  className={`w-full px-4 py-2 text-left text-sm hover:bg-blue-50 transition-colors ${
                                    selectedThematicBasemap === key ? 'bg-blue-100 text-blue-700 font-medium' : 'text-gray-700'
                                  }`}
                                >
                                  {config.name}
                                </button>
                              ))}
                          </div>
                        )}
                      </div>
                      
                      {/* Alaska basemaps */}
                      <div className="border-b border-gray-200">
                        <button
                          onClick={() => setExpandedBasemapSections(prev => ({ ...prev, 'Alaska': !prev['Alaska'] }))}
                          className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-white hover:opacity-90 transition-colors"
                          style={{ backgroundColor: '#059669' }}
                        >
                          <span>Alaska</span>
                          <span className={`transform transition-transform ${expandedBasemapSections['Alaska'] ? 'rotate-180' : ''}`}>
                            ▼
                          </span>
                        </button>
                        {expandedBasemapSections['Alaska'] && (
                          <div className="pb-1 bg-white">
                            {Object.entries(BASEMAP_CONFIGS)
                              .filter(([key]) => key.startsWith('alaska_') || (key.startsWith('fia_') && key.includes('alaska')))
                              .map(([key, config]) => (
                                <button
                                  key={key}
                                  onClick={() => {
                                    // Toggle: if already selected, deselect it; otherwise select it
                                    setSelectedThematicBasemap(selectedThematicBasemap === key ? null : key);
                                  }}
                                  className={`w-full px-4 py-2 text-left text-sm hover:bg-blue-50 transition-colors ${
                                    selectedThematicBasemap === key ? 'bg-blue-100 text-blue-700 font-medium' : 'text-gray-700'
                                  }`}
                                >
                                  {config.name}
                                </button>
                              ))}
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                </div>
                
                {/* Basemaps - Always visible (bottom/base layer) */}
                <div className="border-b border-gray-200 last:border-b-0">
                  <button
                    onClick={() => setExpandedBasemapSections(prev => ({ ...prev, 'Basemaps': !prev['Basemaps'] }))}
                    className="w-full px-3 py-2 flex items-center justify-between text-sm font-semibold text-gray-700 hover:bg-gray-50 transition-colors"
                  >
                    <span>Basemaps</span>
                    <span className={`transform transition-transform ${expandedBasemapSections['Basemaps'] ? 'rotate-180' : ''}`}>
                      ▼
                    </span>
                  </button>
                  {expandedBasemapSections['Basemaps'] && (
                    <div className="pb-1">
                      {Object.entries(BASEMAP_CONFIGS)
                        .filter(([key, config]) => (config.type === 'maplibre' && !key.startsWith('alaska_')) || key === 'natgeo_world_map' || key === 'usa_topo_maps')
                        .map(([key, config]) => (
                          <button
                            key={key}
                            onClick={() => {
                              setSelectedBaseBasemap(key);
                            }}
                            className={`w-full px-4 py-2 text-left text-sm hover:bg-blue-50 transition-colors ${
                              selectedBaseBasemap === key ? 'bg-blue-100 text-blue-700 font-medium' : 'text-gray-700'
                            }`}
                          >
                            {config.name}
                          </button>
                        ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
            
            {/* Show/Hide Base Basemap Toggle */}
            <div className="border-t border-gray-200 pt-3">
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={showBaseBasemap}
                  onChange={(e) => setShowBaseBasemap(e.target.checked)}
                  className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                />
                <span className="text-sm font-semibold text-black">
                  Show Base Basemap
                </span>
              </label>
              <p className="text-xs text-gray-500 mt-1">
                Toggle to show/hide basemap from "Basemaps" section. Thematic overlays work independently.
              </p>
            </div>
            
            {/* Weather Radar Toggle */}
            <div className="border-t border-gray-200 pt-3">
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={showWeatherRadar}
                  onChange={(e) => setShowWeatherRadar(e.target.checked)}
                  className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                />
                <span className="text-sm font-semibold text-black">
                  🌦️ Weather Radar (NEXRAD)
                </span>
              </label>
              <p className="text-xs text-gray-500 mt-1">
                Shows current weather radar overlay
              </p>
            </div>
          </div>
        )}
        
        {/* Weather Radar Toggle - Mobile */}
        {isMobile && (
          <div className="absolute top-4 left-4 bg-white rounded-lg shadow-lg p-3 z-10">
            <label className="flex items-center space-x-2 cursor-pointer">
              <input
                type="checkbox"
                checked={showWeatherRadar}
                onChange={(e) => setShowWeatherRadar(e.target.checked)}
                className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
              />
              <span className="text-sm font-semibold text-black">
                🌦️ Radar
              </span>
            </label>
          </div>
        )}

        {/* Dynamic Legend - Always show when there are legend items (Desktop only) */}
        {legendItems.length > 0 && (
          <div className="absolute top-4 right-4 bg-white rounded-lg shadow-lg p-6 max-w-md z-10">
            <h4 className="text-lg font-semibold text-gray-900 mb-4">Map Legend</h4>
            <div className="space-y-3">
              {legendItems.map((item, index) => {
                // Check if this is a polyline feature (no icon or empty icon) - show line symbol instead
                const isPolyline = !item.icon || item.icon === '' || 
                  item.title?.includes('Bike') || 
                  item.title?.includes('Number of Lanes') ||
                  item.title?.includes('Road') ||
                  item.title?.includes('Route') ||
                  item.title?.includes('Trail');
                
                return (
                  <div key={index}>
                    <div className="flex items-center space-x-3 text-base">
                      {isPolyline ? (
                        // Show line symbol for polylines
                        <div className="w-8 h-8 flex items-center justify-center flex-shrink-0">
                          <div 
                            className="w-full h-1 rounded"
                            style={{ backgroundColor: item.color }}
                          />
                        </div>
                      ) : (
                        // Show icon in circle for points
                        <div 
                          className="w-8 h-8 rounded-full flex items-center justify-center text-base flex-shrink-0"
                          style={{ backgroundColor: item.color }}
                        >
                          {item.icon}
                        </div>
                      )}
                      <span className="text-gray-700 font-medium flex-1">{item.title}</span>
                      <div className="flex items-center gap-2 ml-auto">
                        <span className="text-gray-600 font-semibold">{item.count || 0}</span>
                        {(item.radiusDisplay || (item.radius !== undefined && item.radius > 0)) && (
                          <span className="text-xs text-gray-500">
                            ({item.radiusDisplay || (item.radius !== undefined ? `${item.radius} ${item.radius === 1 ? 'mile' : 'miles'}` : '')})
                          </span>
                        )}
                      </div>
                    </div>
                    {/* Show ranges for color-coded layers (broadband, number of lanes, etc.) */}
                    {item.ranges && item.ranges.length > 0 && (
                      <div className="ml-11 mt-2 space-y-2">
                        {item.ranges.map((range, rangeIndex) => (
                          <div key={rangeIndex} className="flex items-center space-x-3 text-sm">
                            <div 
                              className="w-4 h-4 rounded flex-shrink-0"
                              style={{ backgroundColor: range.color }}
                            />
                            <span className="text-gray-600">{range.label}</span>
                            <span className="text-gray-400">({range.count})</span>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
        )}
        
        {/* Batch Success Message */}
        {showBatchSuccess && (
          <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-10">
            <div className="flex items-center space-x-2">
              <span>✅</span>
              <span className="text-sm font-medium">Batch processing completed successfully!</span>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default MapView;
export { MapView };
